#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Indiana

#include "Basic.hpp"

#include "Indiana_classes.hpp"
#include "Indiana_parameters.hpp"


namespace SDK
{

// Function Indiana.HeadAndBodyTrackingComponent.OnOccupiedElevatorChange
// (Final, Native, Protected)
// Parameters:
// class AElevator*                        Elevator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOccupied                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHeadAndBodyTrackingComponent::OnOccupiedElevatorChange(class AElevator* Elevator, bool bOccupied)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeadAndBodyTrackingComponent", "OnOccupiedElevatorChange");

	Params::HeadAndBodyTrackingComponent_OnOccupiedElevatorChange Parms{};

	Parms.Elevator = Elevator;
	Parms.bOccupied = bOccupied;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Item.ClearAllOwnership
// (Final, Native, Public, BlueprintCallable)

void UItem::ClearAllOwnership()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "ClearAllOwnership");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Item.ClearNonPlayerOwnership
// (Final, Native, Public, BlueprintCallable)

void UItem::ClearNonPlayerOwnership()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "ClearNonPlayerOwnership");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Item.ClearPlayerOwnership
// (Final, Native, Public, BlueprintCallable)

void UItem::ClearPlayerOwnership()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "ClearPlayerOwnership");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Item.SetNonPlayerOwnership
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UFactionData>         Faction                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class AActor>            Actor                                                  (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemovePlayerOwnership                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItem::SetNonPlayerOwnership(TSubclassOf<class UFactionData> Faction, TSoftObjectPtr<class AActor> Actor, bool bRemovePlayerOwnership)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "SetNonPlayerOwnership");

	Params::Item_SetNonPlayerOwnership Parms{};

	Parms.Faction = Faction;
	Parms.Actor = Actor;
	Parms.bRemovePlayerOwnership = bRemovePlayerOwnership;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Item.SetOwnership
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UFactionData>         Faction                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class AActor>            Actor                                                  (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInPlayerOwned                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItem::SetOwnership(TSubclassOf<class UFactionData> Faction, TSoftObjectPtr<class AActor> Actor, bool bInPlayerOwned)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "SetOwnership");

	Params::Item_SetOwnership Parms{};

	Parms.Faction = Faction;
	Parms.Actor = Actor;
	Parms.bInPlayerOwned = bInPlayerOwned;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Item.SetPlayerOwnership
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bRemoveNonPlayerOwnership                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItem::SetPlayerOwnership(bool bRemoveNonPlayerOwnership)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "SetPlayerOwnership");

	Params::Item_SetPlayerOwnership Parms{};

	Parms.bRemoveNonPlayerOwnership = bRemoveNonPlayerOwnership;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Item.CanPlayerSafelyTake
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItem::CanPlayerSafelyTake() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "CanPlayerSafelyTake");

	Params::Item_CanPlayerSafelyTake Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Item.GetOwningActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TSoftObjectPtr<class AActor>      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const TSoftObjectPtr<class AActor> UItem::GetOwningActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetOwningActor");

	Params::Item_GetOwningActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Item.GetOwningFaction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UFactionData>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UFactionData> UItem::GetOwningFaction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetOwningFaction");

	Params::Item_GetOwningFaction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Item.IsPlayerOwned
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItem::IsPlayerOwned() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "IsPlayerOwned");

	Params::Item_IsPlayerOwned Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaUserWidget.OnCancelMinimize
// (Native, Event, Protected, BlueprintEvent)

void UIndianaUserWidget::OnCancelMinimize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "OnCancelMinimize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUserWidget.OnCancelShutdown
// (Native, Event, Protected, BlueprintEvent)

void UIndianaUserWidget::OnCancelShutdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "OnCancelShutdown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUserWidget.OnCounterNonZero
// (Native, Public)

void UIndianaUserWidget::OnCounterNonZero()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "OnCounterNonZero");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUserWidget.OnCounterZero
// (Native, Public)

void UIndianaUserWidget::OnCounterZero()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "OnCounterZero");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUserWidget.OnFinalizeIntroCb
// (Final, Native, Protected)

void UIndianaUserWidget::OnFinalizeIntroCb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "OnFinalizeIntroCb");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUserWidget.OnFinalizeMaximize
// (Native, Event, Protected, BlueprintEvent)

void UIndianaUserWidget::OnFinalizeMaximize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "OnFinalizeMaximize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUserWidget.OnFinalizeMaximizeCb
// (Final, Native, Protected)

void UIndianaUserWidget::OnFinalizeMaximizeCb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "OnFinalizeMaximizeCb");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUserWidget.OnFinalizeMinimize
// (Native, Event, Protected, BlueprintEvent)

void UIndianaUserWidget::OnFinalizeMinimize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "OnFinalizeMinimize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUserWidget.OnFinalizeMinimizeCb
// (Final, Native, Protected)

void UIndianaUserWidget::OnFinalizeMinimizeCb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "OnFinalizeMinimizeCb");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUserWidget.OnFinalizeOutroCb
// (Final, Native, Protected)

void UIndianaUserWidget::OnFinalizeOutroCb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "OnFinalizeOutroCb");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUserWidget.OnInputDeviceChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bUsingGamepad                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaUserWidget::OnInputDeviceChanged(bool bUsingGamepad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "OnInputDeviceChanged");

	Params::IndianaUserWidget_OnInputDeviceChanged Parms{};

	Parms.bUsingGamepad = bUsingGamepad;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.IndianaUserWidget.OnIntro
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// TDelegate<void()>                       AnimationCompleteCallback                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaUserWidget::OnIntro(const TDelegate<void()>& AnimationCompleteCallback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "OnIntro");

	Params::IndianaUserWidget_OnIntro Parms{};

	Parms.AnimationCompleteCallback = AnimationCompleteCallback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaUserWidget.OnMaximize
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// TDelegate<void()>                       AnimationCompleteCallback                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaUserWidget::OnMaximize(const TDelegate<void()>& AnimationCompleteCallback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "OnMaximize");

	Params::IndianaUserWidget_OnMaximize Parms{};

	Parms.AnimationCompleteCallback = AnimationCompleteCallback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaUserWidget.OnMinimize
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// TDelegate<void()>                       AnimationCompleteCallback                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaUserWidget::OnMinimize(const TDelegate<void()>& AnimationCompleteCallback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "OnMinimize");

	Params::IndianaUserWidget_OnMinimize Parms{};

	Parms.AnimationCompleteCallback = AnimationCompleteCallback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaUserWidget.OnOutro
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// TDelegate<void()>                       AnimationCompleteCallback                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaUserWidget::OnOutro(const TDelegate<void()>& AnimationCompleteCallback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "OnOutro");

	Params::IndianaUserWidget_OnOutro Parms{};

	Parms.AnimationCompleteCallback = AnimationCompleteCallback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaUserWidget.OnStartIntroCb
// (Final, Native, Protected)

void UIndianaUserWidget::OnStartIntroCb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "OnStartIntroCb");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUserWidget.OnStartMaximizeCb
// (Final, Native, Protected)

void UIndianaUserWidget::OnStartMaximizeCb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "OnStartMaximizeCb");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUserWidget.OnStartMinimizeCb
// (Final, Native, Protected)

void UIndianaUserWidget::OnStartMinimizeCb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "OnStartMinimizeCb");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUserWidget.OnStartOutroCb
// (Final, Native, Protected)

void UIndianaUserWidget::OnStartOutroCb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "OnStartOutroCb");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUserWidget.RestoreOrSetDefaultUserFocus
// (Final, Native, Public, BlueprintCallable)

void UIndianaUserWidget::RestoreOrSetDefaultUserFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "RestoreOrSetDefaultUserFocus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUserWidget.SetDefaultUserFocus
// (Final, Native, Public, BlueprintCallable)

void UIndianaUserWidget::SetDefaultUserFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "SetDefaultUserFocus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUserWidget.StartIntro
// (Final, Native, Public, BlueprintCallable)

void UIndianaUserWidget::StartIntro()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "StartIntro");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUserWidget.StartMaximize
// (Native, Public, BlueprintCallable)

void UIndianaUserWidget::StartMaximize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "StartMaximize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUserWidget.StartMinimize
// (Native, Public, BlueprintCallable)

void UIndianaUserWidget::StartMinimize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "StartMinimize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUserWidget.GetIndianaUI
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AIndianaUI*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AIndianaUI* UIndianaUserWidget::GetIndianaUI() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "GetIndianaUI");

	Params::IndianaUserWidget_GetIndianaUI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaUserWidget.GetOpenState
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWidgetOpenState                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWidgetOpenState UIndianaUserWidget::GetOpenState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "GetOpenState");

	Params::IndianaUserWidget_GetOpenState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaUserWidget.IsMaximized
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIncludeTransitioning                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaUserWidget::IsMaximized(bool bIncludeTransitioning) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "IsMaximized");

	Params::IndianaUserWidget_IsMaximized Parms{};

	Parms.bIncludeTransitioning = bIncludeTransitioning;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaUserWidget.IsMinimized
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIncludeTransitioning                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaUserWidget::IsMinimized(bool bIncludeTransitioning) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "IsMinimized");

	Params::IndianaUserWidget_IsMinimized Parms{};

	Parms.bIncludeTransitioning = bIncludeTransitioning;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaUserWidget.IsShuttingDown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIncludeTransitioning                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaUserWidget::IsShuttingDown(bool bIncludeTransitioning) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "IsShuttingDown");

	Params::IndianaUserWidget_IsShuttingDown Parms{};

	Parms.bIncludeTransitioning = bIncludeTransitioning;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaUserWidget.ObjectRefHasReferencers
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaUserWidget::ObjectRefHasReferencers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUserWidget", "ObjectRefHasReferencers");

	Params::IndianaUserWidget_ObjectRefHasReferencers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.AbilityOverviewChildWidget.ModifyPulseScale
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   PulseScale                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityOverviewChildWidget::ModifyPulseScale(float PulseScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityOverviewChildWidget", "ModifyPulseScale");

	Params::AbilityOverviewChildWidget_ModifyPulseScale Parms{};

	Parms.PulseScale = PulseScale;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.AbilityOverviewChildWidget.OnAbilityCooldownComplete
// (Event, Protected, BlueprintEvent)

void UAbilityOverviewChildWidget::OnAbilityCooldownComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityOverviewChildWidget", "OnAbilityCooldownComplete");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.AbilityOverviewDetailWidget.OnAbilityUnlockChange
// (Final, Native, Public)
// Parameters:
// EUnlockAbility                          Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityOverviewDetailWidget::OnAbilityUnlockChange(EUnlockAbility Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityOverviewDetailWidget", "OnAbilityUnlockChange");

	Params::AbilityOverviewDetailWidget_OnAbilityUnlockChange Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AbilityOverviewWidget.OnAbilityCooldownEnded
// (Final, Native, Protected)
// Parameters:
// EAbilityPosition                        AbilityPosition                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityOverviewWidget::OnAbilityCooldownEnded(EAbilityPosition AbilityPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityOverviewWidget", "OnAbilityCooldownEnded");

	Params::AbilityOverviewWidget_OnAbilityCooldownEnded Parms{};

	Parms.AbilityPosition = AbilityPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AbilityOverviewWidget.OnAbilityCooldownFinished
// (Event, Protected, BlueprintEvent)
// Parameters:
// EAbilityPosition                        AbillityPosition                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityOverviewWidget::OnAbilityCooldownFinished(EAbilityPosition AbillityPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityOverviewWidget", "OnAbilityCooldownFinished");

	Params::AbilityOverviewWidget_OnAbilityCooldownFinished Parms{};

	Parms.AbillityPosition = AbillityPosition;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.AbilityOverviewWidget.OnAbilityCooldownStarted
// (Event, Protected, BlueprintEvent)
// Parameters:
// EAbilityPosition                        AbilityPosition                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityOverviewWidget::OnAbilityCooldownStarted(EAbilityPosition AbilityPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityOverviewWidget", "OnAbilityCooldownStarted");

	Params::AbilityOverviewWidget_OnAbilityCooldownStarted Parms{};

	Parms.AbilityPosition = AbilityPosition;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.AbilityOverviewWidget.OnAbilityCooldownTriggered
// (Final, Native, Protected)
// Parameters:
// EAbilityPosition                        AbilityPosition                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityOverviewWidget::OnAbilityCooldownTriggered(EAbilityPosition AbilityPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityOverviewWidget", "OnAbilityCooldownTriggered");

	Params::AbilityOverviewWidget_OnAbilityCooldownTriggered Parms{};

	Parms.AbilityPosition = AbilityPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AbilityOverviewWidget.OnAbilityUsed
// (Final, Native, Protected)
// Parameters:
// class UAbilityOverviewDetailWidget*     Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAbilityPosition                        AbilityPosition                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityOverviewWidget::OnAbilityUsed(class UAbilityOverviewDetailWidget* Widget, EAbilityPosition AbilityPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityOverviewWidget", "OnAbilityUsed");

	Params::AbilityOverviewWidget_OnAbilityUsed Parms{};

	Parms.Widget = Widget;
	Parms.AbilityPosition = AbilityPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AbilityOverviewWidget.OnCommandButtonPressed
// (Event, Protected, BlueprintEvent)
// Parameters:
// EAbilityPosition                        AbillityPosition                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityOverviewWidget::OnCommandButtonPressed(EAbilityPosition AbillityPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityOverviewWidget", "OnCommandButtonPressed");

	Params::AbilityOverviewWidget_OnCommandButtonPressed Parms{};

	Parms.AbillityPosition = AbillityPosition;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.AbilityOverviewWidget.OnCompanionAbilityBindingModeChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityOverviewWidget::OnCompanionAbilityBindingModeChanged(int32 ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityOverviewWidget", "OnCompanionAbilityBindingModeChanged");

	Params::AbilityOverviewWidget_OnCompanionAbilityBindingModeChanged Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AbilityOverviewWidget.OnCompanionAbilityModeChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityOverviewWidget::OnCompanionAbilityModeChanged(int32 ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityOverviewWidget", "OnCompanionAbilityModeChanged");

	Params::AbilityOverviewWidget_OnCompanionAbilityModeChanged Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AbilityOverviewWidget.OnHUDModeChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityOverviewWidget::OnHUDModeChanged(int32 ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityOverviewWidget", "OnHUDModeChanged");

	Params::AbilityOverviewWidget_OnHUDModeChanged Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AbilityOverviewWidget.OnHUDVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityOverviewWidget::OnHUDVisibilityChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityOverviewWidget", "OnHUDVisibilityChanged");

	Params::AbilityOverviewWidget_OnHUDVisibilityChanged Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AbilityOverviewWidget.OnPlayerCombatStateChange
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    IsPlayerInCombat                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityOverviewWidget::OnPlayerCombatStateChange(bool IsPlayerInCombat, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityOverviewWidget", "OnPlayerCombatStateChange");

	Params::AbilityOverviewWidget_OnPlayerCombatStateChange Parms{};

	Parms.IsPlayerInCombat = IsPlayerInCombat;
	Parms.bRestoring = bRestoring;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.OnMadScientistKill.OnMadScientistKill
// (Final, Native, Protected)

void UOnMadScientistKill::OnMadScientistKill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnMadScientistKill", "OnMadScientistKill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AchievementsManager.CompleteAchievementBP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAchievementDataAsset*            Achievement                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAchievementsManager::CompleteAchievementBP(const class UAchievementDataAsset* Achievement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AchievementsManager", "CompleteAchievementBP");

	Params::AchievementsManager_CompleteAchievementBP Parms{};

	Parms.Achievement = Achievement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AchievementsManager.CompleteAchievement
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             AchievementBPName                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAchievementsManager::CompleteAchievement(const class FName& AchievementBPName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AchievementsManager", "CompleteAchievement");

	Params::AchievementsManager_CompleteAchievement Parms{};

	Parms.AchievementBPName = AchievementBPName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AchievementsManager.GameOver
// (Final, Exec, Native, Public)

void UAchievementsManager::GameOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AchievementsManager", "GameOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AchievementsManager.IncrementAchievement
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             AchievementBPName                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAchievementsManager::IncrementAchievement(const class FName& AchievementBPName, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AchievementsManager", "IncrementAchievement");

	Params::AchievementsManager_IncrementAchievement Parms{};

	Parms.AchievementBPName = AchievementBPName;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AchievementsManager.OnActiveUserChanged
// (Final, Native, Protected)
// Parameters:
// EActiveUserChangeType                   ChangeType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAchievementsManager::OnActiveUserChanged(EActiveUserChangeType ChangeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AchievementsManager", "OnActiveUserChanged");

	Params::AchievementsManager_OnActiveUserChanged Parms{};

	Parms.ChangeType = ChangeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AchievementsManager.OnItemEquipped
// (Final, Native, Protected)
// Parameters:
// class UItem*                            Item                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAchievementsManager::OnItemEquipped(class UItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AchievementsManager", "OnItemEquipped");

	Params::AchievementsManager_OnItemEquipped Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AchievementsManager.OnKillPreDeath
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAchievementsManager::OnKillPreDeath(class AActor* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AchievementsManager", "OnKillPreDeath");

	Params::AchievementsManager_OnKillPreDeath Parms{};

	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AchievementsManager.OnWeaponSlotted
// (Final, Native, Protected)
// Parameters:
// class UItem*                            Item                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAchievementsManager::OnWeaponSlotted(class UItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AchievementsManager", "OnWeaponSlotted");

	Params::AchievementsManager_OnWeaponSlotted Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AchievementsManager.ResetAchievements
// (Final, Exec, Native, Public)

void UAchievementsManager::ResetAchievements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AchievementsManager", "ResetAchievements");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaInterfaceUserWidget.SetCursorVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaInterfaceUserWidget::SetCursorVisible(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaInterfaceUserWidget", "SetCursorVisible");

	Params::IndianaInterfaceUserWidget_SetCursorVisible Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaInterfaceUserWidget.SetInterfaceUserFocus
// (Final, Native, Public, BlueprintCallable)

void UIndianaInterfaceUserWidget::SetInterfaceUserFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaInterfaceUserWidget", "SetInterfaceUserFocus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DialogBoxWidget.OnInputAbort
// (Final, Native, Protected)

void UDialogBoxWidget::OnInputAbort()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DialogBoxWidget", "OnInputAbort");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DialogBoxWidget.OnInputBack
// (Final, Native, Protected)

void UDialogBoxWidget::OnInputBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DialogBoxWidget", "OnInputBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DialogBoxWidget.OnInputConfirm
// (Final, Native, Protected)

void UDialogBoxWidget::OnInputConfirm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DialogBoxWidget", "OnInputConfirm");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DialogBoxWidget.SetNewBackingMaterialHeight
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   NewHeight                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDialogBoxWidget::SetNewBackingMaterialHeight(float NewHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DialogBoxWidget", "SetNewBackingMaterialHeight");

	Params::DialogBoxWidget_SetNewBackingMaterialHeight Parms{};

	Parms.NewHeight = NewHeight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.BaseInventoryItemManagement.OnDragDrop_BreakDownItem
// (Native, Protected)
// Parameters:
// class UIndianaDragDropOperation*        Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseInventoryItemManagement::OnDragDrop_BreakDownItem(class UIndianaDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseInventoryItemManagement", "OnDragDrop_BreakDownItem");

	Params::BaseInventoryItemManagement_OnDragDrop_BreakDownItem Parms{};

	Parms.Operation = Operation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.BaseInventoryItemManagement.OnDragDrop_ClearWeaponSlot
// (Native, Protected)
// Parameters:
// class UIndianaDragDropOperation*        Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseInventoryItemManagement::OnDragDrop_ClearWeaponSlot(class UIndianaDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseInventoryItemManagement", "OnDragDrop_ClearWeaponSlot");

	Params::BaseInventoryItemManagement_OnDragDrop_ClearWeaponSlot Parms{};

	Parms.Operation = Operation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.BaseInventoryItemManagement.OnDragDrop_JunkItem
// (Native, Protected)
// Parameters:
// class UIndianaDragDropOperation*        Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseInventoryItemManagement::OnDragDrop_JunkItem(class UIndianaDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseInventoryItemManagement", "OnDragDrop_JunkItem");

	Params::BaseInventoryItemManagement_OnDragDrop_JunkItem Parms{};

	Parms.Operation = Operation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.BaseInventoryItemManagement.OnDragDrop_SetArmorSlot
// (Native, Protected)
// Parameters:
// class UIndianaDragDropOperation*        Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseInventoryItemManagement::OnDragDrop_SetArmorSlot(class UIndianaDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseInventoryItemManagement", "OnDragDrop_SetArmorSlot");

	Params::BaseInventoryItemManagement_OnDragDrop_SetArmorSlot Parms{};

	Parms.Operation = Operation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionEquipmentWidget.OnDragDrop_EquipItem
// (Final, Native, Protected)
// Parameters:
// class UIndianaDragDropOperation*        Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionEquipmentWidget::OnDragDrop_EquipItem(class UIndianaDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionEquipmentWidget", "OnDragDrop_EquipItem");

	Params::CompanionEquipmentWidget_OnDragDrop_EquipItem Parms{};

	Parms.Operation = Operation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionEquipmentWidget.OnItemAddedToPlayerInventory
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCompanionEquipmentWidget::OnItemAddedToPlayerInventory(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionEquipmentWidget", "OnItemAddedToPlayerInventory");

	Params::CompanionEquipmentWidget_OnItemAddedToPlayerInventory Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionEquipmentWidget.OnItemRemovedFromPlayerInventory
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCompanionEquipmentWidget::OnItemRemovedFromPlayerInventory(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionEquipmentWidget", "OnItemRemovedFromPlayerInventory");

	Params::CompanionEquipmentWidget_OnItemRemovedFromPlayerInventory Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionOverviewWidget.OnCombatStateChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bCombatIn                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionOverviewWidget::OnCombatStateChanged(bool bCombatIn, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionOverviewWidget", "OnCombatStateChanged");

	Params::CompanionOverviewWidget_OnCombatStateChanged Parms{};

	Parms.bCombatIn = bCombatIn;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionOverviewWidget.OnCompanionStatusModeChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionOverviewWidget::OnCompanionStatusModeChanged(int32 ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionOverviewWidget", "OnCompanionStatusModeChanged");

	Params::CompanionOverviewWidget_OnCompanionStatusModeChanged Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionOverviewWidget.OnFirstStatusEffect
// (Event, Protected, BlueprintEvent)

void UCompanionOverviewWidget::OnFirstStatusEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionOverviewWidget", "OnFirstStatusEffect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.CompanionOverviewWidget.OnHUDVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionOverviewWidget::OnHUDVisibilityChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionOverviewWidget", "OnHUDVisibilityChanged");

	Params::CompanionOverviewWidget_OnHUDVisibilityChanged Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionOverviewWidget.OnMadeActive
// (Event, Protected, BlueprintEvent)

void UCompanionOverviewWidget::OnMadeActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionOverviewWidget", "OnMadeActive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.CompanionOverviewWidget.OnMadeInactive
// (Event, Protected, BlueprintEvent)

void UCompanionOverviewWidget::OnMadeInactive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionOverviewWidget", "OnMadeInactive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.CompanionOverviewWidget.OnNoStatusEffect
// (Event, Protected, BlueprintEvent)

void UCompanionOverviewWidget::OnNoStatusEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionOverviewWidget", "OnNoStatusEffect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.OnSkillUsedEvent.OnSkillUsed
// (Final, Native, Protected)
// Parameters:
// ESkill                                  SkillUsed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnSkillUsedEvent::OnSkillUsed(ESkill SkillUsed, class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnSkillUsedEvent", "OnSkillUsed");

	Params::OnSkillUsedEvent_OnSkillUsed Parms{};

	Parms.SkillUsed = SkillUsed;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionMoveToWidget.OnMoveToCancelled
// (Event, Public, BlueprintEvent)

void UCompanionMoveToWidget::OnMoveToCancelled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionMoveToWidget", "OnMoveToCancelled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.CompanionMoveToWidget.OnNewLocation
// (Event, Public, BlueprintEvent)

void UCompanionMoveToWidget::OnNewLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionMoveToWidget", "OnNewLocation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.OnUdderGatlingNeedler.OnUdderGatlingNeedler
// (Final, Native, Protected)

void UOnUdderGatlingNeedler::OnUdderGatlingNeedler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnUdderGatlingNeedler", "OnUdderGatlingNeedler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DifficultySelectWidget.StartTransitionToDifficultyFromSubtitle
// (Event, Protected, BlueprintEvent)

void UDifficultySelectWidget::StartTransitionToDifficultyFromSubtitle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DifficultySelectWidget", "StartTransitionToDifficultyFromSubtitle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.DifficultySelectWidget.StartTransitionToSubtitleFromDifficulty
// (Event, Protected, BlueprintEvent)

void UDifficultySelectWidget::StartTransitionToSubtitleFromDifficulty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DifficultySelectWidget", "StartTransitionToSubtitleFromDifficulty");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.DifficultySelectWidget.TransitionToDifficultyComplete
// (Final, Native, Protected, BlueprintCallable)

void UDifficultySelectWidget::TransitionToDifficultyComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DifficultySelectWidget", "TransitionToDifficultyComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DifficultySelectWidget.TrasitionToSubtitleComplete
// (Final, Native, Protected, BlueprintCallable)

void UDifficultySelectWidget::TrasitionToSubtitleComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DifficultySelectWidget", "TrasitionToSubtitleComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DifficultySelectWidget.ValueChanged
// (Final, Native, Public)
// Parameters:
// class UUserSetting*                     UserSetting                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDifficultySelectWidget::ValueChanged(class UUserSetting* UserSetting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DifficultySelectWidget", "ValueChanged");

	Params::DifficultySelectWidget_ValueChanged Parms{};

	Parms.UserSetting = UserSetting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ActorRenderWidget.OnBorderMouseDown
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    MouseEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UActorRenderWidget::OnBorderMouseDown(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorRenderWidget", "OnBorderMouseDown");

	Params::ActorRenderWidget_OnBorderMouseDown Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.MouseEvent = std::move(MouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ActorRenderWidget.OnGamepadToggleFullZoom
// (Final, Native, Protected)

void UActorRenderWidget::OnGamepadToggleFullZoom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorRenderWidget", "OnGamepadToggleFullZoom");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ActorRenderWidget.OnMouseZoomIn
// (Final, Native, Protected)

void UActorRenderWidget::OnMouseZoomIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorRenderWidget", "OnMouseZoomIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ActorRenderWidget.OnMouseZoomOut
// (Final, Native, Protected)

void UActorRenderWidget::OnMouseZoomOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorRenderWidget", "OnMouseZoomOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ActorRenderWidget.CanZoom
// (Final, Native, Protected, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorRenderWidget::CanZoom() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorRenderWidget", "CanZoom");

	Params::ActorRenderWidget_CanZoom Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.DecisionTree.RunDecisionTree
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class AIndianaAiCharacter*              Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAIEventInfo*                     EventInfo                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDecisionTreeRequestPriority            OutPriority                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UDecisionTreeRequestData*> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UDecisionTreeRequestData*> UDecisionTree::RunDecisionTree(class AIndianaAiCharacter* Owner, class FName EventType, class UAIEventInfo* EventInfo, EDecisionTreeRequestPriority* OutPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecisionTree", "RunDecisionTree");

	Params::DecisionTree_RunDecisionTree Parms{};

	Parms.Owner = Owner;
	Parms.EventType = EventType;
	Parms.EventInfo = EventInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPriority != nullptr)
		*OutPriority = Parms.OutPriority;

	return Parms.ReturnValue;
}


// Function Indiana.DecisionTree.RunMetaDecisionTree
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class UDecisionTree>        DecisionTree                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AIndianaAiCharacter*              Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAIEventInfo*                     EventInfo                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDecisionTreeRequestPriority            OutPriority                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UDecisionTreeRequestData*> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UDecisionTreeRequestData*> UDecisionTree::RunMetaDecisionTree(TSubclassOf<class UDecisionTree> DecisionTree, class AIndianaAiCharacter* Owner, class FName EventType, class UAIEventInfo* EventInfo, EDecisionTreeRequestPriority* OutPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecisionTree", "RunMetaDecisionTree");

	Params::DecisionTree_RunMetaDecisionTree Parms{};

	Parms.DecisionTree = DecisionTree;
	Parms.Owner = Owner;
	Parms.EventType = EventType;
	Parms.EventInfo = EventInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPriority != nullptr)
		*OutPriority = Parms.OutPriority;

	return Parms.ReturnValue;
}


// Function Indiana.DecisionTree.RunSuperDecisionTree
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class AIndianaAiCharacter*              Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAIEventInfo*                     EventInfo                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDecisionTreeRequestPriority            OutPriority                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UDecisionTreeRequestData*> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UDecisionTreeRequestData*> UDecisionTree::RunSuperDecisionTree(class AIndianaAiCharacter* Owner, class FName EventType, class UAIEventInfo* EventInfo, EDecisionTreeRequestPriority* OutPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecisionTree", "RunSuperDecisionTree");

	Params::DecisionTree_RunSuperDecisionTree Parms{};

	Parms.Owner = Owner;
	Parms.EventType = EventType;
	Parms.EventInfo = EventInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPriority != nullptr)
		*OutPriority = Parms.OutPriority;

	return Parms.ReturnValue;
}


// Function Indiana.StatusEffect.ReceiveApplyEffect
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Ratio                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoredFromSave                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffect::ReceiveApplyEffect(class AActor* Target, float Ratio, bool bRestoredFromSave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "ReceiveApplyEffect");

	Params::StatusEffect_ReceiveApplyEffect Parms{};

	Parms.Target = Target;
	Parms.Ratio = Ratio;
	Parms.bRestoredFromSave = bRestoredFromSave;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.StatusEffect.ReceiveClearEffect
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffect::ReceiveClearEffect(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "ReceiveClearEffect");

	Params::StatusEffect_ReceiveClearEffect Parms{};

	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.StatusEffect.GetStatusEffectOriginActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UStatusEffect::GetStatusEffectOriginActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "GetStatusEffectOriginActor");

	Params::StatusEffect_GetStatusEffectOriginActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.DifficultyManager.GetGameDifficulty
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EGameDifficulty                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGameDifficulty UDifficultyManager::GetGameDifficulty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DifficultyManager", "GetGameDifficulty");

	Params::DifficultyManager_GetGameDifficulty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.DifficultyManager.SetDifficulty
// (Final, Exec, Native, Public)
// Parameters:
// EGameDifficulty                         NewDifficulty                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDifficultyManager::SetDifficulty(EGameDifficulty NewDifficulty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DifficultyManager", "SetDifficulty");

	Params::DifficultyManager_SetDifficulty Parms{};

	Parms.NewDifficulty = NewDifficulty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DifficultyManager.SetSurvivalMode
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    IsSurvivalMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDifficultyManager::SetSurvivalMode(bool IsSurvivalMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DifficultyManager", "SetSurvivalMode");

	Params::DifficultyManager_SetSurvivalMode Parms{};

	Parms.IsSurvivalMode = IsSurvivalMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnSpendMoney.OnMoneySpent
// (Final, Native, Protected)
// Parameters:
// int32                                   Money                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVendorInteraction                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnSpendMoney::OnMoneySpent(int32 Money, bool bVendorInteraction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnSpendMoney", "OnMoneySpent");

	Params::OnSpendMoney_OnMoneySpent Parms{};

	Parms.Money = Money;
	Parms.bVendorInteraction = bVendorInteraction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DisguiseMeterWidget.HideDisguiseMeterTip
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDisguiseMeterWidget::HideDisguiseMeterTip(float StartTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DisguiseMeterWidget", "HideDisguiseMeterTip");

	Params::DisguiseMeterWidget_HideDisguiseMeterTip Parms{};

	Parms.StartTime = StartTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.DisguiseMeterWidget.OnDisguiseBegin
// (Event, Protected, BlueprintEvent)

void UDisguiseMeterWidget::OnDisguiseBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DisguiseMeterWidget", "OnDisguiseBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.DisguiseMeterWidget.OnDisguiseEnd
// (Event, Protected, BlueprintEvent)

void UDisguiseMeterWidget::OnDisguiseEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DisguiseMeterWidget", "OnDisguiseEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.DisguiseMeterWidget.OnDisguiseEquipped
// (Final, Native, Protected)
// Parameters:
// class UDisguiseData*                    Disguise                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDisguiseMeterWidget::OnDisguiseEquipped(const class UDisguiseData* Disguise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DisguiseMeterWidget", "OnDisguiseEquipped");

	Params::DisguiseMeterWidget_OnDisguiseEquipped Parms{};

	Parms.Disguise = Disguise;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DisguiseMeterWidget.OnDisguiseFailure
// (Final, Native, Protected)

void UDisguiseMeterWidget::OnDisguiseFailure()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DisguiseMeterWidget", "OnDisguiseFailure");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DisguiseMeterWidget.OnDisguiseImageLoaded
// (Event, Protected, BlueprintEvent)

void UDisguiseMeterWidget::OnDisguiseImageLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DisguiseMeterWidget", "OnDisguiseImageLoaded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.DisguiseMeterWidget.OnDisguiseMeterChanged
// (Final, Native, Protected)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDisguiseMeterWidget::OnDisguiseMeterChanged(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DisguiseMeterWidget", "OnDisguiseMeterChanged");

	Params::DisguiseMeterWidget_OnDisguiseMeterChanged Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DisguiseMeterWidget.OnDisguiseMeterVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDisguiseMeterWidget::OnDisguiseMeterVisibilityChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DisguiseMeterWidget", "OnDisguiseMeterVisibilityChanged");

	Params::DisguiseMeterWidget_OnDisguiseMeterVisibilityChanged Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DisguiseMeterWidget.OnDisguiseRefilled
// (Final, Native, Protected)

void UDisguiseMeterWidget::OnDisguiseRefilled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DisguiseMeterWidget", "OnDisguiseRefilled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DisguiseMeterWidget.OnDisguiseUnequipped
// (Final, Native, Protected)

void UDisguiseMeterWidget::OnDisguiseUnequipped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DisguiseMeterWidget", "OnDisguiseUnequipped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DisguiseMeterWidget.OnEnterRestrictedAreaWithoutDisguise
// (Final, Native, Protected)
// Parameters:
// class UDisguiseData*                    Disguise                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMissingShroud                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDisguiseMeterWidget::OnEnterRestrictedAreaWithoutDisguise(const class UDisguiseData* Disguise, bool bMissingShroud)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DisguiseMeterWidget", "OnEnterRestrictedAreaWithoutDisguise");

	Params::DisguiseMeterWidget_OnEnterRestrictedAreaWithoutDisguise Parms{};

	Parms.Disguise = Disguise;
	Parms.bMissingShroud = bMissingShroud;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DisguiseMeterWidget.OnHUDVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDisguiseMeterWidget::OnHUDVisibilityChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DisguiseMeterWidget", "OnHUDVisibilityChanged");

	Params::DisguiseMeterWidget_OnHUDVisibilityChanged Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DisguiseMeterWidget.OnRestrictedAreaExited
// (Final, Native, Protected)
// Parameters:
// class ARestrictedArea*                  RestrictedArea                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDisguiseMeterWidget::OnRestrictedAreaExited(const class ARestrictedArea* RestrictedArea)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DisguiseMeterWidget", "OnRestrictedAreaExited");

	Params::DisguiseMeterWidget_OnRestrictedAreaExited Parms{};

	Parms.RestrictedArea = RestrictedArea;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DisguiseMeterWidget.ShowDisguiseMeterTip
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDisguiseMeterWidget::ShowDisguiseMeterTip(float StartTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DisguiseMeterWidget", "ShowDisguiseMeterTip");

	Params::DisguiseMeterWidget_ShowDisguiseMeterTip Parms{};

	Parms.StartTime = StartTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.DisguiseMeterWidget.UpdateDisguiseMeterFill
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDisguiseMeterWidget::UpdateDisguiseMeterFill(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DisguiseMeterWidget", "UpdateDisguiseMeterFill");

	Params::DisguiseMeterWidget_UpdateDisguiseMeterFill Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.DisguiseMeterWidget.UpdateDisguiseMeterInnerAnim
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   CurrentFrame                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDisguiseMeterWidget::UpdateDisguiseMeterInnerAnim(int32 CurrentFrame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DisguiseMeterWidget", "UpdateDisguiseMeterInnerAnim");

	Params::DisguiseMeterWidget_UpdateDisguiseMeterInnerAnim Parms{};

	Parms.CurrentFrame = CurrentFrame;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.WeaponMode.GetPrimaryDamageTypeEnum
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EIndianaDamageType                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EIndianaDamageType UWeaponMode::GetPrimaryDamageTypeEnum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponMode", "GetPrimaryDamageTypeEnum");

	Params::WeaponMode_GetPrimaryDamageTypeEnum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.WeaponMode.IsCharging
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponMode::IsCharging() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponMode", "IsCharging");

	Params::WeaponMode_IsCharging Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.WeaponMode.IsFullyAimed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponMode::IsFullyAimed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponMode", "IsFullyAimed");

	Params::WeaponMode_IsFullyAimed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.WeaponMode.IsIdle
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponMode::IsIdle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponMode", "IsIdle");

	Params::WeaponMode_IsIdle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.RangedMode.OnMontageBlendingOut
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URangedMode::OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedMode", "OnMontageBlendingOut");

	Params::RangedMode_OnMontageBlendingOut Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.RangedMode.GetAimingDirection
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URangedMode::GetAimingDirection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedMode", "GetAimingDirection");

	Params::RangedMode_GetAimingDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.RangedMode.GetAimingUpDirection
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URangedMode::GetAimingUpDirection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedMode", "GetAimingUpDirection");

	Params::RangedMode_GetAimingUpDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.RangedMode.GetMuzzleLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URangedMode::GetMuzzleLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedMode", "GetMuzzleLocation");

	Params::RangedMode_GetMuzzleLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.RangedMode.GetMuzzleLocationAndRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URangedMode::GetMuzzleLocationAndRotation(struct FVector* Location, struct FRotator* Rotation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedMode", "GetMuzzleLocationAndRotation");

	Params::RangedMode_GetMuzzleLocationAndRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Location != nullptr)
		*Location = std::move(Parms.Location);

	if (Rotation != nullptr)
		*Rotation = std::move(Parms.Rotation);

	return Parms.ReturnValue;
}


// Function Indiana.RangedMode.GetMuzzleRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator URangedMode::GetMuzzleRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedMode", "GetMuzzleRotation");

	Params::RangedMode_GetMuzzleRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.RangedMode.GetShotOrigin
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URangedMode::GetShotOrigin() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedMode", "GetShotOrigin");

	Params::RangedMode_GetShotOrigin Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.RangedMode.GetWeaponCurrentAmmoGaugeAlpha
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URangedMode::GetWeaponCurrentAmmoGaugeAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedMode", "GetWeaponCurrentAmmoGaugeAlpha");

	Params::RangedMode_GetWeaponCurrentAmmoGaugeAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.RangedMode.HasScope
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URangedMode::HasScope() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangedMode", "HasScope");

	Params::RangedMode_HasScope Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OnCalledShotCameraChange.OnCameraStepEvent
// (Final, Native, Protected)
// Parameters:
// ECalledShotCameraStep                   CameraStep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnCalledShotCameraChange::OnCameraStepEvent(ECalledShotCameraStep CameraStep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnCalledShotCameraChange", "OnCameraStepEvent");

	Params::OnCalledShotCameraChange_OnCameraStepEvent Parms{};

	Parms.CameraStep = CameraStep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AIDefensiveActionsComponent.OnTakeDamage
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FCauseDamageInfo                 CauseDamageInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UAIDefensiveActionsComponent::OnTakeDamage(const struct FCauseDamageInfo& CauseDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIDefensiveActionsComponent", "OnTakeDamage");

	Params::AIDefensiveActionsComponent_OnTakeDamage Parms{};

	Parms.CauseDamageInfo = std::move(CauseDamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AIDetectionComponent.OnDetectedNonHostileCombatStateChange
// (Final, Native, Private)
// Parameters:
// bool                                    bIsInCombat                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIDetectionComponent::OnDetectedNonHostileCombatStateChange(bool bIsInCombat, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIDetectionComponent", "OnDetectedNonHostileCombatStateChange");

	Params::AIDetectionComponent_OnDetectedNonHostileCombatStateChange Parms{};

	Parms.bIsInCombat = bIsInCombat;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AIDetectionComponent.OnPerceptionUpdate
// (Final, Native, Private)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAIStimulus                      Stimulus                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UAIDetectionComponent::OnPerceptionUpdate(class AActor* Actor, const struct FAIStimulus& Stimulus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIDetectionComponent", "OnPerceptionUpdate");

	Params::AIDetectionComponent_OnPerceptionUpdate Parms{};

	Parms.Actor = Actor;
	Parms.Stimulus = std::move(Stimulus);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AIDetectionComponent.OnPlayerKill
// (Final, Native, Private, HasOutParams)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCauseDamageInfo                 CauseDamageInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UAIDetectionComponent::OnPlayerKill(class AActor* Victim, const struct FCauseDamageInfo& CauseDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIDetectionComponent", "OnPlayerKill");

	Params::AIDetectionComponent_OnPlayerKill Parms{};

	Parms.Victim = Victim;
	Parms.CauseDamageInfo = std::move(CauseDamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnRestrictedAreaEntered.OnRestrictedAreaEntered
// (Final, Native, Protected)
// Parameters:
// class ARestrictedArea*                  RestrictedArea                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnRestrictedAreaEntered::OnRestrictedAreaEntered(const class ARestrictedArea* RestrictedArea)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnRestrictedAreaEntered", "OnRestrictedAreaEntered");

	Params::OnRestrictedAreaEntered_OnRestrictedAreaEntered Parms{};

	Parms.RestrictedArea = RestrictedArea;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Door.OnOCLStateChange
// (Final, Native, Protected)
// Parameters:
// EOCLState                               PreviousState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOCLState                               CurrentState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::OnOCLStateChange(EOCLState PreviousState, EOCLState CurrentState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "OnOCLStateChange");

	Params::Door_OnOCLStateChange Parms{};

	Parms.PreviousState = PreviousState;
	Parms.CurrentState = CurrentState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Door.TriggersTravel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADoor::TriggersTravel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "TriggersTravel");

	Params::Door_TriggersTravel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OnRestrictedAreaExited.OnRestrictedAreaExited
// (Final, Native, Protected)
// Parameters:
// class ARestrictedArea*                  RestrictedArea                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnRestrictedAreaExited::OnRestrictedAreaExited(const class ARestrictedArea* RestrictedArea)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnRestrictedAreaExited", "OnRestrictedAreaExited");

	Params::OnRestrictedAreaExited_OnRestrictedAreaExited Parms{};

	Parms.RestrictedArea = RestrictedArea;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.BackgroundSplitPanelWidget.OnInnerBottomTextureLoaded
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UTexture2D*                       Texture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackgroundSplitPanelWidget::OnInnerBottomTextureLoaded(class UTexture2D* Texture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BackgroundSplitPanelWidget", "OnInnerBottomTextureLoaded");

	Params::BackgroundSplitPanelWidget_OnInnerBottomTextureLoaded Parms{};

	Parms.Texture = Texture;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.BackgroundSplitPanelWidget.OnInnerTopTextureLoaded
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UTexture2D*                       Texture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackgroundSplitPanelWidget::OnInnerTopTextureLoaded(class UTexture2D* Texture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BackgroundSplitPanelWidget", "OnInnerTopTextureLoaded");

	Params::BackgroundSplitPanelWidget_OnInnerTopTextureLoaded Parms{};

	Parms.Texture = Texture;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.BackgroundSplitPanelWidget.OnOuterBottomTextureLoaded
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UTexture2D*                       Texture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackgroundSplitPanelWidget::OnOuterBottomTextureLoaded(class UTexture2D* Texture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BackgroundSplitPanelWidget", "OnOuterBottomTextureLoaded");

	Params::BackgroundSplitPanelWidget_OnOuterBottomTextureLoaded Parms{};

	Parms.Texture = Texture;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.BackgroundSplitPanelWidget.OnOuterTopTextureLoaded
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UTexture2D*                       Texture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackgroundSplitPanelWidget::OnOuterTopTextureLoaded(class UTexture2D* Texture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BackgroundSplitPanelWidget", "OnOuterTopTextureLoaded");

	Params::BackgroundSplitPanelWidget_OnOuterTopTextureLoaded Parms{};

	Parms.Texture = Texture;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.OnJump.OnJump
// (Final, Native, Protected)

void UOnJump::OnJump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnJump", "OnJump");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AIInteractionComponent.OnNavigationPathUpdate
// (Final, Native, Private)

void UAIInteractionComponent::OnNavigationPathUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIInteractionComponent", "OnNavigationPathUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EnemyScannerComponent.TimeDilationEnd
// (Final, Native, Protected)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemyScannerComponent::TimeDilationEnd(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyScannerComponent", "TimeDilationEnd");

	Params::EnemyScannerComponent_TimeDilationEnd Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EnemyScannerComponent.TimeDilationStart
// (Final, Native, Protected)

void UEnemyScannerComponent::TimeDilationStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyScannerComponent", "TimeDilationStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AimAssistComponent.AimAssistVisualAdhesion
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimAssistComponent::AimAssistVisualAdhesion(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimAssistComponent", "AimAssistVisualAdhesion");

	Params::AimAssistComponent_AimAssistVisualAdhesion Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AimAssistComponent.AimAssistVisualBulletMagnetism
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimAssistComponent::AimAssistVisualBulletMagnetism(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimAssistComponent", "AimAssistVisualBulletMagnetism");

	Params::AimAssistComponent_AimAssistVisualBulletMagnetism Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AimAssistComponent.AimAssistVisualFriction
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimAssistComponent::AimAssistVisualFriction(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimAssistComponent", "AimAssistVisualFriction");

	Params::AimAssistComponent_AimAssistVisualFriction Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AimAssistComponent.AimAssistVisualSpread
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimAssistComponent::AimAssistVisualSpread(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimAssistComponent", "AimAssistVisualSpread");

	Params::AimAssistComponent_AimAssistVisualSpread Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AimAssistComponent.EnableAimAssist
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimAssistComponent::EnableAimAssist(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimAssistComponent", "EnableAimAssist");

	Params::AimAssistComponent_EnableAimAssist Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AimAssistComponent.OnDifficultyChanged
// (Final, Native, Protected)
// Parameters:
// EGameDifficulty                         NewDifficulty                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimAssistComponent::OnDifficultyChanged(EGameDifficulty NewDifficulty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimAssistComponent", "OnDifficultyChanged");

	Params::AimAssistComponent_OnDifficultyChanged Parms{};

	Parms.NewDifficulty = NewDifficulty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AimAssistComponent.ToggleAimAssist
// (Final, Native, Public, BlueprintCallable)

void UAimAssistComponent::ToggleAimAssist()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimAssistComponent", "ToggleAimAssist");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AimAssistComponent.ToggleBulletMagnetism
// (Final, Native, Public, BlueprintCallable)

void UAimAssistComponent::ToggleBulletMagnetism()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimAssistComponent", "ToggleBulletMagnetism");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AimAssistComponent.ToggleFriction
// (Final, Native, Public, BlueprintCallable)

void UAimAssistComponent::ToggleFriction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimAssistComponent", "ToggleFriction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AimAssistComponent.ToggleTargetStrafeLock
// (Final, Native, Public, BlueprintCallable)

void UAimAssistComponent::ToggleTargetStrafeLock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimAssistComponent", "ToggleTargetStrafeLock");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AimAssistComponent.ToggleTrackQuickTarget
// (Final, Native, Public, BlueprintCallable)

void UAimAssistComponent::ToggleTrackQuickTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimAssistComponent", "ToggleTrackQuickTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.FireMode.OnStatUpdated
// (Final, Native, Protected)
// Parameters:
// class URpgStat*                         Stat                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFireMode::OnStatUpdated(const class URpgStat* Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FireMode", "OnStatUpdated");

	Params::FireMode_OnStatUpdated Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.FireMode.OnTimeDilationUpdated
// (Final, Native, Protected)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFireMode::OnTimeDilationUpdated(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FireMode", "OnTimeDilationUpdated");

	Params::FireMode_OnTimeDilationUpdated Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.FireMode.ResetCharge
// (Native, Public, BlueprintCallable)

void UFireMode::ResetCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FireMode", "ResetCharge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.FireMode.CanCharge
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFireMode::CanCharge() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FireMode", "CanCharge");

	Params::FireMode_CanCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.FireMode.GetChargeProgress
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFireMode::GetChargeProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FireMode", "GetChargeProgress");

	Params::FireMode_GetChargeProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.FireMode.IsBurst
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFireMode::IsBurst() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FireMode", "IsBurst");

	Params::FireMode_IsBurst Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.FireMode.IsProjectileCharge
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFireMode::IsProjectileCharge() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FireMode", "IsProjectileCharge");

	Params::FireMode_IsProjectileCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.FireMode.IsSemiAutomatic
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFireMode::IsSemiAutomatic() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FireMode", "IsSemiAutomatic");

	Params::FireMode_IsSemiAutomatic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.FireMode.IsSpinUp
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFireMode::IsSpinUp() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FireMode", "IsSpinUp");

	Params::FireMode_IsSpinUp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.FireMode.UsesCharge
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFireMode::UsesCharge() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FireMode", "UsesCharge");

	Params::FireMode_UsesCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.AudioHelpers.LoadAkAudioEventReference
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkAudioEvent* UAudioHelpers::LoadAkAudioEventReference(const class FString& Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AudioHelpers", "LoadAkAudioEventReference");

	Params::AudioHelpers_LoadAkAudioEventReference Parms{};

	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaCharMovementComponent.OnBumped
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           SelfActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UIndianaCharMovementComponent::OnBumped(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCharMovementComponent", "OnBumped");

	Params::IndianaCharMovementComponent_OnBumped Parms{};

	Parms.SelfActor = SelfActor;
	Parms.OtherActor = OtherActor;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AIMovementComponent.OnExtremaBeginOverlap
// (Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAIMovementComponent::OnExtremaBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIMovementComponent", "OnExtremaBeginOverlap");

	Params::AIMovementComponent_OnExtremaBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AIMovementComponent.OnExtremaEndOverlap
// (Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIMovementComponent::OnExtremaEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIMovementComponent", "OnExtremaEndOverlap");

	Params::AIMovementComponent_OnExtremaEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AIMovementComponent.OnNewStateOfBeing
// (Final, Native, Protected)
// Parameters:
// EStateOfBeing                           NewStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStateOfBeing                           OldStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIMovementComponent::OnNewStateOfBeing(EStateOfBeing NewStateOfBeing, EStateOfBeing OldStateOfBeing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIMovementComponent", "OnNewStateOfBeing");

	Params::AIMovementComponent_OnNewStateOfBeing Parms{};

	Parms.NewStateOfBeing = NewStateOfBeing;
	Parms.OldStateOfBeing = OldStateOfBeing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AIMovementComponent.OnRestoredStateOfBeing
// (Final, Native, Protected)
// Parameters:
// EStateOfBeing                           RestoredStateOfBeing                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIMovementComponent::OnRestoredStateOfBeing(EStateOfBeing RestoredStateOfBeing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIMovementComponent", "OnRestoredStateOfBeing");

	Params::AIMovementComponent_OnRestoredStateOfBeing Parms{};

	Parms.RestoredStateOfBeing = RestoredStateOfBeing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionPositionComponent.RequestForceTeleportCompanions
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Position1                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position2                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionPositionComponent::RequestForceTeleportCompanions(const struct FVector& Position1, const struct FVector& Position2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CompanionPositionComponent", "RequestForceTeleportCompanions");

	Params::CompanionPositionComponent_RequestForceTeleportCompanions Parms{};

	Parms.Position1 = std::move(Position1);
	Parms.Position2 = std::move(Position2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionPositionComponent.OnOccupiedElevatorChange
// (Final, Native, Protected)
// Parameters:
// class AElevator*                        Elevator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOccupied                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionPositionComponent::OnOccupiedElevatorChange(class AElevator* Elevator, bool bOccupied)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionPositionComponent", "OnOccupiedElevatorChange");

	Params::CompanionPositionComponent_OnOccupiedElevatorChange Parms{};

	Parms.Elevator = Elevator;
	Parms.bOccupied = bOccupied;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionPositionComponent.OnOccupiedElevatorMove
// (Final, Native, Protected)
// Parameters:
// class AElevator*                        Elevator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionPositionComponent::OnOccupiedElevatorMove(class AElevator* Elevator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionPositionComponent", "OnOccupiedElevatorMove");

	Params::CompanionPositionComponent_OnOccupiedElevatorMove Parms{};

	Parms.Elevator = Elevator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionPositionComponent.OnPlayerConversationChange
// (Final, Native, Protected)
// Parameters:
// class UConversationInstance*            Instance                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEntered                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionPositionComponent::OnPlayerConversationChange(const class UConversationInstance* Instance, bool bEntered)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionPositionComponent", "OnPlayerConversationChange");

	Params::CompanionPositionComponent_OnPlayerConversationChange Parms{};

	Parms.Instance = Instance;
	Parms.bEntered = bEntered;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionPositionComponent.OnStealthChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bStealthed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionPositionComponent::OnStealthChange(bool bStealthed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionPositionComponent", "OnStealthChange");

	Params::CompanionPositionComponent_OnStealthChange Parms{};

	Parms.bStealthed = bStealthed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionScreenWrapperWidget.AddItemToItemViewer
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCompanionScreenWrapperWidget::AddItemToItemViewer(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionScreenWrapperWidget", "AddItemToItemViewer");

	Params::CompanionScreenWrapperWidget_AddItemToItemViewer Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionScreenWrapperWidget.FadeInSharedItemViewer
// (Event, Protected, BlueprintEvent)

void UCompanionScreenWrapperWidget::FadeInSharedItemViewer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionScreenWrapperWidget", "FadeInSharedItemViewer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.OnMaxPositiveFactions.OnMaxPositiveFactions
// (Final, Native, Protected)

void UOnMaxPositiveFactions::OnMaxPositiveFactions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnMaxPositiveFactions", "OnMaxPositiveFactions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompassWidget.OnCompassSettingChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   CompassVisibilityModeIn                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompassWidget::OnCompassSettingChanged(int32 CompassVisibilityModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompassWidget", "OnCompassSettingChanged");

	Params::CompassWidget_OnCompassSettingChanged Parms{};

	Parms.CompassVisibilityModeIn = CompassVisibilityModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompassWidget.OnEnemyAdded
// (Final, Native, Public)
// Parameters:
// class AIndianaAiCharacter*              Detector                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompassWidget::OnEnemyAdded(class AIndianaAiCharacter* Detector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompassWidget", "OnEnemyAdded");

	Params::CompassWidget_OnEnemyAdded Parms{};

	Parms.Detector = Detector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompassWidget.OnEnemyRemoved
// (Final, Native, Public)
// Parameters:
// class AIndianaAiCharacter*              Detector                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompassWidget::OnEnemyRemoved(class AIndianaAiCharacter* Detector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompassWidget", "OnEnemyRemoved");

	Params::CompassWidget_OnEnemyRemoved Parms{};

	Parms.Detector = Detector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompassWidget.OnHUDVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bHUDVisible                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompassWidget::OnHUDVisibilityChanged(bool bHUDVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompassWidget", "OnHUDVisibilityChanged");

	Params::CompassWidget_OnHUDVisibilityChanged Parms{};

	Parms.bHUDVisible = bHUDVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ReputationListener.OnReputationChange
// (Final, Native, Protected)
// Parameters:
// class UFactionData*                     FactionData                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EReputationType                         InReputationType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UReputationData*                  ReputationBefore                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UReputationData*                  ReputationAfter                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UReputationListener::OnReputationChange(const class UFactionData* FactionData, EReputationType InReputationType, int32 Amount, const class UReputationData* ReputationBefore, const class UReputationData* ReputationAfter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReputationListener", "OnReputationChange");

	Params::ReputationListener_OnReputationChange Parms{};

	Parms.FactionData = FactionData;
	Parms.InReputationType = InReputationType;
	Parms.Amount = Amount;
	Parms.ReputationBefore = ReputationBefore;
	Parms.ReputationAfter = ReputationAfter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnModInstalledListener.OnModInstalled
// (Final, Native, Protected)

void UOnModInstalledListener::OnModInstalled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnModInstalledListener", "OnModInstalled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InteractableAudioComponent.PlayCustomEventEffect
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractableAudioComponent::PlayCustomEventEffect(const class FName& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableAudioComponent", "PlayCustomEventEffect");

	Params::InteractableAudioComponent_PlayCustomEventEffect Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InteractableAudioComponent.StopCustomEventEffect
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractableAudioComponent::StopCustomEventEffect(const class FName& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableAudioComponent", "StopCustomEventEffect");

	Params::InteractableAudioComponent_StopCustomEventEffect Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnHealthPercentage.OnHealthChanged
// (Final, Native, Protected)
// Parameters:
// float                                   HealthChange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnHealthPercentage::OnHealthChanged(float HealthChange, class AActor* Instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnHealthPercentage", "OnHealthChanged");

	Params::OnHealthPercentage_OnHealthChanged Parms{};

	Parms.HealthChange = HealthChange;
	Parms.Instigator = Instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Encounter.ActivateEncounter
// (Final, Native, Public, BlueprintCallable)

void AEncounter::ActivateEncounter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Encounter", "ActivateEncounter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Encounter.DeactivateEncounter
// (Final, Native, Public, BlueprintCallable)

void AEncounter::DeactivateEncounter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Encounter", "DeactivateEncounter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Encounter.ForceDeactivateEncounter
// (Final, Native, Public, BlueprintCallable)

void AEncounter::ForceDeactivateEncounter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Encounter", "ForceDeactivateEncounter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Encounter.IterateThroughSpawnedActors
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(class AActor* Actor)>    GenericFunctionCall                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AEncounter::IterateThroughSpawnedActors(const TDelegate<void(class AActor* Actor)>& GenericFunctionCall)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Encounter", "IterateThroughSpawnedActors");

	Params::Encounter_IterateThroughSpawnedActors Parms{};

	Parms.GenericFunctionCall = GenericFunctionCall;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Encounter.OnActivationBeginOverlap
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEncounter::OnActivationBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Encounter", "OnActivationBeginOverlap");

	Params::Encounter_OnActivationBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Encounter.OnActivationEndOverlap
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEncounter::OnActivationEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Encounter", "OnActivationEndOverlap");

	Params::Encounter_OnActivationEndOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Encounter.OnNodeActorAlertState
// (Final, Native, Protected)
// Parameters:
// class ASpawnNodeBase*                   Node                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAlertState                             State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEncounter::OnNodeActorAlertState(class ASpawnNodeBase* Node, class AActor* TargetActor, EAlertState State, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Encounter", "OnNodeActorAlertState");

	Params::Encounter_OnNodeActorAlertState Parms{};

	Parms.Node = Node;
	Parms.TargetActor = TargetActor;
	Parms.State = State;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Encounter.OnNodeActorAwareOfPlayer
// (Final, Native, Protected)
// Parameters:
// class ASpawnNodeBase*                   Node                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEncounter::OnNodeActorAwareOfPlayer(class ASpawnNodeBase* Node, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Encounter", "OnNodeActorAwareOfPlayer");

	Params::Encounter_OnNodeActorAwareOfPlayer Parms{};

	Parms.Node = Node;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Encounter.OnNodeActorCombatState
// (Final, Native, Protected)
// Parameters:
// class ASpawnNodeBase*                   Node                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInCombat                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEncounter::OnNodeActorCombatState(class ASpawnNodeBase* Node, bool bInCombat, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Encounter", "OnNodeActorCombatState");

	Params::Encounter_OnNodeActorCombatState Parms{};

	Parms.Node = Node;
	Parms.bInCombat = bInCombat;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Encounter.OnNodeActorDamaged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class ASpawnNodeBase*                   Node                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCauseDamageInfo                 CauseDamageInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AEncounter::OnNodeActorDamaged(class ASpawnNodeBase* Node, const struct FCauseDamageInfo& CauseDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Encounter", "OnNodeActorDamaged");

	Params::Encounter_OnNodeActorDamaged Parms{};

	Parms.Node = Node;
	Parms.CauseDamageInfo = std::move(CauseDamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Encounter.OnNodeActorDespawned
// (Final, Native, Protected)
// Parameters:
// class ASpawnNodeBase*                   Node                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEncounter::OnNodeActorDespawned(class ASpawnNodeBase* Node)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Encounter", "OnNodeActorDespawned");

	Params::Encounter_OnNodeActorDespawned Parms{};

	Parms.Node = Node;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Encounter.OnNodeActorKilled
// (Final, Native, Protected)
// Parameters:
// class ASpawnNodeBase*                   Node                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFirstKill                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEncounter::OnNodeActorKilled(class ASpawnNodeBase* Node, bool bFirstKill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Encounter", "OnNodeActorKilled");

	Params::Encounter_OnNodeActorKilled Parms{};

	Parms.Node = Node;
	Parms.bFirstKill = bFirstKill;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Encounter.OnNodeActorSpawned
// (Final, Native, Protected)
// Parameters:
// class ASpawnNodeBase*                   Node                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDamageable                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFirstSpawn                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEncounter::OnNodeActorSpawned(class ASpawnNodeBase* Node, bool bDamageable, bool bFirstSpawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Encounter", "OnNodeActorSpawned");

	Params::Encounter_OnNodeActorSpawned Parms{};

	Parms.Node = Node;
	Parms.bDamageable = bDamageable;
	Parms.bFirstSpawn = bFirstSpawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Encounter.OnNodeBeginSpawning
// (Final, Native, Protected)
// Parameters:
// class ASpawnNodeBase*                   Node                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEncounter::OnNodeBeginSpawning(class ASpawnNodeBase* Node)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Encounter", "OnNodeBeginSpawning");

	Params::Encounter_OnNodeBeginSpawning Parms{};

	Parms.Node = Node;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Encounter.RefreshEncounter
// (Final, Native, Public, BlueprintCallable)

void AEncounter::RefreshEncounter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Encounter", "RefreshEncounter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Encounter.ResetActivationFailed
// (Final, Native, Public, BlueprintCallable)

void AEncounter::ResetActivationFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Encounter", "ResetActivationFailed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Encounter.SetEncounterEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEncounter::SetEncounterEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Encounter", "SetEncounterEnabled");

	Params::Encounter_SetEncounterEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Encounter.HasEncounterCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEncounter::HasEncounterCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Encounter", "HasEncounterCompleted");

	Params::Encounter_HasEncounterCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Encounter.IsEncounterActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEncounter::IsEncounterActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Encounter", "IsEncounterActive");

	Params::Encounter_IsEncounterActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OnCompanionKilled.OnCompanionKilled
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Companion                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnCompanionKilled::OnCompanionKilled(class AActor* Companion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnCompanionKilled", "OnCompanionKilled");

	Params::OnCompanionKilled_OnCompanionKilled Parms{};

	Parms.Companion = Companion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Elevator.OnEndMoveExternalDoors
// (Final, Native, Protected)
// Parameters:
// int32                                   DestinationFloor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AElevator::OnEndMoveExternalDoors(int32 DestinationFloor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Elevator", "OnEndMoveExternalDoors");

	Params::Elevator_OnEndMoveExternalDoors Parms{};

	Parms.DestinationFloor = DestinationFloor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Elevator.OnStartMoveExternalDoors
// (Final, Native, Protected)
// Parameters:
// int32                                   DestinationFloor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromStationary                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AElevator::OnStartMoveExternalDoors(int32 DestinationFloor, bool bFromStationary)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Elevator", "OnStartMoveExternalDoors");

	Params::Elevator_OnStartMoveExternalDoors Parms{};

	Parms.DestinationFloor = DestinationFloor;
	Parms.bFromStationary = bFromStationary;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Elevator.SetCurrentFloor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   FloorIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AElevator::SetCurrentFloor(int32 FloorIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Elevator", "SetCurrentFloor");

	Params::Elevator_SetCurrentFloor Parms{};

	Parms.FloorIndex = FloorIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Elevator.GetCurrentFloor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AElevator::GetCurrentFloor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Elevator", "GetCurrentFloor");

	Params::Elevator_GetCurrentFloor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Elevator.GetTargetFloor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AElevator::GetTargetFloor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Elevator", "GetTargetFloor");

	Params::Elevator_GetTargetFloor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Elevator.IsMoving
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AElevator::IsMoving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Elevator", "IsMoving");

	Params::Elevator_IsMoving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Elevator.IsStationary
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AElevator::IsStationary() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Elevator", "IsStationary");

	Params::Elevator_IsStationary Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OnCarryWeightChange.OnCarryWeightChange
// (Final, Native, Protected)

void UOnCarryWeightChange::OnCarryWeightChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnCarryWeightChange", "OnCarryWeightChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.WeaponVisuals.ClearLerpTimers
// (Final, Native, Protected, BlueprintCallable)

void UWeaponVisuals::ClearLerpTimers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponVisuals", "ClearLerpTimers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.WeaponVisuals.CreateLerpTimer
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLerpTimer                       TimerProperties                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UWeaponVisuals::CreateLerpTimer(const struct FLerpTimer& TimerProperties)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponVisuals", "CreateLerpTimer");

	Params::WeaponVisuals_CreateLerpTimer Parms{};

	Parms.TimerProperties = std::move(TimerProperties);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.WeaponVisuals.EnterCustomState
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             StateName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponVisuals::EnterCustomState(class FName StateName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponVisuals", "EnterCustomState");

	Params::WeaponVisuals_EnterCustomState Parms{};

	Parms.StateName = StateName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.WeaponVisuals.EnterCustomStateBP
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEventEffectParams               Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UWeaponVisuals::EnterCustomStateBP(class FName EventName, const struct FEventEffectParams& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponVisuals", "EnterCustomStateBP");

	Params::WeaponVisuals_EnterCustomStateBP Parms{};

	Parms.EventName = EventName;
	Parms.Params_0 = std::move(Params_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.WeaponVisuals.EnterStateBP
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// EWeaponState                            WeaponState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEventEffectParams               Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UWeaponVisuals::EnterStateBP(EWeaponState WeaponState, const struct FEventEffectParams& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponVisuals", "EnterStateBP");

	Params::WeaponVisuals_EnterStateBP Parms{};

	Parms.WeaponState = WeaponState;
	Parms.Params_0 = std::move(Params_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.WeaponVisuals.InitializeBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           NewTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWeapon*                          NewWeapon                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponVisuals::InitializeBP(class AActor* NewTarget, class UWeapon* NewWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponVisuals", "InitializeBP");

	Params::WeaponVisuals_InitializeBP Parms{};

	Parms.NewTarget = NewTarget;
	Parms.NewWeapon = NewWeapon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.WeaponVisuals.InterruptEventBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// EWeaponEvent                            WeaponEvent                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponVisuals::InterruptEventBP(EWeaponEvent WeaponEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponVisuals", "InterruptEventBP");

	Params::WeaponVisuals_InterruptEventBP Parms{};

	Parms.WeaponEvent = WeaponEvent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.WeaponVisuals.LeaveCustomState
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             StateName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponVisuals::LeaveCustomState(class FName StateName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponVisuals", "LeaveCustomState");

	Params::WeaponVisuals_LeaveCustomState Parms{};

	Parms.StateName = StateName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.WeaponVisuals.LeaveCustomStateBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponVisuals::LeaveCustomStateBP(class FName EventName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponVisuals", "LeaveCustomStateBP");

	Params::WeaponVisuals_LeaveCustomStateBP Parms{};

	Parms.EventName = EventName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.WeaponVisuals.LeaveStateBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// EWeaponState                            WeaponState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponVisuals::LeaveStateBP(EWeaponState WeaponState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponVisuals", "LeaveStateBP");

	Params::WeaponVisuals_LeaveStateBP Parms{};

	Parms.WeaponState = WeaponState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.WeaponVisuals.StopCustomEvent
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponVisuals::StopCustomEvent(class FName EventName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponVisuals", "StopCustomEvent");

	Params::WeaponVisuals_StopCustomEvent Parms{};

	Parms.EventName = EventName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.WeaponVisuals.StopCustomEventBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponVisuals::StopCustomEventBP(class FName EventName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponVisuals", "StopCustomEventBP");

	Params::WeaponVisuals_StopCustomEventBP Parms{};

	Parms.EventName = EventName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.WeaponVisuals.TickBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponVisuals::TickBP(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponVisuals", "TickBP");

	Params::WeaponVisuals_TickBP Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.WeaponVisuals.TriggerCustomEvent
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponVisuals::TriggerCustomEvent(class FName EventName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponVisuals", "TriggerCustomEvent");

	Params::WeaponVisuals_TriggerCustomEvent Parms{};

	Parms.EventName = EventName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.WeaponVisuals.TriggerCustomEventBP
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEventEffectParams               Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UWeaponVisuals::TriggerCustomEventBP(class FName EventName, const struct FEventEffectParams& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponVisuals", "TriggerCustomEventBP");

	Params::WeaponVisuals_TriggerCustomEventBP Parms{};

	Parms.EventName = EventName;
	Parms.Params_0 = std::move(Params_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.WeaponVisuals.TriggerDamageTypeMuzzleFx
// (Final, Native, Public, BlueprintCallable)

void UWeaponVisuals::TriggerDamageTypeMuzzleFx()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponVisuals", "TriggerDamageTypeMuzzleFx");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.WeaponVisuals.TriggerEventBP
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// EWeaponEvent                            WeaponEvent                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEventEffectParams               Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UWeaponVisuals::TriggerEventBP(EWeaponEvent WeaponEvent, const struct FEventEffectParams& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponVisuals", "TriggerEventBP");

	Params::WeaponVisuals_TriggerEventBP Parms{};

	Parms.WeaponEvent = WeaponEvent;
	Parms.Params_0 = std::move(Params_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.WeaponVisuals.UninitializeBP
// (Event, Protected, BlueprintEvent)

void UWeaponVisuals::UninitializeBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponVisuals", "UninitializeBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.OnTactialTimeDialationStart.OnTacticalTimeDilationStart
// (Final, Native, Protected)

void UOnTactialTimeDialationStart::OnTacticalTimeDilationStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnTactialTimeDialationStart", "OnTacticalTimeDilationStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnTactialTimeDialationEnd.OnTacticalTimeDilationEnd
// (Final, Native, Protected)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnTactialTimeDialationEnd::OnTacticalTimeDilationEnd(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnTactialTimeDialationEnd", "OnTacticalTimeDilationEnd");

	Params::OnTactialTimeDialationEnd_OnTacticalTimeDilationEnd Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ChatterManager.OnConversationBegin
// (Final, Native, Private)
// Parameters:
// class UConversationInstance*            ConversationInstance                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChatterManager::OnConversationBegin(class UConversationInstance* ConversationInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatterManager", "OnConversationBegin");

	Params::ChatterManager_OnConversationBegin Parms{};

	Parms.ConversationInstance = ConversationInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ExpandableAreaBase.SetIsExpanded
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsExpanded                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExpandableAreaBase::SetIsExpanded(bool IsExpanded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExpandableAreaBase", "SetIsExpanded");

	Params::ExpandableAreaBase_SetIsExpanded Parms{};

	Parms.IsExpanded = IsExpanded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ExpandableAreaBase.SetIsExpanded_Animated
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsExpanded                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExpandableAreaBase::SetIsExpanded_Animated(bool IsExpanded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExpandableAreaBase", "SetIsExpanded_Animated");

	Params::ExpandableAreaBase_SetIsExpanded_Animated Parms{};

	Parms.IsExpanded = IsExpanded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ExpandableAreaBase.GetIsExpanded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UExpandableAreaBase::GetIsExpanded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExpandableAreaBase", "GetIsExpanded");

	Params::ExpandableAreaBase_GetIsExpanded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.CinematicPlayerWidget.FinishCinematic
// (Final, Native, Public, BlueprintCallable)

void UCinematicPlayerWidget::FinishCinematic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicPlayerWidget", "FinishCinematic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CinematicPlayerWidget.InitiateFadeIn
// (Event, Protected, BlueprintEvent)

void UCinematicPlayerWidget::InitiateFadeIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicPlayerWidget", "InitiateFadeIn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.CinematicPlayerWidget.InitiateFadeOut
// (Event, Protected, BlueprintEvent)

void UCinematicPlayerWidget::InitiateFadeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicPlayerWidget", "InitiateFadeOut");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.CinematicPlayerWidget.PauseCinematic
// (Final, Native, Public, BlueprintCallable)

void UCinematicPlayerWidget::PauseCinematic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicPlayerWidget", "PauseCinematic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CinematicPlayerWidget.PlayCinematic
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMovieSceneSequencePlayer*        Cinematic                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCinematicPlayerWidget::PlayCinematic(class UMovieSceneSequencePlayer* Cinematic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicPlayerWidget", "PlayCinematic");

	Params::CinematicPlayerWidget_PlayCinematic Parms{};

	Parms.Cinematic = Cinematic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CinematicPlayerWidget.PlayerInputDetected
// (Final, Native, Protected)

void UCinematicPlayerWidget::PlayerInputDetected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicPlayerWidget", "PlayerInputDetected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CinematicPlayerWidget.SkipCinematic
// (Final, Native, Protected)

void UCinematicPlayerWidget::SkipCinematic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicPlayerWidget", "SkipCinematic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionComponent.DropOffering
// (Final, Native, Public, BlueprintCallable)

void UCompanionComponent::DropOffering()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionComponent", "DropOffering");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionComponent.OnCombatStateChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bIsInCombat                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionComponent::OnCombatStateChange(bool bIsInCombat, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionComponent", "OnCombatStateChange");

	Params::CompanionComponent_OnCombatStateChange Parms{};

	Parms.bIsInCombat = bIsInCombat;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionComponent.OnPlayerEnteredAcknowledgeZone
// (Final, Native, Protected)
// Parameters:
// class AActor*                           ZoneOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionComponent::OnPlayerEnteredAcknowledgeZone(class AActor* ZoneOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionComponent", "OnPlayerEnteredAcknowledgeZone");

	Params::CompanionComponent_OnPlayerEnteredAcknowledgeZone Parms{};

	Parms.ZoneOwner = ZoneOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionComponent.OnPlayerExitedAcknowledgeZone
// (Final, Native, Protected)
// Parameters:
// class AActor*                           ZoneOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionComponent::OnPlayerExitedAcknowledgeZone(class AActor* ZoneOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionComponent", "OnPlayerExitedAcknowledgeZone");

	Params::CompanionComponent_OnPlayerExitedAcknowledgeZone Parms{};

	Parms.ZoneOwner = ZoneOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionComponent.SetOffering
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class APickup>              PickupClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionComponent::SetOffering(TSubclassOf<class APickup> PickupClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionComponent", "SetOffering");

	Params::CompanionComponent_SetOffering Parms{};

	Parms.PickupClass = PickupClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionComponent.UpdateCompanionState
// (Final, Native, Protected)

void UCompanionComponent::UpdateCompanionState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionComponent", "UpdateCompanionState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationInterface.ConversationEnded
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            Guid                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IConversationInterface::ConversationEnded(const struct FGuid& Guid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationInterface", "ConversationEnded");

	Params::ConversationInterface_ConversationEnded Parms{};

	Parms.Guid = std::move(Guid);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.ConversationInterface.ConversationNodeChanged
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Camera                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Audio                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NodeID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IConversationInterface::ConversationNodeChanged(class AActor* Character, class AActor* Camera, class AActor* Audio, int32 NodeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationInterface", "ConversationNodeChanged");

	Params::ConversationInterface_ConversationNodeChanged Parms{};

	Parms.Character = Character;
	Parms.Camera = Camera;
	Parms.Audio = Audio;
	Parms.NodeID = NodeID;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.ConversationInterface.ConversationStarted
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Speaker                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            Guid                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NodeID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IConversationInterface::ConversationStarted(class AActor* Speaker, const struct FGuid& Guid, int32 NodeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationInterface", "ConversationStarted");

	Params::ConversationInterface_ConversationStarted Parms{};

	Parms.Speaker = Speaker;
	Parms.Guid = std::move(Guid);
	Parms.NodeID = NodeID;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.MultiStatusEffect.OnChildCleared
// (Final, Native, Private)
// Parameters:
// class UStatusEffect*                    ChildEffect                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMultiStatusEffect::OnChildCleared(class UStatusEffect* ChildEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultiStatusEffect", "OnChildCleared");

	Params::MultiStatusEffect_OnChildCleared Parms{};

	Parms.ChildEffect = ChildEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationRegisterComponent.StartConversationByComponent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ECheckBranches                          Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ComponentOwner                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConversationRegisterComponent::StartConversationByComponent(ECheckBranches* Branches, class AActor* ComponentOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationRegisterComponent", "StartConversationByComponent");

	Params::ConversationRegisterComponent_StartConversationByComponent Parms{};

	Parms.ComponentOwner = ComponentOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function Indiana.ConversationRegisterComponent.OnChatterComplete
// (Final, Native, Protected)
// Parameters:
// class UChatterPlayer*                   ChatterPlayer                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationRegisterComponent::OnChatterComplete(const class UChatterPlayer* ChatterPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationRegisterComponent", "OnChatterComplete");

	Params::ConversationRegisterComponent_OnChatterComplete Parms{};

	Parms.ChatterPlayer = ChatterPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationRegisterComponent.OnCombatStateChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bInCombat                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationRegisterComponent::OnCombatStateChange(bool bInCombat, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationRegisterComponent", "OnCombatStateChange");

	Params::ConversationRegisterComponent_OnCombatStateChange Parms{};

	Parms.bInCombat = bInCombat;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationRegisterComponent.OnNewStateOfBeing
// (Final, Native, Protected)
// Parameters:
// EStateOfBeing                           NewStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStateOfBeing                           OldStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationRegisterComponent::OnNewStateOfBeing(EStateOfBeing NewStateOfBeing, EStateOfBeing OldStateOfBeing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationRegisterComponent", "OnNewStateOfBeing");

	Params::ConversationRegisterComponent_OnNewStateOfBeing Parms{};

	Parms.NewStateOfBeing = NewStateOfBeing;
	Parms.OldStateOfBeing = OldStateOfBeing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationRegisterComponent.OnResumeConversationTimerComplete
// (Final, Native, Protected)

void UConversationRegisterComponent::OnResumeConversationTimerComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationRegisterComponent", "OnResumeConversationTimerComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MedKitAbilityWidget.UpdateDrugSlots
// (Final, Native, Protected)
// Parameters:
// int32                                   ConsumablesUsed                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMedKitAbilityWidget::UpdateDrugSlots(int32 ConsumablesUsed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MedKitAbilityWidget", "UpdateDrugSlots");

	Params::MedKitAbilityWidget_UpdateDrugSlots Parms{};

	Parms.ConsumablesUsed = ConsumablesUsed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AmmoPoolBase.OnTacticalTimeDilationEnd
// (Final, Native, Protected)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAmmoPoolBase::OnTacticalTimeDilationEnd(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoPoolBase", "OnTacticalTimeDilationEnd");

	Params::AmmoPoolBase_OnTacticalTimeDilationEnd Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AmmoPoolBase.GetBaseReloadTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAmmoPoolBase::GetBaseReloadTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoPoolBase", "GetBaseReloadTime");

	Params::AmmoPoolBase_GetBaseReloadTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.AmmoPoolBase.GetCurrentAmmoClass
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UAmmo>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UAmmo> UAmmoPoolBase::GetCurrentAmmoClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoPoolBase", "GetCurrentAmmoClass");

	Params::AmmoPoolBase_GetCurrentAmmoClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.AmmoPoolBase.GetCurrentConsumableClass
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UConsumableItem>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UConsumableItem> UAmmoPoolBase::GetCurrentConsumableClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoPoolBase", "GetCurrentConsumableClass");

	Params::AmmoPoolBase_GetCurrentConsumableClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.AmmoPoolBase.GetCurrentPoolSize
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAmmoPoolBase::GetCurrentPoolSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoPoolBase", "GetCurrentPoolSize");

	Params::AmmoPoolBase_GetCurrentPoolSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.AmmoPoolBase.IsReloading
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAmmoPoolBase::IsReloading() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoPoolBase", "IsReloading");

	Params::AmmoPoolBase_IsReloading Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.AmmoPoolBase.UsesAmmo
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAmmoPoolBase::UsesAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoPoolBase", "UsesAmmo");

	Params::AmmoPoolBase_UsesAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.AmmoPoolBase.UsesConsumables
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAmmoPoolBase::UsesConsumables() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoPoolBase", "UsesConsumables");

	Params::AmmoPoolBase_UsesConsumables Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ComputerTerminalContainerWidget.OnConversationStateChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bHasStarted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UComputerTerminalContainerWidget::OnConversationStateChange(bool bHasStarted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComputerTerminalContainerWidget", "OnConversationStateChange");

	Params::ComputerTerminalContainerWidget_OnConversationStateChange Parms{};

	Parms.bHasStarted = bHasStarted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CustomHitReceiver.CustomOnHit
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACustomHitReceiver::CustomOnHit(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomHitReceiver", "CustomOnHit");

	Params::CustomHitReceiver_CustomOnHit Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.OnWithinRoboRange.OnRoboWithinRangeStateChanged
// (Final, Native, Protected)

void UOnWithinRoboRange::OnRoboWithinRangeStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnWithinRoboRange", "OnRoboWithinRangeStateChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CustomModVisual.ApplyToNewMeshTrigger
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UMeshComponent*                   NewMesh                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomModVisual::ApplyToNewMeshTrigger(class UMeshComponent* NewMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomModVisual", "ApplyToNewMeshTrigger");

	Params::CustomModVisual_ApplyToNewMeshTrigger Parms{};

	Parms.NewMesh = NewMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.CustomModVisual.ApplyVisualsTrigger
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UObject*                          NewTargetObject                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           NewParentComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomModVisual::ApplyVisualsTrigger(class UObject* NewTargetObject, class USkeletalMeshComponent* NewParentComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomModVisual", "ApplyVisualsTrigger");

	Params::CustomModVisual_ApplyVisualsTrigger Parms{};

	Parms.NewTargetObject = NewTargetObject;
	Parms.NewParentComponent = NewParentComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.CustomModVisual.RemoveVisualsTrigger
// (Event, Protected, BlueprintEvent)

void UCustomModVisual::RemoveVisualsTrigger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomModVisual", "RemoveVisualsTrigger");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.CustomModVisual.ApplyToNewMeshPermanentlyTrigger
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class UMeshComponent*                   NewMesh                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomModVisual::ApplyToNewMeshPermanentlyTrigger(class UMeshComponent* NewMesh) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomModVisual", "ApplyToNewMeshPermanentlyTrigger");

	Params::CustomModVisual_ApplyToNewMeshPermanentlyTrigger Parms{};

	Parms.NewMesh = NewMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.CustomModVisual.NewMeshAddedBP
// (Final, Native, Protected, BlueprintCallable, Const)
// Parameters:
// class USkeletalMeshComponent*           TargetParentComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMeshComponent*                   MeshComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomModVisual::NewMeshAddedBP(class USkeletalMeshComponent* TargetParentComponent, class UMeshComponent* MeshComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomModVisual", "NewMeshAddedBP");

	Params::CustomModVisual_NewMeshAddedBP Parms{};

	Parms.TargetParentComponent = TargetParentComponent;
	Parms.MeshComponent = MeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CustomModVisual.PermanentlyApplyVisualsTrigger
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class UObject*                          NewTargetObject                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           NewParentComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldWeld                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomModVisual::PermanentlyApplyVisualsTrigger(class UObject* NewTargetObject, class USkeletalMeshComponent* NewParentComponent, bool bShouldWeld) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomModVisual", "PermanentlyApplyVisualsTrigger");

	Params::CustomModVisual_PermanentlyApplyVisualsTrigger Parms{};

	Parms.NewTargetObject = NewTargetObject;
	Parms.NewParentComponent = NewParentComponent;
	Parms.bShouldWeld = bShouldWeld;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.Conditionals.AlwaysFalse
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::AlwaysFalse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "AlwaysFalse");

	Params::Conditionals_AlwaysFalse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.CallGlobalConditional
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            GlobalScriptID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::CallGlobalConditional(const struct FGuid& GlobalScriptID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "CallGlobalConditional");

	Params::Conditionals_CallGlobalConditional Parms{};

	Parms.GlobalScriptID = std::move(GlobalScriptID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.CanBribe
// (Final, Native, Static, Public)
// Parameters:
// class FString                           VariableName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBribeDifficulty                        BribeDifficulty                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LevelOverride                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::CanBribe(const class FString& VariableName, EBribeDifficulty BribeDifficulty, int32 LevelOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "CanBribe");

	Params::Conditionals_CanBribe Parms{};

	Parms.VariableName = std::move(VariableName);
	Parms.BribeDifficulty = BribeDifficulty;
	Parms.LevelOverride = LevelOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.CanPlayerAccessTravelDestination
// (Final, Native, Static, Public)
// Parameters:
// class FString                           TravelDestination                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::CanPlayerAccessTravelDestination(const class FString& TravelDestination)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "CanPlayerAccessTravelDestination");

	Params::Conditionals_CanPlayerAccessTravelDestination Parms{};

	Parms.TravelDestination = std::move(TravelDestination);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.CanPlayerDiscoverPointOfInterest
// (Final, Native, Static, Public)
// Parameters:
// class FString                           PointOfInterestData                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::CanPlayerDiscoverPointOfInterest(const class FString& PointOfInterestData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "CanPlayerDiscoverPointOfInterest");

	Params::Conditionals_CanPlayerDiscoverPointOfInterest Parms{};

	Parms.PointOfInterestData = std::move(PointOfInterestData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.CanPlayerReadRedactions
// (Final, Native, Static, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::CanPlayerReadRedactions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "CanPlayerReadRedactions");

	Params::Conditionals_CanPlayerReadRedactions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.CanPlayerSafelyTakeItemTypeInContainer
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            ContainerID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Item                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::CanPlayerSafelyTakeItemTypeInContainer(const struct FGuid& ContainerID, const class FString& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "CanPlayerSafelyTakeItemTypeInContainer");

	Params::Conditionals_CanPlayerSafelyTakeItemTypeInContainer Parms{};

	Parms.ContainerID = std::move(ContainerID);
	Parms.Item = std::move(Item);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.CanPlayerSafelyTakePickup
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            PickupID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::CanPlayerSafelyTakePickup(const struct FGuid& PickupID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "CanPlayerSafelyTakePickup");

	Params::Conditionals_CanPlayerSafelyTakePickup Parms{};

	Parms.PickupID = std::move(PickupID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.CompanionHasPerk
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            CompanionID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Perk                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::CompanionHasPerk(const struct FGuid& CompanionID, const class FString& Perk)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "CompanionHasPerk");

	Params::Conditionals_CompanionHasPerk Parms{};

	Parms.CompanionID = std::move(CompanionID);
	Parms.Perk = std::move(Perk);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.CompanionWantsToTalk
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESpecialObsidianID                      CompanionID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::CompanionWantsToTalk(ESpecialObsidianID CompanionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "CompanionWantsToTalk");

	Params::Conditionals_CompanionWantsToTalk Parms{};

	Parms.CompanionID = CompanionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.CompareGlobals
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           VariableName1                                          (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EComparisonOperator                     Operator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           VariableName2                                          (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::CompareGlobals(const class FString& VariableName1, EComparisonOperator Operator, const class FString& VariableName2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "CompareGlobals");

	Params::Conditionals_CompareGlobals Parms{};

	Parms.VariableName1 = std::move(VariableName1);
	Parms.Operator = Operator;
	Parms.VariableName2 = std::move(VariableName2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.DoesConversationNodePass
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            ConversationID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NodeID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::DoesConversationNodePass(const struct FGuid& ConversationID, int32 NodeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "DoesConversationNodePass");

	Params::Conditionals_DoesConversationNodePass Parms{};

	Parms.ConversationID = std::move(ConversationID);
	Parms.NodeID = NodeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.GetGlobalValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           VariableName                                           (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UConditionals::GetGlobalValue(const class FString& VariableName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "GetGlobalValue");

	Params::Conditionals_GetGlobalValue Parms{};

	Parms.VariableName = std::move(VariableName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.GetOCLState
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            OCLObjectID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOCLState                               State                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBoolResult                             Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConditionals::GetOCLState(const struct FGuid& OCLObjectID, EOCLState* State, EBoolResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "GetOCLState");

	Params::Conditionals_GetOCLState Parms{};

	Parms.OCLObjectID = std::move(OCLObjectID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (State != nullptr)
		*State = Parms.State;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function Indiana.Conditionals.HasConversationNodeBeenVisited
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            ConversationID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NodeID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::HasConversationNodeBeenVisited(const struct FGuid& ConversationID, int32 NodeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "HasConversationNodeBeenVisited");

	Params::Conditionals_HasConversationNodeBeenVisited Parms{};

	Parms.ConversationID = std::move(ConversationID);
	Parms.NodeID = NodeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.HasDLC
// (Final, Native, Static, Public)
// Parameters:
// EDownLoadableContent                    DLC                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::HasDLC(EDownLoadableContent DLC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "HasDLC");

	Params::Conditionals_HasDLC Parms{};

	Parms.DLC = DLC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.HasItem
// (Final, Native, Static, Public)
// Parameters:
// class FString                           Item                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::HasItem(const class FString& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "HasItem");

	Params::Conditionals_HasItem Parms{};

	Parms.Item = std::move(Item);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.HasItemsByTag
// (Final, Native, Static, Public)
// Parameters:
// class FString                           GameplayTag                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EComparisonOperator                     Operator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Quantity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::HasItemsByTag(const class FString& GameplayTag, EComparisonOperator Operator, int32 Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "HasItemsByTag");

	Params::Conditionals_HasItemsByTag Parms{};

	Parms.GameplayTag = std::move(GameplayTag);
	Parms.Operator = Operator;
	Parms.Quantity = Quantity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.HasItemValue
// (Final, Native, Static, Public)
// Parameters:
// class FString                           VariableName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Item                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::HasItemValue(const class FString& VariableName, const class FString& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "HasItemValue");

	Params::Conditionals_HasItemValue Parms{};

	Parms.VariableName = std::move(VariableName);
	Parms.Item = std::move(Item);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.HasPlayerDiscoveredPointOfInterest
// (Final, Native, Static, Public)
// Parameters:
// class FString                           PointOfInterestData                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::HasPlayerDiscoveredPointOfInterest(const class FString& PointOfInterestData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "HasPlayerDiscoveredPointOfInterest");

	Params::Conditionals_HasPlayerDiscoveredPointOfInterest Parms{};

	Parms.PointOfInterestData = std::move(PointOfInterestData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.HasPlayerOnlyHeardAboutPointOfInterest
// (Final, Native, Static, Public)
// Parameters:
// class FString                           PointOfInterestData                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::HasPlayerOnlyHeardAboutPointOfInterest(const class FString& PointOfInterestData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "HasPlayerOnlyHeardAboutPointOfInterest");

	Params::Conditionals_HasPlayerOnlyHeardAboutPointOfInterest Parms{};

	Parms.PointOfInterestData = std::move(PointOfInterestData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.HasPlayerVisitedRegion
// (Final, Native, Static, Public)
// Parameters:
// class FString                           TravelRegion                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::HasPlayerVisitedRegion(const class FString& TravelRegion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "HasPlayerVisitedRegion");

	Params::Conditionals_HasPlayerVisitedRegion Parms{};

	Parms.TravelRegion = std::move(TravelRegion);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.HasPlayerVisitedTravelDestination
// (Final, Native, Static, Public)
// Parameters:
// class FString                           TravelDestination                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::HasPlayerVisitedTravelDestination(const class FString& TravelDestination)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "HasPlayerVisitedTravelDestination");

	Params::Conditionals_HasPlayerVisitedTravelDestination Parms{};

	Parms.TravelDestination = std::move(TravelDestination);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.HasQuestFailed
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::HasQuestFailed(const struct FGuid& QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "HasQuestFailed");

	Params::Conditionals_HasQuestFailed Parms{};

	Parms.QuestID = std::move(QuestID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.HasQuestStateFailed
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NodeID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::HasQuestStateFailed(const struct FGuid& QuestID, int32 NodeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "HasQuestStateFailed");

	Params::Conditionals_HasQuestStateFailed Parms{};

	Parms.QuestID = std::move(QuestID);
	Parms.NodeID = NodeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.HaveDaysElapsedSinceNamedTimestamp
// (Final, Native, Static, Public)
// Parameters:
// class FString                           TimestampName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Days                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::HaveDaysElapsedSinceNamedTimestamp(const class FString& TimestampName, int32 Days)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "HaveDaysElapsedSinceNamedTimestamp");

	Params::Conditionals_HaveDaysElapsedSinceNamedTimestamp Parms{};

	Parms.TimestampName = std::move(TimestampName);
	Parms.Days = Days;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.HaveHoursElapsedSinceNamedTimestamp
// (Final, Native, Static, Public)
// Parameters:
// class FString                           TimestampName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Hours                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::HaveHoursElapsedSinceNamedTimestamp(const class FString& TimestampName, int32 Hours)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "HaveHoursElapsedSinceNamedTimestamp");

	Params::Conditionals_HaveHoursElapsedSinceNamedTimestamp Parms{};

	Parms.TimestampName = std::move(TimestampName);
	Parms.Hours = Hours;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.HaveMinutesElapsedSinceNamedTimestamp
// (Final, Native, Static, Public)
// Parameters:
// class FString                           TimestampName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Minutes                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::HaveMinutesElapsedSinceNamedTimestamp(const class FString& TimestampName, int32 Minutes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "HaveMinutesElapsedSinceNamedTimestamp");

	Params::Conditionals_HaveMinutesElapsedSinceNamedTimestamp Parms{};

	Parms.TimestampName = std::move(TimestampName);
	Parms.Minutes = Minutes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsAnyArmorEquipped
// (Final, Native, Static, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsAnyArmorEquipped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsAnyArmorEquipped");

	Params::Conditionals_IsAnyArmorEquipped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsArmorEquipped
// (Final, Native, Static, Public)
// Parameters:
// class FString                           ArmorItem                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeDerivedClasses                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsArmorEquipped(const class FString& ArmorItem, bool bIncludeDerivedClasses)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsArmorEquipped");

	Params::Conditionals_IsArmorEquipped Parms{};

	Parms.ArmorItem = std::move(ArmorItem);
	Parms.bIncludeDerivedClasses = bIncludeDerivedClasses;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsCharacterGrouping
// (Final, Native, Static, Public)
// Parameters:
// ECharacterGrouping                      CharacterGrouping                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsCharacterGrouping(ECharacterGrouping CharacterGrouping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsCharacterGrouping");

	Params::Conditionals_IsCharacterGrouping Parms{};

	Parms.CharacterGrouping = CharacterGrouping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsCompanionActiveInParty
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            CompanionID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsCompanionActiveInParty(const struct FGuid& CompanionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsCompanionActiveInParty");

	Params::Conditionals_IsCompanionActiveInParty Parms{};

	Parms.CompanionID = std::move(CompanionID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsCompanionDismissed
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESpecialObsidianID                      CompanionID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsCompanionDismissed(ESpecialObsidianID CompanionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsCompanionDismissed");

	Params::Conditionals_IsCompanionDismissed Parms{};

	Parms.CompanionID = CompanionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsCompanionMoral
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESpecialObsidianID                      CompanionID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EComparisonOperator                     Operator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MoralAmount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsCompanionMoral(ESpecialObsidianID CompanionID, EComparisonOperator Operator, float MoralAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsCompanionMoral");

	Params::Conditionals_IsCompanionMoral Parms{};

	Parms.CompanionID = CompanionID;
	Parms.Operator = Operator;
	Parms.MoralAmount = MoralAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsCompanionUnlocked
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESpecialObsidianID                      CompanionID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsCompanionUnlocked(ESpecialObsidianID CompanionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsCompanionUnlocked");

	Params::Conditionals_IsCompanionUnlocked Parms{};

	Parms.CompanionID = CompanionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsCurrentActiveCompanionAmount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EComparisonOperator                     Operator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Quantity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsCurrentActiveCompanionAmount(EComparisonOperator Operator, int32 Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsCurrentActiveCompanionAmount");

	Params::Conditionals_IsCurrentActiveCompanionAmount Parms{};

	Parms.Operator = Operator;
	Parms.Quantity = Quantity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsFactionRelationship
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Faction                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETeamAttitude                           AttitudeType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsFactionRelationship(const class FString& Faction, ETeamAttitude AttitudeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsFactionRelationship");

	Params::Conditionals_IsFactionRelationship Parms{};

	Parms.Faction = std::move(Faction);
	Parms.AttitudeType = AttitudeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsFactionReputationRank
// (Final, Native, Static, Public)
// Parameters:
// class FString                           Faction                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EReputationRankType                     ReputationRankType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Rank                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EComparisonOperator                     Operator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsFactionReputationRank(const class FString& Faction, EReputationRankType ReputationRankType, int32 Rank, EComparisonOperator Operator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsFactionReputationRank");

	Params::Conditionals_IsFactionReputationRank Parms{};

	Parms.Faction = std::move(Faction);
	Parms.ReputationRankType = ReputationRankType;
	Parms.Rank = Rank;
	Parms.Operator = Operator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsFactionReputationRankType
// (Final, Native, Static, Public)
// Parameters:
// class FString                           Faction                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EReputationRankType                     ReputationRankType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EComparisonOperator                     Operator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsFactionReputationRankType(const class FString& Faction, EReputationRankType ReputationRankType, EComparisonOperator Operator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsFactionReputationRankType");

	Params::Conditionals_IsFactionReputationRankType Parms{};

	Parms.Faction = std::move(Faction);
	Parms.ReputationRankType = ReputationRankType;
	Parms.Operator = Operator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsGlobalValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           VariableName                                           (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EComparisonOperator                     Operator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsGlobalValue(const class FString& VariableName, EComparisonOperator Operator, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsGlobalValue");

	Params::Conditionals_IsGlobalValue Parms{};

	Parms.VariableName = std::move(VariableName);
	Parms.Operator = Operator;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsInMap
// (Final, Native, Static, Public)
// Parameters:
// class FString                           MapID                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsInMap(const class FString& MapID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsInMap");

	Params::Conditionals_IsInMap Parms{};

	Parms.MapID = std::move(MapID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsInterrogationCrime
// (Final, Native, Static, Public)
// Parameters:
// ECrimeType                              Crime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsInterrogationCrime(ECrimeType Crime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsInterrogationCrime");

	Params::Conditionals_IsInterrogationCrime Parms{};

	Parms.Crime = Crime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsInterrogationDisguised
// (Final, Native, Static, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsInterrogationDisguised()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsInterrogationDisguised");

	Params::Conditionals_IsInterrogationDisguised Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsInterrogationInRestrictedArea
// (Final, Native, Static, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsInterrogationInRestrictedArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsInterrogationInRestrictedArea");

	Params::Conditionals_IsInterrogationInRestrictedArea Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsInterrogationsPassedCount
// (Final, Native, Static, Public)
// Parameters:
// EComparisonOperator                     Operator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsInterrogationsPassedCount(EComparisonOperator Operator, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsInterrogationsPassedCount");

	Params::Conditionals_IsInterrogationsPassedCount Parms{};

	Parms.Operator = Operator;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsItemQuantity
// (Final, Native, Static, Public)
// Parameters:
// class FString                           Item                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EComparisonOperator                     Operator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Quantity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsItemQuantity(const class FString& Item, EComparisonOperator Operator, int32 Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsItemQuantity");

	Params::Conditionals_IsItemQuantity Parms{};

	Parms.Item = std::move(Item);
	Parms.Operator = Operator;
	Parms.Quantity = Quantity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsOCLStateEqual
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            OCLObjectID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOCLState                               State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsOCLStateEqual(const struct FGuid& OCLObjectID, EOCLState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsOCLStateEqual");

	Params::Conditionals_IsOCLStateEqual Parms{};

	Parms.OCLObjectID = std::move(OCLObjectID);
	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsPartyFull
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsPartyFull()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsPartyFull");

	Params::Conditionals_IsPartyFull Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsPhaseOfDay
// (Final, Native, Static, Public)
// Parameters:
// EPhaseOfDay                             Phase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsPhaseOfDay(EPhaseOfDay Phase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsPhaseOfDay");

	Params::Conditionals_IsPhaseOfDay Parms{};

	Parms.Phase = Phase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsPlayerAttribute
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EAttribute                              Attribute                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EComparisonOperator                     Operator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterAttributeRange                AttributeRange                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsPlayerAttribute(EAttribute Attribute, EComparisonOperator Operator, ECharacterAttributeRange AttributeRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsPlayerAttribute");

	Params::Conditionals_IsPlayerAttribute Parms{};

	Parms.Attribute = Attribute;
	Parms.Operator = Operator;
	Parms.AttributeRange = AttributeRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsPlayerAwareOfPointOfInterest
// (Final, Native, Static, Public)
// Parameters:
// class FString                           PointOfInterestData                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsPlayerAwareOfPointOfInterest(const class FString& PointOfInterestData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsPlayerAwareOfPointOfInterest");

	Params::Conditionals_IsPlayerAwareOfPointOfInterest Parms{};

	Parms.PointOfInterestData = std::move(PointOfInterestData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsPlayerAwareOfRegion
// (Final, Native, Static, Public)
// Parameters:
// class FString                           TravelRegion                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsPlayerAwareOfRegion(const class FString& TravelRegion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsPlayerAwareOfRegion");

	Params::Conditionals_IsPlayerAwareOfRegion Parms{};

	Parms.TravelRegion = std::move(TravelRegion);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsPlayerAwareOfTravelDestination
// (Final, Native, Static, Public)
// Parameters:
// class FString                           TravelDestination                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsPlayerAwareOfTravelDestination(const class FString& TravelDestination)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsPlayerAwareOfTravelDestination");

	Params::Conditionals_IsPlayerAwareOfTravelDestination Parms{};

	Parms.TravelDestination = std::move(TravelDestination);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsPlayerDisguisedAs
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Faction                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsPlayerDisguisedAs(const class FString& Faction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsPlayerDisguisedAs");

	Params::Conditionals_IsPlayerDisguisedAs Parms{};

	Parms.Faction = std::move(Faction);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsPlayerInCombat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsPlayerInCombat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsPlayerInCombat");

	Params::Conditionals_IsPlayerInCombat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsPlayerInStealth
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsPlayerInStealth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsPlayerInStealth");

	Params::Conditionals_IsPlayerInStealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsPlayerShipCurrentAt
// (Final, Native, Static, Public)
// Parameters:
// class FString                           ShipDestination                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsPlayerShipCurrentAt(const class FString& ShipDestination)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsPlayerShipCurrentAt");

	Params::Conditionals_IsPlayerShipCurrentAt Parms{};

	Parms.ShipDestination = std::move(ShipDestination);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsPlayerSkill
// (Final, Native, Static, Public)
// Parameters:
// ESkill                                  Skill                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EComparisonOperator                     Operator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterSkillRange                    SkillRange                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseCompanionInterjection                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsPlayerSkill(ESkill Skill, EComparisonOperator Operator, ECharacterSkillRange SkillRange, bool bUseCompanionInterjection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsPlayerSkill");

	Params::Conditionals_IsPlayerSkill Parms{};

	Parms.Skill = Skill;
	Parms.Operator = Operator;
	Parms.SkillRange = SkillRange;
	Parms.bUseCompanionInterjection = bUseCompanionInterjection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsPlayerSkillLevelScaled
// (Final, Native, Static, Public)
// Parameters:
// ESkill                                  Skill                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EComparisonOperator                     Operator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterSkillRange                    SkillRange                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LevelOverride                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseCompanionInterjection                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsPlayerSkillLevelScaled(ESkill Skill, EComparisonOperator Operator, ECharacterSkillRange SkillRange, int32 LevelOverride, bool bUseCompanionInterjection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsPlayerSkillLevelScaled");

	Params::Conditionals_IsPlayerSkillLevelScaled Parms{};

	Parms.Skill = Skill;
	Parms.Operator = Operator;
	Parms.SkillRange = SkillRange;
	Parms.LevelOverride = LevelOverride;
	Parms.bUseCompanionInterjection = bUseCompanionInterjection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsPlayerSkillValue
// (Final, Native, Static, Public)
// Parameters:
// ESkill                                  Skill                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EComparisonOperator                     Operator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SkillValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseCompanionInterjection                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPermanentOnly                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsPlayerSkillValue(ESkill Skill, EComparisonOperator Operator, int32 SkillValue, bool bUseCompanionInterjection, bool bPermanentOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsPlayerSkillValue");

	Params::Conditionals_IsPlayerSkillValue Parms{};

	Parms.Skill = Skill;
	Parms.Operator = Operator;
	Parms.SkillValue = SkillValue;
	Parms.bUseCompanionInterjection = bUseCompanionInterjection;
	Parms.bPermanentOnly = bPermanentOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsPlayerTravelDestinationHidden
// (Final, Native, Static, Public)
// Parameters:
// class FString                           TravelDestination                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsPlayerTravelDestinationHidden(const class FString& TravelDestination)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsPlayerTravelDestinationHidden");

	Params::Conditionals_IsPlayerTravelDestinationHidden Parms{};

	Parms.TravelDestination = std::move(TravelDestination);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsPlayerTravelDestinationLocked
// (Final, Native, Static, Public)
// Parameters:
// class FString                           TravelDestination                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsPlayerTravelDestinationLocked(const class FString& TravelDestination)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsPlayerTravelDestinationLocked");

	Params::Conditionals_IsPlayerTravelDestinationLocked Parms{};

	Parms.TravelDestination = std::move(TravelDestination);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsQuestActive
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsQuestActive(const struct FGuid& QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsQuestActive");

	Params::Conditionals_IsQuestActive Parms{};

	Parms.QuestID = std::move(QuestID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsQuestAddendumTriggered
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AddendumID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsQuestAddendumTriggered(const struct FGuid& QuestID, int32 AddendumID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsQuestAddendumTriggered");

	Params::Conditionals_IsQuestAddendumTriggered Parms{};

	Parms.QuestID = std::move(QuestID);
	Parms.AddendumID = AddendumID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsQuestComplete
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsQuestComplete(const struct FGuid& QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsQuestComplete");

	Params::Conditionals_IsQuestComplete Parms{};

	Parms.QuestID = std::move(QuestID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsQuestEndStateTriggered
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EndStateID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsQuestEndStateTriggered(const struct FGuid& QuestID, int32 EndStateID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsQuestEndStateTriggered");

	Params::Conditionals_IsQuestEndStateTriggered Parms{};

	Parms.QuestID = std::move(QuestID);
	Parms.EndStateID = EndStateID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsQuestEventTriggered
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   QuestEventID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsQuestEventTriggered(const struct FGuid& QuestID, int32 QuestEventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsQuestEventTriggered");

	Params::Conditionals_IsQuestEventTriggered Parms{};

	Parms.QuestID = std::move(QuestID);
	Parms.QuestEventID = QuestEventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsQuestionNodeOnResponseBranch
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   QuestionNodeID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerResponseNodeID                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsQuestionNodeOnResponseBranch(int32 QuestionNodeID, int32 PlayerResponseNodeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsQuestionNodeOnResponseBranch");

	Params::Conditionals_IsQuestionNodeOnResponseBranch Parms{};

	Parms.QuestionNodeID = QuestionNodeID;
	Parms.PlayerResponseNodeID = PlayerResponseNodeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsQuestMentioned
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsQuestMentioned(const struct FGuid& QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsQuestMentioned");

	Params::Conditionals_IsQuestMentioned Parms{};

	Parms.QuestID = std::move(QuestID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsQuestStarted
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsQuestStarted(const struct FGuid& QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsQuestStarted");

	Params::Conditionals_IsQuestStarted Parms{};

	Parms.QuestID = std::move(QuestID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsQuestStateActive
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NodeID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsQuestStateActive(const struct FGuid& QuestID, int32 NodeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsQuestStateActive");

	Params::Conditionals_IsQuestStateActive Parms{};

	Parms.QuestID = std::move(QuestID);
	Parms.NodeID = NodeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsQuestStateVisited
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NodeID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsQuestStateVisited(const struct FGuid& QuestID, int32 NodeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsQuestStateVisited");

	Params::Conditionals_IsQuestStateVisited Parms{};

	Parms.QuestID = std::move(QuestID);
	Parms.NodeID = NodeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsQuestTracked
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsQuestTracked(const struct FGuid& QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsQuestTracked");

	Params::Conditionals_IsQuestTracked Parms{};

	Parms.QuestID = std::move(QuestID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsRestrictedAreaEnabled
// (Final, Native, Static, Public, HasDefaults)
// Parameters:
// struct FGuid                            RestrictedAreaID                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsRestrictedAreaEnabled(const struct FGuid& RestrictedAreaID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsRestrictedAreaEnabled");

	Params::Conditionals_IsRestrictedAreaEnabled Parms{};

	Parms.RestrictedAreaID = std::move(RestrictedAreaID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsSpeaker
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            SpeakerID                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsSpeaker(const struct FGuid& SpeakerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsSpeaker");

	Params::Conditionals_IsSpeaker Parms{};

	Parms.SpeakerID = std::move(SpeakerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsSpeakerGender
// (Final, Native, Static, Public)
// Parameters:
// EGender                                 Gender                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsSpeakerGender(EGender Gender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsSpeakerGender");

	Params::Conditionals_IsSpeakerGender Parms{};

	Parms.Gender = Gender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsTimeSlice
// (Final, Native, Static, Public)
// Parameters:
// int32                                   StartHour                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EndHour                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsTimeSlice(int32 StartHour, int32 EndHour)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsTimeSlice");

	Params::Conditionals_IsTimeSlice Parms{};

	Parms.StartHour = StartHour;
	Parms.EndHour = EndHour;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsTrapStateEqual
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            TrapObjectID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETrapTriggerState                       State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsTrapStateEqual(const struct FGuid& TrapObjectID, ETrapTriggerState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsTrapStateEqual");

	Params::Conditionals_IsTrapStateEqual Parms{};

	Parms.TrapObjectID = std::move(TrapObjectID);
	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.IsWeaponEquipped
// (Final, Native, Static, Public)
// Parameters:
// class FString                           Weapon                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeDerivedClasses                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::IsWeaponEquipped(const class FString& Weapon, bool bIncludeDerivedClasses)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "IsWeaponEquipped");

	Params::Conditionals_IsWeaponEquipped Parms{};

	Parms.Weapon = std::move(Weapon);
	Parms.bIncludeDerivedClasses = bIncludeDerivedClasses;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.PlayerHasFlaw
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Flaw                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::PlayerHasFlaw(const class FString& Flaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "PlayerHasFlaw");

	Params::Conditionals_PlayerHasFlaw Parms{};

	Parms.Flaw = std::move(Flaw);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Conditionals.PlayerHasPerk
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Perk                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConditionals::PlayerHasPerk(const class FString& Perk)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Conditionals", "PlayerHasPerk");

	Params::Conditionals_PlayerHasPerk Parms{};

	Parms.Perk = std::move(Perk);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.FactionManager.AddReputation_BP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UFactionData>         FactionData                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EReputationType                         ReputationType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EReputationIncrementType                IncrementType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CustomAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EReputationActionType                   ReputationAction                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFactionManager::AddReputation_BP(TSubclassOf<class UFactionData> FactionData, EReputationType ReputationType, EReputationIncrementType IncrementType, int32 CustomAmount, EReputationActionType ReputationAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactionManager", "AddReputation_BP");

	Params::FactionManager_AddReputation_BP Parms{};

	Parms.FactionData = FactionData;
	Parms.ReputationType = ReputationType;
	Parms.IncrementType = IncrementType;
	Parms.CustomAmount = CustomAmount;
	Parms.ReputationAction = ReputationAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.FactionManager.ClearFactionRecentHostilityToPlayer_BP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UFactionData>         FactionData                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFactionManager::ClearFactionRecentHostilityToPlayer_BP(TSubclassOf<class UFactionData> FactionData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactionManager", "ClearFactionRecentHostilityToPlayer_BP");

	Params::FactionManager_ClearFactionRecentHostilityToPlayer_BP Parms{};

	Parms.FactionData = FactionData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.FactionManager.GetReputation_BP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UFactionData>         FactionData                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UReputationData*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UReputationData* UFactionManager::GetReputation_BP(TSubclassOf<class UFactionData> FactionData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactionManager", "GetReputation_BP");

	Params::FactionManager_GetReputation_BP Parms{};

	Parms.FactionData = FactionData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.FactionManager.IsReputationRank_BP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UFactionData>         FactionData                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EReputationRankType                     InRankType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InRank                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EComparisonOperator                     Operator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFactionManager::IsReputationRank_BP(TSubclassOf<class UFactionData> FactionData, EReputationRankType InRankType, int32 InRank, EComparisonOperator Operator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactionManager", "IsReputationRank_BP");

	Params::FactionManager_IsReputationRank_BP Parms{};

	Parms.FactionData = FactionData;
	Parms.InRankType = InRankType;
	Parms.InRank = InRank;
	Parms.Operator = Operator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.FactionManager.IsReputationRankType_BP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UFactionData>         FactionData                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EReputationRankType                     InRankType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EComparisonOperator                     Operator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFactionManager::IsReputationRankType_BP(TSubclassOf<class UFactionData> FactionData, EReputationRankType InRankType, EComparisonOperator Operator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactionManager", "IsReputationRankType_BP");

	Params::FactionManager_IsReputationRankType_BP Parms{};

	Parms.FactionData = FactionData;
	Parms.InRankType = InRankType;
	Parms.Operator = Operator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.FactionManager.SetFactionEncountered_BP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UFactionData>         FactionData                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFactionManager::SetFactionEncountered_BP(TSubclassOf<class UFactionData> FactionData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FactionManager", "SetFactionEncountered_BP");

	Params::FactionManager_SetFactionEncountered_BP Parms{};

	Parms.FactionData = FactionData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.FactionManager.AddNegativeReputation_Debug
// (Final, Exec, Native, Private)
// Parameters:
// class FString                           FactionName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFactionManager::AddNegativeReputation_Debug(const class FString& FactionName, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FactionManager", "AddNegativeReputation_Debug");

	Params::FactionManager_AddNegativeReputation_Debug Parms{};

	Parms.FactionName = std::move(FactionName);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.FactionManager.AddPositiveReputation_Debug
// (Final, Exec, Native, Private)
// Parameters:
// class FString                           FactionName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFactionManager::AddPositiveReputation_Debug(const class FString& FactionName, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FactionManager", "AddPositiveReputation_Debug");

	Params::FactionManager_AddPositiveReputation_Debug Parms{};

	Parms.FactionName = std::move(FactionName);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.FactionManager.SetNegativeReputation_Debug
// (Final, Exec, Native, Private)
// Parameters:
// class FString                           FactionName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFactionManager::SetNegativeReputation_Debug(const class FString& FactionName, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FactionManager", "SetNegativeReputation_Debug");

	Params::FactionManager_SetNegativeReputation_Debug Parms{};

	Parms.FactionName = std::move(FactionName);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.FactionManager.SetPositiveReputation_Debug
// (Final, Exec, Native, Private)
// Parameters:
// class FString                           FactionName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFactionManager::SetPositiveReputation_Debug(const class FString& FactionName, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FactionManager", "SetPositiveReputation_Debug");

	Params::FactionManager_SetPositiveReputation_Debug Parms{};

	Parms.FactionName = std::move(FactionName);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.FactionManager.SetRandomReputations_Debug
// (Final, Exec, Native, Private)

void UFactionManager::SetRandomReputations_Debug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FactionManager", "SetRandomReputations_Debug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ComboBoxStringBase.AddOption
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Option                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UComboBoxStringBase::AddOption(const class FString& Option)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComboBoxStringBase", "AddOption");

	Params::ComboBoxStringBase_AddOption Parms{};

	Parms.Option = std::move(Option);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ComboBoxStringBase.ClearOptions
// (Final, Native, Public, BlueprintCallable)

void UComboBoxStringBase::ClearOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComboBoxStringBase", "ClearOptions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ComboBoxStringBase.ClearSelection
// (Final, Native, Public, BlueprintCallable)

void UComboBoxStringBase::ClearSelection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComboBoxStringBase", "ClearSelection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ComboBoxStringBase.RefreshOptions
// (Final, Native, Public, BlueprintCallable)

void UComboBoxStringBase::RefreshOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComboBoxStringBase", "RefreshOptions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ComboBoxStringBase.RemoveOption
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Option                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UComboBoxStringBase::RemoveOption(const class FString& Option)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComboBoxStringBase", "RemoveOption");

	Params::ComboBoxStringBase_RemoveOption Parms{};

	Parms.Option = std::move(Option);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ComboBoxStringBase.SetSelectedOption
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Option                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UComboBoxStringBase::SetSelectedOption(const class FString& Option)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComboBoxStringBase", "SetSelectedOption");

	Params::ComboBoxStringBase_SetSelectedOption Parms{};

	Parms.Option = std::move(Option);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ComboBoxStringBase.FindOptionIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           Option                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UComboBoxStringBase::FindOptionIndex(const class FString& Option) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComboBoxStringBase", "FindOptionIndex");

	Params::ComboBoxStringBase_FindOptionIndex Parms{};

	Parms.Option = std::move(Option);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ComboBoxStringBase.GetOptionAtIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UComboBoxStringBase::GetOptionAtIndex(int32 Index_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComboBoxStringBase", "GetOptionAtIndex");

	Params::ComboBoxStringBase_GetOptionAtIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ComboBoxStringBase.GetOptionCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UComboBoxStringBase::GetOptionCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComboBoxStringBase", "GetOptionCount");

	Params::ComboBoxStringBase_GetOptionCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ComboBoxStringBase.GetSelectedOption
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UComboBoxStringBase::GetSelectedOption() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComboBoxStringBase", "GetSelectedOption");

	Params::ComboBoxStringBase_GetSelectedOption Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ComboBoxStringBase.GetSelectedOptionIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UComboBoxStringBase::GetSelectedOptionIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComboBoxStringBase", "GetSelectedOptionIndex");

	Params::ComboBoxStringBase_GetSelectedOptionIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ConversationBaseWidget.OnPauseInputAction
// (Native, Protected)

void UConversationBaseWidget::OnPauseInputAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationBaseWidget", "OnPauseInputAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationBaseWidget.OnResponse1InputAction
// (Final, Native, Protected)

void UConversationBaseWidget::OnResponse1InputAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationBaseWidget", "OnResponse1InputAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationBaseWidget.OnResponse2InputAction
// (Final, Native, Protected)

void UConversationBaseWidget::OnResponse2InputAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationBaseWidget", "OnResponse2InputAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationBaseWidget.OnResponse3InputAction
// (Final, Native, Protected)

void UConversationBaseWidget::OnResponse3InputAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationBaseWidget", "OnResponse3InputAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationBaseWidget.OnResponse4InputAction
// (Final, Native, Protected)

void UConversationBaseWidget::OnResponse4InputAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationBaseWidget", "OnResponse4InputAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationBaseWidget.OnResponse5InputAction
// (Final, Native, Protected)

void UConversationBaseWidget::OnResponse5InputAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationBaseWidget", "OnResponse5InputAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationBaseWidget.OnResponse6InputAction
// (Final, Native, Protected)

void UConversationBaseWidget::OnResponse6InputAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationBaseWidget", "OnResponse6InputAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationBaseWidget.OnResponse7InputAction
// (Final, Native, Protected)

void UConversationBaseWidget::OnResponse7InputAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationBaseWidget", "OnResponse7InputAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationBaseWidget.OnResponse8InputAction
// (Final, Native, Protected)

void UConversationBaseWidget::OnResponse8InputAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationBaseWidget", "OnResponse8InputAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationBaseWidget.OnResponse9InputAction
// (Final, Native, Protected)

void UConversationBaseWidget::OnResponse9InputAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationBaseWidget", "OnResponse9InputAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationBaseWidget.OnSkipInputAction
// (Native, Protected)

void UConversationBaseWidget::OnSkipInputAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationBaseWidget", "OnSkipInputAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ComputerTerminalWidget.OnConversationEnded
// (Final, Native, Protected)

void UComputerTerminalWidget::OnConversationEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComputerTerminalWidget", "OnConversationEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ComputerTerminalWidget.OnExitInputAction
// (Final, Native, Protected)

void UComputerTerminalWidget::OnExitInputAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComputerTerminalWidget", "OnExitInputAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Corpse.GetItemsOnCorpse
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UItem*>                    OutItems                                               (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACorpse::GetItemsOnCorpse(TArray<class UItem*>* OutItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Corpse", "GetItemsOnCorpse");

	Params::Corpse_GetItemsOnCorpse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItems != nullptr)
		*OutItems = std::move(Parms.OutItems);
}


// Function Indiana.Corpse.HandleItemAdded
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACorpse::HandleItemAdded(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Corpse", "HandleItemAdded");

	Params::Corpse_HandleItemAdded Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Corpse.HandleItemRemoved
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACorpse::HandleItemRemoved(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Corpse", "HandleItemRemoved");

	Params::Corpse_HandleItemRemoved Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationActorInterface.GetConversationDescription
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// struct FConversationDescription         ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FConversationDescription IConversationActorInterface::GetConversationDescription() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationActorInterface", "GetConversationDescription");

	Params::ConversationActorInterface_GetConversationDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ConversationActorInterface.GetSpeakerGameDataID
// (Native, Event, Public, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FGuid                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGuid IConversationActorInterface::GetSpeakerGameDataID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationActorInterface", "GetSpeakerGameDataID");

	Params::ConversationActorInterface_GetSpeakerGameDataID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.RestrictedArea.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARestrictedArea::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RestrictedArea", "IsEnabled");

	Params::RestrictedArea_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.QuestJournalWidget.OnQuestImageLoaded
// (Event, Protected, BlueprintEvent)

void UQuestJournalWidget::OnQuestImageLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestJournalWidget", "OnQuestImageLoaded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.QuestAddendumWidget.OnObjectiveStatusChange
// (Event, Protected, BlueprintEvent)
// Parameters:
// ECompletionStatus                       ObjectiveCompletion                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestAddendumWidget::OnObjectiveStatusChange(ECompletionStatus ObjectiveCompletion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestAddendumWidget", "OnObjectiveStatusChange");

	Params::QuestAddendumWidget_OnObjectiveStatusChange Parms{};

	Parms.ObjectiveCompletion = ObjectiveCompletion;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.PersonalSpaceComponent.OnNewStateOfBeing
// (Final, Native, Private)
// Parameters:
// EStateOfBeing                           NewStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStateOfBeing                           OldStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPersonalSpaceComponent::OnNewStateOfBeing(EStateOfBeing NewStateOfBeing, EStateOfBeing OldStateOfBeing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PersonalSpaceComponent", "OnNewStateOfBeing");

	Params::PersonalSpaceComponent_OnNewStateOfBeing Parms{};

	Parms.NewStateOfBeing = NewStateOfBeing;
	Parms.OldStateOfBeing = OldStateOfBeing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnInteractableSelectionChanged.OnInteractableSelectionChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FInteractionDescription          Description                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UOnInteractableSelectionChanged::OnInteractableSelectionChanged(const struct FInteractionDescription& Description)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnInteractableSelectionChanged", "OnInteractableSelectionChanged");

	Params::OnInteractableSelectionChanged_OnInteractableSelectionChanged Parms{};

	Parms.Description = std::move(Description);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.RockFoliageTool.MoveBigScaleInstanceToFoliageType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AInstancedFoliageActor*           IFA                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFoliageType*                     OldType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFoliageType*                     NewType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InstanceScale                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARockFoliageTool::MoveBigScaleInstanceToFoliageType(class AInstancedFoliageActor* IFA, class UFoliageType* OldType, class UFoliageType* NewType, float InstanceScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RockFoliageTool", "MoveBigScaleInstanceToFoliageType");

	Params::RockFoliageTool_MoveBigScaleInstanceToFoliageType Parms{};

	Parms.IFA = IFA;
	Parms.OldType = OldType;
	Parms.NewType = NewType;
	Parms.InstanceScale = InstanceScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SavingWidget.HideSavingWidget
// (Final, Native, Public)
// Parameters:
// ESaveGameResult                         SaveGameResult                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESaveGameType                           SaveGameType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USavingWidget::HideSavingWidget(ESaveGameResult SaveGameResult, ESaveGameType SaveGameType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SavingWidget", "HideSavingWidget");

	Params::SavingWidget_HideSavingWidget Parms{};

	Parms.SaveGameResult = SaveGameResult;
	Parms.SaveGameType = SaveGameType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SavingWidget.OnHUDVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USavingWidget::OnHUDVisibilityChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SavingWidget", "OnHUDVisibilityChanged");

	Params::SavingWidget_OnHUDVisibilityChanged Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SavingWidget.ShowSavingWidget
// (Final, Native, Public)

void USavingWidget::ShowSavingWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SavingWidget", "ShowSavingWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnCompanionRegistrationChanged.OnCompanionRegistrationChanged
// (Final, Native, Protected)

void UOnCompanionRegistrationChanged::OnCompanionRegistrationChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnCompanionRegistrationChanged", "OnCompanionRegistrationChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DLCManager.OnGlobalVarChanged
// (Final, Native, Protected)
// Parameters:
// class FString                           VariableName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDLCManager::OnGlobalVarChanged(const class FString& VariableName, int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DLCManager", "OnGlobalVarChanged");

	Params::DLCManager_OnGlobalVarChanged Parms{};

	Parms.VariableName = std::move(VariableName);
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DLCManager.IsINX1Installed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDLCManager::IsINX1Installed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DLCManager", "IsINX1Installed");

	Params::DLCManager_IsINX1Installed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.DLCManager.IsINX2Installed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDLCManager::IsINX2Installed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DLCManager", "IsINX2Installed");

	Params::DLCManager_IsINX2Installed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OnReceiveDamage.OnDamageEvent
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FCauseDamageInfo                 CauseDamageInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UOnReceiveDamage::OnDamageEvent(const struct FCauseDamageInfo& CauseDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnReceiveDamage", "OnDamageEvent");

	Params::OnReceiveDamage_OnDamageEvent Parms{};

	Parms.CauseDamageInfo = std::move(CauseDamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DeathBehavior.Complete
// (Final, Native, Public, BlueprintCallable)

void UDeathBehavior::Complete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathBehavior", "Complete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DeathBehavior.CustomTick
// (Event, Public, BlueprintEvent)

void UDeathBehavior::CustomTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathBehavior", "CustomTick");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.DeathBehavior.CustomTrigger
// (Event, Public, BlueprintEvent)

void UDeathBehavior::CustomTrigger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathBehavior", "CustomTrigger");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.DeathBehavior.GetTargetMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* UDeathBehavior::GetTargetMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathBehavior", "GetTargetMesh");

	Params::DeathBehavior_GetTargetMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.RadialContextMenuWidget.OnRadialMenuSelection
// (Final, Native, Protected)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URadialContextMenuWidget::OnRadialMenuSelection(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadialContextMenuWidget", "OnRadialMenuSelection");

	Params::RadialContextMenuWidget_OnRadialMenuSelection Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuComboBoxWidget.OnValueChanged
// (Final, Native, Protected)
// Parameters:
// class FString                           SelectedItem                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESelectInfo                             SelectionType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USettingsMenuComboBoxWidget::OnValueChanged(const class FString& SelectedItem, ESelectInfo SelectionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuComboBoxWidget", "OnValueChanged");

	Params::SettingsMenuComboBoxWidget_OnValueChanged Parms{};

	Parms.SelectedItem = std::move(SelectedItem);
	Parms.SelectionType = SelectionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AISettingsComponent.OnEquipWeapon
// (Final, Native, Private)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAISettingsComponent::OnEquipWeapon(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AISettingsComponent", "OnEquipWeapon");

	Params::AISettingsComponent_OnEquipWeapon Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AISettingsComponent.OnUnequipWeapon
// (Final, Native, Private)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAISettingsComponent::OnUnequipWeapon(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AISettingsComponent", "OnUnequipWeapon");

	Params::AISettingsComponent_OnUnequipWeapon Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AlarmComponent.GetAlarmState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAlarmState                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAlarmState UAlarmComponent::GetAlarmState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AlarmComponent", "GetAlarmState");

	Params::AlarmComponent_GetAlarmState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.AmmoReadoutWidget.EvaluateLowAmmoWarning
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   MaxClipSize                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurrentClipSize                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RemainingAmmo                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAmmoReadoutWidget::EvaluateLowAmmoWarning(int32 MaxClipSize, int32 CurrentClipSize, int32 RemainingAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoReadoutWidget", "EvaluateLowAmmoWarning");

	Params::AmmoReadoutWidget_EvaluateLowAmmoWarning Parms{};

	Parms.MaxClipSize = MaxClipSize;
	Parms.CurrentClipSize = CurrentClipSize;
	Parms.RemainingAmmo = RemainingAmmo;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.AmmoReadoutWidget.OnHeldWeaponDisplayModeChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAmmoReadoutWidget::OnHeldWeaponDisplayModeChanged(int32 ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoReadoutWidget", "OnHeldWeaponDisplayModeChanged");

	Params::AmmoReadoutWidget_OnHeldWeaponDisplayModeChanged Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AmmoReadoutWidget.OnHeldWeaponTextDisplayModeChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAmmoReadoutWidget::OnHeldWeaponTextDisplayModeChanged(int32 ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoReadoutWidget", "OnHeldWeaponTextDisplayModeChanged");

	Params::AmmoReadoutWidget_OnHeldWeaponTextDisplayModeChanged Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AmmoReadoutWidget.OnHUDVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAmmoReadoutWidget::OnHUDVisibilityChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoReadoutWidget", "OnHUDVisibilityChanged");

	Params::AmmoReadoutWidget_OnHUDVisibilityChanged Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AmmoReadoutWidget.OnInterruptReload
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          EquippedWeapon                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAmmoReadoutWidget::OnInterruptReload(class UWeapon* EquippedWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoReadoutWidget", "OnInterruptReload");

	Params::AmmoReadoutWidget_OnInterruptReload Parms{};

	Parms.EquippedWeapon = EquippedWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AmmoReadoutWidget.OnPlayerCombatStateChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bCombatIn                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAmmoReadoutWidget::OnPlayerCombatStateChange(bool bCombatIn, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoReadoutWidget", "OnPlayerCombatStateChange");

	Params::AmmoReadoutWidget_OnPlayerCombatStateChange Parms{};

	Parms.bCombatIn = bCombatIn;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AmmoReadoutWidget.OnReloadComplete
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          EquippedWeapon                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAmmoReadoutWidget::OnReloadComplete(class UWeapon* EquippedWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoReadoutWidget", "OnReloadComplete");

	Params::AmmoReadoutWidget_OnReloadComplete Parms{};

	Parms.EquippedWeapon = EquippedWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AmmoReadoutWidget.OnWeaponSwitch
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          EquippedWeapon                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAmmoReadoutWidget::OnWeaponSwitch(class UWeapon* EquippedWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoReadoutWidget", "OnWeaponSwitch");

	Params::AmmoReadoutWidget_OnWeaponSwitch Parms{};

	Parms.EquippedWeapon = EquippedWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemDegradationEntryWidget.KillAllAnims
// (Event, Protected, BlueprintEvent)

void UItemDegradationEntryWidget::KillAllAnims()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemDegradationEntryWidget", "KillAllAnims");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.ItemDegradationEntryWidget.PlayIntroDamagedAnim
// (Event, Protected, BlueprintEvent)

void UItemDegradationEntryWidget::PlayIntroDamagedAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemDegradationEntryWidget", "PlayIntroDamagedAnim");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.ItemDegradationEntryWidget.PlaySevereDamageAnim
// (Event, Protected, BlueprintEvent)

void UItemDegradationEntryWidget::PlaySevereDamageAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemDegradationEntryWidget", "PlaySevereDamageAnim");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.IndianaAnimInstance.AnimNotify_DisableFootIK
// (Final, Native, Public, BlueprintCallable)

void UIndianaAnimInstance::AnimNotify_DisableFootIK()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAnimInstance", "AnimNotify_DisableFootIK");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAnimInstance.AnimNotify_EnableFootIK
// (Final, Native, Public, BlueprintCallable)

void UIndianaAnimInstance::AnimNotify_EnableFootIK()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAnimInstance", "AnimNotify_EnableFootIK");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAnimInstance.AnimNotify_ToggleFootIK
// (Final, Native, Public, BlueprintCallable)

void UIndianaAnimInstance::AnimNotify_ToggleFootIK()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAnimInstance", "AnimNotify_ToggleFootIK");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAnimInstance.Montage_SkipToEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     MontageToPlay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaAnimInstance::Montage_SkipToEnd(class UAnimMontage* MontageToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAnimInstance", "Montage_SkipToEnd");

	Params::IndianaAnimInstance_Montage_SkipToEnd Parms{};

	Parms.MontageToPlay = MontageToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.CharacterAnimInstance.OnMovementLanded
// (Final, Native, Protected)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterAnimInstance::OnMovementLanded(float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterAnimInstance", "OnMovementLanded");

	Params::CharacterAnimInstance_OnMovementLanded Parms{};

	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterAnimInstance.OnNewLocomotionAnimationSet
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ULocomotionAnimationSet*          NewLocomtionAnimationSet                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterAnimInstance::OnNewLocomotionAnimationSet(class ULocomotionAnimationSet* NewLocomtionAnimationSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterAnimInstance", "OnNewLocomotionAnimationSet");

	Params::CharacterAnimInstance_OnNewLocomotionAnimationSet Parms{};

	Parms.NewLocomtionAnimationSet = NewLocomtionAnimationSet;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.CharacterAnimInstance.OnNewWeaponAnimations
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UWeaponAnimations*                NewWeaponAnimations                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterAnimInstance::OnNewWeaponAnimations(class UWeaponAnimations* NewWeaponAnimations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterAnimInstance", "OnNewWeaponAnimations");

	Params::CharacterAnimInstance_OnNewWeaponAnimations Parms{};

	Parms.NewWeaponAnimations = NewWeaponAnimations;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.CharacterAnimInstance.OnRebuildAnimationSetData
// (Event, Protected, BlueprintEvent)

void UCharacterAnimInstance::OnRebuildAnimationSetData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterAnimInstance", "OnRebuildAnimationSetData");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.CharacterAnimInstance.SetDisabledAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FAnimEventGameplayTagContainer   Container                                              (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCharacterAnimInstance::SetDisabledAnimation(const struct FAnimEventGameplayTagContainer& Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterAnimInstance", "SetDisabledAnimation");

	Params::CharacterAnimInstance_SetDisabledAnimation Parms{};

	Parms.Container = std::move(Container);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterAnimInstance.IsMontagePlayingOnSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             SlotNodeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterAnimInstance::IsMontagePlayingOnSlot(class FName SlotNodeName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterAnimInstance", "IsMontagePlayingOnSlot");

	Params::CharacterAnimInstance_IsMontagePlayingOnSlot Parms{};

	Parms.SlotNodeName = SlotNodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.LevelOptionsWidget.OnControllerBack
// (Final, Native, Protected)

void ULevelOptionsWidget::OnControllerBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelOptionsWidget", "OnControllerBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnSprintEnd.OnSprintEnded
// (Final, Native, Protected)

void UOnSprintEnd::OnSprintEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnSprintEnd", "OnSprintEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ButtonBase.GetFocusedBrush
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSlateBrush                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateBrush UButtonBase::GetFocusedBrush()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "GetFocusedBrush");

	Params::ButtonBase_GetFocusedBrush Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ButtonBase.GetHoveredBrush
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSlateBrush                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateBrush UButtonBase::GetHoveredBrush()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "GetHoveredBrush");

	Params::ButtonBase_GetHoveredBrush Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ButtonBase.GetNormalBrush
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSlateBrush                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateBrush UButtonBase::GetNormalBrush()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "GetNormalBrush");

	Params::ButtonBase_GetNormalBrush Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ButtonBase.GetPressedBrush
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSlateBrush                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateBrush UButtonBase::GetPressedBrush()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "GetPressedBrush");

	Params::ButtonBase_GetPressedBrush Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ButtonBase.GetSelectedFocusedBrush
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSlateBrush                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateBrush UButtonBase::GetSelectedFocusedBrush()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "GetSelectedFocusedBrush");

	Params::ButtonBase_GetSelectedFocusedBrush Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ButtonBase.GetSelectedHoveredBrush
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSlateBrush                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateBrush UButtonBase::GetSelectedHoveredBrush()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "GetSelectedHoveredBrush");

	Params::ButtonBase_GetSelectedHoveredBrush Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ButtonBase.GetSelectedNormalBrush
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSlateBrush                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateBrush UButtonBase::GetSelectedNormalBrush()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "GetSelectedNormalBrush");

	Params::ButtonBase_GetSelectedNormalBrush Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ButtonBase.GetSelectedPressedBrush
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSlateBrush                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateBrush UButtonBase::GetSelectedPressedBrush()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "GetSelectedPressedBrush");

	Params::ButtonBase_GetSelectedPressedBrush Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ButtonBase.SetAdvancedHitAlpha
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InAlpha                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UButtonBase::SetAdvancedHitAlpha(int32 InAlpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "SetAdvancedHitAlpha");

	Params::ButtonBase_SetAdvancedHitAlpha Parms{};

	Parms.InAlpha = InAlpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ButtonBase.SetAdvancedHitTexture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTexture2D*                       InTexture                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UButtonBase::SetAdvancedHitTexture(class UTexture2D* InTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "SetAdvancedHitTexture");

	Params::ButtonBase_SetAdvancedHitTexture Parms{};

	Parms.InTexture = InTexture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ButtonBase.SetAllowSelectionStateChange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAllowChange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UButtonBase::SetAllowSelectionStateChange(bool bAllowChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "SetAllowSelectionStateChange");

	Params::ButtonBase_SetAllowSelectionStateChange Parms{};

	Parms.bAllowChange = bAllowChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ButtonBase.SetButtonColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InBackgroundColor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UButtonBase::SetButtonColor(const struct FLinearColor& InBackgroundColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "SetButtonColor");

	Params::ButtonBase_SetButtonColor Parms{};

	Parms.InBackgroundColor = std::move(InBackgroundColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ButtonBase.SetButtonType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EButtonType                             TypeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UButtonBase::SetButtonType(EButtonType TypeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "SetButtonType");

	Params::ButtonBase_SetButtonType Parms{};

	Parms.TypeIn = TypeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ButtonBase.SetContentColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InColorAndOpacity                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UButtonBase::SetContentColor(const struct FLinearColor& InColorAndOpacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "SetContentColor");

	Params::ButtonBase_SetContentColor Parms{};

	Parms.InColorAndOpacity = std::move(InColorAndOpacity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ButtonBase.SetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UButtonBase::SetEnabled(bool bInEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "SetEnabled");

	Params::ButtonBase_SetEnabled Parms{};

	Parms.bInEnabled = bInEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ButtonBase.SetFocusable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFocused                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UButtonBase::SetFocusable(bool bFocused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "SetFocusable");

	Params::ButtonBase_SetFocusable Parms{};

	Parms.bFocused = bFocused;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ButtonBase.SetFocusedBrush
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSlateBrush                      InBrush                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UButtonBase::SetFocusedBrush(const struct FSlateBrush& InBrush)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "SetFocusedBrush");

	Params::ButtonBase_SetFocusedBrush Parms{};

	Parms.InBrush = std::move(InBrush);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ButtonBase.SetHoveredBrush
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSlateBrush                      InBrush                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UButtonBase::SetHoveredBrush(const struct FSlateBrush& InBrush)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "SetHoveredBrush");

	Params::ButtonBase_SetHoveredBrush Parms{};

	Parms.InBrush = std::move(InBrush);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ButtonBase.SetNormalBrush
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSlateBrush                      InBrush                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UButtonBase::SetNormalBrush(const struct FSlateBrush& InBrush)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "SetNormalBrush");

	Params::ButtonBase_SetNormalBrush Parms{};

	Parms.InBrush = std::move(InBrush);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ButtonBase.SetPressedBrush
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSlateBrush                      InBrush                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UButtonBase::SetPressedBrush(const struct FSlateBrush& InBrush)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "SetPressedBrush");

	Params::ButtonBase_SetPressedBrush Parms{};

	Parms.InBrush = std::move(InBrush);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ButtonBase.SetSelected
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSelected_0                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFocusCause                             Cause                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UButtonBase::SetSelected(bool bSelected_0, EFocusCause Cause)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "SetSelected");

	Params::ButtonBase_SetSelected Parms{};

	Parms.bSelected_0 = bSelected_0;
	Parms.Cause = Cause;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ButtonBase.SetSelectedFocusedBrush
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSlateBrush                      InBrush                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UButtonBase::SetSelectedFocusedBrush(const struct FSlateBrush& InBrush)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "SetSelectedFocusedBrush");

	Params::ButtonBase_SetSelectedFocusedBrush Parms{};

	Parms.InBrush = std::move(InBrush);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ButtonBase.SetSelectedHoveredBrush
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSlateBrush                      InBrush                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UButtonBase::SetSelectedHoveredBrush(const struct FSlateBrush& InBrush)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "SetSelectedHoveredBrush");

	Params::ButtonBase_SetSelectedHoveredBrush Parms{};

	Parms.InBrush = std::move(InBrush);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ButtonBase.SetSelectedNormalBrush
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSlateBrush                      InBrush                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UButtonBase::SetSelectedNormalBrush(const struct FSlateBrush& InBrush)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "SetSelectedNormalBrush");

	Params::ButtonBase_SetSelectedNormalBrush Parms{};

	Parms.InBrush = std::move(InBrush);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ButtonBase.SetSelectedPressedBrush
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSlateBrush                      InBrush                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UButtonBase::SetSelectedPressedBrush(const struct FSlateBrush& InBrush)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "SetSelectedPressedBrush");

	Params::ButtonBase_SetSelectedPressedBrush Parms{};

	Parms.InBrush = std::move(InBrush);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ButtonBase.AllowsSelectionStateChange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UButtonBase::AllowsSelectionStateChange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "AllowsSelectionStateChange");

	Params::ButtonBase_AllowsSelectionStateChange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ButtonBase.GetButtonType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EButtonType                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EButtonType UButtonBase::GetButtonType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "GetButtonType");

	Params::ButtonBase_GetButtonType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ButtonBase.IsPressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UButtonBase::IsPressed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "IsPressed");

	Params::ButtonBase_IsPressed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ButtonBase.IsSelected
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UButtonBase::IsSelected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBase", "IsSelected");

	Params::ButtonBase_IsSelected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.TPVAnimInstance.AnimNotify_ClearFurnitureFlag
// (Final, Native, Public, BlueprintCallable)

void UTPVAnimInstance::AnimNotify_ClearFurnitureFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TPVAnimInstance", "AnimNotify_ClearFurnitureFlag");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TPVAnimInstance.AnimNotify_CombatStateEntered
// (Final, Native, Protected, BlueprintCallable)

void UTPVAnimInstance::AnimNotify_CombatStateEntered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TPVAnimInstance", "AnimNotify_CombatStateEntered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TPVAnimInstance.AnimNotify_CTurnEntered
// (Final, Native, Public, BlueprintCallable)

void UTPVAnimInstance::AnimNotify_CTurnEntered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TPVAnimInstance", "AnimNotify_CTurnEntered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TPVAnimInstance.AnimNotify_IdleStateLeft
// (Final, Native, Protected, BlueprintCallable)

void UTPVAnimInstance::AnimNotify_IdleStateLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TPVAnimInstance", "AnimNotify_IdleStateLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TPVAnimInstance.AnimNotify_JumpStateMachineComplete
// (Final, Native, Protected, BlueprintCallable)

void UTPVAnimInstance::AnimNotify_JumpStateMachineComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TPVAnimInstance", "AnimNotify_JumpStateMachineComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TPVAnimInstance.AnimNotify_NCIdleEntered
// (Final, Native, Public, BlueprintCallable)

void UTPVAnimInstance::AnimNotify_NCIdleEntered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TPVAnimInstance", "AnimNotify_NCIdleEntered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TPVAnimInstance.AnimNotify_NCRunEntered
// (Final, Native, Public, BlueprintCallable)

void UTPVAnimInstance::AnimNotify_NCRunEntered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TPVAnimInstance", "AnimNotify_NCRunEntered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TPVAnimInstance.AnimNotify_NCTurnEntered
// (Final, Native, Public, BlueprintCallable)

void UTPVAnimInstance::AnimNotify_NCTurnEntered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TPVAnimInstance", "AnimNotify_NCTurnEntered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TPVAnimInstance.AnimNotify_NCWalkEntered
// (Final, Native, Public, BlueprintCallable)

void UTPVAnimInstance::AnimNotify_NCWalkEntered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TPVAnimInstance", "AnimNotify_NCWalkEntered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TPVAnimInstance.AnimNotify_NCWalkStartEntered
// (Final, Native, Public, BlueprintCallable)

void UTPVAnimInstance::AnimNotify_NCWalkStartEntered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TPVAnimInstance", "AnimNotify_NCWalkStartEntered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TPVAnimInstance.AnimNotify_OnJumpIntroEnd
// (Final, Native, Protected, BlueprintCallable)

void UTPVAnimInstance::AnimNotify_OnJumpIntroEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TPVAnimInstance", "AnimNotify_OnJumpIntroEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TPVAnimInstance.AnimNotify_OnLandEnd
// (Final, Native, Protected, BlueprintCallable)

void UTPVAnimInstance::AnimNotify_OnLandEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TPVAnimInstance", "AnimNotify_OnLandEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TPVAnimInstance.AnimNotify_ResetLocomotionState
// (Final, Native, Public, BlueprintCallable)

void UTPVAnimInstance::AnimNotify_ResetLocomotionState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TPVAnimInstance", "AnimNotify_ResetLocomotionState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TPVAnimInstance.ClearCurrentEmotion
// (Native, Public, BlueprintCallable)

void UTPVAnimInstance::ClearCurrentEmotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TPVAnimInstance", "ClearCurrentEmotion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TPVAnimInstance.GetAnimationSetUpdate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTPVAnimInstance::GetAnimationSetUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TPVAnimInstance", "GetAnimationSetUpdate");

	Params::TPVAnimInstance_GetAnimationSetUpdate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.TPVAnimInstance.GetUpFromRagdoll
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   GetUpSpeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTPVAnimInstance::GetUpFromRagdoll(float GetUpSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TPVAnimInstance", "GetUpFromRagdoll");

	Params::TPVAnimInstance_GetUpFromRagdoll Parms{};

	Parms.GetUpSpeed = GetUpSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TPVAnimInstance.OnMontageEnd
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTPVAnimInstance::OnMontageEnd(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TPVAnimInstance", "OnMontageEnd");

	Params::TPVAnimInstance_OnMontageEnd Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TPVAnimInstance.OnMontageStart
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTPVAnimInstance::OnMontageStart(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TPVAnimInstance", "OnMontageStart");

	Params::TPVAnimInstance_OnMontageStart Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TPVAnimInstance.ResetEmotionToDefault
// (Final, Native, Public, BlueprintCallable)

void UTPVAnimInstance::ResetEmotionToDefault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TPVAnimInstance", "ResetEmotionToDefault");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TPVAnimInstance.SetNextEmotion
// (Native, Public, BlueprintCallable)
// Parameters:
// EEmotion                                Emotion                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Persist                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ForceNextEmotion                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTPVAnimInstance::SetNextEmotion(EEmotion Emotion, float Duration, bool Persist, bool ForceNextEmotion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TPVAnimInstance", "SetNextEmotion");

	Params::TPVAnimInstance_SetNextEmotion Parms{};

	Parms.Emotion = Emotion;
	Parms.Duration = Duration;
	Parms.Persist = Persist;
	Parms.ForceNextEmotion = ForceNextEmotion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.TPVAnimInstance.SetPersonality
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UTPVPersonalitySet*               Personality                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTPVAnimInstance::SetPersonality(class UTPVPersonalitySet* Personality)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TPVAnimInstance", "SetPersonality");

	Params::TPVAnimInstance_SetPersonality Parms{};

	Parms.Personality = Personality;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.TPVAnimInstance.SetStateTransitioned
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAnimTreeState                          State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Transitioned                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTPVAnimInstance::SetStateTransitioned(EAnimTreeState State, bool Transitioned)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TPVAnimInstance", "SetStateTransitioned");

	Params::TPVAnimInstance_SetStateTransitioned Parms{};

	Parms.State = State;
	Parms.Transitioned = Transitioned;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TPVAnimInstance.UpdateAnimationSetUpdate
// (Final, Native, Public, BlueprintCallable)

void UTPVAnimInstance::UpdateAnimationSetUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TPVAnimInstance", "UpdateAnimationSetUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.BipedAnimInstance.AnimNotify_SafeToReevaluateTalking
// (Final, Native, Public, BlueprintCallable)

void UBipedAnimInstance::AnimNotify_SafeToReevaluateTalking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BipedAnimInstance", "AnimNotify_SafeToReevaluateTalking");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.BipedAnimInstance.PickRandomIdle
// (Final, Native, Public, BlueprintCallable)

void UBipedAnimInstance::PickRandomIdle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BipedAnimInstance", "PickRandomIdle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.BipedAnimInstance.UpdatePersonalityAnims
// (Final, Native, Public, BlueprintCallable)

void UBipedAnimInstance::UpdatePersonalityAnims()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BipedAnimInstance", "UpdatePersonalityAnims");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnObjectBumped.OnBumped
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           SelfActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UOnObjectBumped::OnBumped(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnObjectBumped", "OnBumped");

	Params::OnObjectBumped_OnBumped Parms{};

	Parms.SelfActor = SelfActor;
	Parms.OtherActor = OtherActor;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DeathComponent.DeathComplete
// (Native, Public, BlueprintCallable)

void UDeathComponent::DeathComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathComponent", "DeathComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterDeathComponent.AttachAllGoreCaps
// (Final, Native, Public, BlueprintCallable)

void UCharacterDeathComponent::AttachAllGoreCaps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDeathComponent", "AttachAllGoreCaps");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterDeathComponent.AttachGoreCaps
// (Final, Native, Public, BlueprintCallable)

void UCharacterDeathComponent::AttachGoreCaps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDeathComponent", "AttachGoreCaps");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterDeathComponent.BreakAllBones
// (Final, Native, Public, BlueprintCallable)

void UCharacterDeathComponent::BreakAllBones()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDeathComponent", "BreakAllBones");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterDeathComponent.BreakBone
// (Final, Native, Public, BlueprintCallable)

void UCharacterDeathComponent::BreakBone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDeathComponent", "BreakBone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterDeathComponent.CalcImpactVector
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCharacterDeathComponent::CalcImpactVector()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDeathComponent", "CalcImpactVector");

	Params::CharacterDeathComponent_CalcImpactVector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.CharacterDeathComponent.DetachImpactFx
// (Final, Native, Public, BlueprintCallable)

void UCharacterDeathComponent::DetachImpactFx()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDeathComponent", "DetachImpactFx");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterDeathComponent.GibCharacter
// (Final, Native, Public, BlueprintCallable)

void UCharacterDeathComponent::GibCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDeathComponent", "GibCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterDeathComponent.HideAppearanceMeshes
// (Final, Native, Public, BlueprintCallable)

void UCharacterDeathComponent::HideAppearanceMeshes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDeathComponent", "HideAppearanceMeshes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterDeathComponent.HideProps
// (Final, Native, Public, BlueprintCallable)

void UCharacterDeathComponent::HideProps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDeathComponent", "HideProps");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterDeathComponent.OnMontageEnded
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterDeathComponent::OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDeathComponent", "OnMontageEnded");

	Params::CharacterDeathComponent_OnMontageEnded Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterDeathComponent.RagdollCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIgnoreDeathMontages                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterDeathComponent::RagdollCharacter(bool bIgnoreDeathMontages)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDeathComponent", "RagdollCharacter");

	Params::CharacterDeathComponent_RagdollCharacter Parms{};

	Parms.bIgnoreDeathMontages = bIgnoreDeathMontages;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterDeathComponent.SpawnAshPile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UStaticMesh*                      Mesh                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               LootablePileMaterial                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* UCharacterDeathComponent::SpawnAshPile(class UStaticMesh* Mesh, class UMaterialInterface* LootablePileMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDeathComponent", "SpawnAshPile");

	Params::CharacterDeathComponent_SpawnAshPile Parms{};

	Parms.Mesh = Mesh;
	Parms.LootablePileMaterial = LootablePileMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.CharacterDeathComponent.StoreDeathImpact
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Impulse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterDeathComponent::StoreDeathImpact(const struct FVector& Impulse, const struct FVector& Location, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDeathComponent", "StoreDeathImpact");

	Params::CharacterDeathComponent_StoreDeathImpact Parms{};

	Parms.Impulse = std::move(Impulse);
	Parms.Location = std::move(Location);
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerDeathComponent.DeathAnimComplete
// (Native, Public, BlueprintCallable)

void UPlayerDeathComponent::DeathAnimComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerDeathComponent", "DeathAnimComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerDeathComponent.FadeToBlackComplete
// (Final, Native, Protected, BlueprintCallable)

void UPlayerDeathComponent::FadeToBlackComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerDeathComponent", "FadeToBlackComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerDeathComponent.OnAnimNotifyEvent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EAnimNotify                             AnimNotifyEvent                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerDeathComponent::OnAnimNotifyEvent(EAnimNotify AnimNotifyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerDeathComponent", "OnAnimNotifyEvent");

	Params::PlayerDeathComponent_OnAnimNotifyEvent Parms{};

	Parms.AnimNotifyEvent = AnimNotifyEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerDeathComponent.OnLanded
// (Final, Native, Private)
// Parameters:
// float                                   DistanceFallen                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerDeathComponent::OnLanded(float DistanceFallen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerDeathComponent", "OnLanded");

	Params::PlayerDeathComponent_OnLanded Parms{};

	Parms.DistanceFallen = DistanceFallen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnAddictionTimerEntersMaxed.OnAddictionTimerEntersMaxed
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     TimerTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnAddictionTimerEntersMaxed::OnAddictionTimerEntersMaxed(const struct FGameplayTag& TimerTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnAddictionTimerEntersMaxed", "OnAddictionTimerEntersMaxed");

	Params::OnAddictionTimerEntersMaxed_OnAddictionTimerEntersMaxed Parms{};

	Parms.TimerTag = std::move(TimerTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.LedgerWidget.AfterSettingAnyPage
// (Final, Native, Protected)
// Parameters:
// class UIndianaUserWidget*               UserWidget                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCanChangePage                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bActivate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULedgerWidget::AfterSettingAnyPage(class UIndianaUserWidget* UserWidget, int32 Index_0, bool bAnimate, bool bCanChangePage, bool bActivate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LedgerWidget", "AfterSettingAnyPage");

	Params::LedgerWidget_AfterSettingAnyPage Parms{};

	Parms.UserWidget = UserWidget;
	Parms.Index_0 = Index_0;
	Parms.bAnimate = bAnimate;
	Parms.bCanChangePage = bCanChangePage;
	Parms.bActivate = bActivate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.LedgerWidget.FadeInSharedItemViewer
// (Event, Protected, BlueprintEvent)

void ULedgerWidget::FadeInSharedItemViewer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LedgerWidget", "FadeInSharedItemViewer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.LedgerWidget.OnItemAdded
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULedgerWidget::OnItemAdded(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LedgerWidget", "OnItemAdded");

	Params::LedgerWidget_OnItemAdded Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.LedgerWidget.OnSetCurrentPage
// (Event, Protected, BlueprintEvent)
// Parameters:
// ELedgerPages                            Page                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULedgerWidget::OnSetCurrentPage(ELedgerPages Page, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LedgerWidget", "OnSetCurrentPage");

	Params::LedgerWidget_OnSetCurrentPage Parms{};

	Parms.Page = Page;
	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.LedgerWidget.UpdateCompanionTabs
// (Final, Native, Protected)

void ULedgerWidget::UpdateCompanionTabs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LedgerWidget", "UpdateCompanionTabs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.BossComponent.OnCombatStateChanged
// (Final, Native, Private)
// Parameters:
// bool                                    bIsInCombat                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBossComponent::OnCombatStateChanged(bool bIsInCombat, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BossComponent", "OnCombatStateChanged");

	Params::BossComponent_OnCombatStateChanged Parms{};

	Parms.bIsInCombat = bIsInCombat;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.BossComponent.OnHealthChanged
// (Final, Native, Private)
// Parameters:
// float                                   HealthChange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InInstigator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBossComponent::OnHealthChanged(float HealthChange, class AActor* InInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BossComponent", "OnHealthChanged");

	Params::BossComponent_OnHealthChanged Parms{};

	Parms.HealthChange = HealthChange;
	Parms.InInstigator = InInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnMeleeActionEnd.OnMeleeActionEnd
// (Final, Native, Protected)
// Parameters:
// EMeleeAction                            ActionEnded                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnMeleeActionEnd::OnMeleeActionEnd(EMeleeAction ActionEnded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnMeleeActionEnd", "OnMeleeActionEnd");

	Params::OnMeleeActionEnd_OnMeleeActionEnd Parms{};

	Parms.ActionEnded = ActionEnded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnBlockEnd.OnBlockEnd
// (Final, Native, Protected)

void UOnBlockEnd::OnBlockEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnBlockEnd", "OnBlockEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnIndividualDetected.OnIndividualDetectedEvent
// (Final, Native, Protected)
// Parameters:
// class AIndianaAiCharacter*              Detector                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnIndividualDetected::OnIndividualDetectedEvent(class AIndianaAiCharacter* Detector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnIndividualDetected", "OnIndividualDetectedEvent");

	Params::OnIndividualDetected_OnIndividualDetectedEvent Parms{};

	Parms.Detector = Detector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnIndividualDetected.OnIndividualUnDetectedEvent
// (Final, Native, Protected)
// Parameters:
// class AIndianaAiCharacter*              Detector                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnIndividualDetected::OnIndividualUnDetectedEvent(class AIndianaAiCharacter* Detector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnIndividualDetected", "OnIndividualUnDetectedEvent");

	Params::OnIndividualDetected_OnIndividualUnDetectedEvent Parms{};

	Parms.Detector = Detector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.GetIndianaPlayerController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AIndianaPlayerController*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AIndianaPlayerController* AIndianaPlayerController::GetIndianaPlayerController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaPlayerController", "GetIndianaPlayerController");

	Params::IndianaPlayerController_GetIndianaPlayerController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaPlayerController.AddStickPitchInput
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerController::AddStickPitchInput(float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "AddStickPitchInput");

	Params::IndianaPlayerController_AddStickPitchInput Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.AddStickRollInput
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerController::AddStickRollInput(float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "AddStickRollInput");

	Params::IndianaPlayerController_AddStickRollInput Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.AddStickYawInput
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerController::AddStickYawInput(float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "AddStickYawInput");

	Params::IndianaPlayerController_AddStickYawInput Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.AsyncSpawnCompanion
// (Final, Exec, Native, Public)
// Parameters:
// ESpecialObsidianID                      CompanionID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AIndianaAiCharacter*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AIndianaAiCharacter* AIndianaPlayerController::AsyncSpawnCompanion(ESpecialObsidianID CompanionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "AsyncSpawnCompanion");

	Params::IndianaPlayerController_AsyncSpawnCompanion Parms{};

	Parms.CompanionID = CompanionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaPlayerController.CloseLedger
// (Final, Native, Public)

void AIndianaPlayerController::CloseLedger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "CloseLedger");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.DebugDutchAngleAdjustment
// (Final, Native, Public)
// Parameters:
// float                                   Axis                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerController::DebugDutchAngleAdjustment(float Axis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "DebugDutchAngleAdjustment");

	Params::IndianaPlayerController_DebugDutchAngleAdjustment Parms{};

	Parms.Axis = Axis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.DebugDynamicallyReplaceCompanion
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             OldCompanionName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NewCompanionName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerController::DebugDynamicallyReplaceCompanion(class FName OldCompanionName, class FName NewCompanionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "DebugDynamicallyReplaceCompanion");

	Params::IndianaPlayerController_DebugDynamicallyReplaceCompanion Parms{};

	Parms.OldCompanionName = OldCompanionName;
	Parms.NewCompanionName = NewCompanionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.DebugRevertDutchAngle
// (Final, Native, Public)
// Parameters:
// float                                   Axis                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerController::DebugRevertDutchAngle(float Axis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "DebugRevertDutchAngle");

	Params::IndianaPlayerController_DebugRevertDutchAngle Parms{};

	Parms.Axis = Axis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.DebugSpawnAICharacter
// (Final, Exec, Native, Protected)
// Parameters:
// class FName                             AICharacterAssetName                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AIndianaAiCharacter*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AIndianaAiCharacter* AIndianaPlayerController::DebugSpawnAICharacter(class FName AICharacterAssetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "DebugSpawnAICharacter");

	Params::IndianaPlayerController_DebugSpawnAICharacter Parms{};

	Parms.AICharacterAssetName = AICharacterAssetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaPlayerController.DebugSpawnCompanion
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             CompanionName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerController::DebugSpawnCompanion(class FName CompanionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "DebugSpawnCompanion");

	Params::IndianaPlayerController_DebugSpawnCompanion Parms{};

	Parms.CompanionName = CompanionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.InputAxis
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumSamples                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGamepad                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AIndianaPlayerController::InputAxis(const struct FKey& Key, float Delta, float DeltaTime, int32 NumSamples, bool bGamepad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "InputAxis");

	Params::IndianaPlayerController_InputAxis Parms{};

	Parms.Key = std::move(Key);
	Parms.Delta = Delta;
	Parms.DeltaTime = DeltaTime;
	Parms.NumSamples = NumSamples;
	Parms.bGamepad = bGamepad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaPlayerController.InputKey
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputEvent                             EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AmountDepressed                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGamepad                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AIndianaPlayerController::InputKey(const struct FKey& Key, EInputEvent EventType, float AmountDepressed, bool bGamepad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "InputKey");

	Params::IndianaPlayerController_InputKey Parms{};

	Parms.Key = std::move(Key);
	Parms.EventType = EventType;
	Parms.AmountDepressed = AmountDepressed;
	Parms.bGamepad = bGamepad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaPlayerController.OnActionMappingAdded
// (Final, Native, Public)
// Parameters:
// struct FInputActionKeyMapping           Value                                                  (Parm, NativeAccessSpecifierPublic)

void AIndianaPlayerController::OnActionMappingAdded(const struct FInputActionKeyMapping& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "OnActionMappingAdded");

	Params::IndianaPlayerController_OnActionMappingAdded Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.OnActionMappingRemoved
// (Final, Native, Public)
// Parameters:
// struct FInputActionKeyMapping           Value                                                  (Parm, NativeAccessSpecifierPublic)

void AIndianaPlayerController::OnActionMappingRemoved(const struct FInputActionKeyMapping& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "OnActionMappingRemoved");

	Params::IndianaPlayerController_OnActionMappingRemoved Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.OnAxisMappingAdded
// (Final, Native, Public)
// Parameters:
// struct FInputAxisKeyMapping             Value                                                  (Parm, NativeAccessSpecifierPublic)

void AIndianaPlayerController::OnAxisMappingAdded(const struct FInputAxisKeyMapping& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "OnAxisMappingAdded");

	Params::IndianaPlayerController_OnAxisMappingAdded Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.OnAxisMappingRemoved
// (Final, Native, Public)
// Parameters:
// struct FInputAxisKeyMapping             Value                                                  (Parm, NativeAccessSpecifierPublic)

void AIndianaPlayerController::OnAxisMappingRemoved(const struct FInputAxisKeyMapping& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "OnAxisMappingRemoved");

	Params::IndianaPlayerController_OnAxisMappingRemoved Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.OnKeyBindsReset
// (Final, Native, Public)

void AIndianaPlayerController::OnKeyBindsReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "OnKeyBindsReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.OnRestoredStateOfBeing
// (Final, Native, Public)
// Parameters:
// EStateOfBeing                           RestoredStateOfBeing                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerController::OnRestoredStateOfBeing(EStateOfBeing RestoredStateOfBeing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "OnRestoredStateOfBeing");

	Params::IndianaPlayerController_OnRestoredStateOfBeing Parms{};

	Parms.RestoredStateOfBeing = RestoredStateOfBeing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.OpenCharacterSummary
// (Final, Native, Public)

void AIndianaPlayerController::OpenCharacterSummary()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "OpenCharacterSummary");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.OpenCompanions
// (Final, Native, Public)

void AIndianaPlayerController::OpenCompanions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "OpenCompanions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.OpenInventory
// (Final, Native, Public)

void AIndianaPlayerController::OpenInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "OpenInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.OpenLedger
// (Final, Native, Public)

void AIndianaPlayerController::OpenLedger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "OpenLedger");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.OpenMap
// (Final, Native, Public)

void AIndianaPlayerController::OpenMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "OpenMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.OpenQuestLog
// (Final, Native, Public)

void AIndianaPlayerController::OpenQuestLog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "OpenQuestLog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.PinGlobalVariable
// (Final, Exec, Native, Protected)
// Parameters:
// class FString                           GlobalVariable                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerController::PinGlobalVariable(const class FString& GlobalVariable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "PinGlobalVariable");

	Params::IndianaPlayerController_PinGlobalVariable Parms{};

	Parms.GlobalVariable = std::move(GlobalVariable);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.PlayChatterOnTarget
// (Final, Exec, Native, Protected)
// Parameters:
// EChatterEventType                       ChatterEvent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerController::PlayChatterOnTarget(EChatterEventType ChatterEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "PlayChatterOnTarget");

	Params::IndianaPlayerController_PlayChatterOnTarget Parms{};

	Parms.ChatterEvent = ChatterEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.SetAutoSprintEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerController::SetAutoSprintEnabled(bool bIsEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "SetAutoSprintEnabled");

	Params::IndianaPlayerController_SetAutoSprintEnabled Parms{};

	Parms.bIsEnabled = bIsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.SetControllerEnableImpulseTriggers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerController::SetControllerEnableImpulseTriggers(bool bIsEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "SetControllerEnableImpulseTriggers");

	Params::IndianaPlayerController_SetControllerEnableImpulseTriggers Parms{};

	Parms.bIsEnabled = bIsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.SetControllerXAxisInverted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsInverted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerController::SetControllerXAxisInverted(bool bIsInverted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "SetControllerXAxisInverted");

	Params::IndianaPlayerController_SetControllerXAxisInverted Parms{};

	Parms.bIsInverted = bIsInverted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.SetControllerYAxisInverted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsInverted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerController::SetControllerYAxisInverted(bool bIsInverted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "SetControllerYAxisInverted");

	Params::IndianaPlayerController_SetControllerYAxisInverted Parms{};

	Parms.bIsInverted = bIsInverted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.SetGlobalVariable
// (Final, Exec, Native, Protected)
// Parameters:
// class FString                           GlobalVariable                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerController::SetGlobalVariable(const class FString& GlobalVariable, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "SetGlobalVariable");

	Params::IndianaPlayerController_SetGlobalVariable Parms{};

	Parms.GlobalVariable = std::move(GlobalVariable);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.SetImpulseTriggerIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerController::SetImpulseTriggerIntensity(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "SetImpulseTriggerIntensity");

	Params::IndianaPlayerController_SetImpulseTriggerIntensity Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.SetMouseADSSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerController::SetMouseADSSensitivity(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "SetMouseADSSensitivity");

	Params::IndianaPlayerController_SetMouseADSSensitivity Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.SetMouseSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerController::SetMouseSensitivity(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "SetMouseSensitivity");

	Params::IndianaPlayerController_SetMouseSensitivity Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.SetXAxisInverted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsInverted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerController::SetXAxisInverted(bool bIsInverted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "SetXAxisInverted");

	Params::IndianaPlayerController_SetXAxisInverted Parms{};

	Parms.bIsInverted = bIsInverted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.SetYAxisInverted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsInverted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerController::SetYAxisInverted(bool bIsInverted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "SetYAxisInverted");

	Params::IndianaPlayerController_SetYAxisInverted Parms{};

	Parms.bIsInverted = bIsInverted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.ToggleCharacterSummary
// (Final, Native, Public)

void AIndianaPlayerController::ToggleCharacterSummary()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "ToggleCharacterSummary");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.ToggleCompanions
// (Final, Native, Public)

void AIndianaPlayerController::ToggleCompanions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "ToggleCompanions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.ToggleCompanionsSecondScreen
// (Final, Native, Public)

void AIndianaPlayerController::ToggleCompanionsSecondScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "ToggleCompanionsSecondScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.ToggleInventory
// (Final, Native, Public)

void AIndianaPlayerController::ToggleInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "ToggleInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.ToggleLedger
// (Final, Native, Public)

void AIndianaPlayerController::ToggleLedger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "ToggleLedger");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.ToggleMap
// (Final, Native, Public)

void AIndianaPlayerController::ToggleMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "ToggleMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.TogglePauseMenu
// (Final, Native, Public, BlueprintCallable)

void AIndianaPlayerController::TogglePauseMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "TogglePauseMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.ToggleQuestLog
// (Final, Native, Public)

void AIndianaPlayerController::ToggleQuestLog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "ToggleQuestLog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.UnpinGlobalVariable
// (Final, Exec, Native, Protected)
// Parameters:
// class FString                           GlobalVariable                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerController::UnpinGlobalVariable(const class FString& GlobalVariable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "UnpinGlobalVariable");

	Params::IndianaPlayerController_UnpinGlobalVariable Parms{};

	Parms.GlobalVariable = std::move(GlobalVariable);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerController.GetInteractHoldTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AIndianaPlayerController::GetInteractHoldTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "GetInteractHoldTime");

	Params::IndianaPlayerController_GetInteractHoldTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaPlayerController.GetMouseADSSensitivity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AIndianaPlayerController::GetMouseADSSensitivity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "GetMouseADSSensitivity");

	Params::IndianaPlayerController_GetMouseADSSensitivity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaPlayerController.GetMouseSensitivity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AIndianaPlayerController::GetMouseSensitivity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "GetMouseSensitivity");

	Params::IndianaPlayerController_GetMouseSensitivity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaPlayerController.IsXAxisInverted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AIndianaPlayerController::IsXAxisInverted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "IsXAxisInverted");

	Params::IndianaPlayerController_IsXAxisInverted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaPlayerController.IsYAxisInverted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AIndianaPlayerController::IsYAxisInverted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerController", "IsYAxisInverted");

	Params::IndianaPlayerController_IsYAxisInverted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OnStatusEffectAddedEvent.OnAddStatusEffect
// (Final, Native, Protected)
// Parameters:
// class UStatusEffectManagerComponent*    Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffect*                    StatusEffectAdded                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnStatusEffectAddedEvent::OnAddStatusEffect(class UStatusEffectManagerComponent* Sender, class UStatusEffect* StatusEffectAdded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnStatusEffectAddedEvent", "OnAddStatusEffect");

	Params::OnStatusEffectAddedEvent_OnAddStatusEffect Parms{};

	Parms.Sender = Sender;
	Parms.StatusEffectAdded = StatusEffectAdded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AnimNotifyState_Prop.OnMontageEnded
// (Final, Native, Protected, Const)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimNotifyState_Prop::OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted, class USkeletalMeshComponent* MeshComp) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimNotifyState_Prop", "OnMontageEnded");

	Params::AnimNotifyState_Prop_OnMontageEnded Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;
	Parms.MeshComp = MeshComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAudioComponent.OnCharacterMovementUpdated
// (Final, Native, Protected, HasDefaults)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OldLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OldVelocity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaAudioComponent::OnCharacterMovementUpdated(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAudioComponent", "OnCharacterMovementUpdated");

	Params::IndianaAudioComponent_OnCharacterMovementUpdated Parms{};

	Parms.DeltaSeconds = DeltaSeconds;
	Parms.OldLocation = std::move(OldLocation);
	Parms.OldVelocity = std::move(OldVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAudioComponent.OnDodge
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// EDodgeDirection                         Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhysicalSurface                        PhysMaterial                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaAudioComponent::OnDodge(EDodgeDirection Direction, const struct FVector& Position, const struct FVector& Normal, EPhysicalSurface PhysMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAudioComponent", "OnDodge");

	Params::IndianaAudioComponent_OnDodge Parms{};

	Parms.Direction = Direction;
	Parms.Position = std::move(Position);
	Parms.Normal = std::move(Normal);
	Parms.PhysMaterial = PhysMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAudioComponent.OnFootstep
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// EFootID                                 FootID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFootstepType                           FootstepType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhysicalSurface                        PhysMaterial                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaAudioComponent::OnFootstep(EFootID FootID, EFootstepType FootstepType, const struct FVector& Position, const struct FVector& Normal, EPhysicalSurface PhysMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAudioComponent", "OnFootstep");

	Params::IndianaAudioComponent_OnFootstep Parms{};

	Parms.FootID = FootID;
	Parms.FootstepType = FootstepType;
	Parms.Position = std::move(Position);
	Parms.Normal = std::move(Normal);
	Parms.PhysMaterial = PhysMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAudioComponent.OnLanded
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// float                                   FallDistance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhysicalSurface                        PhysMaterial                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaAudioComponent::OnLanded(float FallDistance, const struct FVector& Position, const struct FVector& Normal, EPhysicalSurface PhysMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAudioComponent", "OnLanded");

	Params::IndianaAudioComponent_OnLanded Parms{};

	Parms.FallDistance = FallDistance;
	Parms.Position = std::move(Position);
	Parms.Normal = std::move(Normal);
	Parms.PhysMaterial = PhysMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAudioComponent.OnNewFootstepData
// (Final, Native, Protected)
// Parameters:
// class UFootstepData*                    NewData                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaAudioComponent::OnNewFootstepData(const class UFootstepData* NewData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAudioComponent", "OnNewFootstepData");

	Params::IndianaAudioComponent_OnNewFootstepData Parms{};

	Parms.NewData = NewData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAudioComponent.OnNewStateOfBeing
// (Final, Native, Protected)
// Parameters:
// EStateOfBeing                           NewStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStateOfBeing                           OldStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaAudioComponent::OnNewStateOfBeing(EStateOfBeing NewStateOfBeing, EStateOfBeing OldStateOfBeing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAudioComponent", "OnNewStateOfBeing");

	Params::IndianaAudioComponent_OnNewStateOfBeing Parms{};

	Parms.NewStateOfBeing = NewStateOfBeing;
	Parms.OldStateOfBeing = OldStateOfBeing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAudioComponent.OnSpecialMovementEvent
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// ESpecialMovementEvent                   SpecialEvent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhysicalSurface                        PhysMaterial                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaAudioComponent::OnSpecialMovementEvent(ESpecialMovementEvent SpecialEvent, const struct FVector& Position, const struct FVector& Normal, EPhysicalSurface PhysMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAudioComponent", "OnSpecialMovementEvent");

	Params::IndianaAudioComponent_OnSpecialMovementEvent Parms{};

	Parms.SpecialEvent = SpecialEvent;
	Parms.Position = std::move(Position);
	Parms.Normal = std::move(Normal);
	Parms.PhysMaterial = PhysMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAudioComponent.OnStartClimb
// (Final, Native, Protected)

void UIndianaAudioComponent::OnStartClimb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAudioComponent", "OnStartClimb");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAudioComponent.OnStopClimb
// (Final, Native, Protected)

void UIndianaAudioComponent::OnStopClimb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAudioComponent", "OnStopClimb");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerAudioComponent.GamePauseChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bPaused                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaPlayerAudioComponent::GamePauseChanged(bool bPaused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerAudioComponent", "GamePauseChanged");

	Params::IndianaPlayerAudioComponent_GamePauseChanged Parms{};

	Parms.bPaused = bPaused;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerAudioComponent.OnCalledShotCameraStep
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECalledShotCameraStep                   OldCameraStep                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECalledShotCameraStep                   NewCameraStep                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCloseRange                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaPlayerAudioComponent::OnCalledShotCameraStep(class AActor* Attacker, ECalledShotCameraStep OldCameraStep, ECalledShotCameraStep NewCameraStep, bool bCloseRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerAudioComponent", "OnCalledShotCameraStep");

	Params::IndianaPlayerAudioComponent_OnCalledShotCameraStep Parms{};

	Parms.Attacker = Attacker;
	Parms.OldCameraStep = OldCameraStep;
	Parms.NewCameraStep = NewCameraStep;
	Parms.bCloseRange = bCloseRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerAudioComponent.OnCombatStateChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bInCombat                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaPlayerAudioComponent::OnCombatStateChanged(bool bInCombat, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerAudioComponent", "OnCombatStateChanged");

	Params::IndianaPlayerAudioComponent_OnCombatStateChanged Parms{};

	Parms.bInCombat = bInCombat;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerAudioComponent.OnCompanionCommandCooldownEnd
// (Final, Native, Protected)
// Parameters:
// ECompanionCommand                       Command                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaPlayerAudioComponent::OnCompanionCommandCooldownEnd(ECompanionCommand Command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerAudioComponent", "OnCompanionCommandCooldownEnd");

	Params::IndianaPlayerAudioComponent_OnCompanionCommandCooldownEnd Parms{};

	Parms.Command = Command;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerAudioComponent.OnDetectionChange
// (Final, Native, Protected)
// Parameters:
// EDetectionType                          DetectionType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaPlayerAudioComponent::OnDetectionChange(EDetectionType DetectionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerAudioComponent", "OnDetectionChange");

	Params::IndianaPlayerAudioComponent_OnDetectionChange Parms{};

	Parms.DetectionType = DetectionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerAudioComponent.OnDisguiseDrainEnd
// (Final, Native, Protected)

void UIndianaPlayerAudioComponent::OnDisguiseDrainEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerAudioComponent", "OnDisguiseDrainEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerAudioComponent.OnDisguiseDrainStart
// (Final, Native, Protected)

void UIndianaPlayerAudioComponent::OnDisguiseDrainStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerAudioComponent", "OnDisguiseDrainStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerAudioComponent.OnDisguiseEquipped
// (Final, Native, Protected)
// Parameters:
// class UDisguiseData*                    Disguise                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaPlayerAudioComponent::OnDisguiseEquipped(const class UDisguiseData* Disguise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerAudioComponent", "OnDisguiseEquipped");

	Params::IndianaPlayerAudioComponent_OnDisguiseEquipped Parms{};

	Parms.Disguise = Disguise;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerAudioComponent.OnDisguiseMeterChanged
// (Final, Native, Protected)
// Parameters:
// float                                   Meter                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaPlayerAudioComponent::OnDisguiseMeterChanged(float Meter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerAudioComponent", "OnDisguiseMeterChanged");

	Params::IndianaPlayerAudioComponent_OnDisguiseMeterChanged Parms{};

	Parms.Meter = Meter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerAudioComponent.OnDisguiseRefilled
// (Final, Native, Protected)

void UIndianaPlayerAudioComponent::OnDisguiseRefilled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerAudioComponent", "OnDisguiseRefilled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerAudioComponent.OnDisguiseUnequipped
// (Final, Native, Protected)

void UIndianaPlayerAudioComponent::OnDisguiseUnequipped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerAudioComponent", "OnDisguiseUnequipped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerAudioComponent.OnKillCameraEnd
// (Final, Native, Protected)

void UIndianaPlayerAudioComponent::OnKillCameraEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerAudioComponent", "OnKillCameraEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerAudioComponent.OnKillCameraStart
// (Final, Native, Protected)
// Parameters:
// class AActor*                           CameraTarget                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaPlayerAudioComponent::OnKillCameraStart(const class AActor* CameraTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerAudioComponent", "OnKillCameraStart");

	Params::IndianaPlayerAudioComponent_OnKillCameraStart Parms{};

	Parms.CameraTarget = CameraTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerAudioComponent.OnStealthChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bStealthed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaPlayerAudioComponent::OnStealthChange(bool bStealthed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerAudioComponent", "OnStealthChange");

	Params::IndianaPlayerAudioComponent_OnStealthChange Parms{};

	Parms.bStealthed = bStealthed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerAudioComponent.TacticalTimeDilationEnd
// (Final, Native, Protected)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaPlayerAudioComponent::TacticalTimeDilationEnd(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerAudioComponent", "TacticalTimeDilationEnd");

	Params::IndianaPlayerAudioComponent_TacticalTimeDilationEnd Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerAudioComponent.TacticalTimeDilationStart
// (Final, Native, Protected)

void UIndianaPlayerAudioComponent::TacticalTimeDilationStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerAudioComponent", "TacticalTimeDilationStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AppearanceComponent.ApplyAppearancePreset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAppearancePreset*                Preset                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppearanceComponent::ApplyAppearancePreset(const class UAppearancePreset* Preset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "ApplyAppearancePreset");

	Params::AppearanceComponent_ApplyAppearancePreset Parms{};

	Parms.Preset = Preset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AppearanceComponent.DebugTargetVertexColors
// (Final, Exec, Native, Protected)

void UAppearanceComponent::DebugTargetVertexColors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "DebugTargetVertexColors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AppearanceComponent.RefreshFullAppearance
// (Final, Native, Public, BlueprintCallable)

void UAppearanceComponent::RefreshFullAppearance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "RefreshFullAppearance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AppearanceComponent.RemoveBoneModification
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UBoneModifications*               Modifications                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppearanceComponent::RemoveBoneModification(const class UBoneModifications* Modifications)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "RemoveBoneModification");

	Params::AppearanceComponent_RemoveBoneModification Parms{};

	Parms.Modifications = Modifications;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AppearanceComponent.SetAge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewAge                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppearanceComponent::SetAge(float NewAge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "SetAge");

	Params::AppearanceComponent_SetAge Parms{};

	Parms.NewAge = NewAge;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AppearanceComponent.SetBeard
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UBeardAppearances*                NewBeard                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppearanceComponent::SetBeard(const class UBeardAppearances* NewBeard)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "SetBeard");

	Params::AppearanceComponent_SetBeard Parms{};

	Parms.NewBeard = NewBeard;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AppearanceComponent.SetBeardColor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UBeardColor*                      NewColor                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppearanceComponent::SetBeardColor(const class UBeardColor* NewColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "SetBeardColor");

	Params::AppearanceComponent_SetBeardColor Parms{};

	Parms.NewColor = NewColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AppearanceComponent.SetBoneModification
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UBoneModifications*               Modifications                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppearanceComponent::SetBoneModification(const class UBoneModifications* Modifications, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "SetBoneModification");

	Params::AppearanceComponent_SetBoneModification Parms{};

	Parms.Modifications = Modifications;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AppearanceComponent.SetBoneModificationPresets
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UBoneModificationsPreset*         Presets                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppearanceComponent::SetBoneModificationPresets(const class UBoneModificationsPreset* Presets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "SetBoneModificationPresets");

	Params::AppearanceComponent_SetBoneModificationPresets Parms{};

	Parms.Presets = Presets;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AppearanceComponent.SetBrows
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UBrows*                           NewBrows                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppearanceComponent::SetBrows(const class UBrows* NewBrows)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "SetBrows");

	Params::AppearanceComponent_SetBrows Parms{};

	Parms.NewBrows = NewBrows;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AppearanceComponent.SetDefaultBody
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UBodyAppearances*                 Body                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppearanceComponent::SetDefaultBody(const class UBodyAppearances* Body)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "SetDefaultBody");

	Params::AppearanceComponent_SetDefaultBody Parms{};

	Parms.Body = Body;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AppearanceComponent.SetDefaultHead
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UHeadAppearances*                 Head                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppearanceComponent::SetDefaultHead(const class UHeadAppearances* Head)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "SetDefaultHead");

	Params::AppearanceComponent_SetDefaultHead Parms{};

	Parms.Head = Head;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AppearanceComponent.SetDirt
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDirt*                            NewDirt                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppearanceComponent::SetDirt(const class UDirt* NewDirt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "SetDirt");

	Params::AppearanceComponent_SetDirt Parms{};

	Parms.NewDirt = NewDirt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AppearanceComponent.SetEyeColor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEyeColor*                        NewColor                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppearanceComponent::SetEyeColor(const class UEyeColor* NewColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "SetEyeColor");

	Params::AppearanceComponent_SetEyeColor Parms{};

	Parms.NewColor = NewColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AppearanceComponent.SetGender
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Gender                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppearanceComponent::SetGender(const struct FGameplayTag& Gender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "SetGender");

	Params::AppearanceComponent_SetGender Parms{};

	Parms.Gender = std::move(Gender);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AppearanceComponent.SetHair
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UHairAppearances*                 NewHair                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppearanceComponent::SetHair(const class UHairAppearances* NewHair)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "SetHair");

	Params::AppearanceComponent_SetHair Parms{};

	Parms.NewHair = NewHair;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AppearanceComponent.SetHairColor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UHairColor*                       NewColor                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppearanceComponent::SetHairColor(const class UHairColor* NewColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "SetHairColor");

	Params::AppearanceComponent_SetHairColor Parms{};

	Parms.NewColor = NewColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AppearanceComponent.SetMakeup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMakeup*                          NewMakeup                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppearanceComponent::SetMakeup(const class UMakeup* NewMakeup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "SetMakeup");

	Params::AppearanceComponent_SetMakeup Parms{};

	Parms.NewMakeup = NewMakeup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AppearanceComponent.SetScalarParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Parameter                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scalar                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppearanceComponent::SetScalarParameter(class FName Parameter, float Scalar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "SetScalarParameter");

	Params::AppearanceComponent_SetScalarParameter Parms{};

	Parms.Parameter = Parameter;
	Parms.Scalar = Scalar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AppearanceComponent.SetScar
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UScar*                            NewScar                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppearanceComponent::SetScar(const class UScar* NewScar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "SetScar");

	Params::AppearanceComponent_SetScar Parms{};

	Parms.NewScar = NewScar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AppearanceComponent.SetSkinTone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkinTone*                        NewSkinTone                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppearanceComponent::SetSkinTone(const class USkinTone* NewSkinTone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "SetSkinTone");

	Params::AppearanceComponent_SetSkinTone Parms{};

	Parms.NewSkinTone = NewSkinTone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AppearanceComponent.SetSlotScalarParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SlotName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Parameter                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scalar                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppearanceComponent::SetSlotScalarParameter(class FName SlotName, class FName Parameter, float Scalar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "SetSlotScalarParameter");

	Params::AppearanceComponent_SetSlotScalarParameter Parms{};

	Parms.SlotName = SlotName;
	Parms.Parameter = Parameter;
	Parms.Scalar = Scalar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AppearanceComponent.SetSlotTextureParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SlotName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Parameter                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                         Texture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppearanceComponent::SetSlotTextureParameter(class FName SlotName, class FName Parameter, class UTexture* Texture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "SetSlotTextureParameter");

	Params::AppearanceComponent_SetSlotTextureParameter Parms{};

	Parms.SlotName = SlotName;
	Parms.Parameter = Parameter;
	Parms.Texture = Texture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AppearanceComponent.SetSlotVectorParameter
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             SlotName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Parameter                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Vector                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppearanceComponent::SetSlotVectorParameter(class FName SlotName, class FName Parameter, const struct FVector& Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "SetSlotVectorParameter");

	Params::AppearanceComponent_SetSlotVectorParameter Parms{};

	Parms.SlotName = SlotName;
	Parms.Parameter = Parameter;
	Parms.Vector = std::move(Vector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AppearanceComponent.SetVectorParameter
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             Parameter                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Vector                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppearanceComponent::SetVectorParameter(class FName Parameter, const struct FVector& Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "SetVectorParameter");

	Params::AppearanceComponent_SetVectorParameter Parms{};

	Parms.Parameter = Parameter;
	Parms.Vector = std::move(Vector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AppearanceComponent.GetBodyPart
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UAppearanceComponent::GetBodyPart(const class FName& BoneName, const struct FVector& ImpactLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "GetBodyPart");

	Params::AppearanceComponent_GetBodyPart Parms{};

	Parms.BoneName = BoneName;
	Parms.ImpactLocation = std::move(ImpactLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.AppearanceComponent.GetBodyPartsArray
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FBodyPart>          ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FBodyPart> UAppearanceComponent::GetBodyPartsArray() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "GetBodyPartsArray");

	Params::AppearanceComponent_GetBodyPartsArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.AppearanceComponent.GetBodyPartTags
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TSet<struct FGameplayTag>         ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TSet<struct FGameplayTag> UAppearanceComponent::GetBodyPartTags() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "GetBodyPartTags");

	Params::AppearanceComponent_GetBodyPartTags Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.AppearanceComponent.GetBreakableBoneNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TSet<class FName>                 ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TSet<class FName> UAppearanceComponent::GetBreakableBoneNames() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "GetBreakableBoneNames");

	Params::AppearanceComponent_GetBreakableBoneNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.AppearanceComponent.GetBreakBoneAndSocketNames
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     BodyPartTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachedSocket                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DetachedSocket                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppearanceComponent::GetBreakBoneAndSocketNames(const struct FGameplayTag& BodyPartTag, class FName* BoneName, class FName* AttachedSocket, class FName* DetachedSocket) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "GetBreakBoneAndSocketNames");

	Params::AppearanceComponent_GetBreakBoneAndSocketNames Parms{};

	Parms.BodyPartTag = std::move(BodyPartTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (BoneName != nullptr)
		*BoneName = Parms.BoneName;

	if (AttachedSocket != nullptr)
		*AttachedSocket = Parms.AttachedSocket;

	if (DetachedSocket != nullptr)
		*DetachedSocket = Parms.DetachedSocket;

	return Parms.ReturnValue;
}


// Function Indiana.AppearanceComponent.GetBreakBoneName
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     BodyPartTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppearanceComponent::GetBreakBoneName(const struct FGameplayTag& BodyPartTag, class FName* BoneName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "GetBreakBoneName");

	Params::AppearanceComponent_GetBreakBoneName Parms{};

	Parms.BodyPartTag = std::move(BodyPartTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (BoneName != nullptr)
		*BoneName = Parms.BoneName;

	return Parms.ReturnValue;
}


// Function Indiana.AppearanceComponent.InvalidateOldBoneModifications
// (Final, Native, Public, BlueprintCallable, Const)

void UAppearanceComponent::InvalidateOldBoneModifications() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceComponent", "InvalidateOldBoneModifications");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MapTransitionNotification.OnAreaNameModeChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapTransitionNotification::OnAreaNameModeChanged(int32 ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapTransitionNotification", "OnAreaNameModeChanged");

	Params::MapTransitionNotification_OnAreaNameModeChanged Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MapTransitionNotification.OnHUDVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapTransitionNotification::OnHUDVisibilityChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapTransitionNotification", "OnHUDVisibilityChanged");

	Params::MapTransitionNotification_OnHUDVisibilityChanged Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MapTransitionNotification.StartAnimation
// (Event, Protected, BlueprintEvent)

void UMapTransitionNotification::StartAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapTransitionNotification", "StartAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.ArmorComponent.TinkerAdvanceArmor
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bIgnoreCost                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArmorComponent::TinkerAdvanceArmor(bool bIgnoreCost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmorComponent", "TinkerAdvanceArmor");

	Params::ArmorComponent_TinkerAdvanceArmor Parms{};

	Parms.bIgnoreCost = bIgnoreCost;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PerksTierWidget.GetColorType
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                                    bUnlocked                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EIndianaUIColorType                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EIndianaUIColorType UPerksTierWidget::GetColorType(bool bUnlocked) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerksTierWidget", "GetColorType");

	Params::PerksTierWidget_GetColorType Parms{};

	Parms.bUnlocked = bUnlocked;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.PerksTierWidget.GetImageOpacity
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                                    bUnlocked                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPerksTierWidget::GetImageOpacity(bool bUnlocked) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerksTierWidget", "GetImageOpacity");

	Params::PerksTierWidget_GetImageOpacity Parms{};

	Parms.bUnlocked = bUnlocked;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.PerksTierWidget.GetTextOpacity
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                                    bUnlocked                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPerksTierWidget::GetTextOpacity(bool bUnlocked) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerksTierWidget", "GetTextOpacity");

	Params::PerksTierWidget_GetTextOpacity Parms{};

	Parms.bUnlocked = bUnlocked;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.OnStatUpdated.OnStatUpdated
// (Final, Native, Protected)
// Parameters:
// class URpgStat*                         Stat                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnStatUpdated::OnStatUpdated(const class URpgStat* Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnStatUpdated", "OnStatUpdated");

	Params::OnStatUpdated_OnStatUpdated Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MeleeSlotManagerComponent.OnAttackerNumMeleeSlotsRequiredChanged
// (Final, Native, Public)
// Parameters:
// class AIndianaAiController*             AttackerController                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMeleeSlotManagerComponent::OnAttackerNumMeleeSlotsRequiredChanged(class AIndianaAiController* AttackerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeleeSlotManagerComponent", "OnAttackerNumMeleeSlotsRequiredChanged");

	Params::MeleeSlotManagerComponent_OnAttackerNumMeleeSlotsRequiredChanged Parms{};

	Parms.AttackerController = AttackerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MeleeMode.OnStatUpdated
// (Final, Native, Protected)
// Parameters:
// class URpgStat*                         Stat                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMeleeMode::OnStatUpdated(const class URpgStat* Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeleeMode", "OnStatUpdated");

	Params::MeleeMode_OnStatUpdated Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GenericCollapsableList.ExpandableAreaExpansionChanged
// (Final, Native, Protected)
// Parameters:
// class UExpandableAreaBase*              Area                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsExpanded                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGenericCollapsableList::ExpandableAreaExpansionChanged(class UExpandableAreaBase* Area, bool bIsExpanded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GenericCollapsableList", "ExpandableAreaExpansionChanged");

	Params::GenericCollapsableList_ExpandableAreaExpansionChanged Parms{};

	Parms.Area = Area;
	Parms.bIsExpanded = bIsExpanded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AudioLogList.AddNewAudioLog
// (Final, Native, Protected)
// Parameters:
// class UAudioLogDataAsset*               AudioLogDataAsset                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioLogList::AddNewAudioLog(class UAudioLogDataAsset* AudioLogDataAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioLogList", "AddNewAudioLog");

	Params::AudioLogList_AddNewAudioLog Parms{};

	Parms.AudioLogDataAsset = AudioLogDataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AudioLogList.AddOldAudioLog
// (Final, Native, Protected)
// Parameters:
// class UAudioLogDataAsset*               AudioLogDataAsset                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioLogList::AddOldAudioLog(class UAudioLogDataAsset* AudioLogDataAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioLogList", "AddOldAudioLog");

	Params::AudioLogList_AddOldAudioLog Parms{};

	Parms.AudioLogDataAsset = AudioLogDataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AudioLogList.OnAudioLogLibraryLoaded
// (Final, Native, Protected)
// Parameters:
// class UAudioLogLibraryDataAsset*        LoadedAudioLogLibrary                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioLogList::OnAudioLogLibraryLoaded(class UAudioLogLibraryDataAsset* LoadedAudioLogLibrary)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioLogList", "OnAudioLogLibraryLoaded");

	Params::AudioLogList_OnAudioLogLibraryLoaded Parms{};

	Parms.LoadedAudioLogLibrary = LoadedAudioLogLibrary;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AudioLogList.OnAudioLogSelectedCB
// (Final, Native, Protected)
// Parameters:
// class UGenericCollapsableListEntry*     ListEntry                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioLogList::OnAudioLogSelectedCB(class UGenericCollapsableListEntry* ListEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioLogList", "OnAudioLogSelectedCB");

	Params::AudioLogList_OnAudioLogSelectedCB Parms{};

	Parms.ListEntry = ListEntry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AudioLogList.OnAudioLogViewedCB
// (Final, Native, Protected)
// Parameters:
// class UGenericCollapsableListEntry*     ListEntry                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioLogList::OnAudioLogViewedCB(class UGenericCollapsableListEntry* ListEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioLogList", "OnAudioLogViewedCB");

	Params::AudioLogList_OnAudioLogViewedCB Parms{};

	Parms.ListEntry = ListEntry;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnLevelChangedListener.OnLevelChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnLevelChangedListener::OnLevelChanged(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnLevelChangedListener", "OnLevelChanged");

	Params::OnLevelChangedListener_OnLevelChanged Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AudioLogManager.OnAudioLogLibraryLoaded
// (Final, Native, Protected)
// Parameters:
// TSoftObjectPtr<class UAudioLogLibraryDataAsset>LibraryDataAsset                                       (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioLogManager::OnAudioLogLibraryLoaded(TSoftObjectPtr<class UAudioLogLibraryDataAsset> LibraryDataAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioLogManager", "OnAudioLogLibraryLoaded");

	Params::AudioLogManager_OnAudioLogLibraryLoaded Parms{};

	Parms.LibraryDataAsset = LibraryDataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AudioLogManager.OnCombatStateChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bInCombat                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioLogManager::OnCombatStateChanged(bool bInCombat, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioLogManager", "OnCombatStateChanged");

	Params::AudioLogManager_OnCombatStateChanged Parms{};

	Parms.bInCombat = bInCombat;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AudioLogManager.OnConversationEnded
// (Final, Native, Protected)
// Parameters:
// class UConversationInstance*            ConversationInstance                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioLogManager::OnConversationEnded(class UConversationInstance* ConversationInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioLogManager", "OnConversationEnded");

	Params::AudioLogManager_OnConversationEnded Parms{};

	Parms.ConversationInstance = ConversationInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AudioLogManager.OnLoadComplete
// (Final, Native, Protected)
// Parameters:
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELoadGameResult                         Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioLogManager::OnLoadComplete(const class FString& Filename, ELoadGameResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioLogManager", "OnLoadComplete");

	Params::AudioLogManager_OnLoadComplete Parms{};

	Parms.Filename = std::move(Filename);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AudioLogManager.OnPostMapLoad
// (Final, Native, Protected)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioLogManager::OnPostMapLoad(class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioLogManager", "OnPostMapLoad");

	Params::AudioLogManager_OnPostMapLoad Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AudioLogManager.OnPreMapLoad
// (Final, Native, Protected)
// Parameters:
// class FString                           MapName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioLogManager::OnPreMapLoad(const class FString& MapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioLogManager", "OnPreMapLoad");

	Params::AudioLogManager_OnPreMapLoad Parms{};

	Parms.MapName = std::move(MapName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AudioLogManager.PauseCurrentAudioLog
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bForce                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromStop                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioLogManager::PauseCurrentAudioLog(bool bForce, bool bFromStop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioLogManager", "PauseCurrentAudioLog");

	Params::AudioLogManager_PauseCurrentAudioLog Parms{};

	Parms.bForce = bForce;
	Parms.bFromStop = bFromStop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AudioLogManager.PlayAudioLog
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AudioLogIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioLogManager::PlayAudioLog(int32 AudioLogIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioLogManager", "PlayAudioLog");

	Params::AudioLogManager_PlayAudioLog Parms{};

	Parms.AudioLogIndex = AudioLogIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AudioLogManager.ResumeCurrentAudioLog
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bForce                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromPlay                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioLogManager::ResumeCurrentAudioLog(bool bForce, bool bFromPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioLogManager", "ResumeCurrentAudioLog");

	Params::AudioLogManager_ResumeCurrentAudioLog Parms{};

	Parms.bForce = bForce;
	Parms.bFromPlay = bFromPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AudioLogManager.StopCurrentAudioLog
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bForce                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioLogManager::StopCurrentAudioLog(bool bForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioLogManager", "StopCurrentAudioLog");

	Params::AudioLogManager_StopCurrentAudioLog Parms{};

	Parms.bForce = bForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AudioLogManager.CanPauseCurrentAudioLog
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bExclusive                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAudioLogManager::CanPauseCurrentAudioLog(bool bExclusive) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioLogManager", "CanPauseCurrentAudioLog");

	Params::AudioLogManager_CanPauseCurrentAudioLog Parms{};

	Parms.bExclusive = bExclusive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.AudioLogManager.CanResumeCurrentAudioLog
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bExclusive                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAudioLogManager::CanResumeCurrentAudioLog(bool bExclusive) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioLogManager", "CanResumeCurrentAudioLog");

	Params::AudioLogManager_CanResumeCurrentAudioLog Parms{};

	Parms.bExclusive = bExclusive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.AudioLogManager.CanStopCurrentAudioLog
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bExclusive                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAudioLogManager::CanStopCurrentAudioLog(bool bExclusive) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioLogManager", "CanStopCurrentAudioLog");

	Params::AudioLogManager_CanStopCurrentAudioLog Parms{};

	Parms.bExclusive = bExclusive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.AudioLogManager.GetCurrentAudioLogPlayState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAudioLogPlayState                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAudioLogPlayState UAudioLogManager::GetCurrentAudioLogPlayState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioLogManager", "GetCurrentAudioLogPlayState");

	Params::AudioLogManager_GetCurrentAudioLogPlayState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.AudioLogManager.IsPlayingAudioLog
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAudioLogManager::IsPlayingAudioLog() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioLogManager", "IsPlayingAudioLog");

	Params::AudioLogManager_IsPlayingAudioLog Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.MoviePlayerWidget.InitiateFadeIn
// (Event, Protected, BlueprintEvent)

void UMoviePlayerWidget::InitiateFadeIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoviePlayerWidget", "InitiateFadeIn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.MoviePlayerWidget.InitiateFadeOut
// (Event, Protected, BlueprintEvent)

void UMoviePlayerWidget::InitiateFadeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoviePlayerWidget", "InitiateFadeOut");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.MoviePlayerWidget.OnAttemptCancel
// (Final, Native, Public)

void UMoviePlayerWidget::OnAttemptCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoviePlayerWidget", "OnAttemptCancel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MoviePlayerWidget.OnMovieFinished
// (Final, Native, Protected)

void UMoviePlayerWidget::OnMovieFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoviePlayerWidget", "OnMovieFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MoviePlayerWidget.PauseMovie
// (Final, Native, Public, BlueprintCallable)

void UMoviePlayerWidget::PauseMovie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoviePlayerWidget", "PauseMovie");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MoviePlayerWidget.PlayMovie
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFileMediaSource*                 Movie                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoviePlayerWidget::PlayMovie(class UFileMediaSource* Movie)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoviePlayerWidget", "PlayMovie");

	Params::MoviePlayerWidget_PlayMovie Parms{};

	Parms.Movie = Movie;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MoviePlayerWidget.StopMovie
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bWasSkipped                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoviePlayerWidget::StopMovie(bool bWasSkipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoviePlayerWidget", "StopMovie");

	Params::MoviePlayerWidget_StopMovie Parms{};

	Parms.bWasSkipped = bWasSkipped;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AudioLogWidget.OnAudioLogPlayStateChanged
// (Final, Native, Protected)
// Parameters:
// EAudioLogPlayState                      NewPlayState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioLogWidget::OnAudioLogPlayStateChanged(EAudioLogPlayState NewPlayState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioLogWidget", "OnAudioLogPlayStateChanged");

	Params::AudioLogWidget_OnAudioLogPlayStateChanged Parms{};

	Parms.NewPlayState = NewPlayState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AudioLogWidget.OnHUDVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioLogWidget::OnHUDVisibilityChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioLogWidget", "OnHUDVisibilityChanged");

	Params::AudioLogWidget_OnHUDVisibilityChanged Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AudioLogWidget.ShowAudioLog
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurrentRenderOpacity                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioLogWidget::ShowAudioLog(bool bShow, float CurrentRenderOpacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioLogWidget", "ShowAudioLog");

	Params::AudioLogWidget_ShowAudioLog Parms{};

	Parms.bShow = bShow;
	Parms.CurrentRenderOpacity = CurrentRenderOpacity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.AudioLogWidget.TacticalTimeDilationEnd
// (Final, Native, Protected)
// Parameters:
// float                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioLogWidget::TacticalTimeDilationEnd(float Delta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioLogWidget", "TacticalTimeDilationEnd");

	Params::AudioLogWidget_TacticalTimeDilationEnd Parms{};

	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AudioLogWidget.TacticalTimeDilationStart
// (Final, Native, Protected)

void UAudioLogWidget::TacticalTimeDilationStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioLogWidget", "TacticalTimeDilationStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.AudioLogWidget.CanStopAudioLog
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAudioLogWidget::CanStopAudioLog() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioLogWidget", "CanStopAudioLog");

	Params::AudioLogWidget_CanStopAudioLog Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OnStopCrouch.OnStopCrouch
// (Final, Native, Protected)

void UOnStopCrouch::OnStopCrouch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnStopCrouch", "OnStopCrouch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.BackgroundPanelWidget.OnInnerTextureLoaded
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UTexture2D*                       Texture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackgroundPanelWidget::OnInnerTextureLoaded(class UTexture2D* Texture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BackgroundPanelWidget", "OnInnerTextureLoaded");

	Params::BackgroundPanelWidget_OnInnerTextureLoaded Parms{};

	Parms.Texture = Texture;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.BackgroundPanelWidget.OnOuterTextureLoaded
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UTexture2D*                       Texture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackgroundPanelWidget::OnOuterTextureLoaded(class UTexture2D* Texture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BackgroundPanelWidget", "OnOuterTextureLoaded");

	Params::BackgroundPanelWidget_OnOuterTextureLoaded Parms{};

	Parms.Texture = Texture;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.BackgroundPanelWidget.RegisterButtons
// (Final, Native, Public)
// Parameters:
// TArray<class UButtonBase*>              Buttons                                                (ConstParm, Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UBackgroundPanelWidget::RegisterButtons(const TArray<class UButtonBase*>& Buttons)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BackgroundPanelWidget", "RegisterButtons");

	Params::BackgroundPanelWidget_RegisterButtons Parms{};

	Parms.Buttons = std::move(Buttons);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.BackgroundPanelWidget.SetBackgroundFocused
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bFocused                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackgroundPanelWidget::SetBackgroundFocused(bool bFocused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BackgroundPanelWidget", "SetBackgroundFocused");

	Params::BackgroundPanelWidget_SetBackgroundFocused Parms{};

	Parms.bFocused = bFocused;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.PointOfInterest.OnBeginOverlap
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APointOfInterest::OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PointOfInterest", "OnBeginOverlap");

	Params::PointOfInterest_OnBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerStatsWidget.OnItemEquipped
// (Final, Native, Protected)
// Parameters:
// class UItem*                            ItemEquipped                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerStatsWidget::OnItemEquipped(class UItem* ItemEquipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatsWidget", "OnItemEquipped");

	Params::PlayerStatsWidget_OnItemEquipped Parms{};

	Parms.ItemEquipped = ItemEquipped;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerStatsWidget.OnItemPartsChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   WeaponParts                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ArmorParts                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerStatsWidget::OnItemPartsChanged(int32 WeaponParts, int32 ArmorParts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatsWidget", "OnItemPartsChanged");

	Params::PlayerStatsWidget_OnItemPartsChanged Parms{};

	Parms.WeaponParts = WeaponParts;
	Parms.ArmorParts = ArmorParts;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerStatsWidget.OnLevelChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   NewLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerStatsWidget::OnLevelChanged(int32 NewLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatsWidget", "OnLevelChanged");

	Params::PlayerStatsWidget_OnLevelChanged Parms{};

	Parms.NewLevel = NewLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerStatsWidget.OnPlayerWeightChange
// (Final, Native, Protected)

void UPlayerStatsWidget::OnPlayerWeightChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatsWidget", "OnPlayerWeightChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerStatsWidget.SetXPRatio
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   XPRatio                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerStatsWidget::SetXPRatio(float XPRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStatsWidget", "SetXPRatio");

	Params::PlayerStatsWidget_SetXPRatio Parms{};

	Parms.XPRatio = XPRatio;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.BeaconComponent.Hide
// (Final, Native, Public, BlueprintCallable)

void UBeaconComponent::Hide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeaconComponent", "Hide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.BeaconComponent.Show
// (Final, Native, Public, BlueprintCallable)

void UBeaconComponent::Show()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeaconComponent", "Show");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.BeaconManager.OnShipChangedLocation
// (Final, Native, Protected)
// Parameters:
// class UShipDestinationData*             NewShipLocation                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeaconManager::OnShipChangedLocation(const class UShipDestinationData* NewShipLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeaconManager", "OnShipChangedLocation");

	Params::BeaconManager_OnShipChangedLocation Parms{};

	Parms.NewShipLocation = NewShipLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.BeaconTagWidget.OnHUDVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeaconTagWidget::OnHUDVisibilityChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeaconTagWidget", "OnHUDVisibilityChanged");

	Params::BeaconTagWidget_OnHUDVisibilityChanged Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.BeaconTagWidget.OnWaypointMarkerVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBeaconTagWidget::OnWaypointMarkerVisibilityChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeaconTagWidget", "OnWaypointMarkerVisibilityChanged");

	Params::BeaconTagWidget_OnWaypointMarkerVisibilityChanged Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Destructible.OnHealthChanged
// (Final, Native, Protected)
// Parameters:
// float                                   HealthChange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InInstigator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADestructible::OnHealthChanged(float HealthChange, class AActor* InInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Destructible", "OnHealthChanged");

	Params::Destructible_OnHealthChanged Parms{};

	Parms.HealthChange = HealthChange;
	Parms.InInstigator = InInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Destructible.ReceiveDeployOrder
// (Native, Event, Protected, BlueprintEvent)

void ADestructible::ReceiveDeployOrder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Destructible", "ReceiveDeployOrder");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Destructible.ReceivePreDeploy
// (Native, Event, Protected, BlueprintEvent)

void ADestructible::ReceivePreDeploy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Destructible", "ReceivePreDeploy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Destructible.ReceiveTriggerArmed
// (Native, Event, Protected, BlueprintEvent)

void ADestructible::ReceiveTriggerArmed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Destructible", "ReceiveTriggerArmed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Destructible.ReceiveTriggerDisarmed
// (Native, Event, Protected, BlueprintEvent)

void ADestructible::ReceiveTriggerDisarmed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Destructible", "ReceiveTriggerDisarmed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Destructible.ReceiveTriggerTripped
// (Native, Event, Protected, BlueprintEvent)

void ADestructible::ReceiveTriggerTripped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Destructible", "ReceiveTriggerTripped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Destructible.ReceiveTriggerUntripped
// (Native, Event, Protected, BlueprintEvent)

void ADestructible::ReceiveTriggerUntripped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Destructible", "ReceiveTriggerUntripped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Destructible.SetDestructibleState
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EDestructibleState                      NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADestructible::SetDestructibleState(EDestructibleState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Destructible", "SetDestructibleState");

	Params::Destructible_SetDestructibleState Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.BeamMode.GetTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UBeamMode::GetTargetLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeamMode", "GetTargetLocation");

	Params::BeamMode_GetTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.BeamMode.HasLockedTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBeamMode::HasLockedTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeamMode", "HasLockedTarget");

	Params::BeamMode_HasLockedTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.BeamMode.IsTargetingPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBeamMode::IsTargetingPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BeamMode", "IsTargetingPlayer");

	Params::BeamMode_IsTargetingPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ItemViewerPageWidget.PlayCollapseAnimation
// (Event, Public, BlueprintEvent)

void UItemViewerPageWidget::PlayCollapseAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemViewerPageWidget", "PlayCollapseAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.VendorWidget.FadeInFactionImage
// (Event, Protected, BlueprintEvent)

void UVendorWidget::FadeInFactionImage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorWidget", "FadeInFactionImage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.VendorWidget.OnAnimationBoughtItem
// (Event, Protected, BlueprintEvent)

void UVendorWidget::OnAnimationBoughtItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorWidget", "OnAnimationBoughtItem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.VendorWidget.OnAnimationRepairedItem
// (Event, Protected, BlueprintEvent)

void UVendorWidget::OnAnimationRepairedItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorWidget", "OnAnimationRepairedItem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.VendorWidget.OnAnimationSoldItem
// (Event, Protected, BlueprintEvent)

void UVendorWidget::OnAnimationSoldItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorWidget", "OnAnimationSoldItem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.VendorWidget.OnAnimationSoldJunk
// (Event, Protected, BlueprintEvent)

void UVendorWidget::OnAnimationSoldJunk()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorWidget", "OnAnimationSoldJunk");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.VendorWidget.OnItemInspectorClosed
// (Final, Native, Protected)
// Parameters:
// class UItemInspectorWidget*             ItemInspectorWidget                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorWidget::OnItemInspectorClosed(class UItemInspectorWidget* ItemInspectorWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorWidget", "OnItemInspectorClosed");

	Params::VendorWidget_OnItemInspectorClosed Parms{};

	Parms.ItemInspectorWidget = ItemInspectorWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.VendorWidget.OnPlayerItemAdded
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UVendorWidget::OnPlayerItemAdded(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorWidget", "OnPlayerItemAdded");

	Params::VendorWidget_OnPlayerItemAdded Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.VendorWidget.OnPlayerItemRemoved
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UVendorWidget::OnPlayerItemRemoved(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorWidget", "OnPlayerItemRemoved");

	Params::VendorWidget_OnPlayerItemRemoved Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.VendorWidget.OnSetCurrentPage
// (Event, Protected, BlueprintEvent)
// Parameters:
// EVendorPages                            Page                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorWidget::OnSetCurrentPage(EVendorPages Page, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorWidget", "OnSetCurrentPage");

	Params::VendorWidget_OnSetCurrentPage Parms{};

	Parms.Page = Page;
	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.VendorWidget.OnStoreItemAdded
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UVendorWidget::OnStoreItemAdded(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorWidget", "OnStoreItemAdded");

	Params::VendorWidget_OnStoreItemAdded Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.VendorWidget.OnStoreItemRemoved
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UVendorWidget::OnStoreItemRemoved(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorWidget", "OnStoreItemRemoved");

	Params::VendorWidget_OnStoreItemRemoved Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.VendorWidget.UpdateSubnavigationActivation
// (Final, Native, Protected)

void UVendorWidget::UpdateSubnavigationActivation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorWidget", "UpdateSubnavigationActivation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DeathMenuWidget.OnLoadComplete
// (Final, Native, Protected)
// Parameters:
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELoadGameResult                         Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDeathMenuWidget::OnLoadComplete(const class FString& Filename, ELoadGameResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathMenuWidget", "OnLoadComplete");

	Params::DeathMenuWidget_OnLoadComplete Parms{};

	Parms.Filename = std::move(Filename);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DeathMenuWidget.OnQueryLatestSaveFinished
// (Final, Native, Protected)
// Parameters:
// class FString                           LatestSaveName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHasSaves                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDeathMenuWidget::OnQueryLatestSaveFinished(const class FString& LatestSaveName, bool bHasSaves)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathMenuWidget", "OnQueryLatestSaveFinished");

	Params::DeathMenuWidget_OnQueryLatestSaveFinished Parms{};

	Parms.LatestSaveName = std::move(LatestSaveName);
	Parms.bHasSaves = bHasSaves;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusEffectTagEntryWidget.OnImageSet
// (Event, Protected, BlueprintEvent)

void UStatusEffectTagEntryWidget::OnImageSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectTagEntryWidget", "OnImageSet");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.TravelTriggerComponent.OnInteract
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FInteractionDescription          Description                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTravelTriggerComponent::OnInteract(const struct FInteractionDescription& Description)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TravelTriggerComponent", "OnInteract");

	Params::TravelTriggerComponent_OnInteract Parms{};

	Parms.Description = std::move(Description);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TravelTriggerComponent.OnOpen
// (Final, Native, Public)
// Parameters:
// class AActor*                           OpeningActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTravelTriggerComponent::OnOpen(class AActor* OpeningActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TravelTriggerComponent", "OnOpen");

	Params::TravelTriggerComponent_OnOpen Parms{};

	Parms.OpeningActor = OpeningActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TravelTriggerComponent.OnOverlapActor
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTravelTriggerComponent::OnOverlapActor(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TravelTriggerComponent", "OnOverlapActor");

	Params::TravelTriggerComponent_OnOverlapActor Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TravelTriggerComponent.GetAreaDescription
// (Final, Native, Public, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTravelTriggerComponent::GetAreaDescription() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TravelTriggerComponent", "GetAreaDescription");

	Params::TravelTriggerComponent_GetAreaDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.TravelTriggerComponent.GetAreaName
// (Final, Native, Public, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTravelTriggerComponent::GetAreaName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TravelTriggerComponent", "GetAreaName");

	Params::TravelTriggerComponent_GetAreaName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.TravelTriggerComponent.GetDebugString
// (Final, Native, Public, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTravelTriggerComponent::GetDebugString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TravelTriggerComponent", "GetDebugString");

	Params::TravelTriggerComponent_GetDebugString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.CombatCameraComponent.EndCamera
// (Final, Native, Protected)

void UCombatCameraComponent::EndCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CombatCameraComponent", "EndCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.KillCameraComponent.OnKill
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCauseDamageInfo                 CauseDamageInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKillCameraComponent::OnKill(class AActor* Victim, const struct FCauseDamageInfo& CauseDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillCameraComponent", "OnKill");

	Params::KillCameraComponent_OnKill Parms{};

	Parms.Victim = Victim;
	Parms.CauseDamageInfo = std::move(CauseDamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryPageWidget.OnItemCompare
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bCompared                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryPageWidget::OnItemCompare(bool bCompared)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryPageWidget", "OnItemCompare");

	Params::InventoryPageWidget_OnItemCompare Parms{};

	Parms.bCompared = bCompared;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.TimeDilationComponent.OnTimeDilationEnd
// (Event, Public, BlueprintEvent)

void UTimeDilationComponent::OnTimeDilationEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimeDilationComponent", "OnTimeDilationEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.TimeDilationComponent.OnTimeDilationStart
// (Event, Public, BlueprintEvent)

void UTimeDilationComponent::OnTimeDilationStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimeDilationComponent", "OnTimeDilationStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.TimeDilationComponent.SlomoWorld
// (Final, Exec, Native, Protected)
// Parameters:
// float                                   Dilation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimeDilationComponent::SlomoWorld(float Dilation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimeDilationComponent", "SlomoWorld");

	Params::TimeDilationComponent_SlomoWorld Parms{};

	Parms.Dilation = Dilation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TimeDilationComponent.TimeDilatePlayer
// (Final, Exec, Native, Protected)
// Parameters:
// float                                   Dilation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimeDilationComponent::TimeDilatePlayer(float Dilation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimeDilationComponent", "TimeDilatePlayer");

	Params::TimeDilationComponent_TimeDilatePlayer Parms{};

	Parms.Dilation = Dilation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CodexJournal.OnAudioLogFocusedCB
// (Final, Native, Protected)
// Parameters:
// class UButtonBase*                      ButtonFocused                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCodexJournal::OnAudioLogFocusedCB(class UButtonBase* ButtonFocused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CodexJournal", "OnAudioLogFocusedCB");

	Params::CodexJournal_OnAudioLogFocusedCB Parms{};

	Parms.ButtonFocused = ButtonFocused;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CodexJournal.OnAudioLogHoveredCB
// (Final, Native, Protected)
// Parameters:
// class UButtonBase*                      ButtonHovered                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCodexJournal::OnAudioLogHoveredCB(class UButtonBase* ButtonHovered)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CodexJournal", "OnAudioLogHoveredCB");

	Params::CodexJournal_OnAudioLogHoveredCB Parms{};

	Parms.ButtonHovered = ButtonHovered;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CodexJournal.OnAudioLogListEntryAdded
// (Final, Native, Protected)
// Parameters:
// class UGenericCollapsableListEntry*     ListEntry                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioLogDataAsset*               DataAsset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCodexJournal::OnAudioLogListEntryAdded(class UGenericCollapsableListEntry* ListEntry, class UAudioLogDataAsset* DataAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CodexJournal", "OnAudioLogListEntryAdded");

	Params::CodexJournal_OnAudioLogListEntryAdded Parms{};

	Parms.ListEntry = ListEntry;
	Parms.DataAsset = DataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CodexJournal.OnAudioLogUnfocusedCB
// (Final, Native, Protected)
// Parameters:
// class UButtonBase*                      ButtonUnfocused                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCodexJournal::OnAudioLogUnfocusedCB(class UButtonBase* ButtonUnfocused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CodexJournal", "OnAudioLogUnfocusedCB");

	Params::CodexJournal_OnAudioLogUnfocusedCB Parms{};

	Parms.ButtonUnfocused = ButtonUnfocused;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CodexJournal.OnAudioLogUnhoveredCB
// (Final, Native, Protected)
// Parameters:
// class UButtonBase*                      ButtonUnhovered                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCodexJournal::OnAudioLogUnhoveredCB(class UButtonBase* ButtonUnhovered)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CodexJournal", "OnAudioLogUnhoveredCB");

	Params::CodexJournal_OnAudioLogUnhoveredCB Parms{};

	Parms.ButtonUnhovered = ButtonUnhovered;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerStart.OnPlayerPawnOverlappedAwareness
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AIndianaPlayerStart::OnPlayerPawnOverlappedAwareness(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerStart", "OnPlayerPawnOverlappedAwareness");

	Params::IndianaPlayerStart_OnPlayerPawnOverlappedAwareness Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerStart.OnPlayerPawnOverlappedVisited
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AIndianaPlayerStart::OnPlayerPawnOverlappedVisited(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerStart", "OnPlayerPawnOverlappedVisited");

	Params::IndianaPlayerStart_OnPlayerPawnOverlappedVisited Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerStart.GetCompanionSpawnLocation
// (Final, Native, Public, HasOutParams, HasDefaults, Const)
// Parameters:
// class FString                           CompanionCapsuleName                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bFeetLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AIndianaPlayerStart::GetCompanionSpawnLocation(const class FString& CompanionCapsuleName, struct FVector* Location, struct FRotator* Rotation, bool bFeetLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerStart", "GetCompanionSpawnLocation");

	Params::IndianaPlayerStart_GetCompanionSpawnLocation Parms{};

	Parms.CompanionCapsuleName = std::move(CompanionCapsuleName);
	Parms.bFeetLocation = bFeetLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Location != nullptr)
		*Location = std::move(Parms.Location);

	if (Rotation != nullptr)
		*Rotation = std::move(Parms.Rotation);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaPlayerStart.GetDebugString
// (Final, Native, Public, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString AIndianaPlayerStart::GetDebugString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerStart", "GetDebugString");

	Params::IndianaPlayerStart_GetDebugString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.DragContainerWidget.OnDragConfirmDrop
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// class UIndianaDragDropOperation*        Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragContainerWidget::OnDragConfirmDrop(class UIndianaDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragContainerWidget", "OnDragConfirmDrop");

	Params::DragContainerWidget_OnDragConfirmDrop Parms{};

	Parms.Operation = Operation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.DragContainerWidget.OnDragGroupCancelled
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// class UIndianaDragDropOperation*        Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragContainerWidget::OnDragGroupCancelled(class UIndianaDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragContainerWidget", "OnDragGroupCancelled");

	Params::DragContainerWidget_OnDragGroupCancelled Parms{};

	Parms.Operation = Operation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.DragContainerWidget.OnDragGroupDrop
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// class UIndianaDragDropOperation*        Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragContainerWidget::OnDragGroupDrop(class UIndianaDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragContainerWidget", "OnDragGroupDrop");

	Params::DragContainerWidget_OnDragGroupDrop Parms{};

	Parms.Operation = Operation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.DragContainerWidget.OnDragGroupStarted
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// class UIndianaDragDropOperation*        Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragContainerWidget::OnDragGroupStarted(class UIndianaDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragContainerWidget", "OnDragGroupStarted");

	Params::DragContainerWidget_OnDragGroupStarted Parms{};

	Parms.Operation = Operation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.DragContainerWidget.OnDragStarted
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// class UIndianaDragDropOperation*        Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragContainerWidget::OnDragStarted(class UIndianaDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragContainerWidget", "OnDragStarted");

	Params::DragContainerWidget_OnDragStarted Parms{};

	Parms.Operation = Operation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.DragContainerWidget.OnOperationDragCancelled
// (Final, Native, Public)
// Parameters:
// class UDragDropOperation*               Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragContainerWidget::OnOperationDragCancelled(class UDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragContainerWidget", "OnOperationDragCancelled");

	Params::DragContainerWidget_OnOperationDragCancelled Parms{};

	Parms.Operation = Operation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DragContainerWidget.OnOperationDrop
// (Final, Native, Public)
// Parameters:
// class UDragDropOperation*               Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragContainerWidget::OnOperationDrop(class UDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragContainerWidget", "OnOperationDrop");

	Params::DragContainerWidget_OnOperationDrop Parms{};

	Parms.Operation = Operation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompassEntryWidget.InitProperties
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FEntryData                       EntryData                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCompassEntryWidget::InitProperties(const struct FEntryData& EntryData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompassEntryWidget", "InitProperties");

	Params::CompassEntryWidget_InitProperties Parms{};

	Parms.EntryData = std::move(EntryData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.DynamicTOD.ForceUpdate
// (Native, Event, Protected, BlueprintEvent)

void ADynamicTOD::ForceUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicTOD", "ForceUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DynamicTOD.GetPreviousWeatherState
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UWeatherStateContainer*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWeatherStateContainer* ADynamicTOD::GetPreviousWeatherState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicTOD", "GetPreviousWeatherState");

	Params::DynamicTOD_GetPreviousWeatherState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.DynamicTOD.GetWeatherParticleSystem
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class UParticleSystem*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleSystem* ADynamicTOD::GetWeatherParticleSystem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicTOD", "GetWeatherParticleSystem");

	Params::DynamicTOD_GetWeatherParticleSystem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.DynamicTOD.GetWeatherWwiseStateName
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ADynamicTOD::GetWeatherWwiseStateName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicTOD", "GetWeatherWwiseStateName");

	Params::DynamicTOD_GetWeatherWwiseStateName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.DynamicTOD.ResetSavedWeather
// (Final, Native, Protected, BlueprintCallable)

void ADynamicTOD::ResetSavedWeather()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicTOD", "ResetSavedWeather");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DynamicTOD.SaveCurrentWeather
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UWeatherStateContainer*           InWeatherState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADynamicTOD::SaveCurrentWeather(class UWeatherStateContainer* InWeatherState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicTOD", "SaveCurrentWeather");

	Params::DynamicTOD_SaveCurrentWeather Parms{};

	Parms.InWeatherState = InWeatherState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DynamicTOD.StartSaveWeather
// (Event, Public, BlueprintEvent)

void ADynamicTOD::StartSaveWeather()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicTOD", "StartSaveWeather");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.DynamicTOD.WeatherTimelineUpdateForward
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   CurrentWeatherAmount                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurrentMaterialWetness                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADynamicTOD::WeatherTimelineUpdateForward(float CurrentWeatherAmount, float CurrentMaterialWetness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicTOD", "WeatherTimelineUpdateForward");

	Params::DynamicTOD_WeatherTimelineUpdateForward Parms{};

	Parms.CurrentWeatherAmount = CurrentWeatherAmount;
	Parms.CurrentMaterialWetness = CurrentMaterialWetness;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.DynamicTOD.WeatherTimelineUpdateReverse
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   CurrentWeatherAmount                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurrentMaterialWetness                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADynamicTOD::WeatherTimelineUpdateReverse(float CurrentWeatherAmount, float CurrentMaterialWetness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicTOD", "WeatherTimelineUpdateReverse");

	Params::DynamicTOD_WeatherTimelineUpdateReverse Parms{};

	Parms.CurrentWeatherAmount = CurrentWeatherAmount;
	Parms.CurrentMaterialWetness = CurrentMaterialWetness;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.ComputerTerminal.AttemptUnlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Initiator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EComputerTerminalResult                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EComputerTerminalResult AComputerTerminal::AttemptUnlock(class AActor* Initiator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComputerTerminal", "AttemptUnlock");

	Params::ComputerTerminal_AttemptUnlock Parms{};

	Parms.Initiator = Initiator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ComputerTerminal.AttemptUse
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Initiator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForce                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EComputerTerminalResult                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EComputerTerminalResult AComputerTerminal::AttemptUse(class AActor* Initiator, bool bForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComputerTerminal", "AttemptUse");

	Params::ComputerTerminal_AttemptUse Parms{};

	Parms.Initiator = Initiator;
	Parms.bForce = bForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ComputerTerminal.GetCurrentState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EComputerLockState                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EComputerLockState AComputerTerminal::GetCurrentState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComputerTerminal", "GetCurrentState");

	Params::ComputerTerminal_GetCurrentState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ComputerTerminal.LockComputer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFireComputerLockedEvent                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AComputerTerminal::LockComputer(bool bFireComputerLockedEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComputerTerminal", "LockComputer");

	Params::ComputerTerminal_LockComputer Parms{};

	Parms.bFireComputerLockedEvent = bFireComputerLockedEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ComputerTerminal.UnlockComputer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFireComputerUnlockedEvent                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AComputerTerminal::UnlockComputer(bool bFireComputerUnlockedEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComputerTerminal", "UnlockComputer");

	Params::ComputerTerminal_UnlockComputer Parms{};

	Parms.bFireComputerUnlockedEvent = bFireComputerUnlockedEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ComputerTerminal.GetExactHackDifficulty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 AComputerTerminal::GetExactHackDifficulty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComputerTerminal", "GetExactHackDifficulty");

	Params::ComputerTerminal_GetExactHackDifficulty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ElevatorDisableStatusEffect.OnElevatorMoveEnd
// (Final, Native, Protected)
// Parameters:
// int32                                   DestinationFloor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UElevatorDisableStatusEffect::OnElevatorMoveEnd(int32 DestinationFloor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ElevatorDisableStatusEffect", "OnElevatorMoveEnd");

	Params::ElevatorDisableStatusEffect_OnElevatorMoveEnd Parms{};

	Parms.DestinationFloor = DestinationFloor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.BTTask_Disable.OnDisableFinished
// (Final, Native, Protected)
// Parameters:
// class UStatusEffect*                    StatusEffect                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBTTask_Disable::OnDisableFinished(class UStatusEffect* StatusEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BTTask_Disable", "OnDisableFinished");

	Params::BTTask_Disable_OnDisableFinished Parms{};

	Parms.StatusEffect = StatusEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.BTTask_Disable.OnFreezeComplete
// (Final, Native, Protected)
// Parameters:
// class UStatusEffect*                    StatusEffect                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBTTask_Disable::OnFreezeComplete(class UStatusEffect* StatusEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BTTask_Disable", "OnFreezeComplete");

	Params::BTTask_Disable_OnFreezeComplete Parms{};

	Parms.StatusEffect = StatusEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.BTTask_Disable.OnIdleFinished
// (Final, Native, Protected)
// Parameters:
// class UStatusEffect*                    StatusEffect                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBTTask_Disable::OnIdleFinished(class UStatusEffect* StatusEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BTTask_Disable", "OnIdleFinished");

	Params::BTTask_Disable_OnIdleFinished Parms{};

	Parms.StatusEffect = StatusEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.BTTask_Disable.OnMontageBlendingOut
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBTTask_Disable::OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BTTask_Disable", "OnMontageBlendingOut");

	Params::BTTask_Disable_OnMontageBlendingOut Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.BTTask_Disable.OnPushComplete
// (Final, Native, Protected)
// Parameters:
// class UStatusEffect*                    StatusEffect                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBTTask_Disable::OnPushComplete(class UStatusEffect* StatusEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BTTask_Disable", "OnPushComplete");

	Params::BTTask_Disable_OnPushComplete Parms{};

	Parms.StatusEffect = StatusEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.BTTask_Disable.OnRagdollComplete
// (Final, Native, Protected)
// Parameters:
// class UStatusEffect*                    StatusEffect                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBTTask_Disable::OnRagdollComplete(class UStatusEffect* StatusEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BTTask_Disable", "OnRagdollComplete");

	Params::BTTask_Disable_OnRagdollComplete Parms{};

	Parms.StatusEffect = StatusEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ShipLocation.OnShipLocationChanged
// (Final, Native, Protected)
// Parameters:
// class UShipDestinationData*             NewLocation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AShipLocation::OnShipLocationChanged(const class UShipDestinationData* NewLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShipLocation", "OnShipLocationChanged");

	Params::ShipLocation_OnShipLocationChanged Parms{};

	Parms.NewLocation = NewLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ShipLocation.ShipLocationActivated
// (Native, Event, Protected, BlueprintEvent)

void AShipLocation::ShipLocationActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShipLocation", "ShipLocationActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ShipLocation.ShipLocationDeactivated
// (Native, Event, Protected, BlueprintEvent)

void AShipLocation::ShipLocationDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShipLocation", "ShipLocationDeactivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ButtonBaseContainerWidget.OnActivatableChange
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bActivatable                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UButtonBaseContainerWidget::OnActivatableChange(bool bActivatable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBaseContainerWidget", "OnActivatableChange");

	Params::ButtonBaseContainerWidget_OnActivatableChange Parms{};

	Parms.bActivatable = bActivatable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.ButtonBaseSlot.SetHorizontalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHorizontalAlignment                    InHorizontalAlignment                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UButtonBaseSlot::SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBaseSlot", "SetHorizontalAlignment");

	Params::ButtonBaseSlot_SetHorizontalAlignment Parms{};

	Parms.InHorizontalAlignment = InHorizontalAlignment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ButtonBaseSlot.SetPadding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMargin                          InPadding                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UButtonBaseSlot::SetPadding(const struct FMargin& InPadding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBaseSlot", "SetPadding");

	Params::ButtonBaseSlot_SetPadding Parms{};

	Parms.InPadding = std::move(InPadding);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ButtonBaseSlot.SetVerticalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVerticalAlignment                      InVerticalAlignment                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UButtonBaseSlot::SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonBaseSlot", "SetVerticalAlignment");

	Params::ButtonBaseSlot_SetVerticalAlignment Parms{};

	Parms.InVerticalAlignment = InVerticalAlignment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaCheatManager.DropAllItemsDebug
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bSplitStacks                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaCheatManager::DropAllItemsDebug(bool bSplitStacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCheatManager", "DropAllItemsDebug");

	Params::IndianaCheatManager_DropAllItemsDebug Parms{};

	Parms.bSplitStacks = bSplitStacks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaCheatManager.GivePlayerAllItems
// (Final, Exec, Native, Public)

void UIndianaCheatManager::GivePlayerAllItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCheatManager", "GivePlayerAllItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaCheatManager.LootTableDebug
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           LootTable                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumTimes                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaCheatManager::LootTableDebug(const class FString& LootTable, int32 NumTimes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCheatManager", "LootTableDebug");

	Params::IndianaCheatManager_LootTableDebug Parms{};

	Parms.LootTable = std::move(LootTable);
	Parms.NumTimes = NumTimes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaCheatManager.SetLevelNPC
// (Exec, Native, Public)
// Parameters:
// int32                                   NewLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaCheatManager::SetLevelNPC(int32 NewLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCheatManager", "SetLevelNPC");

	Params::IndianaCheatManager_SetLevelNPC Parms{};

	Parms.NewLevel = NewLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusEffectTagWidget.OnStatusEffectAdded
// (Final, Native, Protected)
// Parameters:
// class UStatusEffectManagerComponent*    Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffect*                    StatusEffect                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffectTagWidget::OnStatusEffectAdded(class UStatusEffectManagerComponent* Sender, class UStatusEffect* StatusEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectTagWidget", "OnStatusEffectAdded");

	Params::StatusEffectTagWidget_OnStatusEffectAdded Parms{};

	Parms.Sender = Sender;
	Parms.StatusEffect = StatusEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusEffectTagWidget.OnStatusEffectRemoved
// (Final, Native, Protected)
// Parameters:
// class UStatusEffectManagerComponent*    Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffect*                    StatusEffect                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffectTagWidget::OnStatusEffectRemoved(class UStatusEffectManagerComponent* Sender, class UStatusEffect* StatusEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectTagWidget", "OnStatusEffectRemoved");

	Params::StatusEffectTagWidget_OnStatusEffectRemoved Parms{};

	Parms.Sender = Sender;
	Parms.StatusEffect = StatusEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationManager.ClearConversationNodeAsRead
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UConversationData*                Conversation                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NodeID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationManager::ClearConversationNodeAsRead(const class UConversationData* Conversation, int32 NodeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationManager", "ClearConversationNodeAsRead");

	Params::ConversationManager_ClearConversationNodeAsRead Parms{};

	Parms.Conversation = Conversation;
	Parms.NodeID = NodeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationManager.HasConversationNodeBeenVisited
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UConversationData*                Conversation                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NodeID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECheckBranches                          Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConversationManager::HasConversationNodeBeenVisited(const class UConversationData* Conversation, int32 NodeID, ECheckBranches* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationManager", "HasConversationNodeBeenVisited");

	Params::ConversationManager_HasConversationNodeBeenVisited Parms{};

	Parms.Conversation = Conversation;
	Parms.NodeID = NodeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function Indiana.ConversationManager.MarkConversationNodeAsRead
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UConversationData*                Conversation                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NodeID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationManager::MarkConversationNodeAsRead(const class UConversationData* Conversation, int32 NodeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationManager", "MarkConversationNodeAsRead");

	Params::ConversationManager_MarkConversationNodeAsRead Parms{};

	Parms.Conversation = Conversation;
	Parms.NodeID = NodeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationResponseWidget.OnResponseSkillsChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bContainsSkillCheck                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationResponseWidget::OnResponseSkillsChanged(bool bContainsSkillCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationResponseWidget", "OnResponseSkillsChanged");

	Params::ConversationResponseWidget_OnResponseSkillsChanged Parms{};

	Parms.bContainsSkillCheck = bContainsSkillCheck;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.ConversationResponseWidget.OnSetSelectableOption
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bSelectable                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationResponseWidget::OnSetSelectableOption(bool bSelectable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationResponseWidget", "OnSetSelectableOption");

	Params::ConversationResponseWidget_OnSetSelectableOption Parms{};

	Parms.bSelectable = bSelectable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.ConversationResponseWidget.OnSetSkillCheckRequiredCompanion
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bSelectable                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationResponseWidget::OnSetSkillCheckRequiredCompanion(bool bSelectable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationResponseWidget", "OnSetSkillCheckRequiredCompanion");

	Params::ConversationResponseWidget_OnSetSkillCheckRequiredCompanion Parms{};

	Parms.bSelectable = bSelectable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.ConversationResponseWidget.IsSelectable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConversationResponseWidget::IsSelectable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationResponseWidget", "IsSelectable");

	Params::ConversationResponseWidget_IsSelectable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.SkillStatusEffect.OnSpawnedEffectCleared
// (Final, Native, Protected)
// Parameters:
// class UStatusEffect*                    SpawnedEffect                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillStatusEffect::OnSpawnedEffectCleared(class UStatusEffect* SpawnedEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillStatusEffect", "OnSpawnedEffectCleared");

	Params::SkillStatusEffect_OnSpawnedEffectCleared Parms{};

	Parms.SpawnedEffect = SpawnedEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatsSkillButtonEntryBase.UpdateButtonBrush
// (Event, Protected, BlueprintEvent)

void UStatsSkillButtonEntryBase::UpdateButtonBrush()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsSkillButtonEntryBase", "UpdateButtonBrush");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.CategoryButtonEntryWidget.OnCategoryUnhoveredUnfocused
// (Final, Native, Protected)

void UCategoryButtonEntryWidget::OnCategoryUnhoveredUnfocused()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CategoryButtonEntryWidget", "OnCategoryUnhoveredUnfocused");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CauseDamageReticleWidget.OnCauseDamage
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FCauseDamageInfo                 CauseDamageInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCauseDamageReticleWidget::OnCauseDamage(const struct FCauseDamageInfo& CauseDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CauseDamageReticleWidget", "OnCauseDamage");

	Params::CauseDamageReticleWidget_OnCauseDamage Parms{};

	Parms.CauseDamageInfo = std::move(CauseDamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CauseDamageReticleWidget.ShowHitAnim
// (Event, Protected, BlueprintEvent)

void UCauseDamageReticleWidget::ShowHitAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CauseDamageReticleWidget", "ShowHitAnim");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.CauseDamageReticleWidget.ShowKillAnim
// (Event, Protected, BlueprintEvent)

void UCauseDamageReticleWidget::ShowKillAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CauseDamageReticleWidget", "ShowKillAnim");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.CauseDamageReticleWidget.ShowWeakAnim
// (Event, Protected, BlueprintEvent)

void UCauseDamageReticleWidget::ShowWeakAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CauseDamageReticleWidget", "ShowWeakAnim");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.CCAppearancePageWidget.OnBorderMouseDown
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    MouseEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UCCAppearancePageWidget::OnBorderMouseDown(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCAppearancePageWidget", "OnBorderMouseDown");

	Params::CCAppearancePageWidget_OnBorderMouseDown Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.MouseEvent = std::move(MouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.CCAppearancePageWidget.OnExpandableAreaChanged
// (Final, Native, Protected)
// Parameters:
// class UExpandableAreaBase*              AreaBaseWidget                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsExpanded                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCCAppearancePageWidget::OnExpandableAreaChanged(class UExpandableAreaBase* AreaBaseWidget, bool bIsExpanded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCAppearancePageWidget", "OnExpandableAreaChanged");

	Params::CCAppearancePageWidget_OnExpandableAreaChanged Parms{};

	Parms.AreaBaseWidget = AreaBaseWidget;
	Parms.bIsExpanded = bIsExpanded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CCAppearancePageWidget.OnProgressToNextPage
// (Final, Native, Protected)

void UCCAppearancePageWidget::OnProgressToNextPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCAppearancePageWidget", "OnProgressToNextPage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CCAppearancePageWidget.RandomizeCharacter
// (Final, Native, Protected)

void UCCAppearancePageWidget::RandomizeCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCAppearancePageWidget", "RandomizeCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CCAppearancePageWidget.SetCharacterDefaults
// (Final, Native, Protected)

void UCCAppearancePageWidget::SetCharacterDefaults()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCAppearancePageWidget", "SetCharacterDefaults");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TTDEnemyScanner.OnActiveScannerTargetChanged
// (Final, Native, Protected)

void UTTDEnemyScanner::OnActiveScannerTargetChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TTDEnemyScanner", "OnActiveScannerTargetChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TTDEnemyScanner.OnFactionImageLoaded
// (Event, Protected, BlueprintEvent)

void UTTDEnemyScanner::OnFactionImageLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TTDEnemyScanner", "OnFactionImageLoaded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.TTDEnemyScanner.OnHUDVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTTDEnemyScanner::OnHUDVisibilityChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TTDEnemyScanner", "OnHUDVisibilityChanged");

	Params::TTDEnemyScanner_OnHUDVisibilityChanged Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TTDEnemyScanner.OnMadeInvisible
// (Final, Native, Protected, BlueprintCallable)

void UTTDEnemyScanner::OnMadeInvisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TTDEnemyScanner", "OnMadeInvisible");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TTDEnemyScanner.OnMakeInvisible
// (Event, Protected, BlueprintEvent)

void UTTDEnemyScanner::OnMakeInvisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TTDEnemyScanner", "OnMakeInvisible");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.TTDEnemyScanner.OnMakeVisible
// (Event, Protected, BlueprintEvent)

void UTTDEnemyScanner::OnMakeVisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TTDEnemyScanner", "OnMakeVisible");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.TTDEnemyScanner.OnTTDScannerVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTTDEnemyScanner::OnTTDScannerVisibilityChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TTDEnemyScanner", "OnTTDScannerVisibilityChanged");

	Params::TTDEnemyScanner_OnTTDScannerVisibilityChanged Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TTDEnemyScanner.ScanCompleted
// (Final, Native, Protected)

void UTTDEnemyScanner::ScanCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TTDEnemyScanner", "ScanCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TTDEnemyScanner.ScanEnded
// (Final, Native, Protected)

void UTTDEnemyScanner::ScanEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TTDEnemyScanner", "ScanEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TTDEnemyScanner.StopFactionImageAnimation
// (Event, Protected, BlueprintEvent)

void UTTDEnemyScanner::StopFactionImageAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TTDEnemyScanner", "StopFactionImageAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.CCSkillsPageWidget.OnUserScrolled
// (Final, Native, Protected)
// Parameters:
// float                                   ScrollAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCCSkillsPageWidget::OnUserScrolled(float ScrollAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCSkillsPageWidget", "OnUserScrolled");

	Params::CCSkillsPageWidget_OnUserScrolled Parms{};

	Parms.ScrollAmount = ScrollAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterCreationMasterWidget.OnCharacterCreationUIStart
// (Event, Protected, BlueprintEvent)

void UCharacterCreationMasterWidget::OnCharacterCreationUIStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCreationMasterWidget", "OnCharacterCreationUIStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.CharacterCreationMasterWidget.OnFadeInContents
// (Event, Protected, BlueprintEvent)

void UCharacterCreationMasterWidget::OnFadeInContents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCreationMasterWidget", "OnFadeInContents");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.CharacterCreationMasterWidget.OnFadeOutContents
// (Event, Protected, BlueprintEvent)

void UCharacterCreationMasterWidget::OnFadeOutContents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCreationMasterWidget", "OnFadeOutContents");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.CharacterCreationMasterWidget.OnIntroAnimSequenceComplete
// (Final, Native, Protected, BlueprintCallable)

void UCharacterCreationMasterWidget::OnIntroAnimSequenceComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCreationMasterWidget", "OnIntroAnimSequenceComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterCreationMasterWidget.OnIntroMovieComplete
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bWasSkipped                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCreationMasterWidget::OnIntroMovieComplete(bool bWasSkipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCreationMasterWidget", "OnIntroMovieComplete");

	Params::CharacterCreationMasterWidget_OnIntroMovieComplete Parms{};

	Parms.bWasSkipped = bWasSkipped;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.CharacterCreationMasterWidget.OnIntroMovieCompleteImpl
// (Final, Native, Protected)
// Parameters:
// bool                                    bWasSkipped                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCreationMasterWidget::OnIntroMovieCompleteImpl(bool bWasSkipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCreationMasterWidget", "OnIntroMovieCompleteImpl");

	Params::CharacterCreationMasterWidget_OnIntroMovieCompleteImpl Parms{};

	Parms.bWasSkipped = bWasSkipped;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterCreationMasterWidget.OnOutroMoviePartOneComplete
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bWasSkipped                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCreationMasterWidget::OnOutroMoviePartOneComplete(bool bWasSkipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCreationMasterWidget", "OnOutroMoviePartOneComplete");

	Params::CharacterCreationMasterWidget_OnOutroMoviePartOneComplete Parms{};

	Parms.bWasSkipped = bWasSkipped;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.CharacterCreationMasterWidget.OnOutroMoviePartTwoComplete
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bWasSkipped                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCreationMasterWidget::OnOutroMoviePartTwoComplete(bool bWasSkipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCreationMasterWidget", "OnOutroMoviePartTwoComplete");

	Params::CharacterCreationMasterWidget_OnOutroMoviePartTwoComplete Parms{};

	Parms.bWasSkipped = bWasSkipped;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.CharacterCreationMasterWidget.OnOutroMovieStarted
// (Event, Protected, BlueprintEvent)

void UCharacterCreationMasterWidget::OnOutroMovieStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCreationMasterWidget", "OnOutroMovieStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.CharacterCreationMasterWidget.OnOutroMovieTwoComplete
// (Final, Native, Protected)
// Parameters:
// bool                                    bWasSkipped                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCreationMasterWidget::OnOutroMovieTwoComplete(bool bWasSkipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCreationMasterWidget", "OnOutroMovieTwoComplete");

	Params::CharacterCreationMasterWidget_OnOutroMovieTwoComplete Parms{};

	Parms.bWasSkipped = bWasSkipped;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterCreationMasterWidget.OnPageBack
// (Final, Native, Protected)

void UCharacterCreationMasterWidget::OnPageBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCreationMasterWidget", "OnPageBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterCreationMasterWidget.PlayPartTwoOutroMovie
// (Final, Native, Protected)
// Parameters:
// bool                                    bWasSkipped                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCreationMasterWidget::PlayPartTwoOutroMovie(bool bWasSkipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCreationMasterWidget", "PlayPartTwoOutroMovie");

	Params::CharacterCreationMasterWidget_PlayPartTwoOutroMovie Parms{};

	Parms.bWasSkipped = bWasSkipped;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DeathClass.Execute
// (Event, Public, BlueprintEvent)
// Parameters:
// class UCharacterDeathComponent*         InDeathComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDeathClass::Execute(class UCharacterDeathComponent* InDeathComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathClass", "Execute");

	Params::DeathClass_Execute Parms{};

	Parms.InDeathComponent = InDeathComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.DeathClass.ExecuteOnReload
// (Event, Public, BlueprintEvent)
// Parameters:
// class UCharacterDeathComponent*         InDeathComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDeathClass::ExecuteOnReload(class UCharacterDeathComponent* InDeathComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathClass", "ExecuteOnReload");

	Params::DeathClass_ExecuteOnReload Parms{};

	Parms.InDeathComponent = InDeathComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.DeathClass.FindAndPostAudioEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     DeathAudioEvent                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDeathClass::FindAndPostAudioEvent(const struct FGameplayTag& DeathAudioEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathClass", "FindAndPostAudioEvent");

	Params::DeathClass_FindAndPostAudioEvent Parms{};

	Parms.DeathAudioEvent = std::move(DeathAudioEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DeathClass.FindAudioEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     DeathAudioEvent                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkAudioEvent* UDeathClass::FindAudioEvent(const struct FGameplayTag& DeathAudioEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathClass", "FindAudioEvent");

	Params::DeathClass_FindAudioEvent Parms{};

	Parms.DeathAudioEvent = std::move(DeathAudioEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.DeathClass.Tick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDeathClass::Tick(float Delta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathClass", "Tick");

	Params::DeathClass_Tick Parms{};

	Parms.Delta = Delta;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.CustomEventEffect.CustomStop
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomEventEffect::CustomStop(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEventEffect", "CustomStop");

	Params::CustomEventEffect_CustomStop Parms{};

	Parms.TargetActor = TargetActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.CustomEventEffect.CustomTrigger
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEventEffectParams               Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCustomEventEffect::CustomTrigger(class AActor* TargetActor, const struct FEventEffectParams& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEventEffect", "CustomTrigger");

	Params::CustomEventEffect_CustomTrigger Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Params_0 = std::move(Params_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.CharacterInfoComponent.OnCompanionRegistered
// (Final, Native, Public)
// Parameters:
// class AIndianaAiCharacter*              Companion                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRegister                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInfoComponent::OnCompanionRegistered(class AIndianaAiCharacter* Companion, bool bRegister)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInfoComponent", "OnCompanionRegistered");

	Params::CharacterInfoComponent_OnCompanionRegistered Parms{};

	Parms.Companion = Companion;
	Parms.bRegister = bRegister;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterInfoComponent.OnStatUpdated
// (Final, Native, Public)
// Parameters:
// class URpgStat*                         Stat                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInfoComponent::OnStatUpdated(const class URpgStat* Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInfoComponent", "OnStatUpdated");

	Params::CharacterInfoComponent_OnStatUpdated Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterInfoComponent.OnWeaponEndEquip
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInfoComponent::OnWeaponEndEquip(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInfoComponent", "OnWeaponEndEquip");

	Params::CharacterInfoComponent_OnWeaponEndEquip Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterInfoComponent.OnWeaponEndUnequip
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInfoComponent::OnWeaponEndUnequip(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInfoComponent", "OnWeaponEndUnequip");

	Params::CharacterInfoComponent_OnWeaponEndUnequip Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterInfoComponent.PerkPointsAdd
// (Final, Exec, Native, Protected)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInfoComponent::PerkPointsAdd(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInfoComponent", "PerkPointsAdd");

	Params::CharacterInfoComponent_PerkPointsAdd Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterInfoComponent.PerkPurchase
// (Final, Exec, Native, Protected)
// Parameters:
// class FString                           PerkName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInfoComponent::PerkPurchase(const class FString& PerkName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInfoComponent", "PerkPurchase");

	Params::CharacterInfoComponent_PerkPurchase Parms{};

	Parms.PerkName = std::move(PerkName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterInfoComponent.PerkRemove
// (Final, Exec, Native, Protected)
// Parameters:
// class FString                           PerkName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInfoComponent::PerkRemove(const class FString& PerkName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInfoComponent", "PerkRemove");

	Params::CharacterInfoComponent_PerkRemove Parms{};

	Parms.PerkName = std::move(PerkName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterInfoComponent.SetLevel
// (Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInfoComponent::SetLevel(int32 NewLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInfoComponent", "SetLevel");

	Params::CharacterInfoComponent_SetLevel Parms{};

	Parms.NewLevel = NewLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterInfoComponent.UnlockPerksWithRandomLevels_Debug
// (Final, Exec, Native, Public)

void UCharacterInfoComponent::UnlockPerksWithRandomLevels_Debug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInfoComponent", "UnlockPerksWithRandomLevels_Debug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterInfoComponent.GetCreatureXPType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECreatureXPType                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECreatureXPType UCharacterInfoComponent::GetCreatureXPType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInfoComponent", "GetCreatureXPType");

	Params::CharacterInfoComponent_GetCreatureXPType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.CharacterInfoComponent.GetGender
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGender                                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGender UCharacterInfoComponent::GetGender() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInfoComponent", "GetGender");

	Params::CharacterInfoComponent_GetGender Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.CharacterInfoComponent.GetLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCharacterInfoComponent::GetLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInfoComponent", "GetLevel");

	Params::CharacterInfoComponent_GetLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.CharacterInfoComponent.GetLevelScaledAtLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCharacterInfoComponent::GetLevelScaledAtLocation(const struct FVector& Location) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInfoComponent", "GetLevelScaledAtLocation");

	Params::CharacterInfoComponent_GetLevelScaledAtLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.CharacterInfoComponent.GetLevelScaledByWorld
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCharacterInfoComponent::GetLevelScaledByWorld() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInfoComponent", "GetLevelScaledByWorld");

	Params::CharacterInfoComponent_GetLevelScaledByWorld Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.CharacterInfoComponent.GetName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCharacterInfoComponent::GetName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInfoComponent", "GetName");

	Params::CharacterInfoComponent_GetName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.InventoryComponent.AddItemToActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UItem>                ItemType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLootable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent::AddItemToActor(class AActor* Actor, TSubclassOf<class UItem> ItemType, int32 Count, bool bLootable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryComponent", "AddItemToActor");

	Params::InventoryComponent_AddItemToActor Parms{};

	Parms.Actor = Actor;
	Parms.ItemType = ItemType;
	Parms.Count = Count;
	Parms.bLootable = bLootable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryComponent.GetItemCountOnActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UItem>                ItemType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventoryComponent::GetItemCountOnActor(class AActor* Actor, TSubclassOf<class UItem> ItemType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryComponent", "GetItemCountOnActor");

	Params::InventoryComponent_GetItemCountOnActor Parms{};

	Parms.Actor = Actor;
	Parms.ItemType = ItemType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.InventoryComponent.HasItemCountOnActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UItem>                ItemType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent::HasItemCountOnActor(class AActor* Actor, TSubclassOf<class UItem> ItemType, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryComponent", "HasItemCountOnActor");

	Params::InventoryComponent_HasItemCountOnActor Parms{};

	Parms.Actor = Actor;
	Parms.ItemType = ItemType;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.InventoryComponent.HasItemCountOnActorByTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            MatchTags                                              (Parm, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent::HasItemCountOnActorByTag(class AActor* Actor, const struct FGameplayTagContainer& MatchTags, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryComponent", "HasItemCountOnActorByTag");

	Params::InventoryComponent_HasItemCountOnActorByTag Parms{};

	Parms.Actor = Actor;
	Parms.MatchTags = std::move(MatchTags);
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.InventoryComponent.RemoveItemFromActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UItem>                ItemType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent::RemoveItemFromActor(class AActor* Actor, TSubclassOf<class UItem> ItemType, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryComponent", "RemoveItemFromActor");

	Params::InventoryComponent_RemoveItemFromActor Parms{};

	Parms.Actor = Actor;
	Parms.ItemType = ItemType;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.InventoryComponent.RemoveItemsFromActorByTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            MatchTags                                              (Parm, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent::RemoveItemsFromActorByTag(class AActor* Actor, const struct FGameplayTagContainer& MatchTags, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryComponent", "RemoveItemsFromActorByTag");

	Params::InventoryComponent_RemoveItemsFromActorByTag Parms{};

	Parms.Actor = Actor;
	Parms.MatchTags = std::move(MatchTags);
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.InventoryComponent.ShowItemGainedNotification
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UItem>                ItemType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent::ShowItemGainedNotification(TSubclassOf<class UItem> ItemType, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryComponent", "ShowItemGainedNotification");

	Params::InventoryComponent_ShowItemGainedNotification Parms{};

	Parms.ItemType = ItemType;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryComponent.ShowItemRemovedNotification
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UItem>                ItemType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent::ShowItemRemovedNotification(TSubclassOf<class UItem> ItemType, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryComponent", "ShowItemRemovedNotification");

	Params::InventoryComponent_ShowItemRemovedNotification Parms{};

	Parms.ItemType = ItemType;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryComponent.TransferItemsBetweenActorsByTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           SourceActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DestinationActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            MatchTags                                              (Parm, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPotentialTheft                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent::TransferItemsBetweenActorsByTag(class AActor* SourceActor, class AActor* DestinationActor, const struct FGameplayTagContainer& MatchTags, int32 Count, bool bPotentialTheft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryComponent", "TransferItemsBetweenActorsByTag");

	Params::InventoryComponent_TransferItemsBetweenActorsByTag Parms{};

	Parms.SourceActor = SourceActor;
	Parms.DestinationActor = DestinationActor;
	Parms.MatchTags = std::move(MatchTags);
	Parms.Count = Count;
	Parms.bPotentialTheft = bPotentialTheft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.InventoryComponent.AddCurrency
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLootable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent::AddCurrency(int32 Amount, bool bLootable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "AddCurrency");

	Params::InventoryComponent_AddCurrency Parms{};

	Parms.Amount = Amount;
	Parms.bLootable = bLootable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryComponent.AddItemDebug
// (Final, Exec, Native, Protected, HasOutParams)
// Parameters:
// class FName                             ItemName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent::AddItemDebug(const class FName& ItemName, uint32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "AddItemDebug");

	Params::InventoryComponent_AddItemDebug Parms{};

	Parms.ItemName = ItemName;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryComponent.AddLootFromTable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULootTableData*                   LootTable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent::AddLootFromTable(class ULootTableData* LootTable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "AddLootFromTable");

	Params::InventoryComponent_AddLootFromTable Parms{};

	Parms.LootTable = LootTable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryComponent.DebugCreateInventory
// (Final, Exec, Native, Protected)
// Parameters:
// int32                                   NumToAddPerItem                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Skip                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent::DebugCreateInventory(int32 NumToAddPerItem, int32 Skip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "DebugCreateInventory");

	Params::InventoryComponent_DebugCreateInventory Parms{};

	Parms.NumToAddPerItem = NumToAddPerItem;
	Parms.Skip = Skip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryComponent.RemoveCurrency
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVendorInteraction                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent::RemoveCurrency(int32 Amount, bool bVendorInteraction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "RemoveCurrency");

	Params::InventoryComponent_RemoveCurrency Parms{};

	Parms.Amount = Amount;
	Parms.bVendorInteraction = bVendorInteraction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryComponent.ContainsLoot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent::ContainsLoot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "ContainsLoot");

	Params::InventoryComponent_ContainsLoot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.InventoryComponent.IsEmpty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent::IsEmpty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "IsEmpty");

	Params::InventoryComponent_IsEmpty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaAutoPlayer.OnAsyncSaveComplete
// (Final, Native, Protected)
// Parameters:
// ESaveGameResult                         Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESaveGameType                           SaveType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaAutoPlayer::OnAsyncSaveComplete(ESaveGameResult Result, ESaveGameType SaveType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAutoPlayer", "OnAsyncSaveComplete");

	Params::IndianaAutoPlayer_OnAsyncSaveComplete Parms{};

	Parms.Result = Result;
	Parms.SaveType = SaveType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAutoPlayer.StartAutoPlayer
// (Final, Exec, Native, Public)

void UIndianaAutoPlayer::StartAutoPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAutoPlayer", "StartAutoPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAutoPlayer.StopAutoPlayer
// (Final, Exec, Native, Public)

void UIndianaAutoPlayer::StopAutoPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAutoPlayer", "StopAutoPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterMedKitWidget.AbilityControlModeChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   NewSetting                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMedKitWidget::AbilityControlModeChanged(int32 NewSetting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMedKitWidget", "AbilityControlModeChanged");

	Params::CharacterMedKitWidget_AbilityControlModeChanged Parms{};

	Parms.NewSetting = NewSetting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterMedKitWidget.InhalerModeChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   NewSetting                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMedKitWidget::InhalerModeChanged(int32 NewSetting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMedKitWidget", "InhalerModeChanged");

	Params::CharacterMedKitWidget_InhalerModeChanged Parms{};

	Parms.NewSetting = NewSetting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterMedKitWidget.OnHealthChanged
// (Final, Native, Protected)
// Parameters:
// float                                   HealthChange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InInstigator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMedKitWidget::OnHealthChanged(float HealthChange, class AActor* InInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMedKitWidget", "OnHealthChanged");

	Params::CharacterMedKitWidget_OnHealthChanged Parms{};

	Parms.HealthChange = HealthChange;
	Parms.InInstigator = InInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterMedKitWidget.OnInventoryItemAddedRemoved
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCharacterMedKitWidget::OnInventoryItemAddedRemoved(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMedKitWidget", "OnInventoryItemAddedRemoved");

	Params::CharacterMedKitWidget_OnInventoryItemAddedRemoved Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterMedKitWidget.UpdateDrugSlots
// (Final, Native, Protected)
// Parameters:
// int32                                   ConsumablesUsed                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMedKitWidget::UpdateDrugSlots(int32 ConsumablesUsed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMedKitWidget", "UpdateDrugSlots");

	Params::CharacterMedKitWidget_UpdateDrugSlots Parms{};

	Parms.ConsumablesUsed = ConsumablesUsed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ComputerTerminalWidgetComponent.OnOwnerStateChange
// (Final, Native, Protected)
// Parameters:
// EComputerLockState                      PreviousState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EComputerLockState                      CurrentState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UComputerTerminalWidgetComponent::OnOwnerStateChange(EComputerLockState PreviousState, EComputerLockState CurrentState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComputerTerminalWidgetComponent", "OnOwnerStateChange");

	Params::ComputerTerminalWidgetComponent_OnOwnerStateChange Parms{};

	Parms.PreviousState = PreviousState;
	Parms.CurrentState = CurrentState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterNameplateWidget.OnLevelChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   NewLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterNameplateWidget::OnLevelChanged(int32 NewLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterNameplateWidget", "OnLevelChanged");

	Params::CharacterNameplateWidget_OnLevelChanged Parms{};

	Parms.NewLevel = NewLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterOverviewWidget.HideTTDMeter
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bHide                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterOverviewWidget::HideTTDMeter(bool bHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterOverviewWidget", "HideTTDMeter");

	Params::CharacterOverviewWidget_HideTTDMeter Parms{};

	Parms.bHide = bHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterOverviewWidget.OnAbilityControlModeChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   AbilityControlModeIn                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterOverviewWidget::OnAbilityControlModeChanged(int32 AbilityControlModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterOverviewWidget", "OnAbilityControlModeChanged");

	Params::CharacterOverviewWidget_OnAbilityControlModeChanged Parms{};

	Parms.AbilityControlModeIn = AbilityControlModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterOverviewWidget.OnCombatStateChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bCombatIn                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterOverviewWidget::OnCombatStateChange(bool bCombatIn, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterOverviewWidget", "OnCombatStateChange");

	Params::CharacterOverviewWidget_OnCombatStateChange Parms{};

	Parms.bCombatIn = bCombatIn;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterOverviewWidget.OnDifficultyChanged
// (Final, Native, Protected)
// Parameters:
// EGameDifficulty                         DifficultyIn                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterOverviewWidget::OnDifficultyChanged(EGameDifficulty DifficultyIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterOverviewWidget", "OnDifficultyChanged");

	Params::CharacterOverviewWidget_OnDifficultyChanged Parms{};

	Parms.DifficultyIn = DifficultyIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterOverviewWidget.OnDodged
// (Final, Native, Protected)
// Parameters:
// EDodgeDirection                         EDodgeDirection                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterOverviewWidget::OnDodged(EDodgeDirection EDodgeDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterOverviewWidget", "OnDodged");

	Params::CharacterOverviewWidget_OnDodged Parms{};

	Parms.EDodgeDirection = EDodgeDirection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterOverviewWidget.OnDodgeDisplayModeChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   DodgeDisplayModeIn                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterOverviewWidget::OnDodgeDisplayModeChanged(int32 DodgeDisplayModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterOverviewWidget", "OnDodgeDisplayModeChanged");

	Params::CharacterOverviewWidget_OnDodgeDisplayModeChanged Parms{};

	Parms.DodgeDisplayModeIn = DodgeDisplayModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterOverviewWidget.OnHUDVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bHUDVisibility                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterOverviewWidget::OnHUDVisibilityChanged(bool bHUDVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterOverviewWidget", "OnHUDVisibilityChanged");

	Params::CharacterOverviewWidget_OnHUDVisibilityChanged Parms{};

	Parms.bHUDVisibility = bHUDVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterOverviewWidget.OnInhalerModeChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   InhalerModeIn                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterOverviewWidget::OnInhalerModeChanged(int32 InhalerModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterOverviewWidget", "OnInhalerModeChanged");

	Params::CharacterOverviewWidget_OnInhalerModeChanged Parms{};

	Parms.InhalerModeIn = InhalerModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterOverviewWidget.OnPlayerCombatStateChange
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    IsPlayerInCombat                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterOverviewWidget::OnPlayerCombatStateChange(bool IsPlayerInCombat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterOverviewWidget", "OnPlayerCombatStateChange");

	Params::CharacterOverviewWidget_OnPlayerCombatStateChange Parms{};

	Parms.IsPlayerInCombat = IsPlayerInCombat;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.CharacterOverviewWidget.OnPlayerStatusBarModeChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterOverviewWidget::OnPlayerStatusBarModeChanged(int32 ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterOverviewWidget", "OnPlayerStatusBarModeChanged");

	Params::CharacterOverviewWidget_OnPlayerStatusBarModeChanged Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterOverviewWidget.OnPreventTTDChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bPreventTTD                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterOverviewWidget::OnPreventTTDChanged(bool bPreventTTD)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterOverviewWidget", "OnPreventTTDChanged");

	Params::CharacterOverviewWidget_OnPreventTTDChanged Parms{};

	Parms.bPreventTTD = bPreventTTD;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterOverviewWidget.OnSkillUpdated
// (Final, Native, Protected)
// Parameters:
// ESkill                                  Skill                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterOverviewWidget::OnSkillUpdated(ESkill Skill, int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterOverviewWidget", "OnSkillUpdated");

	Params::CharacterOverviewWidget_OnSkillUpdated Parms{};

	Parms.Skill = Skill;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterOverviewWidget.OnSurvivalModeChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bSurvivalBarVisibilityIn                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterOverviewWidget::OnSurvivalModeChanged(bool bSurvivalBarVisibilityIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterOverviewWidget", "OnSurvivalModeChanged");

	Params::CharacterOverviewWidget_OnSurvivalModeChanged Parms{};

	Parms.bSurvivalBarVisibilityIn = bSurvivalBarVisibilityIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterOverviewWidget.OnTTDDisplayModeChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   TTDDisplayModeIn                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterOverviewWidget::OnTTDDisplayModeChanged(int32 TTDDisplayModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterOverviewWidget", "OnTTDDisplayModeChanged");

	Params::CharacterOverviewWidget_OnTTDDisplayModeChanged Parms{};

	Parms.TTDDisplayModeIn = TTDDisplayModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterLibrary.GetAttributeValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttribute                              Attribute                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCharacterLibrary::GetAttributeValue(class AActor* Actor, EAttribute Attribute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterLibrary", "GetAttributeValue");

	Params::CharacterLibrary_GetAttributeValue Parms{};

	Parms.Actor = Actor;
	Parms.Attribute = Attribute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.CharacterLibrary.GetSkillValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkill                                  Skill                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCharacterLibrary::GetSkillValue(class AActor* Actor, ESkill Skill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterLibrary", "GetSkillValue");

	Params::CharacterLibrary_GetSkillValue Parms{};

	Parms.Actor = Actor;
	Parms.Skill = Skill;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ConsumableItem.OnStatUpdated
// (Final, Native, Protected)
// Parameters:
// class URpgStat*                         Stat                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConsumableItem::OnStatUpdated(const class URpgStat* Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsumableItem", "OnStatUpdated");

	Params::ConsumableItem_OnStatUpdated Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterShoutComponent.OnAlertStateChange
// (Final, Native, Private)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAlertState                             PreviousAlertState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAlertState                             TargetAlertState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterShoutComponent::OnAlertStateChange(class AActor* TargetActor, EAlertState PreviousAlertState, EAlertState TargetAlertState, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterShoutComponent", "OnAlertStateChange");

	Params::CharacterShoutComponent_OnAlertStateChange Parms{};

	Parms.TargetActor = TargetActor;
	Parms.PreviousAlertState = PreviousAlertState;
	Parms.TargetAlertState = TargetAlertState;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterShoutComponent.OnCharacterDeath
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FCauseDamageInfo                 CDI                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCharacterShoutComponent::OnCharacterDeath(const struct FCauseDamageInfo& CDI)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterShoutComponent", "OnCharacterDeath");

	Params::CharacterShoutComponent_OnCharacterDeath Parms{};

	Parms.CDI = std::move(CDI);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterShoutComponent.OnCombatStateChange
// (Final, Native, Private)
// Parameters:
// bool                                    bIsInCombat                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterShoutComponent::OnCombatStateChange(bool bIsInCombat, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterShoutComponent", "OnCombatStateChange");

	Params::CharacterShoutComponent_OnCombatStateChange Parms{};

	Parms.bIsInCombat = bIsInCombat;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterStatusEffectsWidget.OnAddStatusEffect
// (Final, Native, Protected)
// Parameters:
// class UStatusEffectManagerComponent*    Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffect*                    StatusEffect                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterStatusEffectsWidget::OnAddStatusEffect(class UStatusEffectManagerComponent* Sender, class UStatusEffect* StatusEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusEffectsWidget", "OnAddStatusEffect");

	Params::CharacterStatusEffectsWidget_OnAddStatusEffect Parms{};

	Parms.Sender = Sender;
	Parms.StatusEffect = StatusEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CharacterStatusEffectsWidget.OnRemoveStatusEffect
// (Final, Native, Protected)
// Parameters:
// class UStatusEffectManagerComponent*    Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffect*                    StatusEffect                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterStatusEffectsWidget::OnRemoveStatusEffect(class UStatusEffectManagerComponent* Sender, class UStatusEffect* StatusEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusEffectsWidget", "OnRemoveStatusEffect");

	Params::CharacterStatusEffectsWidget_OnRemoveStatusEffect Parms{};

	Parms.Sender = Sender;
	Parms.StatusEffect = StatusEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaFormulas.ArmTime
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   ExactTrapDifficulty                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerEngineeringSkill                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UIndianaFormulas::ArmTime(uint8 ExactTrapDifficulty, int32 PlayerEngineeringSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "ArmTime");

	Params::IndianaFormulas_ArmTime Parms{};

	Parms.ExactTrapDifficulty = ExactTrapDifficulty;
	Parms.PlayerEngineeringSkill = PlayerEngineeringSkill;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.BaseRepairPartCost
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// float                                   Durability                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemLevel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaFormulas::BaseRepairPartCost(float Durability, int32 ItemLevel) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "BaseRepairPartCost");

	Params::IndianaFormulas_BaseRepairPartCost Parms{};

	Parms.Durability = Durability;
	Parms.ItemLevel = ItemLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.CalculateGadgetSlots
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// int32                                   ScienceSkill                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIndianaFormulas::CalculateGadgetSlots(const int32 ScienceSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "CalculateGadgetSlots");

	Params::IndianaFormulas_CalculateGadgetSlots Parms{};

	Parms.ScienceSkill = ScienceSkill;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.CalculateIntialMorale
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// int32                                   TemperamentAttribute                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaFormulas::CalculateIntialMorale(int32 TemperamentAttribute) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "CalculateIntialMorale");

	Params::IndianaFormulas_CalculateIntialMorale Parms{};

	Parms.TemperamentAttribute = TemperamentAttribute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.CalculateItemBasePrice
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// int32                                   BasePrice                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPristine                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Condition                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaFormulas::CalculateItemBasePrice(int32 BasePrice, bool bPristine, float Condition) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "CalculateItemBasePrice");

	Params::IndianaFormulas_CalculateItemBasePrice Parms{};

	Parms.BasePrice = BasePrice;
	Parms.bPristine = bPristine;
	Parms.Condition = Condition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.CalculateItemEffectiveness
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class UDegradableItem*                  Item                                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaFormulas::CalculateItemEffectiveness(const class UDegradableItem* Item) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "CalculateItemEffectiveness");

	Params::IndianaFormulas_CalculateItemEffectiveness Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.CalculateMerchantSkillDiscount
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// int32                                   MerchantSkill                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaFormulas::CalculateMerchantSkillDiscount(int32 MerchantSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "CalculateMerchantSkillDiscount");

	Params::IndianaFormulas_CalculateMerchantSkillDiscount Parms{};

	Parms.MerchantSkill = MerchantSkill;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.CalculateMoraleAdjustment
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// float                                   AddedMoral                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CharmAttribute                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TemperamentAttribute                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaFormulas::CalculateMoraleAdjustment(float AddedMoral, int32 CharmAttribute, int32 TemperamentAttribute) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "CalculateMoraleAdjustment");

	Params::IndianaFormulas_CalculateMoraleAdjustment Parms{};

	Parms.AddedMoral = AddedMoral;
	Parms.CharmAttribute = CharmAttribute;
	Parms.TemperamentAttribute = TemperamentAttribute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.CalculatePartsRecoveredOnBreakdown
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// float                                   Durability                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemLevel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFieldBreakdown                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIndianaFormulas::CalculatePartsRecoveredOnBreakdown(float Durability, int32 ItemLevel, bool bFieldBreakdown) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "CalculatePartsRecoveredOnBreakdown");

	Params::IndianaFormulas_CalculatePartsRecoveredOnBreakdown Parms{};

	Parms.Durability = Durability;
	Parms.ItemLevel = ItemLevel;
	Parms.bFieldBreakdown = bFieldBreakdown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.CalculateTier1Count
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// int32                                   ScienceSkill                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIndianaFormulas::CalculateTier1Count(const int32 ScienceSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "CalculateTier1Count");

	Params::IndianaFormulas_CalculateTier1Count Parms{};

	Parms.ScienceSkill = ScienceSkill;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.CalculateTier2Count
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// int32                                   ScienceSkill                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIndianaFormulas::CalculateTier2Count(const int32 ScienceSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "CalculateTier2Count");

	Params::IndianaFormulas_CalculateTier2Count Parms{};

	Parms.ScienceSkill = ScienceSkill;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.CalculateTier3Count
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// int32                                   ScienceSkill                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIndianaFormulas::CalculateTier3Count(const int32 ScienceSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "CalculateTier3Count");

	Params::IndianaFormulas_CalculateTier3Count Parms{};

	Parms.ScienceSkill = ScienceSkill;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.CanArm
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   ExactTrapDifficulty                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerEngineeringSkill                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaFormulas::CanArm(uint8 ExactTrapDifficulty, int32 PlayerEngineeringSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "CanArm");

	Params::IndianaFormulas_CanArm Parms{};

	Parms.ExactTrapDifficulty = ExactTrapDifficulty;
	Parms.PlayerEngineeringSkill = PlayerEngineeringSkill;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.CanDisarm
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   ExactTrapDifficulty                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerEngineeringSkill                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaFormulas::CanDisarm(uint8 ExactTrapDifficulty, int32 PlayerEngineeringSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "CanDisarm");

	Params::IndianaFormulas_CanDisarm Parms{};

	Parms.ExactTrapDifficulty = ExactTrapDifficulty;
	Parms.PlayerEngineeringSkill = PlayerEngineeringSkill;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.CanHack
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   ExactComputerDifficulty                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerHackSkill                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaFormulas::CanHack(uint8 ExactComputerDifficulty, int32 PlayerHackSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "CanHack");

	Params::IndianaFormulas_CanHack Parms{};

	Parms.ExactComputerDifficulty = ExactComputerDifficulty;
	Parms.PlayerHackSkill = PlayerHackSkill;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.CanLockpick
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   ExactLockpickDifficulty                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerLockpickSkill                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaFormulas::CanLockpick(uint8 ExactLockpickDifficulty, int32 PlayerLockpickSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "CanLockpick");

	Params::IndianaFormulas_CanLockpick Parms{};

	Parms.ExactLockpickDifficulty = ExactLockpickDifficulty;
	Parms.PlayerLockpickSkill = PlayerLockpickSkill;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.ComputeExactHackDifficulty
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// EOCLDifficulty                          HackDifficulty                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UIndianaFormulas::ComputeExactHackDifficulty(EOCLDifficulty HackDifficulty) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "ComputeExactHackDifficulty");

	Params::IndianaFormulas_ComputeExactHackDifficulty Parms{};

	Parms.HackDifficulty = HackDifficulty;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.ComputeExactLockpickDifficulty
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// EOCLDifficulty                          LockpickDifficulty                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UIndianaFormulas::ComputeExactLockpickDifficulty(EOCLDifficulty LockpickDifficulty) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "ComputeExactLockpickDifficulty");

	Params::IndianaFormulas_ComputeExactLockpickDifficulty Parms{};

	Parms.LockpickDifficulty = LockpickDifficulty;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.ComputeExactTrapDifficulty
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// ETrapDifficulty                         TrapDifficulty                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UIndianaFormulas::ComputeExactTrapDifficulty(ETrapDifficulty TrapDifficulty) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "ComputeExactTrapDifficulty");

	Params::IndianaFormulas_ComputeExactTrapDifficulty Parms{};

	Parms.TrapDifficulty = TrapDifficulty;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.ComputeFallingDamagePercent
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   DistanceFallen                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaFormulas::ComputeFallingDamagePercent(float DistanceFallen) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "ComputeFallingDamagePercent");

	Params::IndianaFormulas_ComputeFallingDamagePercent Parms{};

	Parms.DistanceFallen = DistanceFallen;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.ComputeSkillPointsForPrimaryAttribute
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   AttributeRank                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIndianaFormulas::ComputeSkillPointsForPrimaryAttribute(uint8 AttributeRank) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "ComputeSkillPointsForPrimaryAttribute");

	Params::IndianaFormulas_ComputeSkillPointsForPrimaryAttribute Parms{};

	Parms.AttributeRank = AttributeRank;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.ComputeSkillPointsForSecondaryAttribute
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   AttributeRank                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIndianaFormulas::ComputeSkillPointsForSecondaryAttribute(uint8 AttributeRank) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "ComputeSkillPointsForSecondaryAttribute");

	Params::IndianaFormulas_ComputeSkillPointsForSecondaryAttribute Parms{};

	Parms.AttributeRank = AttributeRank;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.ComputeSkillValueToRange
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   SkillValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterSkillRange                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECharacterSkillRange UIndianaFormulas::ComputeSkillValueToRange(int32 SkillValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "ComputeSkillValueToRange");

	Params::IndianaFormulas_ComputeSkillValueToRange Parms{};

	Parms.SkillValue = SkillValue;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.ConversationAttributeNearMissThreshold
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIndianaFormulas::ConversationAttributeNearMissThreshold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "ConversationAttributeNearMissThreshold");

	Params::IndianaFormulas_ConversationAttributeNearMissThreshold Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.ConversationNearMissMaxOptions
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIndianaFormulas::ConversationNearMissMaxOptions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "ConversationNearMissMaxOptions");

	Params::IndianaFormulas_ConversationNearMissMaxOptions Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.ConversationSkillNearMissThreshold
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIndianaFormulas::ConversationSkillNearMissThreshold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "ConversationSkillNearMissThreshold");

	Params::IndianaFormulas_ConversationSkillNearMissThreshold Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.DisarmTime
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   ExactTrapDifficulty                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerEngineeringSkill                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UIndianaFormulas::DisarmTime(uint8 ExactTrapDifficulty, int32 PlayerEngineeringSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "DisarmTime");

	Params::IndianaFormulas_DisarmTime Parms{};

	Parms.ExactTrapDifficulty = ExactTrapDifficulty;
	Parms.PlayerEngineeringSkill = PlayerEngineeringSkill;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.DoesHackSkillUnlockRestrictedStock
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// int32                                   HackSkill                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaFormulas::DoesHackSkillUnlockRestrictedStock(int32 HackSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "DoesHackSkillUnlockRestrictedStock");

	Params::IndianaFormulas_DoesHackSkillUnlockRestrictedStock Parms{};

	Parms.HackSkill = HackSkill;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.FieldRepairPartCost
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// float                                   Durability                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemLevel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EngineerSkill                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIndianaFormulas::FieldRepairPartCost(float Durability, int32 ItemLevel, int32 EngineerSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "FieldRepairPartCost");

	Params::IndianaFormulas_FieldRepairPartCost Parms{};

	Parms.Durability = Durability;
	Parms.ItemLevel = ItemLevel;
	Parms.EngineerSkill = EngineerSkill;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.GetBribeAmount
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// EBribeDifficulty                        BribeDifficulty                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MerchantSkill                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIndianaFormulas::GetBribeAmount(EBribeDifficulty BribeDifficulty, int32 Level, int32 MerchantSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "GetBribeAmount");

	Params::IndianaFormulas_GetBribeAmount Parms{};

	Parms.BribeDifficulty = BribeDifficulty;
	Parms.Level = Level;
	Parms.MerchantSkill = MerchantSkill;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.GetDisguiseDrainRate
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// int32                                   StealthSkill                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMoving                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSprinting                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCrouching                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaFormulas::GetDisguiseDrainRate(int32 StealthSkill, bool bMoving, bool bSprinting, bool bCrouching) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "GetDisguiseDrainRate");

	Params::IndianaFormulas_GetDisguiseDrainRate Parms{};

	Parms.StealthSkill = StealthSkill;
	Parms.bMoving = bMoving;
	Parms.bSprinting = bSprinting;
	Parms.bCrouching = bCrouching;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.GetInterrogationBribeAmount
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// ECrimeType                              CrimeType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestrictedArea                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDisguised                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DisguiseInterrogationsPassed                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MerchantSkill                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StolenItemsValue                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIndianaFormulas::GetInterrogationBribeAmount(ECrimeType CrimeType, bool bRestrictedArea, bool bDisguised, int32 DisguiseInterrogationsPassed, int32 PlayerLevel, int32 MerchantSkill, int32 StolenItemsValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "GetInterrogationBribeAmount");

	Params::IndianaFormulas_GetInterrogationBribeAmount Parms{};

	Parms.CrimeType = CrimeType;
	Parms.bRestrictedArea = bRestrictedArea;
	Parms.bDisguised = bDisguised;
	Parms.DisguiseInterrogationsPassed = DisguiseInterrogationsPassed;
	Parms.PlayerLevel = PlayerLevel;
	Parms.MerchantSkill = MerchantSkill;
	Parms.StolenItemsValue = StolenItemsValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.GetModifiedItemEffectiveness
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class UDegradableItem*                  Item                                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaFormulas::GetModifiedItemEffectiveness(const class UDegradableItem* Item) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "GetModifiedItemEffectiveness");

	Params::IndianaFormulas_GetModifiedItemEffectiveness Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.GetRespecCost
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// int32                                   NumRespecs                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIndianaFormulas::GetRespecCost(int32 NumRespecs) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "GetRespecCost");

	Params::IndianaFormulas_GetRespecCost Parms{};

	Parms.NumRespecs = NumRespecs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.HackDifficultyFullRange
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UIndianaFormulas::HackDifficultyFullRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "HackDifficultyFullRange");

	Params::IndianaFormulas_HackDifficultyFullRange Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.HackDifficultyNumRanges
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UIndianaFormulas::HackDifficultyNumRanges() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "HackDifficultyNumRanges");

	Params::IndianaFormulas_HackDifficultyNumRanges Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.HackDifficultyRange
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaFormulas::HackDifficultyRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "HackDifficultyRange");

	Params::IndianaFormulas_HackDifficultyRange Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.HackNoise
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   ExactHackDifficulty                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerHackSkill                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaFormulas::HackNoise(uint8 ExactHackDifficulty, int32 PlayerHackSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "HackNoise");

	Params::IndianaFormulas_HackNoise Parms{};

	Parms.ExactHackDifficulty = ExactHackDifficulty;
	Parms.PlayerHackSkill = PlayerHackSkill;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.HackNumResources
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   ExactHackDifficulty                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerHackSkill                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UIndianaFormulas::HackNumResources(uint8 ExactHackDifficulty, int32 PlayerHackSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "HackNumResources");

	Params::IndianaFormulas_HackNumResources Parms{};

	Parms.ExactHackDifficulty = ExactHackDifficulty;
	Parms.PlayerHackSkill = PlayerHackSkill;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.HackRobotTime
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   ExactHackDifficulty                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerHackSkill                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UIndianaFormulas::HackRobotTime(uint8 ExactHackDifficulty, int32 PlayerHackSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "HackRobotTime");

	Params::IndianaFormulas_HackRobotTime Parms{};

	Parms.ExactHackDifficulty = ExactHackDifficulty;
	Parms.PlayerHackSkill = PlayerHackSkill;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.HackTime
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   ExactHackDifficulty                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerHackSkill                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UIndianaFormulas::HackTime(uint8 ExactHackDifficulty, int32 PlayerHackSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "HackTime");

	Params::IndianaFormulas_HackTime Parms{};

	Parms.ExactHackDifficulty = ExactHackDifficulty;
	Parms.PlayerHackSkill = PlayerHackSkill;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.HackToughness
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   ExactHackDifficulty                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerHackSkill                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UIndianaFormulas::HackToughness(uint8 ExactHackDifficulty, int32 PlayerHackSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "HackToughness");

	Params::IndianaFormulas_HackToughness Parms{};

	Parms.ExactHackDifficulty = ExactHackDifficulty;
	Parms.PlayerHackSkill = PlayerHackSkill;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.LockpickDifficultyFullRange
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UIndianaFormulas::LockpickDifficultyFullRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "LockpickDifficultyFullRange");

	Params::IndianaFormulas_LockpickDifficultyFullRange Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.LockpickDifficultyNumRanges
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UIndianaFormulas::LockpickDifficultyNumRanges() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "LockpickDifficultyNumRanges");

	Params::IndianaFormulas_LockpickDifficultyNumRanges Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.LockpickDifficultyRange
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaFormulas::LockpickDifficultyRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "LockpickDifficultyRange");

	Params::IndianaFormulas_LockpickDifficultyRange Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.LockpickNoise
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   ExactLockpickDifficulty                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerLockpickSkill                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaFormulas::LockpickNoise(uint8 ExactLockpickDifficulty, int32 PlayerLockpickSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "LockpickNoise");

	Params::IndianaFormulas_LockpickNoise Parms{};

	Parms.ExactLockpickDifficulty = ExactLockpickDifficulty;
	Parms.PlayerLockpickSkill = PlayerLockpickSkill;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.LockpickNumResources
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   ExactLockpickDifficulty                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerLockpickSkill                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BasePlayerLockpickSkill                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UIndianaFormulas::LockpickNumResources(uint8 ExactLockpickDifficulty, int32 PlayerLockpickSkill, int32 BasePlayerLockpickSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "LockpickNumResources");

	Params::IndianaFormulas_LockpickNumResources Parms{};

	Parms.ExactLockpickDifficulty = ExactLockpickDifficulty;
	Parms.PlayerLockpickSkill = PlayerLockpickSkill;
	Parms.BasePlayerLockpickSkill = BasePlayerLockpickSkill;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.LockpickTime
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   ExactLockpickDifficulty                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerLockpickSkill                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BasePlayerLockpickSkill                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaFormulas::LockpickTime(uint8 ExactLockpickDifficulty, int32 PlayerLockpickSkill, int32 BasePlayerLockpickSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "LockpickTime");

	Params::IndianaFormulas_LockpickTime Parms{};

	Parms.ExactLockpickDifficulty = ExactLockpickDifficulty;
	Parms.PlayerLockpickSkill = PlayerLockpickSkill;
	Parms.BasePlayerLockpickSkill = BasePlayerLockpickSkill;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.LockpickToughness
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   ExactLockpickDifficulty                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerLockpickSkill                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UIndianaFormulas::LockpickToughness(uint8 ExactLockpickDifficulty, int32 PlayerLockpickSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "LockpickToughness");

	Params::IndianaFormulas_LockpickToughness Parms{};

	Parms.ExactLockpickDifficulty = ExactLockpickDifficulty;
	Parms.PlayerLockpickSkill = PlayerLockpickSkill;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.PickPocketTime
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   LockpickSkill                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TargetPerception                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaFormulas::PickPocketTime(int32 LockpickSkill, int32 TargetPerception) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "PickPocketTime");

	Params::IndianaFormulas_PickPocketTime Parms{};

	Parms.LockpickSkill = LockpickSkill;
	Parms.TargetPerception = TargetPerception;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.PlayerSneakEnemyDetectionRage
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    bInterior                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerSneakSkill                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaFormulas::PlayerSneakEnemyDetectionRage(bool bInterior, int32 PlayerSneakSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "PlayerSneakEnemyDetectionRage");

	Params::IndianaFormulas_PlayerSneakEnemyDetectionRage Parms{};

	Parms.bInterior = bInterior;
	Parms.PlayerSneakSkill = PlayerSneakSkill;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.ShouldDrawFireSwitchCompanionTargets
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   OldHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OldDTBody                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OldDTHead                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewDTBody                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewDTHead                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaFormulas::ShouldDrawFireSwitchCompanionTargets(float OldHealth, float OldDTBody, float OldDTHead, float NewHealth, float NewDTBody, float NewDTHead) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "ShouldDrawFireSwitchCompanionTargets");

	Params::IndianaFormulas_ShouldDrawFireSwitchCompanionTargets Parms{};

	Parms.OldHealth = OldHealth;
	Parms.OldDTBody = OldDTBody;
	Parms.OldDTHead = OldDTHead;
	Parms.NewHealth = NewHealth;
	Parms.NewDTBody = NewDTBody;
	Parms.NewDTHead = NewDTHead;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.TrapArmNoise
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   ExactTrapDifficulty                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerEngineeringSkill                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaFormulas::TrapArmNoise(uint8 ExactTrapDifficulty, int32 PlayerEngineeringSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "TrapArmNoise");

	Params::IndianaFormulas_TrapArmNoise Parms{};

	Parms.ExactTrapDifficulty = ExactTrapDifficulty;
	Parms.PlayerEngineeringSkill = PlayerEngineeringSkill;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.TrapDamagePercent
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// ETrapDifficulty                         TrapDifficulty                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaFormulas::TrapDamagePercent(ETrapDifficulty TrapDifficulty) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "TrapDamagePercent");

	Params::IndianaFormulas_TrapDamagePercent Parms{};

	Parms.TrapDifficulty = TrapDifficulty;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.TrapDifficultyFullRange
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UIndianaFormulas::TrapDifficultyFullRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "TrapDifficultyFullRange");

	Params::IndianaFormulas_TrapDifficultyFullRange Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.TrapDifficultyNumRanges
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UIndianaFormulas::TrapDifficultyNumRanges() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "TrapDifficultyNumRanges");

	Params::IndianaFormulas_TrapDifficultyNumRanges Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.TrapDifficultyRange
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaFormulas::TrapDifficultyRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "TrapDifficultyRange");

	Params::IndianaFormulas_TrapDifficultyRange Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.TrapDisarmNoise
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   ExactTrapDifficulty                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerEngineeringSkill                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaFormulas::TrapDisarmNoise(uint8 ExactTrapDifficulty, int32 PlayerEngineeringSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "TrapDisarmNoise");

	Params::IndianaFormulas_TrapDisarmNoise Parms{};

	Parms.ExactTrapDifficulty = ExactTrapDifficulty;
	Parms.PlayerEngineeringSkill = PlayerEngineeringSkill;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.TrapToughness
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   ExactTrapDifficulty                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerEngineeringSkill                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UIndianaFormulas::TrapToughness(uint8 ExactTrapDifficulty, int32 PlayerEngineeringSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "TrapToughness");

	Params::IndianaFormulas_TrapToughness Parms{};

	Parms.ExactTrapDifficulty = ExactTrapDifficulty;
	Parms.PlayerEngineeringSkill = PlayerEngineeringSkill;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.VendorRepairCurrencyCost
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// float                                   Durability                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemLevel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIndianaFormulas::VendorRepairCurrencyCost(float Durability, int32 ItemLevel) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "VendorRepairCurrencyCost");

	Params::IndianaFormulas_VendorRepairCurrencyCost Parms{};

	Parms.Durability = Durability;
	Parms.ItemLevel = ItemLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaFormulas.WorkbenchRepairPartCost
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// float                                   Durability                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemLevel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EngineerSkill                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIndianaFormulas::WorkbenchRepairPartCost(float Durability, int32 ItemLevel, int32 EngineerSkill) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFormulas", "WorkbenchRepairPartCost");

	Params::IndianaFormulas_WorkbenchRepairPartCost Parms{};

	Parms.Durability = Durability;
	Parms.ItemLevel = ItemLevel;
	Parms.EngineerSkill = EngineerSkill;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ChatterGameHelpers.PlayChatterEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Speaker                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EChatterEventType                       ChatterEvent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChatterGameHelpers::PlayChatterEvent(class AActor* Speaker, EChatterEventType ChatterEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ChatterGameHelpers", "PlayChatterEvent");

	Params::ChatterGameHelpers_PlayChatterEvent Parms{};

	Parms.Speaker = Speaker;
	Parms.ChatterEvent = ChatterEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CheckBoxWidget.UpdateCheckBoxSize
// (Final, Native, Protected)
// Parameters:
// int32                                   FontSizeModifier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheckBoxWidget::UpdateCheckBoxSize(int32 FontSizeModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheckBoxWidget", "UpdateCheckBoxSize");

	Params::CheckBoxWidget_UpdateCheckBoxSize Parms{};

	Parms.FontSizeModifier = FontSizeModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SpawnNodeBase.OnActorAlertStateChanged
// (Final, Native, Protected)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAlertState                             PreviousAlertState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAlertState                             TargetAlertState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpawnNodeBase::OnActorAlertStateChanged(class AActor* TargetActor, EAlertState PreviousAlertState, EAlertState TargetAlertState, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnNodeBase", "OnActorAlertStateChanged");

	Params::SpawnNodeBase_OnActorAlertStateChanged Parms{};

	Parms.TargetActor = TargetActor;
	Parms.PreviousAlertState = PreviousAlertState;
	Parms.TargetAlertState = TargetAlertState;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SpawnNodeBase.OnActorAwareOfPlayer
// (Final, Native, Protected)
// Parameters:
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpawnNodeBase::OnActorAwareOfPlayer(bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnNodeBase", "OnActorAwareOfPlayer");

	Params::SpawnNodeBase_OnActorAwareOfPlayer Parms{};

	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SpawnNodeBase.OnActorCombatStateChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bInCombat                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpawnNodeBase::OnActorCombatStateChanged(bool bInCombat, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnNodeBase", "OnActorCombatStateChanged");

	Params::SpawnNodeBase_OnActorCombatStateChanged Parms{};

	Parms.bInCombat = bInCombat;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SpawnNodeBase.OnActorDespawned
// (Final, Native, Protected)

void ASpawnNodeBase::OnActorDespawned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnNodeBase", "OnActorDespawned");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SpawnNodeBase.OnActorNewStateOfBeing
// (Final, Native, Protected)
// Parameters:
// EStateOfBeing                           NewStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStateOfBeing                           OldStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpawnNodeBase::OnActorNewStateOfBeing(EStateOfBeing NewStateOfBeing, EStateOfBeing OldStateOfBeing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnNodeBase", "OnActorNewStateOfBeing");

	Params::SpawnNodeBase_OnActorNewStateOfBeing Parms{};

	Parms.NewStateOfBeing = NewStateOfBeing;
	Parms.OldStateOfBeing = OldStateOfBeing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SpawnNodeBase.OnActorTookDamage
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FCauseDamageInfo                 CauseDamageInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ASpawnNodeBase::OnActorTookDamage(const struct FCauseDamageInfo& CauseDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnNodeBase", "OnActorTookDamage");

	Params::SpawnNodeBase_OnActorTookDamage Parms{};

	Parms.CauseDamageInfo = std::move(CauseDamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionCommandComponent.CompanionCommandInfinite
// (Final, Exec, Native, Public)

void UCompanionCommandComponent::CompanionCommandInfinite()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionCommandComponent", "CompanionCommandInfinite");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionCommandComponent.FillMeter
// (Final, Exec, Native, Public)

void UCompanionCommandComponent::FillMeter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionCommandComponent", "FillMeter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionCommandComponent.OnCalledShotCameraStep
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECalledShotCameraStep                   OldCameraStep                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECalledShotCameraStep                   NewCameraStep                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCloseRange                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionCommandComponent::OnCalledShotCameraStep(class AActor* Attacker, ECalledShotCameraStep OldCameraStep, ECalledShotCameraStep NewCameraStep, bool bCloseRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionCommandComponent", "OnCalledShotCameraStep");

	Params::CompanionCommandComponent_OnCalledShotCameraStep Parms{};

	Parms.Attacker = Attacker;
	Parms.OldCameraStep = OldCameraStep;
	Parms.NewCameraStep = NewCameraStep;
	Parms.bCloseRange = bCloseRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionCommandComponent.OnStatUpdated
// (Final, Native, Protected)
// Parameters:
// class URpgStat*                         Stat                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionCommandComponent::OnStatUpdated(const class URpgStat* Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionCommandComponent", "OnStatUpdated");

	Params::CompanionCommandComponent_OnStatUpdated Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionManager.ChangeCompanionMorale
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESpecialObsidianID                      Companion                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMoraleContribution                     Contribution                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MoraleAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPositiveMorale                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlyActivePartyMembers                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionManager::ChangeCompanionMorale(ESpecialObsidianID Companion, EMoraleContribution Contribution, float MoraleAmount, bool bPositiveMorale, bool bOnlyActivePartyMembers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CompanionManager", "ChangeCompanionMorale");

	Params::CompanionManager_ChangeCompanionMorale Parms{};

	Parms.Companion = Companion;
	Parms.Contribution = Contribution;
	Parms.MoraleAmount = MoraleAmount;
	Parms.bPositiveMorale = bPositiveMorale;
	Parms.bOnlyActivePartyMembers = bOnlyActivePartyMembers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionManager.DebugUnlockCompanion
// (Final, Exec, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESpecialObsidianID                      Companion                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionManager::DebugUnlockCompanion(ESpecialObsidianID Companion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CompanionManager", "DebugUnlockCompanion");

	Params::CompanionManager_DebugUnlockCompanion Parms{};

	Parms.Companion = Companion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionManager.GetCompanionGuid
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// ESpecialObsidianID                      SpecialID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGuid UCompanionManager::GetCompanionGuid(ESpecialObsidianID SpecialID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CompanionManager", "GetCompanionGuid");

	Params::CompanionManager_GetCompanionGuid Parms{};

	Parms.SpecialID = SpecialID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.CompanionManager.GetCompanionMorale
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESpecialObsidianID                      Companion                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCompanionManager::GetCompanionMorale(ESpecialObsidianID Companion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CompanionManager", "GetCompanionMorale");

	Params::CompanionManager_GetCompanionMorale Parms{};

	Parms.Companion = Companion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.CompanionManager.GetCompanionWantsToTalk
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESpecialObsidianID                      Companion                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCompanionManager::GetCompanionWantsToTalk(ESpecialObsidianID Companion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CompanionManager", "GetCompanionWantsToTalk");

	Params::CompanionManager_GetCompanionWantsToTalk Parms{};

	Parms.Companion = Companion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.CompanionManager.HasPlayerUnlockedCompanions
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCompanionManager::HasPlayerUnlockedCompanions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CompanionManager", "HasPlayerUnlockedCompanions");

	Params::CompanionManager_HasPlayerUnlockedCompanions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.CompanionManager.IsCompanionDismissed
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESpecialObsidianID                      Companion                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCompanionManager::IsCompanionDismissed(ESpecialObsidianID Companion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CompanionManager", "IsCompanionDismissed");

	Params::CompanionManager_IsCompanionDismissed Parms{};

	Parms.Companion = Companion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.CompanionManager.IsCompanionInActiveParty
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESpecialObsidianID                      Companion                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCompanionManager::IsCompanionInActiveParty(ESpecialObsidianID Companion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CompanionManager", "IsCompanionInActiveParty");

	Params::CompanionManager_IsCompanionInActiveParty Parms{};

	Parms.Companion = Companion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.CompanionManager.IsCompanionInRequestedParty
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESpecialObsidianID                      Companion                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCompanionManager::IsCompanionInRequestedParty(ESpecialObsidianID Companion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CompanionManager", "IsCompanionInRequestedParty");

	Params::CompanionManager_IsCompanionInRequestedParty Parms{};

	Parms.Companion = Companion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.CompanionManager.IsCompanionUnlocked
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESpecialObsidianID                      Companion                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCompanionManager::IsCompanionUnlocked(ESpecialObsidianID Companion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CompanionManager", "IsCompanionUnlocked");

	Params::CompanionManager_IsCompanionUnlocked Parms{};

	Parms.Companion = Companion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.CompanionManager.SetCompanionWantsToTalk
// (Final, Exec, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESpecialObsidianID                      Companion                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWantsToTalk                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionManager::SetCompanionWantsToTalk(ESpecialObsidianID Companion, bool bWantsToTalk)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CompanionManager", "SetCompanionWantsToTalk");

	Params::CompanionManager_SetCompanionWantsToTalk Parms{};

	Parms.Companion = Companion;
	Parms.bWantsToTalk = bWantsToTalk;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionManager.DebugAddCompanionMorale
// (Final, Exec, Native, Public)
// Parameters:
// uint8                                   Companion                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MoraleAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPositiveMorale                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionManager::DebugAddCompanionMorale(uint8 Companion, float MoraleAmount, bool bPositiveMorale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionManager", "DebugAddCompanionMorale");

	Params::CompanionManager_DebugAddCompanionMorale Parms{};

	Parms.Companion = Companion;
	Parms.MoraleAmount = MoraleAmount;
	Parms.bPositiveMorale = bPositiveMorale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionManagerComponent.ScriptAddCompanionToParty
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AIndianaAiCharacter*              Companion                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionManagerComponent::ScriptAddCompanionToParty(class AIndianaAiCharacter* Companion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CompanionManagerComponent", "ScriptAddCompanionToParty");

	Params::CompanionManagerComponent_ScriptAddCompanionToParty Parms{};

	Parms.Companion = Companion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionManagerComponent.ScriptRemoveCompanionFromParty
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AIndianaAiCharacter*              Companion                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionManagerComponent::ScriptRemoveCompanionFromParty(class AIndianaAiCharacter* Companion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CompanionManagerComponent", "ScriptRemoveCompanionFromParty");

	Params::CompanionManagerComponent_ScriptRemoveCompanionFromParty Parms{};

	Parms.Companion = Companion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionManagerComponent.AddPerkPointsToCompanions
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Points                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionManagerComponent::AddPerkPointsToCompanions(int32 Points)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionManagerComponent", "AddPerkPointsToCompanions");

	Params::CompanionManagerComponent_AddPerkPointsToCompanions Parms{};

	Parms.Points = Points;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionManagerComponent.DebugKillCompanions
// (Final, Exec, Native, Protected)

void UCompanionManagerComponent::DebugKillCompanions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionManagerComponent", "DebugKillCompanions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionManagerComponent.OnCauseDamage
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FCauseDamageInfo                 CauseDamageInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCompanionManagerComponent::OnCauseDamage(const struct FCauseDamageInfo& CauseDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionManagerComponent", "OnCauseDamage");

	Params::CompanionManagerComponent_OnCauseDamage Parms{};

	Parms.CauseDamageInfo = std::move(CauseDamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionManagerComponent.OnDeath
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FCauseDamageInfo                 DamageInfo                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCompanionManagerComponent::OnDeath(const struct FCauseDamageInfo& DamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionManagerComponent", "OnDeath");

	Params::CompanionManagerComponent_OnDeath Parms{};

	Parms.DamageInfo = std::move(DamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionManagerComponent.OnDifficultyChanged
// (Final, Native, Private)
// Parameters:
// EGameDifficulty                         NewDifficulty                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionManagerComponent::OnDifficultyChanged(EGameDifficulty NewDifficulty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionManagerComponent", "OnDifficultyChanged");

	Params::CompanionManagerComponent_OnDifficultyChanged Parms{};

	Parms.NewDifficulty = NewDifficulty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionManagerComponent.OnKill
// (Final, Native, Private, HasOutParams)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCauseDamageInfo                 CauseDamageInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCompanionManagerComponent::OnKill(class AActor* Victim, const struct FCauseDamageInfo& CauseDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionManagerComponent", "OnKill");

	Params::CompanionManagerComponent_OnKill Parms{};

	Parms.Victim = Victim;
	Parms.CauseDamageInfo = std::move(CauseDamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionManagerComponent.OnNewStateOfBeing
// (Final, Native, Private)
// Parameters:
// EStateOfBeing                           NewStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStateOfBeing                           OldStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionManagerComponent::OnNewStateOfBeing(EStateOfBeing NewStateOfBeing, EStateOfBeing OldStateOfBeing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionManagerComponent", "OnNewStateOfBeing");

	Params::CompanionManagerComponent_OnNewStateOfBeing Parms{};

	Parms.NewStateOfBeing = NewStateOfBeing;
	Parms.OldStateOfBeing = OldStateOfBeing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionManagerComponent.OnPlayerCinematicModeChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bCinematicModeEnabled                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionManagerComponent::OnPlayerCinematicModeChanged(bool bCinematicModeEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionManagerComponent", "OnPlayerCinematicModeChanged");

	Params::CompanionManagerComponent_OnPlayerCinematicModeChanged Parms{};

	Parms.bCinematicModeEnabled = bCinematicModeEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionManagerComponent.OnPlayerIndividualDetected
// (Final, Native, Protected)
// Parameters:
// class AIndianaAiCharacter*              Detector                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionManagerComponent::OnPlayerIndividualDetected(class AIndianaAiCharacter* Detector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionManagerComponent", "OnPlayerIndividualDetected");

	Params::CompanionManagerComponent_OnPlayerIndividualDetected Parms{};

	Parms.Detector = Detector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionManagerComponent.OnPlayerLevelChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   PlayerLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionManagerComponent::OnPlayerLevelChanged(int32 PlayerLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionManagerComponent", "OnPlayerLevelChanged");

	Params::CompanionManagerComponent_OnPlayerLevelChanged Parms{};

	Parms.PlayerLevel = PlayerLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionManagerComponent.OnRestartController
// (Final, Native, Private)
// Parameters:
// class AIndianaAiCharacter*              Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionManagerComponent::OnRestartController(class AIndianaAiCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionManagerComponent", "OnRestartController");

	Params::CompanionManagerComponent_OnRestartController Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionManagerComponent.SendCharacterToShip
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AIndianaAiCharacter*              Companion                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionManagerComponent::SendCharacterToShip(class AIndianaAiCharacter* Companion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionManagerComponent", "SendCharacterToShip");

	Params::CompanionManagerComponent_SendCharacterToShip Parms{};

	Parms.Companion = Companion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionManagerComponent.SetCompanionOutlineMode
// (Final, Exec, Native, Protected)
// Parameters:
// ECompanionOutlineMode                   OutlineMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionManagerComponent::SetCompanionOutlineMode(ECompanionOutlineMode OutlineMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionManagerComponent", "SetCompanionOutlineMode");

	Params::CompanionManagerComponent_SetCompanionOutlineMode Parms{};

	Parms.OutlineMode = OutlineMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CompanionManagerComponent.GetActiveCompanionWithSpecialID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESpecialObsidianID                      SpecialID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AIndianaAiCharacter*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AIndianaAiCharacter* UCompanionManagerComponent::GetActiveCompanionWithSpecialID(ESpecialObsidianID SpecialID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionManagerComponent", "GetActiveCompanionWithSpecialID");

	Params::CompanionManagerComponent_GetActiveCompanionWithSpecialID Parms{};

	Parms.SpecialID = SpecialID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.CompanionManagerComponent.GetCompanionFromSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECompanionSlot                          Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AIndianaAiCharacter*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AIndianaAiCharacter* UCompanionManagerComponent::GetCompanionFromSlot(ECompanionSlot Slot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionManagerComponent", "GetCompanionFromSlot");

	Params::CompanionManagerComponent_GetCompanionFromSlot Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.CompanionManagerComponent.IsPartyFull
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCompanionManagerComponent::IsPartyFull() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionManagerComponent", "IsPartyFull");

	Params::CompanionManagerComponent_IsPartyFull Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.CompanionSelectionWidget.SelectionFailed
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   CharacterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionSelectionWidget::SelectionFailed(int32 CharacterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionSelectionWidget", "SelectionFailed");

	Params::CompanionSelectionWidget_SelectionFailed Parms{};

	Parms.CharacterIndex = CharacterIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.CompanionSelectionWidget.SetCharacterAvailable
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   CharacterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUsable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionSelectionWidget::SetCharacterAvailable(int32 CharacterIndex, bool bUsable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionSelectionWidget", "SetCharacterAvailable");

	Params::CompanionSelectionWidget_SetCharacterAvailable Parms{};

	Parms.CharacterIndex = CharacterIndex;
	Parms.bUsable = bUsable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.CompanionSelectionWidget.SetCharacterSelected
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   CharacterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSelected                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionSelectionWidget::SetCharacterSelected(int32 CharacterIndex, bool bSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionSelectionWidget", "SetCharacterSelected");

	Params::CompanionSelectionWidget_SetCharacterSelected Parms{};

	Parms.CharacterIndex = CharacterIndex;
	Parms.bSelected = bSelected;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.ReactionComponent.OnTakeDamage
// (Native, Public, HasOutParams)
// Parameters:
// struct FCauseDamageInfo                 CDI                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UReactionComponent::OnTakeDamage(const struct FCauseDamageInfo& CDI)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReactionComponent", "OnTakeDamage");

	Params::ReactionComponent_OnTakeDamage Parms{};

	Parms.CDI = std::move(CDI);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ReactionComponent.TriggerDebugCameraShake
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UReactionComponent::TriggerDebugCameraShake(float Strength, float X, float Y)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReactionComponent", "TriggerDebugCameraShake");

	Params::ReactionComponent_TriggerDebugCameraShake Parms{};

	Parms.Strength = Strength;
	Parms.X = X;
	Parms.Y = Y;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuWidget.DefaultsActionHandler
// (Final, Native, Public)

void USettingsMenuWidget::DefaultsActionHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuWidget", "DefaultsActionHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuWidget.EmptyHandler
// (Final, Native, Public)

void USettingsMenuWidget::EmptyHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuWidget", "EmptyHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuWidget.OnCyclePageLeft
// (Final, Native, Private)

void USettingsMenuWidget::OnCyclePageLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuWidget", "OnCyclePageLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuWidget.OnCyclePageRight
// (Final, Native, Private)

void USettingsMenuWidget::OnCyclePageRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuWidget", "OnCyclePageRight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuWidget.OnDetectGraphics
// (Final, Native, Protected)

void USettingsMenuWidget::OnDetectGraphics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuWidget", "OnDetectGraphics");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuWidget.OnInputBack
// (Final, Native, Private)

void USettingsMenuWidget::OnInputBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuWidget", "OnInputBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuWidget.OnOpenGamepadLayout
// (Final, Native, Private)

void USettingsMenuWidget::OnOpenGamepadLayout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuWidget", "OnOpenGamepadLayout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuWidget.OnOpenPCKeyBinds
// (Final, Native, Private)

void USettingsMenuWidget::OnOpenPCKeyBinds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuWidget", "OnOpenPCKeyBinds");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuWidget.QueueRefreshHUDMode
// (Final, Native, Protected)

void USettingsMenuWidget::QueueRefreshHUDMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuWidget", "QueueRefreshHUDMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuWidget.SetAntiAliasingMethod
// (Final, Native, Protected)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USettingsMenuWidget::SetAntiAliasingMethod(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuWidget", "SetAntiAliasingMethod");

	Params::SettingsMenuWidget_SetAntiAliasingMethod Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuWidget.SetAntiAliasingQuality
// (Final, Native, Protected)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USettingsMenuWidget::SetAntiAliasingQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuWidget", "SetAntiAliasingQuality");

	Params::SettingsMenuWidget_SetAntiAliasingQuality Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuWidget.SetFoliageQuality
// (Final, Native, Protected)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USettingsMenuWidget::SetFoliageQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuWidget", "SetFoliageQuality");

	Params::SettingsMenuWidget_SetFoliageQuality Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuWidget.SetGraphicsQuality
// (Final, Native, Protected)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USettingsMenuWidget::SetGraphicsQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuWidget", "SetGraphicsQuality");

	Params::SettingsMenuWidget_SetGraphicsQuality Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuWidget.SetPostProcessingQuality
// (Final, Native, Protected)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USettingsMenuWidget::SetPostProcessingQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuWidget", "SetPostProcessingQuality");

	Params::SettingsMenuWidget_SetPostProcessingQuality Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuWidget.SetShadowQuality
// (Final, Native, Protected)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USettingsMenuWidget::SetShadowQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuWidget", "SetShadowQuality");

	Params::SettingsMenuWidget_SetShadowQuality Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuWidget.SetSSGIQuality
// (Final, Native, Protected)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USettingsMenuWidget::SetSSGIQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuWidget", "SetSSGIQuality");

	Params::SettingsMenuWidget_SetSSGIQuality Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuWidget.SetTextureQuality
// (Final, Native, Protected)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USettingsMenuWidget::SetTextureQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuWidget", "SetTextureQuality");

	Params::SettingsMenuWidget_SetTextureQuality Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuWidget.SetViewDistanceQuality
// (Final, Native, Protected)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USettingsMenuWidget::SetViewDistanceQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuWidget", "SetViewDistanceQuality");

	Params::SettingsMenuWidget_SetViewDistanceQuality Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuWidget.SetVisualEffectQuality
// (Final, Native, Protected)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USettingsMenuWidget::SetVisualEffectQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuWidget", "SetVisualEffectQuality");

	Params::SettingsMenuWidget_SetVisualEffectQuality Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuWidget.UpdateDialogTimerText
// (Final, Native, Private)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USettingsMenuWidget::UpdateDialogTimerText(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuWidget", "UpdateDialogTimerText");

	Params::SettingsMenuWidget_UpdateDialogTimerText Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuWidget.ValueChanged
// (Final, Native, Public)
// Parameters:
// class UUserSetting*                     UserSetting                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USettingsMenuWidget::ValueChanged(class UUserSetting* UserSetting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuWidget", "ValueChanged");

	Params::SettingsMenuWidget_ValueChanged Parms{};

	Parms.UserSetting = UserSetting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ComputerTerminalAudioComponent.Play
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EComputerTerminalEventType              Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UComputerTerminalAudioComponent::Play(EComputerTerminalEventType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComputerTerminalAudioComponent", "Play");

	Params::ComputerTerminalAudioComponent_Play Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ComputerTerminalAudioComponent.Stop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EComputerTerminalEventType              Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UComputerTerminalAudioComponent::Stop(EComputerTerminalEventType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComputerTerminalAudioComponent", "Stop");

	Params::ComputerTerminalAudioComponent_Stop Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ComputerTerminalHeaderWidget.FadeInLogoImage
// (Event, Protected, BlueprintEvent)

void UComputerTerminalHeaderWidget::FadeInLogoImage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComputerTerminalHeaderWidget", "FadeInLogoImage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.ConsumableAmmoPool.GetNextConsumableClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UConsumableItem>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UConsumableItem> UConsumableAmmoPool::GetNextConsumableClass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsumableAmmoPool", "GetNextConsumableClass");

	Params::ConsumableAmmoPool_GetNextConsumableClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Container.GetItemsInContainer
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UItem*>                    OutItems                                               (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AContainer::GetItemsInContainer(TArray<class UItem*>* OutItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Container", "GetItemsInContainer");

	Params::Container_GetItemsInContainer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItems != nullptr)
		*OutItems = std::move(Parms.OutItems);
}


// Function Indiana.Container.HandleItemAdded
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AContainer::HandleItemAdded(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Container", "HandleItemAdded");

	Params::Container_HandleItemAdded Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Container.HandleItemCountChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AContainer::HandleItemCountChanged(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Container", "HandleItemCountChanged");

	Params::Container_HandleItemCountChanged Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Container.HandleItemRemoved
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AContainer::HandleItemRemoved(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Container", "HandleItemRemoved");

	Params::Container_HandleItemRemoved Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Container.IsLightEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AContainer::IsLightEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Container", "IsLightEnabled");

	Params::Container_IsLightEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ConversationBlueprintLibrary.AddConversationEndedDelegate
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InstanceId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       Event                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UConversationBlueprintLibrary::AddConversationEndedDelegate(int32 InstanceId, const TDelegate<void()>& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationBlueprintLibrary", "AddConversationEndedDelegate");

	Params::ConversationBlueprintLibrary_AddConversationEndedDelegate Parms{};

	Parms.InstanceId = InstanceId;
	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationBlueprintLibrary.AssignAllParticipantsAsOverrides
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConversationDescription         Description                                            (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           OverrideActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationBlueprintLibrary::AssignAllParticipantsAsOverrides(struct FConversationDescription& Description, class AActor* OverrideActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationBlueprintLibrary", "AssignAllParticipantsAsOverrides");

	Params::ConversationBlueprintLibrary_AssignAllParticipantsAsOverrides Parms{};

	Parms.Description = std::move(Description);
	Parms.OverrideActor = OverrideActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Description = std::move(Parms.Description);
}


// Function Indiana.ConversationBlueprintLibrary.CanStartConversation
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ECheckBranches                          Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UConversationData*                Conversation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StartNode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCharacterDescription>    OverrideCharacters                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bAllowedDuringCombat                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConversationBlueprintLibrary::CanStartConversation(ECheckBranches* Branches, class UConversationData* Conversation, int32 StartNode, const TArray<struct FCharacterDescription>& OverrideCharacters, bool bAllowedDuringCombat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationBlueprintLibrary", "CanStartConversation");

	Params::ConversationBlueprintLibrary_CanStartConversation Parms{};

	Parms.Conversation = Conversation;
	Parms.StartNode = StartNode;
	Parms.OverrideCharacters = std::move(OverrideCharacters);
	Parms.bAllowedDuringCombat = bAllowedDuringCombat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function Indiana.ConversationBlueprintLibrary.CanStartConversationByDescription
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ECheckBranches                          Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FConversationDescription         Description                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConversationBlueprintLibrary::CanStartConversationByDescription(ECheckBranches* Branches, const struct FConversationDescription& Description)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationBlueprintLibrary", "CanStartConversationByDescription");

	Params::ConversationBlueprintLibrary_CanStartConversationByDescription Parms{};

	Parms.Description = std::move(Description);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function Indiana.ConversationBlueprintLibrary.EndConversation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ConversationInstanceID                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UConversationBlueprintLibrary::EndConversation(int32 ConversationInstanceID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationBlueprintLibrary", "EndConversation");

	Params::ConversationBlueprintLibrary_EndConversation Parms{};

	Parms.ConversationInstanceID = ConversationInstanceID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ConversationBlueprintLibrary.GetSpeakerGameDataReferences
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UConversationData*                ConversationData                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSpeakerGameDataReferenceID>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FSpeakerGameDataReferenceID> UConversationBlueprintLibrary::GetSpeakerGameDataReferences(class UConversationData* ConversationData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationBlueprintLibrary", "GetSpeakerGameDataReferences");

	Params::ConversationBlueprintLibrary_GetSpeakerGameDataReferences Parms{};

	Parms.ConversationData = ConversationData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ConversationBlueprintLibrary.MakeCharacterDescription
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCharacterDescription            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCharacterDescription UConversationBlueprintLibrary::MakeCharacterDescription(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationBlueprintLibrary", "MakeCharacterDescription");

	Params::ConversationBlueprintLibrary_MakeCharacterDescription Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ConversationBlueprintLibrary.StartConversation
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ECheckBranches                          Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InstanceId                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UConversationData*                Conversation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StartNode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCharacterDescription>    OverrideCharacters                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bAllowedDuringCombat                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConversationBlueprintLibrary::StartConversation(ECheckBranches* Branches, int32* InstanceId, class UConversationData* Conversation, int32 StartNode, const TArray<struct FCharacterDescription>& OverrideCharacters, bool bAllowedDuringCombat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationBlueprintLibrary", "StartConversation");

	Params::ConversationBlueprintLibrary_StartConversation Parms{};

	Parms.Conversation = Conversation;
	Parms.StartNode = StartNode;
	Parms.OverrideCharacters = std::move(OverrideCharacters);
	Parms.bAllowedDuringCombat = bAllowedDuringCombat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	if (InstanceId != nullptr)
		*InstanceId = Parms.InstanceId;

	return Parms.ReturnValue;
}


// Function Indiana.ConversationBlueprintLibrary.StartConversationByDescription
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ECheckBranches                          Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FConversationDescription         Description                                            (Parm, NativeAccessSpecifierPublic)
// int32                                   InstanceId                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConversationBlueprintLibrary::StartConversationByDescription(ECheckBranches* Branches, const struct FConversationDescription& Description, int32* InstanceId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationBlueprintLibrary", "StartConversationByDescription");

	Params::ConversationBlueprintLibrary_StartConversationByDescription Parms{};

	Parms.Description = std::move(Description);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	if (InstanceId != nullptr)
		*InstanceId = Parms.InstanceId;

	return Parms.ReturnValue;
}


// Function Indiana.ConversationBlueprintLibrary.StartConversationByDescriptionAtNode
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ECheckBranches                          Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FConversationDescription         Description                                            (Parm, NativeAccessSpecifierPublic)
// int32                                   StartNode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InstanceId                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConversationBlueprintLibrary::StartConversationByDescriptionAtNode(ECheckBranches* Branches, const struct FConversationDescription& Description, int32 StartNode, int32* InstanceId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationBlueprintLibrary", "StartConversationByDescriptionAtNode");

	Params::ConversationBlueprintLibrary_StartConversationByDescriptionAtNode Parms{};

	Parms.Description = std::move(Description);
	Parms.StartNode = StartNode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	if (InstanceId != nullptr)
		*InstanceId = Parms.InstanceId;

	return Parms.ReturnValue;
}


// Function Indiana.ConversationBlueprintLibrary.StartConversationWithActorInterface
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ECheckBranches                          Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TScriptInterface<class IConversationActorInterface>Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// int32                                   StartNode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InstanceId                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConversationBlueprintLibrary::StartConversationWithActorInterface(ECheckBranches* Branches, TScriptInterface<class IConversationActorInterface> Actor, int32 StartNode, int32* InstanceId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationBlueprintLibrary", "StartConversationWithActorInterface");

	Params::ConversationBlueprintLibrary_StartConversationWithActorInterface Parms{};

	Parms.Actor = Actor;
	Parms.StartNode = StartNode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	if (InstanceId != nullptr)
		*InstanceId = Parms.InstanceId;

	return Parms.ReturnValue;
}


// Function Indiana.ConversationBlueprintLibrary.StartPlayerControllerConversation
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ECheckBranches                          Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InstanceId                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UConversationData*                ConversationData                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StartNode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCharacterDescription>    OverrideCharacters                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bAllowedDuringCombat                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConversationBlueprintLibrary::StartPlayerControllerConversation(ECheckBranches* Branches, int32* InstanceId, class UConversationData* ConversationData, int32 StartNode, const TArray<struct FCharacterDescription>& OverrideCharacters, bool bAllowedDuringCombat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationBlueprintLibrary", "StartPlayerControllerConversation");

	Params::ConversationBlueprintLibrary_StartPlayerControllerConversation Parms{};

	Parms.ConversationData = ConversationData;
	Parms.StartNode = StartNode;
	Parms.OverrideCharacters = std::move(OverrideCharacters);
	Parms.bAllowedDuringCombat = bAllowedDuringCombat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	if (InstanceId != nullptr)
		*InstanceId = Parms.InstanceId;

	return Parms.ReturnValue;
}


// Function Indiana.ConversationBlueprintLibrary.StartSlideshow
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UConversationData*                Conversation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InstanceId                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConversationBlueprintLibrary::StartSlideshow(class UConversationData* Conversation, int32* InstanceId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConversationBlueprintLibrary", "StartSlideshow");

	Params::ConversationBlueprintLibrary_StartSlideshow Parms{};

	Parms.Conversation = Conversation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InstanceId != nullptr)
		*InstanceId = Parms.InstanceId;

	return Parms.ReturnValue;
}


// Function Indiana.ConversationInstance.GetPayloadActorChecked
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// EPayloadID                              Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECheckBranches                          Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UConversationInstance::GetPayloadActorChecked(EPayloadID Key, ECheckBranches* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationInstance", "GetPayloadActorChecked");

	Params::ConversationInstance_GetPayloadActorChecked Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function Indiana.ConversationInstance.OnCharacterCombatStateChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bInCombat                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationInstance::OnCharacterCombatStateChange(bool bInCombat, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationInstance", "OnCharacterCombatStateChange");

	Params::ConversationInstance_OnCharacterCombatStateChange Parms{};

	Parms.bInCombat = bInCombat;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationInstance.OnCharacterDeath
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCauseDamageInfo                 CauseDamageInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UConversationInstance::OnCharacterDeath(class AActor* Instigator, const struct FCauseDamageInfo& CauseDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationInstance", "OnCharacterDeath");

	Params::ConversationInstance_OnCharacterDeath Parms{};

	Parms.Instigator = Instigator;
	Parms.CauseDamageInfo = std::move(CauseDamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationInstance.OnParticipantEndPlay
// (Final, Native, Public)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEndPlayReason                          Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationInstance::OnParticipantEndPlay(class AActor* Actor, EEndPlayReason Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationInstance", "OnParticipantEndPlay");

	Params::ConversationInstance_OnParticipantEndPlay Parms{};

	Parms.Actor = Actor;
	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationInstance.GetCurrentSpeakerGameDataReferenceID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSpeakerGameDataReferenceID      ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FSpeakerGameDataReferenceID UConversationInstance::GetCurrentSpeakerGameDataReferenceID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationInstance", "GetCurrentSpeakerGameDataReferenceID");

	Params::ConversationInstance_GetCurrentSpeakerGameDataReferenceID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ConversationInstance.IsCurrentSpeakerGameDataReferenceID
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSpeakerGameDataReferenceID      SpeakerGameData                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConversationInstance::IsCurrentSpeakerGameDataReferenceID(const struct FSpeakerGameDataReferenceID& SpeakerGameData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationInstance", "IsCurrentSpeakerGameDataReferenceID");

	Params::ConversationInstance_IsCurrentSpeakerGameDataReferenceID Parms{};

	Parms.SpeakerGameData = std::move(SpeakerGameData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.SkillCheckInterruption.MontageFinished
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillCheckInterruption::MontageFinished(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCheckInterruption", "MontageFinished");

	Params::SkillCheckInterruption_MontageFinished Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationMessageWidget.ContentLerpTick
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationMessageWidget::ContentLerpTick(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationMessageWidget", "ContentLerpTick");

	Params::ConversationMessageWidget_ContentLerpTick Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationWidget.OnConversationEnded
// (Final, Native, Protected)

void UConversationWidget::OnConversationEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationWidget", "OnConversationEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationWidget.OnHistoryScroll
// (Final, Native, Protected)
// Parameters:
// float                                   InputDelta                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationWidget::OnHistoryScroll(float InputDelta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationWidget", "OnHistoryScroll");

	Params::ConversationWidget_OnHistoryScroll Parms{};

	Parms.InputDelta = InputDelta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationWidget.OnHistoryToggleInputAction
// (Final, Native, Protected)

void UConversationWidget::OnHistoryToggleInputAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationWidget", "OnHistoryToggleInputAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ConversationWidget.SetConversationBackingFillRatio
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   DesiredOverlayHeight                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationWidget::SetConversationBackingFillRatio(float DesiredOverlayHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationWidget", "SetConversationBackingFillRatio");

	Params::ConversationWidget_SetConversationBackingFillRatio Parms{};

	Parms.DesiredOverlayHeight = DesiredOverlayHeight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.ConversationWidget.SetHistoryBackingFillRatio
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   DesiredHistoryHeight                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConversationWidget::SetHistoryBackingFillRatio(float DesiredHistoryHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationWidget", "SetHistoryBackingFillRatio");

	Params::ConversationWidget_SetHistoryBackingFillRatio Parms{};

	Parms.DesiredHistoryHeight = DesiredHistoryHeight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.ConversationWidget.ShouldShowInputLabelLine
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConversationWidget::ShouldShowInputLabelLine()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationWidget", "ShouldShowInputLabelLine");

	Params::ConversationWidget_ShouldShowInputLabelLine Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ConversationWidget.ShouldShowResponseLine
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConversationWidget::ShouldShowResponseLine()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConversationWidget", "ShouldShowResponseLine");

	Params::ConversationWidget_ShouldShowResponseLine Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.QuestObjectiveWidget.OnObjectiveStatusChange
// (Event, Protected, BlueprintEvent)
// Parameters:
// ECompletionStatus                       ObjectiveStatus                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestObjectiveWidget::OnObjectiveStatusChange(ECompletionStatus ObjectiveStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestObjectiveWidget", "OnObjectiveStatusChange");

	Params::QuestObjectiveWidget_OnObjectiveStatusChange Parms{};

	Parms.ObjectiveStatus = ObjectiveStatus;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.CustomMaterialModVisual.Apply
// (Event, Protected, BlueprintEvent)

void UCustomMaterialModVisual::Apply()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomMaterialModVisual", "Apply");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.CustomMaterialModVisual.ApplyScalarParam
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             MaterialSlotName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ParamValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomMaterialModVisual::ApplyScalarParam(class FName MaterialSlotName, class FName ParamName, float ParamValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomMaterialModVisual", "ApplyScalarParam");

	Params::CustomMaterialModVisual_ApplyScalarParam Parms{};

	Parms.MaterialSlotName = MaterialSlotName;
	Parms.ParamName = ParamName;
	Parms.ParamValue = ParamValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CustomMaterialModVisual.ApplyScalarParamToAll
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ParamValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OnlyApplyIfParamSet                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomMaterialModVisual::ApplyScalarParamToAll(class FName ParamName, float ParamValue, class FName OnlyApplyIfParamSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomMaterialModVisual", "ApplyScalarParamToAll");

	Params::CustomMaterialModVisual_ApplyScalarParamToAll Parms{};

	Parms.ParamName = ParamName;
	Parms.ParamValue = ParamValue;
	Parms.OnlyApplyIfParamSet = OnlyApplyIfParamSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CustomMaterialModVisual.ApplyTextureParam
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             MaterialSlotName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture>          ParamValue                                             (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomMaterialModVisual::ApplyTextureParam(class FName MaterialSlotName, class FName ParamName, TSoftObjectPtr<class UTexture> ParamValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomMaterialModVisual", "ApplyTextureParam");

	Params::CustomMaterialModVisual_ApplyTextureParam Parms{};

	Parms.MaterialSlotName = MaterialSlotName;
	Parms.ParamName = ParamName;
	Parms.ParamValue = ParamValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CustomMaterialModVisual.ApplyTextureParamToAll
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture>          ParamValue                                             (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OnlyApplyIfParamSet                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomMaterialModVisual::ApplyTextureParamToAll(class FName ParamName, TSoftObjectPtr<class UTexture> ParamValue, class FName OnlyApplyIfParamSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomMaterialModVisual", "ApplyTextureParamToAll");

	Params::CustomMaterialModVisual_ApplyTextureParamToAll Parms{};

	Parms.ParamName = ParamName;
	Parms.ParamValue = ParamValue;
	Parms.OnlyApplyIfParamSet = OnlyApplyIfParamSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CustomMaterialModVisual.ApplyVectorParam
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             MaterialSlotName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ParamValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomMaterialModVisual::ApplyVectorParam(class FName MaterialSlotName, class FName ParamName, const struct FLinearColor& ParamValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomMaterialModVisual", "ApplyVectorParam");

	Params::CustomMaterialModVisual_ApplyVectorParam Parms{};

	Parms.MaterialSlotName = MaterialSlotName;
	Parms.ParamName = ParamName;
	Parms.ParamValue = std::move(ParamValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CustomMaterialModVisual.ApplyVectorParamToAll
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ParamValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OnlyApplyIfParamSet                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomMaterialModVisual::ApplyVectorParamToAll(class FName ParamName, const struct FLinearColor& ParamValue, class FName OnlyApplyIfParamSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomMaterialModVisual", "ApplyVectorParamToAll");

	Params::CustomMaterialModVisual_ApplyVectorParamToAll Parms{};

	Parms.ParamName = ParamName;
	Parms.ParamValue = std::move(ParamValue);
	Parms.OnlyApplyIfParamSet = OnlyApplyIfParamSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.CustomMaterialModVisual.CopyParamOverrides
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DestinationSlotName                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomMaterialModVisual::CopyParamOverrides(class UMaterialInstanceDynamic* Source, class FName DestinationSlotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomMaterialModVisual", "CopyParamOverrides");

	Params::CustomMaterialModVisual_CopyParamOverrides Parms{};

	Parms.Source = Source;
	Parms.DestinationSlotName = DestinationSlotName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DecisionTreeComponent.OnActionToggled
// (Final, Native, Private)
// Parameters:
// ETogglableAction                        Action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bToggled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecisionTreeComponent::OnActionToggled(ETogglableAction Action, bool bToggled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecisionTreeComponent", "OnActionToggled");

	Params::DecisionTreeComponent_OnActionToggled Parms{};

	Parms.Action = Action;
	Parms.bToggled = bToggled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DecisionTreeComponent.OnAlertStateChange
// (Final, Native, Private)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAlertState                             PreviousAlertState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAlertState                             TargetAlertState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecisionTreeComponent::OnAlertStateChange(class AActor* TargetActor, EAlertState PreviousAlertState, EAlertState TargetAlertState, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecisionTreeComponent", "OnAlertStateChange");

	Params::DecisionTreeComponent_OnAlertStateChange Parms{};

	Parms.TargetActor = TargetActor;
	Parms.PreviousAlertState = PreviousAlertState;
	Parms.TargetAlertState = TargetAlertState;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DecisionTreeComponent.OnBehaviorPhaseChange
// (Final, Native, Private)
// Parameters:
// int32                                   NewBehaviorPhase                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecisionTreeComponent::OnBehaviorPhaseChange(int32 NewBehaviorPhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecisionTreeComponent", "OnBehaviorPhaseChange");

	Params::DecisionTreeComponent_OnBehaviorPhaseChange Parms{};

	Parms.NewBehaviorPhase = NewBehaviorPhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DecisionTreeComponent.OnCombatStateChange
// (Final, Native, Private)
// Parameters:
// bool                                    bIsInCombat                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecisionTreeComponent::OnCombatStateChange(bool bIsInCombat, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecisionTreeComponent", "OnCombatStateChange");

	Params::DecisionTreeComponent_OnCombatStateChange Parms{};

	Parms.bIsInCombat = bIsInCombat;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DecisionTreeComponent.OnDefaultBehaviorChange
// (Final, Native, Private)
// Parameters:
// class UAISettings_Behavior*             NewDefaultBehavior                                     (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFullReset                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecisionTreeComponent::OnDefaultBehaviorChange(const class UAISettings_Behavior* NewDefaultBehavior, bool bFullReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecisionTreeComponent", "OnDefaultBehaviorChange");

	Params::DecisionTreeComponent_OnDefaultBehaviorChange Parms{};

	Parms.NewDefaultBehavior = NewDefaultBehavior;
	Parms.bFullReset = bFullReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DecisionTreeComponent.OnNearbyInterestPoint
// (Final, Native, Private)
// Parameters:
// class UFurnitureComponent*              InterestPoint                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecisionTreeComponent::OnNearbyInterestPoint(class UFurnitureComponent* InterestPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecisionTreeComponent", "OnNearbyInterestPoint");

	Params::DecisionTreeComponent_OnNearbyInterestPoint Parms{};

	Parms.InterestPoint = InterestPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DecisionTreeComponent.OnNewTarget
// (Final, Native, Private)

void UDecisionTreeComponent::OnNewTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecisionTreeComponent", "OnNewTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DecisionTreeComponent.OnPlayerConversationChange
// (Final, Native, Private)
// Parameters:
// class UConversationInstance*            Instance                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEntered                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecisionTreeComponent::OnPlayerConversationChange(const class UConversationInstance* Instance, bool bEntered)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecisionTreeComponent", "OnPlayerConversationChange");

	Params::DecisionTreeComponent_OnPlayerConversationChange Parms{};

	Parms.Instance = Instance;
	Parms.bEntered = bEntered;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DecisionTreeComponent.OnPlayerConversationProximityChange
// (Final, Native, Private)
// Parameters:
// bool                                    bInProximity                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecisionTreeComponent::OnPlayerConversationProximityChange(bool bInProximity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecisionTreeComponent", "OnPlayerConversationProximityChange");

	Params::DecisionTreeComponent_OnPlayerConversationProximityChange Parms{};

	Parms.bInProximity = bInProximity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DecisionTreeComponent.OnPlayerProximityChange
// (Final, Native, Private)
// Parameters:
// bool                                    bEnteredProximity                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecisionTreeComponent::OnPlayerProximityChange(bool bEnteredProximity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecisionTreeComponent", "OnPlayerProximityChange");

	Params::DecisionTreeComponent_OnPlayerProximityChange Parms{};

	Parms.bEnteredProximity = bEnteredProximity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DecisionTreeComponent.OnReactiveRangeAction
// (Final, Native, Private)

void UDecisionTreeComponent::OnReactiveRangeAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecisionTreeComponent", "OnReactiveRangeAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DecisionTreeComponent.OnScriptedBehaviorCall
// (Final, Native, Private)
// Parameters:
// class UAISettings_Behavior*             ScriptedBehavior                                       (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterruptible                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecisionTreeComponent::OnScriptedBehaviorCall(const class UAISettings_Behavior* ScriptedBehavior, bool bInterruptible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecisionTreeComponent", "OnScriptedBehaviorCall");

	Params::DecisionTreeComponent_OnScriptedBehaviorCall Parms{};

	Parms.ScriptedBehavior = ScriptedBehavior;
	Parms.bInterruptible = bInterruptible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DecisionTreeComponent.OnStartTraverse
// (Final, Native, Private)
// Parameters:
// ETraverseType                           TraverseType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NavLinkDirection                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AReservableNavLink*               ReservableNavLink                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALadder*                          ClimbLadder                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecisionTreeComponent::OnStartTraverse(ETraverseType TraverseType, int32 NavLinkDirection, class AReservableNavLink* ReservableNavLink, class ALadder* ClimbLadder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecisionTreeComponent", "OnStartTraverse");

	Params::DecisionTreeComponent_OnStartTraverse Parms{};

	Parms.TraverseType = TraverseType;
	Parms.NavLinkDirection = NavLinkDirection;
	Parms.ReservableNavLink = ReservableNavLink;
	Parms.ClimbLadder = ClimbLadder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DecisionTreeComponent.OnStateOfBeingChange
// (Final, Native, Private)
// Parameters:
// EStateOfBeing                           NewStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStateOfBeing                           OldStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecisionTreeComponent::OnStateOfBeingChange(EStateOfBeing NewStateOfBeing, EStateOfBeing OldStateOfBeing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecisionTreeComponent", "OnStateOfBeingChange");

	Params::DecisionTreeComponent_OnStateOfBeingChange Parms{};

	Parms.NewStateOfBeing = NewStateOfBeing;
	Parms.OldStateOfBeing = OldStateOfBeing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DecisionTreeComponent.OnStatusEffectAdded
// (Final, Native, Private)
// Parameters:
// class UStatusEffectManagerComponent*    Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffect*                    StatusEffect                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecisionTreeComponent::OnStatusEffectAdded(class UStatusEffectManagerComponent* Sender, class UStatusEffect* StatusEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecisionTreeComponent", "OnStatusEffectAdded");

	Params::DecisionTreeComponent_OnStatusEffectAdded Parms{};

	Parms.Sender = Sender;
	Parms.StatusEffect = StatusEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DecisionTreeComponent.OnTether
// (Final, Native, Private, HasDefaults)
// Parameters:
// bool                                    bCanceled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TetherReturnLocation                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecisionTreeComponent::OnTether(bool bCanceled, const struct FVector& TetherReturnLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecisionTreeComponent", "OnTether");

	Params::DecisionTreeComponent_OnTether Parms{};

	Parms.bCanceled = bCanceled;
	Parms.TetherReturnLocation = std::move(TetherReturnLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DecisionTreeComponent.OnWeaponPreferenceChange
// (Final, Native, Private)
// Parameters:
// EWeaponPreference                       NewWeaponPreference                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWeaponPreference                       OldWeaponPreference                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecisionTreeComponent::OnWeaponPreferenceChange(EWeaponPreference NewWeaponPreference, EWeaponPreference OldWeaponPreference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecisionTreeComponent", "OnWeaponPreferenceChange");

	Params::DecisionTreeComponent_OnWeaponPreferenceChange Parms{};

	Parms.NewWeaponPreference = NewWeaponPreference;
	Parms.OldWeaponPreference = OldWeaponPreference;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DestructibleAudioComponent.Play
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDestructibleEventType                  Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDestructibleAudioComponent::Play(EDestructibleEventType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DestructibleAudioComponent", "Play");

	Params::DestructibleAudioComponent_Play Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DestructibleAudioComponent.Stop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDestructibleEventType                  Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDestructibleAudioComponent::Stop(EDestructibleEventType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DestructibleAudioComponent", "Stop");

	Params::DestructibleAudioComponent_Stop Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DestructibleShoutComponent.OnDestructibleDestroyed
// (Final, Native, Private)
// Parameters:
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDestructibleShoutComponent::OnDestructibleDestroyed(class AActor* Instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DestructibleShoutComponent", "OnDestructibleDestroyed");

	Params::DestructibleShoutComponent_OnDestructibleDestroyed Parms{};

	Parms.Instigator = Instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DevelopmentFunctionality.Bug
// (Final, Exec, Native, Protected)

void UDevelopmentFunctionality::Bug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DevelopmentFunctionality", "Bug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DevelopmentFunctionality.CharacterMemReport
// (Final, Exec, Native, Protected)

void UDevelopmentFunctionality::CharacterMemReport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DevelopmentFunctionality", "CharacterMemReport");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DevelopmentFunctionality.Crash
// (Final, Exec, Native, Protected)

void UDevelopmentFunctionality::Crash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DevelopmentFunctionality", "Crash");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DevelopmentFunctionality.DebugDrawLightmapInfo
// (Final, Exec, Native, Protected)
// Parameters:
// class FString                           LightmapName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDevelopmentFunctionality::DebugDrawLightmapInfo(const class FString& LightmapName, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DevelopmentFunctionality", "DebugDrawLightmapInfo");

	Params::DevelopmentFunctionality_DebugDrawLightmapInfo Parms{};

	Parms.LightmapName = std::move(LightmapName);
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DevelopmentFunctionality.DebugDrawLightmapNamesPerComponent
// (Final, Exec, Native, Protected)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LightmapTextureIndex                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDevelopmentFunctionality::DebugDrawLightmapNamesPerComponent(float Duration, int32 LightmapTextureIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DevelopmentFunctionality", "DebugDrawLightmapNamesPerComponent");

	Params::DevelopmentFunctionality_DebugDrawLightmapNamesPerComponent Parms{};

	Parms.Duration = Duration;
	Parms.LightmapTextureIndex = LightmapTextureIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DevelopmentFunctionality.DebugDrawLightmapNamesSummary
// (Final, Exec, Native, Protected)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LightmapTextureIndex                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VolumeThreshold                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDevelopmentFunctionality::DebugDrawLightmapNamesSummary(float Duration, int32 LightmapTextureIndex, float VolumeThreshold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DevelopmentFunctionality", "DebugDrawLightmapNamesSummary");

	Params::DevelopmentFunctionality_DebugDrawLightmapNamesSummary Parms{};

	Parms.Duration = Duration;
	Parms.LightmapTextureIndex = LightmapTextureIndex;
	Parms.VolumeThreshold = VolumeThreshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DevelopmentFunctionality.DumpNameTable
// (Final, Exec, Native, Protected)

void UDevelopmentFunctionality::DumpNameTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DevelopmentFunctionality", "DumpNameTable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DevelopmentFunctionality.EndInfoTracking
// (Final, Exec, Native, Protected)

void UDevelopmentFunctionality::EndInfoTracking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DevelopmentFunctionality", "EndInfoTracking");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DevelopmentFunctionality.FlushAsyncLoading
// (Final, Exec, Native, Protected)

void UDevelopmentFunctionality::FlushAsyncLoading()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DevelopmentFunctionality", "FlushAsyncLoading");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DevelopmentFunctionality.FlushLevelStreaming
// (Final, Exec, Native, Protected)

void UDevelopmentFunctionality::FlushLevelStreaming()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DevelopmentFunctionality", "FlushLevelStreaming");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DevelopmentFunctionality.StartInfoTracking
// (Final, Exec, Native, Protected)
// Parameters:
// float                                   TrackRate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTrackStats                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDevelopmentFunctionality::StartInfoTracking(float TrackRate, bool bTrackStats)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DevelopmentFunctionality", "StartInfoTracking");

	Params::DevelopmentFunctionality_StartInfoTracking Parms{};

	Parms.TrackRate = TrackRate;
	Parms.bTrackStats = bTrackStats;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DevelopmentFunctionality.Task
// (Final, Exec, Native, Protected)

void UDevelopmentFunctionality::Task()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DevelopmentFunctionality", "Task");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DevelopmentFunctionality.ToggleTempVO
// (Final, Exec, Native, Protected)

void UDevelopmentFunctionality::ToggleTempVO()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DevelopmentFunctionality", "ToggleTempVO");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DialogWarningBoxWidget.OnInputBack
// (Final, Native, Protected)

void UDialogWarningBoxWidget::OnInputBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DialogWarningBoxWidget", "OnInputBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.DialogWarningBoxWidget.OnInputConfirm
// (Final, Native, Protected)

void UDialogWarningBoxWidget::OnInputConfirm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DialogWarningBoxWidget", "OnInputConfirm");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ElevatorAudioComponent.Play
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EElevatorEventType                      Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UElevatorAudioComponent::Play(EElevatorEventType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ElevatorAudioComponent", "Play");

	Params::ElevatorAudioComponent_Play Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ElevatorAudioComponent.Stop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EElevatorEventType                      Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UElevatorAudioComponent::Stop(EElevatorEventType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ElevatorAudioComponent", "Stop");

	Params::ElevatorAudioComponent_Stop Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EnemyScannerWidget.ScanCompleted
// (Final, Native, Protected)

void UEnemyScannerWidget::ScanCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyScannerWidget", "ScanCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EnemyScannerWidget.ScanEnded
// (Final, Native, Protected)

void UEnemyScannerWidget::ScanEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyScannerWidget", "ScanEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OptionSliderWidget.OnSliderValueChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FSliderEvent                     Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UOptionSliderWidget::OnSliderValueChanged(const struct FSliderEvent& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionSliderWidget", "OnSliderValueChanged");

	Params::OptionSliderWidget_OnSliderValueChanged Parms{};

	Parms.Event = std::move(Event);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OCLAudioComponent.Play
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOCLEventType                           Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOCLAudioComponent::Play(EOCLEventType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OCLAudioComponent", "Play");

	Params::OCLAudioComponent_Play Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OCLAudioComponent.Stop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOCLEventType                           Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOCLAudioComponent::Stop(EOCLEventType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OCLAudioComponent", "Stop");

	Params::OCLAudioComponent_Stop Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.WorkbenchPageWidget.OnDragDrop_ClearArmorSlot
// (Final, Native, Protected)
// Parameters:
// class UIndianaDragDropOperation*        Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorkbenchPageWidget::OnDragDrop_ClearArmorSlot(class UIndianaDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorkbenchPageWidget", "OnDragDrop_ClearArmorSlot");

	Params::WorkbenchPageWidget_OnDragDrop_ClearArmorSlot Parms{};

	Parms.Operation = Operation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.WorkbenchPageWidget.OnDragDrop_SetWeaponSlot
// (Final, Native, Protected)
// Parameters:
// class UIndianaDragDropOperation*        Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorkbenchPageWidget::OnDragDrop_SetWeaponSlot(class UIndianaDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorkbenchPageWidget", "OnDragDrop_SetWeaponSlot");

	Params::WorkbenchPageWidget_OnDragDrop_SetWeaponSlot Parms{};

	Parms.Operation = Operation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.WorkbenchPageWidget.OnDragDrop_SwapWeaponSlot
// (Final, Native, Protected)
// Parameters:
// class UIndianaDragDropOperation*        Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorkbenchPageWidget::OnDragDrop_SwapWeaponSlot(class UIndianaDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorkbenchPageWidget", "OnDragDrop_SwapWeaponSlot");

	Params::WorkbenchPageWidget_OnDragDrop_SwapWeaponSlot Parms{};

	Parms.Operation = Operation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.WorkbenchPageWidget.OnItemRemoved
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UWorkbenchPageWidget::OnItemRemoved(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorkbenchPageWidget", "OnItemRemoved");

	Params::WorkbenchPageWidget_OnItemRemoved Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemStatsWidget.OnAlternateChanged
// (Final, Native, Protected)

void UItemStatsWidget::OnAlternateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemStatsWidget", "OnAlternateChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.WeaponSelectWidget.OnInputBack
// (Final, Native, Protected)

void UWeaponSelectWidget::OnInputBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponSelectWidget", "OnInputBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.WeaponSelectWidget.HasAmmo
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponSelectWidget::HasAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponSelectWidget", "HasAmmo");

	Params::WeaponSelectWidget_HasAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.WeaponSelectWidget.IsAmmoSectionValid
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponSelectWidget::IsAmmoSectionValid(int32 Index_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponSelectWidget", "IsAmmoSectionValid");

	Params::WeaponSelectWidget_IsAmmoSectionValid Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.WeaponSelectWidget.IsSectionValid
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponSelectWidget::IsSectionValid(int32 Index_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponSelectWidget", "IsSectionValid");

	Params::WeaponSelectWidget_IsSectionValid Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.WeaponSelectWidget.IsWeaponSectionValid
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponSelectWidget::IsWeaponSectionValid(int32 Index_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponSelectWidget", "IsWeaponSectionValid");

	Params::WeaponSelectWidget_IsWeaponSectionValid Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.InputGuideWidget.GetContentWidth
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInputGuideWidget::GetContentWidth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputGuideWidget", "GetContentWidth");

	Params::InputGuideWidget_GetContentWidth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.InputGuideWidget.InteractChanged
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputGuideWidget::InteractChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputGuideWidget", "InteractChanged");

	Params::InputGuideWidget_InteractChanged Parms{};

	Parms.bVisible = bVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.InputGuideWidget.OnInteractionProgressChange
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   CurrentProgressRatio                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputGuideWidget::OnInteractionProgressChange(float CurrentProgressRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputGuideWidget", "OnInteractionProgressChange");

	Params::InputGuideWidget_OnInteractionProgressChange Parms{};

	Parms.CurrentProgressRatio = CurrentProgressRatio;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.LogList.AddNewFoundLog
// (Final, Native, Protected)
// Parameters:
// struct FLocString                       ExaminableName                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLocString                       ExaminableDescription                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULogList::AddNewFoundLog(const struct FLocString& ExaminableName, const struct FLocString& ExaminableDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogList", "AddNewFoundLog");

	Params::LogList_AddNewFoundLog Parms{};

	Parms.ExaminableName = std::move(ExaminableName);
	Parms.ExaminableDescription = std::move(ExaminableDescription);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.EquipArmorByClassDebug
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EArmorSlot                              ArmorSlot                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UArmorItem>           ArmorItem                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::EquipArmorByClassDebug(EArmorSlot ArmorSlot, TSubclassOf<class UArmorItem> ArmorItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "EquipArmorByClassDebug");

	Params::EquipmentComponent_EquipArmorByClassDebug Parms{};

	Parms.ArmorSlot = ArmorSlot;
	Parms.ArmorItem = ArmorItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.EquipArmorDebug
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             ArmorName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::EquipArmorDebug(class FName ArmorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "EquipArmorDebug");

	Params::EquipmentComponent_EquipArmorDebug Parms{};

	Parms.ArmorName = ArmorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.EquipArmorModByClassDebug
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EArmorModSlot                           ArmorModSlot                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UArmorModItem>        ArmorModItem                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::EquipArmorModByClassDebug(EArmorModSlot ArmorModSlot, TSubclassOf<class UArmorModItem> ArmorModItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "EquipArmorModByClassDebug");

	Params::EquipmentComponent_EquipArmorModByClassDebug Parms{};

	Parms.ArmorModSlot = ArmorModSlot;
	Parms.ArmorModItem = ArmorModItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.EquipArmorSetMicroModDebug
// (Final, Exec, Native, Protected)
// Parameters:
// class FName                             MicroModName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::EquipArmorSetMicroModDebug(class FName MicroModName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "EquipArmorSetMicroModDebug");

	Params::EquipmentComponent_EquipArmorSetMicroModDebug Parms{};

	Parms.MicroModName = MicroModName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.EquipDefaultWeapon
// (Final, Native, Public, BlueprintCallable)

void UEquipmentComponent::EquipDefaultWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "EquipDefaultWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.EquipModDebug
// (Final, Exec, Native, Protected)
// Parameters:
// class FName                             ModName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::EquipModDebug(class FName ModName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "EquipModDebug");

	Params::EquipmentComponent_EquipModDebug Parms{};

	Parms.ModName = ModName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.EquipPreviousWeapon
// (Final, Exec, Native, Public)

void UEquipmentComponent::EquipPreviousWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "EquipPreviousWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.EquipWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWeapon*                          WeaponToEquip                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInstantEquip                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::EquipWeapon(class UWeapon* WeaponToEquip, bool bInstantEquip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "EquipWeapon");

	Params::EquipmentComponent_EquipWeapon Parms{};

	Parms.WeaponToEquip = WeaponToEquip;
	Parms.bInstantEquip = bInstantEquip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.EquipWeaponDebug
// (Final, Exec, Native, Protected)
// Parameters:
// class FName                             WeaponName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::EquipWeaponDebug(class FName WeaponName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "EquipWeaponDebug");

	Params::EquipmentComponent_EquipWeaponDebug Parms{};

	Parms.WeaponName = WeaponName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.EquipWeaponFromSlot
// (Final, Exec, Native, Public)
// Parameters:
// uint32                                  SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInstantEquip                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::EquipWeaponFromSlot(uint32 SlotIndex, bool bInstantEquip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "EquipWeaponFromSlot");

	Params::EquipmentComponent_EquipWeaponFromSlot Parms{};

	Parms.SlotIndex = SlotIndex;
	Parms.bInstantEquip = bInstantEquip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.EquipWeaponMicroModDebug
// (Final, Exec, Native, Protected)
// Parameters:
// class FName                             MicroModName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::EquipWeaponMicroModDebug(class FName MicroModName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "EquipWeaponMicroModDebug");

	Params::EquipmentComponent_EquipWeaponMicroModDebug Parms{};

	Parms.MicroModName = MicroModName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.HolsterWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHolsterRequestSource                   InSource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInstantHolster                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::HolsterWeapon(EHolsterRequestSource InSource, bool bInstantHolster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "HolsterWeapon");

	Params::EquipmentComponent_HolsterWeapon Parms{};

	Parms.InSource = InSource;
	Parms.bInstantHolster = bInstantHolster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.LoadAmmoDebug
// (Final, Exec, Native, Protected)
// Parameters:
// class FName                             AmmoName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::LoadAmmoDebug(class FName AmmoName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "LoadAmmoDebug");

	Params::EquipmentComponent_LoadAmmoDebug Parms{};

	Parms.AmmoName = AmmoName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.OnEndEquipWeapon
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::OnEndEquipWeapon(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "OnEndEquipWeapon");

	Params::EquipmentComponent_OnEndEquipWeapon Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.OnEndHolsterWeapon
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::OnEndHolsterWeapon(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "OnEndHolsterWeapon");

	Params::EquipmentComponent_OnEndHolsterWeapon Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.OnEndReloadWeapon
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::OnEndReloadWeapon(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "OnEndReloadWeapon");

	Params::EquipmentComponent_OnEndReloadWeapon Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.OnEndUnequipWeapon
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::OnEndUnequipWeapon(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "OnEndUnequipWeapon");

	Params::EquipmentComponent_OnEndUnequipWeapon Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.OnEndUnholsterWeapon
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::OnEndUnholsterWeapon(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "OnEndUnholsterWeapon");

	Params::EquipmentComponent_OnEndUnholsterWeapon Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.OnEquipDisguise
// (Final, Native, Public)
// Parameters:
// class UDisguiseData*                    Disguise                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::OnEquipDisguise(const class UDisguiseData* Disguise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "OnEquipDisguise");

	Params::EquipmentComponent_OnEquipDisguise Parms{};

	Parms.Disguise = Disguise;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.OnInterruptReloadWeapon
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::OnInterruptReloadWeapon(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "OnInterruptReloadWeapon");

	Params::EquipmentComponent_OnInterruptReloadWeapon Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.OnItemAddedToInventory
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UEquipmentComponent::OnItemAddedToInventory(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "OnItemAddedToInventory");

	Params::EquipmentComponent_OnItemAddedToInventory Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.OnItemRemovedFromInventory
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UEquipmentComponent::OnItemRemovedFromInventory(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "OnItemRemovedFromInventory");

	Params::EquipmentComponent_OnItemRemovedFromInventory Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.OnMedKitUsed
// (Final, Native, Protected)
// Parameters:
// int32                                   ConsumeablesUsed                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::OnMedKitUsed(int32 ConsumeablesUsed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "OnMedKitUsed");

	Params::EquipmentComponent_OnMedKitUsed Parms{};

	Parms.ConsumeablesUsed = ConsumeablesUsed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.OnStartClimb
// (Final, Native, Protected)

void UEquipmentComponent::OnStartClimb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "OnStartClimb");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.OnStartEquipWeapon
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::OnStartEquipWeapon(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "OnStartEquipWeapon");

	Params::EquipmentComponent_OnStartEquipWeapon Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.OnStartHolsterWeapon
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::OnStartHolsterWeapon(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "OnStartHolsterWeapon");

	Params::EquipmentComponent_OnStartHolsterWeapon Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.OnStartReloadWeapon
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::OnStartReloadWeapon(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "OnStartReloadWeapon");

	Params::EquipmentComponent_OnStartReloadWeapon Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.OnStartUnequipWeapon
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::OnStartUnequipWeapon(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "OnStartUnequipWeapon");

	Params::EquipmentComponent_OnStartUnequipWeapon Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.OnStartUnholsterWeapon
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::OnStartUnholsterWeapon(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "OnStartUnholsterWeapon");

	Params::EquipmentComponent_OnStartUnholsterWeapon Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.OnStatUpdated
// (Final, Native, Protected)
// Parameters:
// class URpgStat*                         Stat                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::OnStatUpdated(const class URpgStat* Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "OnStatUpdated");

	Params::EquipmentComponent_OnStatUpdated Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.OnStopClimb
// (Final, Native, Protected)

void UEquipmentComponent::OnStopClimb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "OnStopClimb");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.OnUnequipDisguise
// (Final, Native, Public)

void UEquipmentComponent::OnUnequipDisguise()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "OnUnequipDisguise");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.OnUnlockAbilityChanged
// (Final, Native, Protected)
// Parameters:
// EUnlockAbility                          Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::OnUnlockAbilityChanged(EUnlockAbility Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "OnUnlockAbilityChanged");

	Params::EquipmentComponent_OnUnlockAbilityChanged Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.SetArmorLevel
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOverrideArmorLevels                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::SetArmorLevel(int32 Level, bool bOverrideArmorLevels)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "SetArmorLevel");

	Params::EquipmentComponent_SetArmorLevel Parms{};

	Parms.Level = Level;
	Parms.bOverrideArmorLevels = bOverrideArmorLevels;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.SetCalledShotWeaponLevel
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::SetCalledShotWeaponLevel(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "SetCalledShotWeaponLevel");

	Params::EquipmentComponent_SetCalledShotWeaponLevel Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.SetWeaponLevel
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOverrideWeaponLevels                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::SetWeaponLevel(int32 Level, bool bOverrideWeaponLevels)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "SetWeaponLevel");

	Params::EquipmentComponent_SetWeaponLevel Parms{};

	Parms.Level = Level;
	Parms.bOverrideWeaponLevels = bOverrideWeaponLevels;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.UnequipAllModsDebug
// (Final, Exec, Native, Protected)

void UEquipmentComponent::UnequipAllModsDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "UnequipAllModsDebug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.UnholsterWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHolsterRequestSource                   InSource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::UnholsterWeapon(EHolsterRequestSource InSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "UnholsterWeapon");

	Params::EquipmentComponent_UnholsterWeapon Parms{};

	Parms.InSource = InSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.WeaponAdvanceLevelDebug
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   NumLevels                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreCost                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentComponent::WeaponAdvanceLevelDebug(int32 NumLevels, bool bIgnoreCost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "WeaponAdvanceLevelDebug");

	Params::EquipmentComponent_WeaponAdvanceLevelDebug Parms{};

	Parms.NumLevels = NumLevels;
	Parms.bIgnoreCost = bIgnoreCost;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EquipmentComponent.GetEquippedWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWeapon*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWeapon* UEquipmentComponent::GetEquippedWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentComponent", "GetEquippedWeapon");

	Params::EquipmentComponent_GetEquippedWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.StatusTagWidget.OnCombatStateChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bCombatIn                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusTagWidget::OnCombatStateChanged(bool bCombatIn, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusTagWidget", "OnCombatStateChanged");

	Params::StatusTagWidget_OnCombatStateChanged Parms{};

	Parms.bCombatIn = bCombatIn;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusTagWidget.OnHealthBarModeChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusTagWidget::OnHealthBarModeChanged(int32 ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusTagWidget", "OnHealthBarModeChanged");

	Params::StatusTagWidget_OnHealthBarModeChanged Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusTagWidget.OnHUDVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusTagWidget::OnHUDVisibilityChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusTagWidget", "OnHUDVisibilityChanged");

	Params::StatusTagWidget_OnHUDVisibilityChanged Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusTagWidget.OnMeterVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusTagWidget::OnMeterVisibilityChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusTagWidget", "OnMeterVisibilityChanged");

	Params::StatusTagWidget_OnMeterVisibilityChanged Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusTagWidget.OnSetPlayerTargeted
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bIsTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusTagWidget::OnSetPlayerTargeted(bool bIsTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusTagWidget", "OnSetPlayerTargeted");

	Params::StatusTagWidget_OnSetPlayerTargeted Parms{};

	Parms.bIsTarget = bIsTarget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.ScalableImage.SizeSettingChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   SizeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScalableImage::SizeSettingChanged(int32 SizeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScalableImage", "SizeSettingChanged");

	Params::ScalableImage_SizeSettingChanged Parms{};

	Parms.SizeIn = SizeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnKillListener.OnKill
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCauseDamageInfo                 CauseDamageInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UOnKillListener::OnKill(class AActor* Victim, const struct FCauseDamageInfo& CauseDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnKillListener", "OnKill");

	Params::OnKillListener_OnKill Parms{};

	Parms.Victim = Victim;
	Parms.CauseDamageInfo = std::move(CauseDamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaNavigationSystem.RegisterArea
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOccupationChannel                      Channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Extents                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Transform                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UIndianaNavigationSystem::RegisterArea(class AActor* Source, EOccupationChannel Channel, const struct FVector& Location, const struct FVector& Extents, const struct FRotator& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaNavigationSystem", "RegisterArea");

	Params::IndianaNavigationSystem_RegisterArea Parms{};

	Parms.Source = Source;
	Parms.Channel = Channel;
	Parms.Location = std::move(Location);
	Parms.Extents = std::move(Extents);
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaNavigationSystem.TraceOccupation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOccupationChannel                      Channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaNavigationSystem::TraceOccupation(class AActor* Source, EOccupationChannel Channel, const struct FVector& Start, const struct FVector& End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaNavigationSystem", "TraceOccupation");

	Params::IndianaNavigationSystem_TraceOccupation Parms{};

	Parms.Source = Source;
	Parms.Channel = Channel;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaNavigationSystem.UnregisterArea
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOccupationChannel                      Channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaNavigationSystem::UnregisterArea(class AActor* Source, EOccupationChannel Channel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaNavigationSystem", "UnregisterArea");

	Params::IndianaNavigationSystem_UnregisterArea Parms{};

	Parms.Source = Source;
	Parms.Channel = Channel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnCompanionKillListener.OnKill
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCauseDamageInfo                 CauseDamageInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UOnCompanionKillListener::OnKill(class AActor* Victim, const struct FCauseDamageInfo& CauseDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnCompanionKillListener", "OnKill");

	Params::OnCompanionKillListener_OnKill Parms{};

	Parms.Victim = Victim;
	Parms.CauseDamageInfo = std::move(CauseDamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusTagAwarenessWidget.SetTalkImage
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UTexture2D*                       TalkTexture                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusTagAwarenessWidget::SetTalkImage(class UTexture2D* TalkTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusTagAwarenessWidget", "SetTalkImage");

	Params::StatusTagAwarenessWidget_SetTalkImage Parms{};

	Parms.TalkTexture = TalkTexture;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.StatusTagAwarenessWidget.SetTextures
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UTexture2D*                       BackingTexture                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       FillTexture                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusTagAwarenessWidget::SetTextures(class UTexture2D* BackingTexture, class UTexture2D* FillTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusTagAwarenessWidget", "SetTextures");

	Params::StatusTagAwarenessWidget_SetTextures Parms{};

	Parms.BackingTexture = BackingTexture;
	Parms.FillTexture = FillTexture;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.OnKillTurnToAshListener.OnKill
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UIndianaDamageType>   DmgType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnKillTurnToAshListener::OnKill(class AActor* Victim, TSubclassOf<class UIndianaDamageType> DmgType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnKillTurnToAshListener", "OnKill");

	Params::OnKillTurnToAshListener_OnKill Parms{};

	Parms.Victim = Victim;
	Parms.DmgType = DmgType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnCompanionRegistrationAdded.OnCompanionRegistrationAdded
// (Final, Native, Protected)

void UOnCompanionRegistrationAdded::OnCompanionRegistrationAdded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnCompanionRegistrationAdded", "OnCompanionRegistrationAdded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnAttackComplete.OnAttackComplete
// (Final, Native, Protected)
// Parameters:
// int32                                   AttackID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnAttackComplete::OnAttackComplete(int32 AttackID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnAttackComplete", "OnAttackComplete");

	Params::OnAttackComplete_OnAttackComplete Parms{};

	Parms.AttackID = AttackID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnCausedDamage.OnCauseDamage
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FCauseDamageInfo                 CauseDamageInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UOnCausedDamage::OnCauseDamage(const struct FCauseDamageInfo& CauseDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnCausedDamage", "OnCauseDamage");

	Params::OnCausedDamage_OnCauseDamage Parms{};

	Parms.CauseDamageInfo = std::move(CauseDamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnReceiveFallingDamage.OnFallingDamage
// (Final, Native, Protected)
// Parameters:
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnReceiveFallingDamage::OnFallingDamage(float Damage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnReceiveFallingDamage", "OnFallingDamage");

	Params::OnReceiveFallingDamage_OnFallingDamage Parms{};

	Parms.Damage = Damage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnMeleeHit.OnMeleeHit
// (Final, Native, Protected, HasOutParams)
// Parameters:
// TArray<class AActor*>                   HitActors                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnMeleeHit::OnMeleeHit(const TArray<class AActor*>& HitActors, class UWeapon* Weapon, float Damage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnMeleeHit", "OnMeleeHit");

	Params::OnMeleeHit_OnMeleeHit Parms{};

	Parms.HitActors = std::move(HitActors);
	Parms.Weapon = Weapon;
	Parms.Damage = Damage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnMeleeActionStart.OnMeleeActionStart
// (Final, Native, Protected)
// Parameters:
// EMeleeAction                            ActionStarted                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnMeleeActionStart::OnMeleeActionStart(EMeleeAction ActionStarted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnMeleeActionStart", "OnMeleeActionStart");

	Params::OnMeleeActionStart_OnMeleeActionStart Parms{};

	Parms.ActionStarted = ActionStarted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TutorialManager.HideTutorialEventMessage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ETutorialEvent                          TutorialEvent                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialManager::HideTutorialEventMessage(const ETutorialEvent TutorialEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TutorialManager", "HideTutorialEventMessage");

	Params::TutorialManager_HideTutorialEventMessage Parms{};

	Parms.TutorialEvent = TutorialEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TutorialManager.IsTutorialEventCompleted
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETutorialEvent                          TutorialEvent                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTutorialManager::IsTutorialEventCompleted(const ETutorialEvent TutorialEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TutorialManager", "IsTutorialEventCompleted");

	Params::TutorialManager_IsTutorialEventCompleted Parms{};

	Parms.TutorialEvent = TutorialEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.TutorialManager.MarkTutorialEventComplete
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ETutorialEvent                          TutorialEvent                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialManager::MarkTutorialEventComplete(const ETutorialEvent TutorialEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TutorialManager", "MarkTutorialEventComplete");

	Params::TutorialManager_MarkTutorialEventComplete Parms{};

	Parms.TutorialEvent = TutorialEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TutorialManager.ShowTutorialEventMessage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ETutorialEvent                          TutorialEvent                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowOncePerSession                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInfiniteDuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialManager::ShowTutorialEventMessage(const ETutorialEvent TutorialEvent, bool bShowOncePerSession, bool bInfiniteDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TutorialManager", "ShowTutorialEventMessage");

	Params::TutorialManager_ShowTutorialEventMessage Parms{};

	Parms.TutorialEvent = TutorialEvent;
	Parms.bShowOncePerSession = bShowOncePerSession;
	Parms.bInfiniteDuration = bInfiniteDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TutorialManager.ItemDamageStatusChange
// (Final, Native, Protected)
// Parameters:
// EItemDegradationState                   DegredationState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialManager::ItemDamageStatusChange(EItemDegradationState DegredationState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "ItemDamageStatusChange");

	Params::TutorialManager_ItemDamageStatusChange Parms{};

	Parms.DegredationState = DegredationState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TutorialManager.PlayerCausedDamage
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FCauseDamageInfo                 CauseDamageInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UTutorialManager::PlayerCausedDamage(const struct FCauseDamageInfo& CauseDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "PlayerCausedDamage");

	Params::TutorialManager_PlayerCausedDamage Parms{};

	Parms.CauseDamageInfo = std::move(CauseDamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TutorialManager.PlayerCombatStateChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bIsInCombat                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialManager::PlayerCombatStateChanged(bool bIsInCombat, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "PlayerCombatStateChanged");

	Params::TutorialManager_PlayerCombatStateChanged Parms{};

	Parms.bIsInCombat = bIsInCombat;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TutorialManager.PlayerCompanionAdded
// (Final, Native, Protected)
// Parameters:
// class AIndianaAiCharacter*              NPC                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRegister                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialManager::PlayerCompanionAdded(class AIndianaAiCharacter* NPC, bool bRegister)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "PlayerCompanionAdded");

	Params::TutorialManager_PlayerCompanionAdded Parms{};

	Parms.NPC = NPC;
	Parms.bRegister = bRegister;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TutorialManager.PlayerCompanionKilled
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Companion                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialManager::PlayerCompanionKilled(class AActor* Companion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "PlayerCompanionKilled");

	Params::TutorialManager_PlayerCompanionKilled Parms{};

	Parms.Companion = Companion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TutorialManager.PlayerDisguiseDrainEnd
// (Final, Native, Protected)

void UTutorialManager::PlayerDisguiseDrainEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "PlayerDisguiseDrainEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TutorialManager.PlayerEncumberedChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bEncumbered                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialManager::PlayerEncumberedChanged(bool bEncumbered)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "PlayerEncumberedChanged");

	Params::TutorialManager_PlayerEncumberedChanged Parms{};

	Parms.bEncumbered = bEncumbered;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TutorialManager.PlayerEnteredRestrictedArea
// (Final, Native, Protected)
// Parameters:
// class ARestrictedArea*                  RestrictedArea                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialManager::PlayerEnteredRestrictedArea(const class ARestrictedArea* RestrictedArea)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "PlayerEnteredRestrictedArea");

	Params::TutorialManager_PlayerEnteredRestrictedArea Parms{};

	Parms.RestrictedArea = RestrictedArea;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TutorialManager.PlayerFinishedEquipping
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialManager::PlayerFinishedEquipping(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "PlayerFinishedEquipping");

	Params::TutorialManager_PlayerFinishedEquipping Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TutorialManager.PlayerHealthChanged
// (Final, Native, Protected)
// Parameters:
// float                                   HealthChanged                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialManager::PlayerHealthChanged(float HealthChanged, class AActor* Instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "PlayerHealthChanged");

	Params::TutorialManager_PlayerHealthChanged Parms{};

	Parms.HealthChanged = HealthChanged;
	Parms.Instigator = Instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TutorialManager.PlayerItemAdded
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       Item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTutorialManager::PlayerItemAdded(const struct FItemStack& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "PlayerItemAdded");

	Params::TutorialManager_PlayerItemAdded Parms{};

	Parms.Item = std::move(Item);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TutorialManager.PlayerKill
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCauseDamageInfo                 CauseDamageInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UTutorialManager::PlayerKill(class AActor* Victim, const struct FCauseDamageInfo& CauseDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "PlayerKill");

	Params::TutorialManager_PlayerKill Parms{};

	Parms.Victim = Victim;
	Parms.CauseDamageInfo = std::move(CauseDamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TutorialManager.PlayerLanded
// (Final, Native, Protected)
// Parameters:
// float                                   DistanceFell                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialManager::PlayerLanded(float DistanceFell)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "PlayerLanded");

	Params::TutorialManager_PlayerLanded Parms{};

	Parms.DistanceFell = DistanceFell;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TutorialManager.PlayerLevelChanged
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialManager::PlayerLevelChanged(int32 NewLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "PlayerLevelChanged");

	Params::TutorialManager_PlayerLevelChanged Parms{};

	Parms.NewLevel = NewLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TutorialManager.PlayerMedKitUsed
// (Final, Native, Protected)

void UTutorialManager::PlayerMedKitUsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "PlayerMedKitUsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TutorialManager.PlayerSkillCheckSuccess
// (Final, Native, Protected)
// Parameters:
// EXPGainReason                           Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   XPEarned                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkill                                  SkillUsed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialManager::PlayerSkillCheckSuccess(EXPGainReason Reason, int32 XPEarned, ESkill SkillUsed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "PlayerSkillCheckSuccess");

	Params::TutorialManager_PlayerSkillCheckSuccess Parms{};

	Parms.Reason = Reason;
	Parms.XPEarned = XPEarned;
	Parms.SkillUsed = SkillUsed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TutorialManager.PlayerSkillUpdated
// (Final, Native, Public)
// Parameters:
// ESkill                                  Skill                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialManager::PlayerSkillUpdated(ESkill Skill, int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "PlayerSkillUpdated");

	Params::TutorialManager_PlayerSkillUpdated Parms{};

	Parms.Skill = Skill;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TutorialManager.PlayerTakeDamage
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FCauseDamageInfo                 CauseDamageInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UTutorialManager::PlayerTakeDamage(const struct FCauseDamageInfo& CauseDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "PlayerTakeDamage");

	Params::TutorialManager_PlayerTakeDamage Parms{};

	Parms.CauseDamageInfo = std::move(CauseDamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TutorialManager.PlayerTargetChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bAdded                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialManager::PlayerTargetChange(const bool bAdded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialManager", "PlayerTargetChange");

	Params::TutorialManager_PlayerTargetChange Parms{};

	Parms.bAdded = bAdded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnSpellCast.OnSpellCast
// (Final, Native, Protected)
// Parameters:
// TSubclassOf<class USpell>               Spell_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnSpellCast::OnSpellCast(TSubclassOf<class USpell> Spell_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnSpellCast", "OnSpellCast");

	Params::OnSpellCast_OnSpellCast Parms{};

	Parms.Spell_0 = Spell_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnSpellRemoved.OnSpellRemoved
// (Final, Native, Protected)
// Parameters:
// TSubclassOf<class USpell>               RemovedSpell                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnSpellRemoved::OnSpellRemoved(TSubclassOf<class USpell> RemovedSpell)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnSpellRemoved", "OnSpellRemoved");

	Params::OnSpellRemoved_OnSpellRemoved Parms{};

	Parms.RemovedSpell = RemovedSpell;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnBlockStart.OnBlockStart
// (Final, Native, Protected)

void UOnBlockStart::OnBlockStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnBlockStart", "OnBlockStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnPerfectBlock.OnPerfectBlockEvent
// (Final, Native, Protected)
// Parameters:
// class AIndianaCharacter*                Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnPerfectBlock::OnPerfectBlockEvent(class AIndianaCharacter* Attacker, float Damage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnPerfectBlock", "OnPerfectBlockEvent");

	Params::OnPerfectBlock_OnPerfectBlockEvent Parms{};

	Parms.Attacker = Attacker;
	Parms.Damage = Damage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnBlockedHit.OnBlockedHitEvent
// (Final, Native, Protected)
// Parameters:
// bool                                    bIsMeleeHit                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnBlockedHit::OnBlockedHitEvent(bool bIsMeleeHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnBlockedHit", "OnBlockedHitEvent");

	Params::OnBlockedHit_OnBlockedHitEvent Parms{};

	Parms.bIsMeleeHit = bIsMeleeHit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TutorialList.AddNewCompletedTutorial
// (Final, Native, Public)
// Parameters:
// ETutorialEvent                          TutorialEvent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialList::AddNewCompletedTutorial(ETutorialEvent TutorialEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialList", "AddNewCompletedTutorial");

	Params::TutorialList_AddNewCompletedTutorial Parms{};

	Parms.TutorialEvent = TutorialEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnDetected.OnDetectedEvent
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Detector                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnDetected::OnDetectedEvent(class AActor* Detector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnDetected", "OnDetectedEvent");

	Params::OnDetected_OnDetectedEvent Parms{};

	Parms.Detector = Detector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnPlayerMoveStart.OnPlayerMoveStart
// (Final, Native, Protected)

void UOnPlayerMoveStart::OnPlayerMoveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnPlayerMoveStart", "OnPlayerMoveStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnPlayerMoveEnd.OnPlayerMoveEnd
// (Final, Native, Protected)

void UOnPlayerMoveEnd::OnPlayerMoveEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnPlayerMoveEnd", "OnPlayerMoveEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnDodgeEvent.OnDodge
// (Final, Native, Protected)
// Parameters:
// EDodgeDirection                         Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnDodgeEvent::OnDodge(EDodgeDirection Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnDodgeEvent", "OnDodge");

	Params::OnDodgeEvent_OnDodge Parms{};

	Parms.Direction = Direction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnStatusEffectRemovedEvent.OnStatusEffectRemoved
// (Final, Native, Protected)
// Parameters:
// class UStatusEffectManagerComponent*    Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffect*                    StatusEffectRemoved                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnStatusEffectRemovedEvent::OnStatusEffectRemoved(class UStatusEffectManagerComponent* Sender, class UStatusEffect* StatusEffectRemoved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnStatusEffectRemovedEvent", "OnStatusEffectRemoved");

	Params::OnStatusEffectRemovedEvent_OnStatusEffectRemoved Parms{};

	Parms.Sender = Sender;
	Parms.StatusEffectRemoved = StatusEffectRemoved;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnNumHostileStatusEffects.OnStatusEffectAdded
// (Final, Native, Protected)
// Parameters:
// class UStatusEffectManagerComponent*    Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffect*                    StatusEffectAdded                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnNumHostileStatusEffects::OnStatusEffectAdded(class UStatusEffectManagerComponent* Sender, class UStatusEffect* StatusEffectAdded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnNumHostileStatusEffects", "OnStatusEffectAdded");

	Params::OnNumHostileStatusEffects_OnStatusEffectAdded Parms{};

	Parms.Sender = Sender;
	Parms.StatusEffectAdded = StatusEffectAdded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnNumHostileStatusEffects.OnStatusEffectRemoved
// (Final, Native, Protected)
// Parameters:
// class UStatusEffectManagerComponent*    Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffect*                    StatusEffectRemoved                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnNumHostileStatusEffects::OnStatusEffectRemoved(class UStatusEffectManagerComponent* Sender, class UStatusEffect* StatusEffectRemoved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnNumHostileStatusEffects", "OnStatusEffectRemoved");

	Params::OnNumHostileStatusEffects_OnStatusEffectRemoved Parms{};

	Parms.Sender = Sender;
	Parms.StatusEffectRemoved = StatusEffectRemoved;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.HasStatusEffectsEvent.OnAddStatusEffect
// (Final, Native, Protected)
// Parameters:
// class UStatusEffectManagerComponent*    Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffect*                    StatusEffectAdded                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHasStatusEffectsEvent::OnAddStatusEffect(class UStatusEffectManagerComponent* Sender, class UStatusEffect* StatusEffectAdded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HasStatusEffectsEvent", "OnAddStatusEffect");

	Params::HasStatusEffectsEvent_OnAddStatusEffect Parms{};

	Parms.Sender = Sender;
	Parms.StatusEffectAdded = StatusEffectAdded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnSkillEndedEvent.OnSkillEnded
// (Final, Native, Protected)
// Parameters:
// ESkill                                  SkillUsed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnSkillEndedEvent::OnSkillEnded(ESkill SkillUsed, class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnSkillEndedEvent", "OnSkillEnded");

	Params::OnSkillEndedEvent_OnSkillEnded Parms{};

	Parms.SkillUsed = SkillUsed;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnSkillCheckSuccess.OnSkillCheckSuccess
// (Final, Native, Protected)
// Parameters:
// EXPGainReason                           Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   XPEarned                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkill                                  SkillUsed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnSkillCheckSuccess::OnSkillCheckSuccess(EXPGainReason Reason, int32 XPEarned, ESkill SkillUsed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnSkillCheckSuccess", "OnSkillCheckSuccess");

	Params::OnSkillCheckSuccess_OnSkillCheckSuccess Parms{};

	Parms.Reason = Reason;
	Parms.XPEarned = XPEarned;
	Parms.SkillUsed = SkillUsed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnItemConsumed.OnItemConsumed
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UOnItemConsumed::OnItemConsumed(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnItemConsumed", "OnItemConsumed");

	Params::OnItemConsumed_OnItemConsumed Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnPickPocket.OnPickPocket
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnPickPocket::OnPickPocket(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnPickPocket", "OnPickPocket");

	Params::OnPickPocket_OnPickPocket Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnPickPocketStart.OnPickPocket
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnPickPocketStart::OnPickPocket(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnPickPocketStart", "OnPickPocket");

	Params::OnPickPocketStart_OnPickPocket Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnPickPocketEnd.OnPickPocket
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnPickPocketEnd::OnPickPocket(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnPickPocketEnd", "OnPickPocket");

	Params::OnPickPocketEnd_OnPickPocket Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnPartyChange.OnPartyChanged
// (Final, Native, Protected)
// Parameters:
// class AIndianaAiCharacter*              Companion                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAdded                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnPartyChange::OnPartyChanged(class AIndianaAiCharacter* Companion, bool bAdded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnPartyChange", "OnPartyChanged");

	Params::OnPartyChange_OnPartyChanged Parms{};

	Parms.Companion = Companion;
	Parms.bAdded = bAdded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnPerfectDodge.OnPerfectDodge
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnPerfectDodge::OnPerfectDodge(class AActor* Attacker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnPerfectDodge", "OnPerfectDodge");

	Params::OnPerfectDodge_OnPerfectDodge Parms{};

	Parms.Attacker = Attacker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnBehaviorStateChange.OnBehaviorStateEvent
// (Final, Native, Protected)
// Parameters:
// EBehaviorState                          InBehaviorState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBehaviorStateEventType                 InEventType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnBehaviorStateChange::OnBehaviorStateEvent(EBehaviorState InBehaviorState, EBehaviorStateEventType InEventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnBehaviorStateChange", "OnBehaviorStateEvent");

	Params::OnBehaviorStateChange_OnBehaviorStateEvent Parms{};

	Parms.InBehaviorState = InBehaviorState;
	Parms.InEventType = InEventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnCinematicModeChange.OnCinematicModeChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bCinematicMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnCinematicModeChange::OnCinematicModeChange(bool bCinematicMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnCinematicModeChange", "OnCinematicModeChange");

	Params::OnCinematicModeChange_OnCinematicModeChange Parms{};

	Parms.bCinematicMode = bCinematicMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnMedKitUsed.OnMedKitUsed
// (Final, Native, Protected)
// Parameters:
// int32                                   ConsumablesUsed                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnMedKitUsed::OnMedKitUsed(int32 ConsumablesUsed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnMedKitUsed", "OnMedKitUsed");

	Params::OnMedKitUsed_OnMedKitUsed Parms{};

	Parms.ConsumablesUsed = ConsumablesUsed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.JumpBehaviorStateInfo.OnIntroAnimationComplete
// (Final, Native, Protected)

void UJumpBehaviorStateInfo::OnIntroAnimationComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JumpBehaviorStateInfo", "OnIntroAnimationComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.JumpBehaviorStateInfo.OnOutroAnimationComplete
// (Final, Native, Protected)

void UJumpBehaviorStateInfo::OnOutroAnimationComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JumpBehaviorStateInfo", "OnOutroAnimationComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnAcrophobiaEnabled.OnAcrophobiaChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bNowEnabled                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnAcrophobiaEnabled::OnAcrophobiaChanged(bool bNowEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnAcrophobiaEnabled", "OnAcrophobiaChanged");

	Params::OnAcrophobiaEnabled_OnAcrophobiaChanged Parms{};

	Parms.bNowEnabled = bNowEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnResurrect.OnNewStateOfBeing
// (Final, Native, Protected)
// Parameters:
// EStateOfBeing                           NewStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStateOfBeing                           OldStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnResurrect::OnNewStateOfBeing(EStateOfBeing NewStateOfBeing, EStateOfBeing OldStateOfBeing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnResurrect", "OnNewStateOfBeing");

	Params::OnResurrect_OnNewStateOfBeing Parms{};

	Parms.NewStateOfBeing = NewStateOfBeing;
	Parms.OldStateOfBeing = OldStateOfBeing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnRest.OnRest
// (Final, Native, Protected)

void UOnRest::OnRest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnRest", "OnRest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnSkillUpdated.OnSkillUpdated
// (Final, Native, Protected)
// Parameters:
// ESkill                                  Skill                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnSkillUpdated::OnSkillUpdated(ESkill Skill, int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnSkillUpdated", "OnSkillUpdated");

	Params::OnSkillUpdated_OnSkillUpdated Parms{};

	Parms.Skill = Skill;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnOccupiedElevatorMove.OnOccupiedElevatorMove
// (Final, Native, Protected)
// Parameters:
// class AElevator*                        Elevator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnOccupiedElevatorMove::OnOccupiedElevatorMove(class AElevator* Elevator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnOccupiedElevatorMove", "OnOccupiedElevatorMove");

	Params::OnOccupiedElevatorMove_OnOccupiedElevatorMove Parms{};

	Parms.Elevator = Elevator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnAnimationSpellTrigger.OnAnimationTriggered
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayTag                     TriggerType                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnAnimationSpellTrigger::OnAnimationTriggered(const struct FGameplayTag& TriggerType, bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnAnimationSpellTrigger", "OnAnimationTriggered");

	Params::OnAnimationSpellTrigger_OnAnimationTriggered Parms{};

	Parms.TriggerType = std::move(TriggerType);
	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Trap.ArmTrap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AIndianaCharacter*                Initiator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFireTrapArmedEvent                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATrap::ArmTrap(class AIndianaCharacter* Initiator, bool bFireTrapArmedEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Trap", "ArmTrap");

	Params::Trap_ArmTrap Parms{};

	Parms.Initiator = Initiator;
	Parms.bFireTrapArmedEvent = bFireTrapArmedEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Trap.DeactivateTrap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AIndianaCharacter*                Initiator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFireTrapDeactivatedEvent                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATrap::DeactivateTrap(class AIndianaCharacter* Initiator, bool bFireTrapDeactivatedEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Trap", "DeactivateTrap");

	Params::Trap_DeactivateTrap Parms{};

	Parms.Initiator = Initiator;
	Parms.bFireTrapDeactivatedEvent = bFireTrapDeactivatedEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Trap.DisarmTrap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AIndianaCharacter*                Initiator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFireTrapDisarmedEvent                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATrap::DisarmTrap(class AIndianaCharacter* Initiator, bool bFireTrapDisarmedEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Trap", "DisarmTrap");

	Params::Trap_DisarmTrap Parms{};

	Parms.Initiator = Initiator;
	Parms.bFireTrapDisarmedEvent = bFireTrapDisarmedEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Trap.OnActivationShapeBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ATrap::OnActivationShapeBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Trap", "OnActivationShapeBeginOverlap");

	Params::Trap_OnActivationShapeBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Trap.OnActivationShapeEndOverlap
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATrap::OnActivationShapeEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Trap", "OnActivationShapeEndOverlap");

	Params::Trap_OnActivationShapeEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Trap.OnActivatorTrackingShapeBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ATrap::OnActivatorTrackingShapeBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Trap", "OnActivatorTrackingShapeBeginOverlap");

	Params::Trap_OnActivatorTrackingShapeBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Trap.OnActivatorTrackingShapeEndOverlap
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATrap::OnActivatorTrackingShapeEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Trap", "OnActivatorTrackingShapeEndOverlap");

	Params::Trap_OnActivatorTrackingShapeEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Trap.OnNewStateOfBeing
// (Final, Native, Protected)
// Parameters:
// EStateOfBeing                           NewStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStateOfBeing                           OldStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATrap::OnNewStateOfBeing(EStateOfBeing NewStateOfBeing, EStateOfBeing OldStateOfBeing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Trap", "OnNewStateOfBeing");

	Params::Trap_OnNewStateOfBeing Parms{};

	Parms.NewStateOfBeing = NewStateOfBeing;
	Parms.OldStateOfBeing = OldStateOfBeing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Trap.OnStatUpdated
// (Final, Native, Protected)
// Parameters:
// class URpgStat*                         Stat                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATrap::OnStatUpdated(const class URpgStat* Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Trap", "OnStatUpdated");

	Params::Trap_OnStatUpdated Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Trap.GetActivationShapeComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UShapeComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UShapeComponent* ATrap::GetActivationShapeComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Trap", "GetActivationShapeComponent");

	Params::Trap_GetActivationShapeComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Trap.GetActivatorTrackingShapeComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UShapeComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UShapeComponent* ATrap::GetActivatorTrackingShapeComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Trap", "GetActivatorTrackingShapeComponent");

	Params::Trap_GetActivatorTrackingShapeComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Trap.GetCurrentState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETrapState                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETrapState ATrap::GetCurrentState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Trap", "GetCurrentState");

	Params::Trap_GetCurrentState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Trap.GetExactTrapDifficulty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 ATrap::GetExactTrapDifficulty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Trap", "GetExactTrapDifficulty");

	Params::Trap_GetExactTrapDifficulty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Trap.IsDetonationPending
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATrap::IsDetonationPending() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Trap", "IsDetonationPending");

	Params::Trap_IsDetonationPending Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Trap.IsRearming
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATrap::IsRearming() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Trap", "IsRearming");

	Params::Trap_IsRearming Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OnLanded.OnLanded
// (Final, Native, Protected)
// Parameters:
// float                                   FallDistance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnLanded::OnLanded(float FallDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnLanded", "OnLanded");

	Params::OnLanded_OnLanded Parms{};

	Parms.FallDistance = FallDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnTTDMeterPercentage.OnTTDMeterChanged
// (Final, Native, Protected)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnTTDMeterPercentage::OnTTDMeterChanged(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnTTDMeterPercentage", "OnTTDMeterChanged");

	Params::OnTTDMeterPercentage_OnTTDMeterChanged Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnSprintStart.OnSprintStarted
// (Final, Native, Protected)

void UOnSprintStart::OnSprintStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnSprintStart", "OnSprintStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnPlayerFirstAttacked.OnFirstAttacked
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnPlayerFirstAttacked::OnFirstAttacked(class AActor* Attacker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnPlayerFirstAttacked", "OnFirstAttacked");

	Params::OnPlayerFirstAttacked_OnFirstAttacked Parms{};

	Parms.Attacker = Attacker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnPlayerFirstAttack.OnFirstAttack
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnPlayerFirstAttack::OnFirstAttack(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnPlayerFirstAttack", "OnFirstAttack");

	Params::OnPlayerFirstAttack_OnFirstAttack Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnStateOfBeingChanged.OnStateOfBeingChanged
// (Final, Native, Protected)
// Parameters:
// EStateOfBeing                           NewStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStateOfBeing                           OldStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnStateOfBeingChanged::OnStateOfBeingChanged(EStateOfBeing NewStateOfBeing, EStateOfBeing OldStateOfBeing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnStateOfBeingChanged", "OnStateOfBeingChanged");

	Params::OnStateOfBeingChanged_OnStateOfBeingChanged Parms{};

	Parms.NewStateOfBeing = NewStateOfBeing;
	Parms.OldStateOfBeing = OldStateOfBeing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnCombatStateChange.OnCombatStateChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bInCombat                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnCombatStateChange::OnCombatStateChange(bool bInCombat, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnCombatStateChange", "OnCombatStateChange");

	Params::OnCombatStateChange_OnCombatStateChange Parms{};

	Parms.bInCombat = bInCombat;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnGetUp.OnGetUp
// (Final, Native, Protected)
// Parameters:
// bool                                    bInBegan                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnGetUp::OnGetUp(bool bInBegan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnGetUp", "OnGetUp");

	Params::OnGetUp_OnGetUp Parms{};

	Parms.bInBegan = bInBegan;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnPlayerConversationChange.OnPlayerConversationChange
// (Final, Native, Protected)
// Parameters:
// class UConversationInstance*            Instance                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInEntered                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnPlayerConversationChange::OnPlayerConversationChange(const class UConversationInstance* Instance, bool bInEntered)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnPlayerConversationChange", "OnPlayerConversationChange");

	Params::OnPlayerConversationChange_OnPlayerConversationChange Parms{};

	Parms.Instance = Instance;
	Parms.bInEntered = bInEntered;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnAddictionTimerLeavesMaxed.OnAddictionTimerLeavesMaxed
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     TimerTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnAddictionTimerLeavesMaxed::OnAddictionTimerLeavesMaxed(const struct FGameplayTag& TimerTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnAddictionTimerLeavesMaxed", "OnAddictionTimerLeavesMaxed");

	Params::OnAddictionTimerLeavesMaxed_OnAddictionTimerLeavesMaxed Parms{};

	Parms.TimerTag = std::move(TimerTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnSellItemNumBits.OnVectorTransaction
// (Final, Native, Protected, HasOutParams)
// Parameters:
// int32                                   BuyingBalance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SellingBalance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RepairingBalance                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FItemStackSplit                  ItemStackSplit                                         (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UOnSellItemNumBits::OnVectorTransaction(int32 BuyingBalance, int32 SellingBalance, int32 RepairingBalance, struct FItemStackSplit* ItemStackSplit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnSellItemNumBits", "OnVectorTransaction");

	Params::OnSellItemNumBits_OnVectorTransaction Parms{};

	Parms.BuyingBalance = BuyingBalance;
	Parms.SellingBalance = SellingBalance;
	Parms.RepairingBalance = RepairingBalance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ItemStackSplit != nullptr)
		*ItemStackSplit = std::move(Parms.ItemStackSplit);
}


// Function Indiana.OnFlawAccepted.OnFlawAccepted
// (Final, Native, Protected)
// Parameters:
// TSubclassOf<class UFlaw>                Flaw                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnFlawAccepted::OnFlawAccepted(TSubclassOf<class UFlaw> Flaw, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnFlawAccepted", "OnFlawAccepted");

	Params::OnFlawAccepted_OnFlawAccepted Parms{};

	Parms.Flaw = Flaw;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnItemTinkered.OnItemTinkered
// (Final, Native, Protected)

void UOnItemTinkered::OnItemTinkered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnItemTinkered", "OnItemTinkered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnEncumberedChange.OnEncumberedChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bInEncumbered                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnEncumberedChange::OnEncumberedChange(bool bInEncumbered)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnEncumberedChange", "OnEncumberedChange");

	Params::OnEncumberedChange_OnEncumberedChange Parms{};

	Parms.bInEncumbered = bInEncumbered;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnStartCrouch.OnCrouch
// (Final, Native, Protected)

void UOnStartCrouch::OnCrouch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnStartCrouch", "OnCrouch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnInterrogateStartEvent.OnStartInterrogation
// (Final, Native, Protected)

void UOnInterrogateStartEvent::OnStartInterrogation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnInterrogateStartEvent", "OnStartInterrogation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainMenuDLCWidget.OnButtonHoveredFocused
// (Final, Native, Protected)

void UMainMenuDLCWidget::OnButtonHoveredFocused()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuDLCWidget", "OnButtonHoveredFocused");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainMenuDLCWidget.OnButtonUnhoveredUnfocused
// (Final, Native, Protected)

void UMainMenuDLCWidget::OnButtonUnhoveredUnfocused()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuDLCWidget", "OnButtonUnhoveredUnfocused");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnGroinHit.OnGroinHit
// (Final, Native, Protected)

void UOnGroinHit::OnGroinHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnGroinHit", "OnGroinHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnPatientNKill.OnPatientNKill
// (Final, Native, Protected)

void UOnPatientNKill::OnPatientNKill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnPatientNKill", "OnPatientNKill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnBrandsMatch.OnBrandsMatch
// (Final, Native, Protected)

void UOnBrandsMatch::OnBrandsMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnBrandsMatch", "OnBrandsMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnSharpDressed.OnSharpDressed
// (Final, Native, Protected)

void UOnSharpDressed::OnSharpDressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnSharpDressed", "OnSharpDressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnSpecialPETBenefits.OnSpecialPETBenefits
// (Final, Native, Protected)

void UOnSpecialPETBenefits::OnSpecialPETBenefits()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnSpecialPETBenefits", "OnSpecialPETBenefits");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnElementalMaelstrom.OnElementalMaelstrom
// (Final, Native, Protected)

void UOnElementalMaelstrom::OnElementalMaelstrom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnElementalMaelstrom", "OnElementalMaelstrom");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnInterrogateEndEvent.OnEndInterrogation
// (Final, Native, Protected)
// Parameters:
// EInterrogationResult                    InterrogationResult                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AIndianaAiCharacter*              Interrogator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrimeType                              InCrime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInDisguised                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InDisguiseInterrogationsPassed                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnInterrogateEndEvent::OnEndInterrogation(EInterrogationResult InterrogationResult, class AIndianaAiCharacter* Interrogator, ECrimeType InCrime, bool bInDisguised, int32 InDisguiseInterrogationsPassed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnInterrogateEndEvent", "OnEndInterrogation");

	Params::OnInterrogateEndEvent_OnEndInterrogation Parms{};

	Parms.InterrogationResult = InterrogationResult;
	Parms.Interrogator = Interrogator;
	Parms.InCrime = InCrime;
	Parms.bInDisguised = bInDisguised;
	Parms.InDisguiseInterrogationsPassed = InDisguiseInterrogationsPassed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnMaxNegativeFactions.OnMaxNegativeFactions
// (Final, Native, Protected)

void UOnMaxNegativeFactions::OnMaxNegativeFactions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnMaxNegativeFactions", "OnMaxNegativeFactions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnKillingBlowListener.OnKillingBlow
// (Final, Native, Protected)

void UOnKillingBlowListener::OnKillingBlow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnKillingBlowListener", "OnKillingBlow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnQuestCompleteListener.OnQuestComplete
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            QuestID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnQuestCompleteListener::OnQuestComplete(const struct FGuid& QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnQuestCompleteListener", "OnQuestComplete");

	Params::OnQuestCompleteListener_OnQuestComplete Parms{};

	Parms.QuestID = std::move(QuestID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnWeaponEquipped.OnWeaponEquipped
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnWeaponEquipped::OnWeaponEquipped(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnWeaponEquipped", "OnWeaponEquipped");

	Params::OnWeaponEquipped_OnWeaponEquipped Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnWeaponHolstered.OnWeaponHolstered
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnWeaponHolstered::OnWeaponHolstered(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnWeaponHolstered", "OnWeaponHolstered");

	Params::OnWeaponHolstered_OnWeaponHolstered Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnWeaponUnholstered.OnWeaponUnholstered
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnWeaponUnholstered::OnWeaponUnholstered(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnWeaponUnholstered", "OnWeaponUnholstered");

	Params::OnWeaponUnholstered_OnWeaponUnholstered Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnPlayerBeginPlay.OnPlayerBeginPlay
// (Final, Native, Protected)

void UOnPlayerBeginPlay::OnPlayerBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnPlayerBeginPlay", "OnPlayerBeginPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnFastTravelInitiated.OnFastTravelInitiated
// (Final, Native, Protected)
// Parameters:
// class UTravelDestinationData*           TravelData                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimePassed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTravelFromMapLedger                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnFastTravelInitiated::OnFastTravelInitiated(const class UTravelDestinationData* TravelData, float TimePassed, bool bTravelFromMapLedger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnFastTravelInitiated", "OnFastTravelInitiated");

	Params::OnFastTravelInitiated_OnFastTravelInitiated Parms{};

	Parms.TravelData = TravelData;
	Parms.TimePassed = TimePassed;
	Parms.bTravelFromMapLedger = bTravelFromMapLedger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SlideshowWidget.OnCinematicSubtitleSettingChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisibleIn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlideshowWidget::OnCinematicSubtitleSettingChanged(bool bVisibleIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlideshowWidget", "OnCinematicSubtitleSettingChanged");

	Params::SlideshowWidget_OnCinematicSubtitleSettingChanged Parms{};

	Parms.bVisibleIn = bVisibleIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SlideshowWidget.OnSlideshowEnd
// (Final, Native, Protected)
// Parameters:
// class UConversationInstance*            Instance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlideshowWidget::OnSlideshowEnd(class UConversationInstance* Instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlideshowWidget", "OnSlideshowEnd");

	Params::SlideshowWidget_OnSlideshowEnd Parms{};

	Parms.Instance = Instance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SlideshowWidget.SetSlideshowImageKey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ImageKey                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlideshowWidget::SetSlideshowImageKey(const class FString& ImageKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlideshowWidget", "SetSlideshowImageKey");

	Params::SlideshowWidget_SetSlideshowImageKey Parms{};

	Parms.ImageKey = std::move(ImageKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SlideshowWidget.SetSlideshowImagesAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USlideshowImageSet*               ImageSet                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlideshowWidget::SetSlideshowImagesAsset(class USlideshowImageSet* ImageSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlideshowWidget", "SetSlideshowImagesAsset");

	Params::SlideshowWidget_SetSlideshowImagesAsset Parms{};

	Parms.ImageSet = ImageSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnRespec.OnRespec
// (Final, Native, Protected)

void UOnRespec::OnRespec()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnRespec", "OnRespec");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnGlobalVarChanged.OnGlobalVarChanged
// (Final, Native, Protected)
// Parameters:
// class FString                           VariableName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnGlobalVarChanged::OnGlobalVarChanged(const class FString& VariableName, int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnGlobalVarChanged", "OnGlobalVarChanged");

	Params::OnGlobalVarChanged_OnGlobalVarChanged Parms{};

	Parms.VariableName = std::move(VariableName);
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnPickupAudioLog.OnPickupAudioLog
// (Final, Native, Protected)
// Parameters:
// class UAudioLogDataAsset*               AudioLogDataAsset                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnPickupAudioLog::OnPickupAudioLog(class UAudioLogDataAsset* AudioLogDataAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnPickupAudioLog", "OnPickupAudioLog");

	Params::OnPickupAudioLog_OnPickupAudioLog Parms{};

	Parms.AudioLogDataAsset = AudioLogDataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EvidenceActor.OnActivated
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bActivated                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEvidenceActor::OnActivated(bool bActivated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvidenceActor", "OnActivated");

	Params::EvidenceActor_OnActivated Parms{};

	Parms.bActivated = bActivated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EvidenceActor.OnCombatStateChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bCombatIn                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEvidenceActor::OnCombatStateChanged(bool bCombatIn, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvidenceActor", "OnCombatStateChanged");

	Params::EvidenceActor_OnCombatStateChanged Parms{};

	Parms.bCombatIn = bCombatIn;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EvidenceActor.OnConversationEnded
// (Final, Native, Protected)
// Parameters:
// class UConversationInstance*            Instance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEvidenceActor::OnConversationEnded(class UConversationInstance* Instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvidenceActor", "OnConversationEnded");

	Params::EvidenceActor_OnConversationEnded Parms{};

	Parms.Instance = Instance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EvidenceActor.OnConversationStarted
// (Final, Native, Protected)
// Parameters:
// class UConversationInstance*            Instance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEvidenceActor::OnConversationStarted(class UConversationInstance* Instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvidenceActor", "OnConversationStarted");

	Params::EvidenceActor_OnConversationStarted Parms{};

	Parms.Instance = Instance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EvidenceActor.OnVisibilityStateChanged
// (Event, Protected, BlueprintEvent)

void AEvidenceActor::OnVisibilityStateChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvidenceActor", "OnVisibilityStateChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.EvidenceActor.PlayerEnteredProximity
// (Event, Protected, BlueprintEvent)

void AEvidenceActor::PlayerEnteredProximity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvidenceActor", "PlayerEnteredProximity");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.EvidenceActor.PlayerExitedProximity
// (Event, Protected, BlueprintEvent)

void AEvidenceActor::PlayerExitedProximity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvidenceActor", "PlayerExitedProximity");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.EvidenceActor.RefreshHasItem
// (Final, Native, Protected)

void AEvidenceActor::RefreshHasItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvidenceActor", "RefreshHasItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EvidenceActor.RefreshHasItemEquipped
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEvidenceActor::RefreshHasItemEquipped(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvidenceActor", "RefreshHasItemEquipped");

	Params::EvidenceActor_RefreshHasItemEquipped Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.EvidenceActor.HasBeenScanned
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEvidenceActor::HasBeenScanned() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvidenceActor", "HasBeenScanned");

	Params::EvidenceActor_HasBeenScanned Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.EvidenceActor.IsInDAConversation
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEvidenceActor::IsInDAConversation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvidenceActor", "IsInDAConversation");

	Params::EvidenceActor_IsInDAConversation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.EvidenceActor.IsVisible
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEvidenceActor::IsVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvidenceActor", "IsVisible");

	Params::EvidenceActor_IsVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaBossBar.GetHideAnimation
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UWidgetAnimation*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetAnimation* UIndianaBossBar::GetHideAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaBossBar", "GetHideAnimation");

	Params::IndianaBossBar_GetHideAnimation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaBossBar.GetShowAnimation
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UWidgetAnimation*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetAnimation* UIndianaBossBar::GetShowAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaBossBar", "GetShowAnimation");

	Params::IndianaBossBar_GetShowAnimation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaBossBar.OnBeginBossFight
// (Final, Native, Protected)
// Parameters:
// class AIndianaCharacter*                OwnerCharacter                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           BossName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartingNormalizedHealth                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaBossBar::OnBeginBossFight(class AIndianaCharacter* OwnerCharacter, const class FString& BossName, float StartingNormalizedHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaBossBar", "OnBeginBossFight");

	Params::IndianaBossBar_OnBeginBossFight Parms{};

	Parms.OwnerCharacter = OwnerCharacter;
	Parms.BossName = std::move(BossName);
	Parms.StartingNormalizedHealth = StartingNormalizedHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaBossBar.OnBossHealthChanged
// (Final, Native, Protected)
// Parameters:
// float                                   NormalizedHealth                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaBossBar::OnBossHealthChanged(float NormalizedHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaBossBar", "OnBossHealthChanged");

	Params::IndianaBossBar_OnBossHealthChanged Parms{};

	Parms.NormalizedHealth = NormalizedHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaBossBar.OnEndBossFight
// (Final, Native, Protected)

void UIndianaBossBar::OnEndBossFight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaBossBar", "OnEndBossFight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.FlipbookWidget.BeginPlay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInShouldLoop                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayFromFrame                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlipbookWidget::BeginPlay(bool bInShouldLoop, int32 PlayFromFrame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlipbookWidget", "BeginPlay");

	Params::FlipbookWidget_BeginPlay Parms{};

	Parms.bInShouldLoop = bInShouldLoop;
	Parms.PlayFromFrame = PlayFromFrame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.FlipbookWidget.EndPlay
// (Final, Native, Public, BlueprintCallable)

void UFlipbookWidget::EndPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlipbookWidget", "EndPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.FlipbookWidget.IsPlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlipbookWidget::IsPlaying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlipbookWidget", "IsPlaying");

	Params::FlipbookWidget_IsPlaying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ForcedAnimationComponent.OnWeaponEquipped
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UForcedAnimationComponent::OnWeaponEquipped(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ForcedAnimationComponent", "OnWeaponEquipped");

	Params::ForcedAnimationComponent_OnWeaponEquipped Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ForcedAnimationComponent.PlayEquippedWeaponInspectionAnimation
// (Final, Native, Public, BlueprintCallable)

void UForcedAnimationComponent::PlayEquippedWeaponInspectionAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ForcedAnimationComponent", "PlayEquippedWeaponInspectionAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.FPVAnimInstance.OnHeadbobbingChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bShouldHeadbob                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFPVAnimInstance::OnHeadbobbingChanged(bool bShouldHeadbob)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FPVAnimInstance", "OnHeadbobbingChanged");

	Params::FPVAnimInstance_OnHeadbobbingChanged Parms{};

	Parms.bShouldHeadbob = bShouldHeadbob;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.FPVAnimInstance.GetHeadbobWeight
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFPVAnimInstance::GetHeadbobWeight() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FPVAnimInstance", "GetHeadbobWeight");

	Params::FPVAnimInstance_GetHeadbobWeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.FPVAnimInstance.IsAimTransitioning
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFPVAnimInstance::IsAimTransitioning() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FPVAnimInstance", "IsAimTransitioning");

	Params::FPVAnimInstance_IsAimTransitioning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.FPVCameraComponent.OnFieldOfViewSettingChanged
// (Final, Native, Protected)
// Parameters:
// float                                   NewFOV                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFPVCameraComponent::OnFieldOfViewSettingChanged(float NewFOV)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FPVCameraComponent", "OnFieldOfViewSettingChanged");

	Params::FPVCameraComponent_OnFieldOfViewSettingChanged Parms{};

	Parms.NewFOV = NewFOV;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.FPVSkeletalMeshComponent.SetFixedFOVforFPVEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InbFixedFOVEnabled                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFPVSkeletalMeshComponent::SetFixedFOVforFPVEnabled(bool InbFixedFOVEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FPVSkeletalMeshComponent", "SetFixedFOVforFPVEnabled");

	Params::FPVSkeletalMeshComponent_SetFixedFOVforFPVEnabled Parms{};

	Parms.InbFixedFOVEnabled = InbFixedFOVEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.FPVSkeletalMeshComponent.IsFixedFOVEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFPVSkeletalMeshComponent::IsFixedFOVEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FPVSkeletalMeshComponent", "IsFixedFOVEnabled");

	Params::FPVSkeletalMeshComponent_IsFixedFOVEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.GameCalendar.K2_AdvanceDays
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Days                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameCalendar::K2_AdvanceDays(float Days)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameCalendar", "K2_AdvanceDays");

	Params::GameCalendar_K2_AdvanceDays Parms{};

	Parms.Days = Days;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GameCalendar.K2_AdvanceHours
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Hours                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameCalendar::K2_AdvanceHours(float Hours)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameCalendar", "K2_AdvanceHours");

	Params::GameCalendar_K2_AdvanceHours Parms{};

	Parms.Hours = Hours;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GameCalendar.K2_AdvanceMinutes
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Minutes                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameCalendar::K2_AdvanceMinutes(float Minutes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameCalendar", "K2_AdvanceMinutes");

	Params::GameCalendar_K2_AdvanceMinutes Parms{};

	Parms.Minutes = Minutes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GameCalendar.K2_AdvanceSeconds
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameCalendar::K2_AdvanceSeconds(float Seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameCalendar", "K2_AdvanceSeconds");

	Params::GameCalendar_K2_AdvanceSeconds Parms{};

	Parms.Seconds = Seconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GameCalendar.K2_AdvanceTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Days                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Hours                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Minutes                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameCalendar::K2_AdvanceTime(float Days, float Hours, float Minutes, float Seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameCalendar", "K2_AdvanceTime");

	Params::GameCalendar_K2_AdvanceTime Parms{};

	Parms.Days = Days;
	Parms.Hours = Hours;
	Parms.Minutes = Minutes;
	Parms.Seconds = Seconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GameCalendar.K2_AdvanceToHour
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   TargetHour                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameCalendar::K2_AdvanceToHour(int32 TargetHour)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameCalendar", "K2_AdvanceToHour");

	Params::GameCalendar_K2_AdvanceToHour Parms{};

	Parms.TargetHour = TargetHour;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GameCalendar.K2_ClearNamedTimestamp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           TimestampName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameCalendar::K2_ClearNamedTimestamp(const class FString& TimestampName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameCalendar", "K2_ClearNamedTimestamp");

	Params::GameCalendar_K2_ClearNamedTimestamp Parms{};

	Parms.TimestampName = std::move(TimestampName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GameCalendar.K2_GetNormalizedTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameCalendar::K2_GetNormalizedTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameCalendar", "K2_GetNormalizedTime");

	Params::GameCalendar_K2_GetNormalizedTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.GameCalendar.K2_GetRawHour
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameCalendar::K2_GetRawHour()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameCalendar", "K2_GetRawHour");

	Params::GameCalendar_K2_GetRawHour Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.GameCalendar.K2_HaveDaysElapsedSinceNamedTimestamp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           TimestampName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Days                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameCalendar::K2_HaveDaysElapsedSinceNamedTimestamp(const class FString& TimestampName, int32 Days)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameCalendar", "K2_HaveDaysElapsedSinceNamedTimestamp");

	Params::GameCalendar_K2_HaveDaysElapsedSinceNamedTimestamp Parms{};

	Parms.TimestampName = std::move(TimestampName);
	Parms.Days = Days;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.GameCalendar.K2_HaveHoursElapsedSinceNamedTimestamp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           TimestampName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Hours                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameCalendar::K2_HaveHoursElapsedSinceNamedTimestamp(const class FString& TimestampName, int32 Hours)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameCalendar", "K2_HaveHoursElapsedSinceNamedTimestamp");

	Params::GameCalendar_K2_HaveHoursElapsedSinceNamedTimestamp Parms{};

	Parms.TimestampName = std::move(TimestampName);
	Parms.Hours = Hours;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.GameCalendar.K2_HaveMinutesElapsedSinceNamedTimestamp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           TimestampName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Minutes                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameCalendar::K2_HaveMinutesElapsedSinceNamedTimestamp(const class FString& TimestampName, int32 Minutes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameCalendar", "K2_HaveMinutesElapsedSinceNamedTimestamp");

	Params::GameCalendar_K2_HaveMinutesElapsedSinceNamedTimestamp Parms{};

	Parms.TimestampName = std::move(TimestampName);
	Parms.Minutes = Minutes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.GameCalendar.K2_IsPhaseOfDay
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EPhaseOfDay                             Phase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameCalendar::K2_IsPhaseOfDay(EPhaseOfDay Phase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameCalendar", "K2_IsPhaseOfDay");

	Params::GameCalendar_K2_IsPhaseOfDay Parms{};

	Parms.Phase = Phase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.GameCalendar.K2_IsTimeSlice
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   StartHour                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EndHour                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameCalendar::K2_IsTimeSlice(int32 StartHour, int32 EndHour)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameCalendar", "K2_IsTimeSlice");

	Params::GameCalendar_K2_IsTimeSlice Parms{};

	Parms.StartHour = StartHour;
	Parms.EndHour = EndHour;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.GameCalendar.K2_RegisterNamedTimestamp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           TimestampName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameCalendar::K2_RegisterNamedTimestamp(const class FString& TimestampName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameCalendar", "K2_RegisterNamedTimestamp");

	Params::GameCalendar_K2_RegisterNamedTimestamp Parms{};

	Parms.TimestampName = std::move(TimestampName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GameCalendar.K2_SetupDelayedCallback
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       EventToDelay                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   SecondsToDelay                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameCalendar::K2_SetupDelayedCallback(class UObject* WorldContextObject, const TDelegate<void()>& EventToDelay, float SecondsToDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameCalendar", "K2_SetupDelayedCallback");

	Params::GameCalendar_K2_SetupDelayedCallback Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EventToDelay = EventToDelay;
	Parms.SecondsToDelay = SecondsToDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GameCalendar.AdvanceDays
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Days                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameCalendar::AdvanceDays(float Days)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCalendar", "AdvanceDays");

	Params::GameCalendar_AdvanceDays Parms{};

	Parms.Days = Days;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GameCalendar.AdvanceHours
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Hours                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameCalendar::AdvanceHours(float Hours)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCalendar", "AdvanceHours");

	Params::GameCalendar_AdvanceHours Parms{};

	Parms.Hours = Hours;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GameCalendar.AdvanceMinutes
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Minutes                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameCalendar::AdvanceMinutes(float Minutes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCalendar", "AdvanceMinutes");

	Params::GameCalendar_AdvanceMinutes Parms{};

	Parms.Minutes = Minutes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GameCalendar.AdvanceSeconds
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameCalendar::AdvanceSeconds(float Seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCalendar", "AdvanceSeconds");

	Params::GameCalendar_AdvanceSeconds Parms{};

	Parms.Seconds = Seconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GameCalendar.AdvanceTime
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Days                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Hours                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Minutes                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameCalendar::AdvanceTime(float Days, float Hours, float Minutes, float Seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCalendar", "AdvanceTime");

	Params::GameCalendar_AdvanceTime Parms{};

	Parms.Days = Days;
	Parms.Hours = Hours;
	Parms.Minutes = Minutes;
	Parms.Seconds = Seconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GameCalendar.AdvanceToHour
// (Final, Exec, Native, Public)
// Parameters:
// float                                   TargetHour                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameCalendar::AdvanceToHour(float TargetHour)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCalendar", "AdvanceToHour");

	Params::GameCalendar_AdvanceToHour Parms{};

	Parms.TargetHour = TargetHour;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GameCalendar.ForceWeatherEnd
// (Final, Exec, Native, Public)

void UGameCalendar::ForceWeatherEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCalendar", "ForceWeatherEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GameCalendar.ForceWeatherStart
// (Final, Exec, Native, Public)

void UGameCalendar::ForceWeatherStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCalendar", "ForceWeatherStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GameCalendar.LockCalendar
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    Block                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameCalendar::LockCalendar(bool Block)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCalendar", "LockCalendar");

	Params::GameCalendar_LockCalendar Parms{};

	Parms.Block = Block;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GameCalendar.RequestPauseTime
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             RequestContext                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameCalendar::RequestPauseTime(const class FName& RequestContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCalendar", "RequestPauseTime");

	Params::GameCalendar_RequestPauseTime Parms{};

	Parms.RequestContext = RequestContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GameCalendar.RequestUnpauseTime
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             RequestContext                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameCalendar::RequestUnpauseTime(const class FName& RequestContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCalendar", "RequestUnpauseTime");

	Params::GameCalendar_RequestUnpauseTime Parms{};

	Parms.RequestContext = RequestContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GammaSelectionWidget.ApplyDefaults
// (Final, Native, Protected)

void UGammaSelectionWidget::ApplyDefaults()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GammaSelectionWidget", "ApplyDefaults");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GammaSelectionWidget.OnGammaAccepted
// (Final, Native, Protected)

void UGammaSelectionWidget::OnGammaAccepted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GammaSelectionWidget", "OnGammaAccepted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GammaSelectionWidget.OnGammaChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FSliderEvent                     Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGammaSelectionWidget::OnGammaChanged(const struct FSliderEvent& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GammaSelectionWidget", "OnGammaChanged");

	Params::GammaSelectionWidget_OnGammaChanged Parms{};

	Parms.Event = std::move(Event);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GammaSelectionWidget.OnLocStringChanged
// (Final, Native, Protected)

void UGammaSelectionWidget::OnLocStringChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GammaSelectionWidget", "OnLocStringChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GammaSelectionWidget.OnRestoreDefaults
// (Final, Native, Protected)

void UGammaSelectionWidget::OnRestoreDefaults()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GammaSelectionWidget", "OnRestoreDefaults");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaCharacter.CastSpellDebug
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           SpellName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaCharacter::CastSpellDebug(const class FString& SpellName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCharacter", "CastSpellDebug");

	Params::IndianaCharacter_CastSpellDebug Parms{};

	Parms.SpellName = std::move(SpellName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaCharacter.CastSpellDebugTarget
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           SpellName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaCharacter::CastSpellDebugTarget(const class FString& SpellName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCharacter", "CastSpellDebugTarget");

	Params::IndianaCharacter_CastSpellDebugTarget Parms{};

	Parms.SpellName = std::move(SpellName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaCharacter.DamageCaused
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FCauseDamageInfo                 CauseDamageInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AIndianaCharacter::DamageCaused(const struct FCauseDamageInfo& CauseDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCharacter", "DamageCaused");

	Params::IndianaCharacter_DamageCaused Parms{};

	Parms.CauseDamageInfo = std::move(CauseDamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaCharacter.Died
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FCauseDamageInfo                 CDI                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AIndianaCharacter::Died(const struct FCauseDamageInfo& CDI)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCharacter", "Died");

	Params::IndianaCharacter_Died Parms{};

	Parms.CDI = std::move(CDI);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaCharacter.ExecuteDeath
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bFromReload                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaCharacter::ExecuteDeath(bool bFromReload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCharacter", "ExecuteDeath");

	Params::IndianaCharacter_ExecuteDeath Parms{};

	Parms.bFromReload = bFromReload;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.IndianaCharacter.ItemAdded
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FItemStack                       Item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AIndianaCharacter::ItemAdded(const struct FItemStack& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCharacter", "ItemAdded");

	Params::IndianaCharacter_ItemAdded Parms{};

	Parms.Item = std::move(Item);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaCharacter.ItemRemoved
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FItemStack                       Item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AIndianaCharacter::ItemRemoved(const struct FItemStack& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCharacter", "ItemRemoved");

	Params::IndianaCharacter_ItemRemoved Parms{};

	Parms.Item = std::move(Item);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaCharacter.OnAttack
// (Final, Native, Protected)
// Parameters:
// float                                   DurationScalar                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaCharacter::OnAttack(float DurationScalar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCharacter", "OnAttack");

	Params::IndianaCharacter_OnAttack Parms{};

	Parms.DurationScalar = DurationScalar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaCharacter.OnDifficultyChanged
// (Final, Native, Protected)
// Parameters:
// EGameDifficulty                         NewDifficulty                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaCharacter::OnDifficultyChanged(EGameDifficulty NewDifficulty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCharacter", "OnDifficultyChanged");

	Params::IndianaCharacter_OnDifficultyChanged Parms{};

	Parms.NewDifficulty = NewDifficulty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaCharacter.OnLevelChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaCharacter::OnLevelChanged(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCharacter", "OnLevelChanged");

	Params::IndianaCharacter_OnLevelChanged Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaCharacter.OnNewStateOfBeing
// (Native, Protected)
// Parameters:
// EStateOfBeing                           NewStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStateOfBeing                           OldStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaCharacter::OnNewStateOfBeing(EStateOfBeing NewStateOfBeing, EStateOfBeing OldStateOfBeing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCharacter", "OnNewStateOfBeing");

	Params::IndianaCharacter_OnNewStateOfBeing Parms{};

	Parms.NewStateOfBeing = NewStateOfBeing;
	Parms.OldStateOfBeing = OldStateOfBeing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaCharacter.OnPreStateOfBeingChange
// (Native, Protected)
// Parameters:
// EStateOfBeing                           StateOfBeing                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaCharacter::OnPreStateOfBeingChange(EStateOfBeing StateOfBeing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCharacter", "OnPreStateOfBeingChange");

	Params::IndianaCharacter_OnPreStateOfBeingChange Parms{};

	Parms.StateOfBeing = StateOfBeing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaCharacter.OnRestoredStateOfBeing
// (Native, Protected)
// Parameters:
// EStateOfBeing                           RestoredStateOfBeing                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaCharacter::OnRestoredStateOfBeing(EStateOfBeing RestoredStateOfBeing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCharacter", "OnRestoredStateOfBeing");

	Params::IndianaCharacter_OnRestoredStateOfBeing Parms{};

	Parms.RestoredStateOfBeing = RestoredStateOfBeing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaCharacter.PlayWeaponEvent
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           WeaponEvent                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaCharacter::PlayWeaponEvent(const class FString& WeaponEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCharacter", "PlayWeaponEvent");

	Params::IndianaCharacter_PlayWeaponEvent Parms{};

	Parms.WeaponEvent = std::move(WeaponEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaCharacter.UpdateOutlines
// (Final, Native, Public)

void AIndianaCharacter::UpdateOutlines()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCharacter", "UpdateOutlines");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaCharacter.GetCurrentWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWeapon*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWeapon* AIndianaCharacter::GetCurrentWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCharacter", "GetCurrentWeapon");

	Params::IndianaCharacter_GetCurrentWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaCharacter.GetEquipmentComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEquipmentComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEquipmentComponent* AIndianaCharacter::GetEquipmentComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCharacter", "GetEquipmentComponent");

	Params::IndianaCharacter_GetEquipmentComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaCharacter.GetItemQuantity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UItem>                Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AIndianaCharacter::GetItemQuantity(TSubclassOf<class UItem> Item) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCharacter", "GetItemQuantity");

	Params::IndianaCharacter_GetItemQuantity Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaCharacter.GetStatusEffectManager
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UStatusEffectManagerComponent*    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStatusEffectManagerComponent* AIndianaCharacter::GetStatusEffectManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCharacter", "GetStatusEffectManager");

	Params::IndianaCharacter_GetStatusEffectManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaCharacter.HasItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UItem>                Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AIndianaCharacter::HasItem(TSubclassOf<class UItem> Item) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCharacter", "HasItem");

	Params::IndianaCharacter_HasItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaCharacter.IsArmorEquipped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UArmorItem>           ArmorClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AIndianaCharacter::IsArmorEquipped(TSubclassOf<class UArmorItem> ArmorClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCharacter", "IsArmorEquipped");

	Params::IndianaCharacter_IsArmorEquipped Parms{};

	Parms.ArmorClass = ArmorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaCharacter.IsWeaponEquipped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UWeapon>              WeaponClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AIndianaCharacter::IsWeaponEquipped(TSubclassOf<class UWeapon> WeaponClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCharacter", "IsWeaponEquipped");

	Params::IndianaCharacter_IsWeaponEquipped Parms{};

	Parms.WeaponClass = WeaponClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaAiCharacter.OnActorHiddenChange
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsHidden                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaAiCharacter::OnActorHiddenChange(bool bIsHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAiCharacter", "OnActorHiddenChange");

	Params::IndianaAiCharacter_OnActorHiddenChange Parms{};

	Parms.bIsHidden = bIsHidden;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.IndianaAiCharacter.OnAlertStateChange
// (Final, Native, Protected)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAlertState                             PreviousAlertState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAlertState                             TargetAlertState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaAiCharacter::OnAlertStateChange(class AActor* TargetActor, EAlertState PreviousAlertState, EAlertState TargetAlertState, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAiCharacter", "OnAlertStateChange");

	Params::IndianaAiCharacter_OnAlertStateChange Parms{};

	Parms.TargetActor = TargetActor;
	Parms.PreviousAlertState = PreviousAlertState;
	Parms.TargetAlertState = TargetAlertState;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAiCharacter.OnDamageEvent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FCauseDamageInfo                 CauseDamageInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AIndianaAiCharacter::OnDamageEvent(const struct FCauseDamageInfo& CauseDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAiCharacter", "OnDamageEvent");

	Params::IndianaAiCharacter_OnDamageEvent Parms{};

	Parms.CauseDamageInfo = std::move(CauseDamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAiCharacter.OnMontageEndDelegate
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaAiCharacter::OnMontageEndDelegate(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAiCharacter", "OnMontageEndDelegate");

	Params::IndianaAiCharacter_OnMontageEndDelegate Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAiCharacter.OnWeaponEndEquip
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaAiCharacter::OnWeaponEndEquip(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAiCharacter", "OnWeaponEndEquip");

	Params::IndianaAiCharacter_OnWeaponEndEquip Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAiCharacter.OnWeaponEndUnequip
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaAiCharacter::OnWeaponEndUnequip(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAiCharacter", "OnWeaponEndUnequip");

	Params::IndianaAiCharacter_OnWeaponEndUnequip Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAiCharacter.SetIsInLowGrav
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewIsInLowGrav                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaAiCharacter::SetIsInLowGrav(bool bNewIsInLowGrav)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAiCharacter", "SetIsInLowGrav");

	Params::IndianaAiCharacter_SetIsInLowGrav Parms{};

	Parms.bNewIsInLowGrav = bNewIsInLowGrav;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAiCharacter.SetRagdoll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInIsRagdoll                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInstantFreeze                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaAiCharacter::SetRagdoll(bool bInIsRagdoll, bool bInstantFreeze)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAiCharacter", "SetRagdoll");

	Params::IndianaAiCharacter_SetRagdoll Parms{};

	Parms.bInIsRagdoll = bInIsRagdoll;
	Parms.bInstantFreeze = bInstantFreeze;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAiCharacter.GetOwningController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AIndianaAiController*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AIndianaAiController* AIndianaAiCharacter::GetOwningController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAiCharacter", "GetOwningController");

	Params::IndianaAiCharacter_GetOwningController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaAiCharacter.IsInCombat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AIndianaAiCharacter::IsInCombat() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAiCharacter", "IsInCombat");

	Params::IndianaAiCharacter_IsInCombat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.GenericNotificationEntryWidget.OnFadeInComplete
// (Final, Native, Protected, BlueprintCallable)

void UGenericNotificationEntryWidget::OnFadeInComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GenericNotificationEntryWidget", "OnFadeInComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GenericNotificationEntryWidget.OnFadeOutComplete
// (Final, Native, Protected, BlueprintCallable)

void UGenericNotificationEntryWidget::OnFadeOutComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GenericNotificationEntryWidget", "OnFadeOutComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GenericNotificationEntryWidget.OnStickLayoutChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGenericNotificationEntryWidget::OnStickLayoutChanged(int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GenericNotificationEntryWidget", "OnStickLayoutChanged");

	Params::GenericNotificationEntryWidget_OnStickLayoutChanged Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GenericNotificationEntryWidget.PrepareNewMessage
// (Event, Protected, BlueprintEvent)

void UGenericNotificationEntryWidget::PrepareNewMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GenericNotificationEntryWidget", "PrepareNewMessage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.GenericNotificationEntryWidget.PrepareNextMessage
// (Event, Protected, BlueprintEvent)

void UGenericNotificationEntryWidget::PrepareNextMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GenericNotificationEntryWidget", "PrepareNextMessage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.GenericNotificationWidget.OnFadeOutComplete
// (Final, Native, Protected, BlueprintCallable)

void UGenericNotificationWidget::OnFadeOutComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GenericNotificationWidget", "OnFadeOutComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GenericNotificationWidget.OnHUDVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGenericNotificationWidget::OnHUDVisibilityChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GenericNotificationWidget", "OnHUDVisibilityChanged");

	Params::GenericNotificationWidget_OnHUDVisibilityChanged Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GenericNotificationWidget.OnNotificationDurationChanged
// (Final, Native, Protected)
// Parameters:
// float                                   NotificationTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGenericNotificationWidget::OnNotificationDurationChanged(float NotificationTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GenericNotificationWidget", "OnNotificationDurationChanged");

	Params::GenericNotificationWidget_OnNotificationDurationChanged Parms{};

	Parms.NotificationTime = NotificationTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GenericNotificationWidget.OnSaveGameComplete
// (Final, Native, Protected)
// Parameters:
// ESaveGameResult                         SaveResult                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESaveGameType                           SaveGameType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGenericNotificationWidget::OnSaveGameComplete(ESaveGameResult SaveResult, ESaveGameType SaveGameType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GenericNotificationWidget", "OnSaveGameComplete");

	Params::GenericNotificationWidget_OnSaveGameComplete Parms{};

	Parms.SaveResult = SaveResult;
	Parms.SaveGameType = SaveGameType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.GenericNotificationWidget.SetBackingMaterialHeight
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   NewHeight                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGenericNotificationWidget::SetBackingMaterialHeight(float NewHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GenericNotificationWidget", "SetBackingMaterialHeight");

	Params::GenericNotificationWidget_SetBackingMaterialHeight Parms{};

	Parms.NewHeight = NewHeight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.GenericNotificationWidget.TriggerFadeIn
// (Event, Protected, BlueprintEvent)

void UGenericNotificationWidget::TriggerFadeIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GenericNotificationWidget", "TriggerFadeIn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.GenericNotificationWidget.TriggerFadeOut
// (Event, Protected, BlueprintEvent)

void UGenericNotificationWidget::TriggerFadeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GenericNotificationWidget", "TriggerFadeOut");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.TravelDestinationData.GetDebugString
// (Final, Native, Public, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTravelDestinationData::GetDebugString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TravelDestinationData", "GetDebugString");

	Params::TravelDestinationData_GetDebugString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.GravManger.SetLowGravAmbientAudioEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGravManger::SetLowGravAmbientAudioEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GravManger", "SetLowGravAmbientAudioEnabled");

	Params::GravManger_SetLowGravAmbientAudioEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ButtonGroup.CycleNextButton
// (Final, Native, Private)

void UButtonGroup::CycleNextButton()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonGroup", "CycleNextButton");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ButtonGroup.CyclePreviousButton
// (Final, Native, Private)

void UButtonGroup::CyclePreviousButton()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonGroup", "CyclePreviousButton");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ButtonGroup.OnButtonFocused
// (Final, Native, Private)
// Parameters:
// class UButtonBase*                      Button                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UButtonGroup::OnButtonFocused(class UButtonBase* Button)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonGroup", "OnButtonFocused");

	Params::ButtonGroup_OnButtonFocused Parms{};

	Parms.Button = Button;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ButtonGroup.OnButtonUnFocused
// (Final, Native, Private)
// Parameters:
// class UButtonBase*                      Button                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UButtonGroup::OnButtonUnFocused(class UButtonBase* Button)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ButtonGroup", "OnButtonUnFocused");

	Params::ButtonGroup_OnButtonUnFocused Parms{};

	Parms.Button = Button;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ScrollingWidgetGroup.OnScrollingComplete
// (Final, Native, Protected)

void UScrollingWidgetGroup::OnScrollingComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScrollingWidgetGroup", "OnScrollingComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Hazard.AttemptEnableHazard
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHazard::AttemptEnableHazard(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hazard", "AttemptEnableHazard");

	Params::Hazard_AttemptEnableHazard Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Hazard.CustomUpdate
// (Event, Public, BlueprintEvent)

void AHazard::CustomUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hazard", "CustomUpdate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.Hazard.ForceSetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewEnabled                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHazard::ForceSetEnabled(bool bNewEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hazard", "ForceSetEnabled");

	Params::Hazard_ForceSetEnabled Parms{};

	Parms.bNewEnabled = bNewEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Hazard.OnActorEntered
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AHazard::OnActorEntered(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hazard", "OnActorEntered");

	Params::Hazard_OnActorEntered Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Hazard.OnActorExited
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHazard::OnActorExited(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hazard", "OnActorExited");

	Params::Hazard_OnActorExited Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.HazardAudioComponent.Play
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHazardEventType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHazardAudioComponent::Play(EHazardEventType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HazardAudioComponent", "Play");

	Params::HazardAudioComponent_Play Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.HazardAudioComponent.Stop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHazardEventType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHazardAudioComponent::Stop(EHazardEventType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HazardAudioComponent", "Stop");

	Params::HazardAudioComponent_Stop Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.HealthComponent.KillNPC
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AIndianaAiCharacter*              Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::KillNPC(class AIndianaAiCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HealthComponent", "KillNPC");

	Params::HealthComponent_KillNPC Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.HealthComponent.DeathComplete
// (Native, Protected)
// Parameters:
// class AActor*                           DeadActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::DeathComplete(class AActor* DeadActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "DeathComplete");

	Params::HealthComponent_DeathComplete Parms{};

	Parms.DeadActor = DeadActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.HealthComponent.GetNormalizedHealth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetNormalizedHealth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetNormalizedHealth");

	Params::HealthComponent_GetNormalizedHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.HealthComponent.God
// (Final, Exec, Native, Public)

void UHealthComponent::God()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "God");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.HealthComponent.GodCompanions
// (Final, Exec, Native, Public)

void UHealthComponent::GodCompanions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GodCompanions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.HealthComponent.HealthFill
// (Final, Exec, Native, Public)

void UHealthComponent::HealthFill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "HealthFill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.HealthComponent.LevelChanged
// (Native, Protected)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::LevelChanged(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "LevelChanged");

	Params::HealthComponent_LevelChanged Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.HealthComponent.OnAttributeUpdated
// (Native, Protected)
// Parameters:
// EAttribute                              Attribute                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::OnAttributeUpdated(EAttribute Attribute, int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "OnAttributeUpdated");

	Params::HealthComponent_OnAttributeUpdated Parms{};

	Parms.Attribute = Attribute;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.HealthComponent.OnStatUpdated
// (Native, Protected)
// Parameters:
// class URpgStat*                         Stat                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::OnStatUpdated(const class URpgStat* Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "OnStatUpdated");

	Params::HealthComponent_OnStatUpdated Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.HealthComponent.PseudoGod
// (Final, Exec, Native, Public)

void UHealthComponent::PseudoGod()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "PseudoGod");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.HealthComponent.SetGod
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::SetGod(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "SetGod");

	Params::HealthComponent_SetGod Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.HealthComponent.SetHealthPercent
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::SetHealthPercent(float Percent, class AActor* Instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "SetHealthPercent");

	Params::HealthComponent_SetHealthPercent Parms{};

	Parms.Percent = Percent;
	Parms.Instigator = Instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.HealthComponent.SetHealthPercentNPC
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::SetHealthPercentNPC(float Percent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "SetHealthPercentNPC");

	Params::HealthComponent_SetHealthPercentNPC Parms{};

	Parms.Percent = Percent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.HealthComponent.SetPseudoGod
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::SetPseudoGod(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "SetPseudoGod");

	Params::HealthComponent_SetPseudoGod Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.HealthComponent.Suicide
// (Final, Exec, Native, Public)

void UHealthComponent::Suicide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "Suicide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.HealthComponent.GetHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetHealth");

	Params::HealthComponent_GetHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.HealthComponent.GetMaxHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetMaxHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetMaxHealth");

	Params::HealthComponent_GetMaxHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.HealthComponent.GetRegenRate
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetRegenRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetRegenRate");

	Params::HealthComponent_GetRegenRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.HealthComponent.GetRegenRatePoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthComponent::GetRegenRatePoints() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetRegenRatePoints");

	Params::HealthComponent_GetRegenRatePoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.HealthComponent.GetStateOfBeing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EStateOfBeing                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EStateOfBeing UHealthComponent::GetStateOfBeing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "GetStateOfBeing");

	Params::HealthComponent_GetStateOfBeing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.HealthKitTooltipWidget.FontSizeChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   NewModifier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthKitTooltipWidget::FontSizeChanged(int32 NewModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthKitTooltipWidget", "FontSizeChanged");

	Params::HealthKitTooltipWidget_FontSizeChanged Parms{};

	Parms.NewModifier = NewModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameplayStatics.ApplyCACVisibilityToActorCollision
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UChildActorComponent*             CAC                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameplayStatics::ApplyCACVisibilityToActorCollision(class UChildActorComponent* CAC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "ApplyCACVisibilityToActorCollision");

	Params::IndianaGameplayStatics_ApplyCACVisibilityToActorCollision Parms{};

	Parms.CAC = CAC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameplayStatics.ApplyGenericDamage
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseDamage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>          DamageType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseCustomDamageDescription                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageDescription               CustomDamageDescription                                (Parm, AdvancedDisplay, NativeAccessSpecifierPublic)

void UIndianaGameplayStatics::ApplyGenericDamage(class AActor* DamageCauser, class AActor* DamagedActor, float BaseDamage, TSubclassOf<class UDamageType> DamageType, bool bUseCustomDamageDescription, const struct FDamageDescription& CustomDamageDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "ApplyGenericDamage");

	Params::IndianaGameplayStatics_ApplyGenericDamage Parms{};

	Parms.DamageCauser = DamageCauser;
	Parms.DamagedActor = DamagedActor;
	Parms.BaseDamage = BaseDamage;
	Parms.DamageType = DamageType;
	Parms.bUseCustomDamageDescription = bUseCustomDamageDescription;
	Parms.CustomDamageDescription = std::move(CustomDamageDescription);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameplayStatics.CanCharacterUnlockRestrictedStock
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AIndianaCharacter*                Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameplayStatics::CanCharacterUnlockRestrictedStock(class AIndianaCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "CanCharacterUnlockRestrictedStock");

	Params::IndianaGameplayStatics_CanCharacterUnlockRestrictedStock Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.ClearPlayerCombat
// (Final, Native, Static, Public, BlueprintCallable)

void UIndianaGameplayStatics::ClearPlayerCombat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "ClearPlayerCombat");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameplayStatics.ConstructComponentByClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ECheckBranches                          Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InOuter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           InClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* UIndianaGameplayStatics::ConstructComponentByClass(ECheckBranches* Branches, class UObject* InOuter, class UClass* InClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "ConstructComponentByClass");

	Params::IndianaGameplayStatics_ConstructComponentByClass Parms{};

	Parms.InOuter = InOuter;
	Parms.InClass = InClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.CreateDialogWidget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLocString                       BodyLocString                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCancellable                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDialogBoxWidget*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDialogBoxWidget* UIndianaGameplayStatics::CreateDialogWidget(const struct FLocString& BodyLocString, bool bCancellable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "CreateDialogWidget");

	Params::IndianaGameplayStatics_CreateDialogWidget Parms{};

	Parms.BodyLocString = std::move(BodyLocString);
	Parms.bCancellable = bCancellable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.CreateEndGameDialogWidget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLocString                       BodyLocString                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDialogBoxWidget*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDialogBoxWidget* UIndianaGameplayStatics::CreateEndGameDialogWidget(const struct FLocString& BodyLocString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "CreateEndGameDialogWidget");

	Params::IndianaGameplayStatics_CreateEndGameDialogWidget Parms{};

	Parms.BodyLocString = std::move(BodyLocString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.DilateTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          ContextObject                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   UndilatedTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameplayStatics::DilateTime(class UObject* ContextObject, float UndilatedTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "DilateTime");

	Params::IndianaGameplayStatics_DilateTime Parms{};

	Parms.ContextObject = ContextObject;
	Parms.UndilatedTime = UndilatedTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.EnableParticleSystemEmitters
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleSystemComponent*         ParticleSystem                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     EnabledEmitters                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UIndianaGameplayStatics::EnableParticleSystemEmitters(class UParticleSystemComponent* ParticleSystem, const TArray<class FName>& EnabledEmitters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "EnableParticleSystemEmitters");

	Params::IndianaGameplayStatics_EnableParticleSystemEmitters Parms{};

	Parms.ParticleSystem = ParticleSystem;
	Parms.EnabledEmitters = std::move(EnabledEmitters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameplayStatics.FindChildComponentsByTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USceneComponent*                  ParentComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class USceneComponent*>          ChildComponents                                        (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameplayStatics::FindChildComponentsByTag(class USceneComponent* ParentComponent, class FName Tag, TArray<class USceneComponent*>* ChildComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "FindChildComponentsByTag");

	Params::IndianaGameplayStatics_FindChildComponentsByTag Parms{};

	Parms.ParentComponent = ParentComponent;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ChildComponents != nullptr)
		*ChildComponents = std::move(Parms.ChildComponents);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.FindFirstChildComponentByTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ECheckBranches                          Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  ParentComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* UIndianaGameplayStatics::FindFirstChildComponentByTag(ECheckBranches* Branches, class USceneComponent* ParentComponent, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "FindFirstChildComponentByTag");

	Params::IndianaGameplayStatics_FindFirstChildComponentByTag Parms{};

	Parms.ParentComponent = ParentComponent;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.GetActorBySpeakerName
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// ECheckBranches                          Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            SpeakerReference                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UIndianaGameplayStatics::GetActorBySpeakerName(ECheckBranches* Branches, const struct FGuid& SpeakerReference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "GetActorBySpeakerName");

	Params::IndianaGameplayStatics_GetActorBySpeakerName Parms{};

	Parms.SpeakerReference = std::move(SpeakerReference);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.GetAllAppearanceRelatedMeshes
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMeshComponent*>           Meshes                                                 (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIncludeWeapon                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameplayStatics::GetAllAppearanceRelatedMeshes(class AActor* Actor, TArray<class UMeshComponent*>* Meshes, bool bIncludeWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "GetAllAppearanceRelatedMeshes");

	Params::IndianaGameplayStatics_GetAllAppearanceRelatedMeshes Parms{};

	Parms.Actor = Actor;
	Parms.bIncludeWeapon = bIncludeWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Meshes != nullptr)
		*Meshes = std::move(Parms.Meshes);
}


// Function Indiana.IndianaGameplayStatics.GetBlendSpaceLength
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UBlendSpaceBase*                  BlendSpace                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameplayStatics::GetBlendSpaceLength(const class UBlendSpaceBase* BlendSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "GetBlendSpaceLength");

	Params::IndianaGameplayStatics_GetBlendSpaceLength Parms{};

	Parms.BlendSpace = BlendSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.GetEventEffectEnabledEmitters
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEventEffectParams               Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class FName> UIndianaGameplayStatics::GetEventEffectEnabledEmitters(const struct FEventEffectParams& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "GetEventEffectEnabledEmitters");

	Params::IndianaGameplayStatics_GetEventEffectEnabledEmitters Parms{};

	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.GetEventEffectParam
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEventEffectParams               Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EEventEffectFloatParams                 Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameplayStatics::GetEventEffectParam(const struct FEventEffectParams& Params_0, EEventEffectFloatParams Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "GetEventEffectParam");

	Params::IndianaGameplayStatics_GetEventEffectParam Parms{};

	Parms.Params_0 = std::move(Params_0);
	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.GetEventEffectPhysicalSurface
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEventEffectParams               Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EPhysicalSurface                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPhysicalSurface UIndianaGameplayStatics::GetEventEffectPhysicalSurface(const struct FEventEffectParams& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "GetEventEffectPhysicalSurface");

	Params::IndianaGameplayStatics_GetEventEffectPhysicalSurface Parms{};

	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.GetGameCalendar
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameCalendar*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameCalendar* UIndianaGameplayStatics::GetGameCalendar()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "GetGameCalendar");

	Params::IndianaGameplayStatics_GetGameCalendar Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.GetMeshComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMeshTarget                             MeshType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMeshComponent*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMeshComponent* UIndianaGameplayStatics::GetMeshComponent(const class AActor* TargetActor, EMeshTarget MeshType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "GetMeshComponent");

	Params::IndianaGameplayStatics_GetMeshComponent Parms{};

	Parms.TargetActor = TargetActor;
	Parms.MeshType = MeshType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.GetSkeletalMeshComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMeshTarget                             MeshType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* UIndianaGameplayStatics::GetSkeletalMeshComponent(class AActor* TargetActor, EMeshTarget MeshType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "GetSkeletalMeshComponent");

	Params::IndianaGameplayStatics_GetSkeletalMeshComponent Parms{};

	Parms.TargetActor = TargetActor;
	Parms.MeshType = MeshType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.GetWeaponCurrentAmmoGaugeAlpha
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameplayStatics::GetWeaponCurrentAmmoGaugeAlpha(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "GetWeaponCurrentAmmoGaugeAlpha");

	Params::IndianaGameplayStatics_GetWeaponCurrentAmmoGaugeAlpha Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.GetWeaponCurrentCharge
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameplayStatics::GetWeaponCurrentCharge(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "GetWeaponCurrentCharge");

	Params::IndianaGameplayStatics_GetWeaponCurrentCharge Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.GetWeaponForceSpin
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameplayStatics::GetWeaponForceSpin(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "GetWeaponForceSpin");

	Params::IndianaGameplayStatics_GetWeaponForceSpin Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.GetWeaponIsSwinging
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameplayStatics::GetWeaponIsSwinging(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "GetWeaponIsSwinging");

	Params::IndianaGameplayStatics_GetWeaponIsSwinging Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.GetWeaponProjectileCharge
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameplayStatics::GetWeaponProjectileCharge(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "GetWeaponProjectileCharge");

	Params::IndianaGameplayStatics_GetWeaponProjectileCharge Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.GetWeaponSpinningUp
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameplayStatics::GetWeaponSpinningUp(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "GetWeaponSpinningUp");

	Params::IndianaGameplayStatics_GetWeaponSpinningUp Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.GetWeaponSpinProgress
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameplayStatics::GetWeaponSpinProgress(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "GetWeaponSpinProgress");

	Params::IndianaGameplayStatics_GetWeaponSpinProgress Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.IndianaAsyncLoadAsset
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UObject>           Asset                                                  (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class UObject* LoadedObject)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   HandleOut                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameplayStatics::IndianaAsyncLoadAsset(TSoftObjectPtr<class UObject> Asset, int32 Priority, const TDelegate<void(class UObject* LoadedObject)>& Callback, int32* HandleOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "IndianaAsyncLoadAsset");

	Params::IndianaGameplayStatics_IndianaAsyncLoadAsset Parms{};

	Parms.Asset = Asset;
	Parms.Priority = Priority;
	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (HandleOut != nullptr)
		*HandleOut = Parms.HandleOut;
}


// Function Indiana.IndianaGameplayStatics.IndianaCancelAsyncLoadAsset
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Handle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameplayStatics::IndianaCancelAsyncLoadAsset(int32 Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "IndianaCancelAsyncLoadAsset");

	Params::IndianaGameplayStatics_IndianaCancelAsyncLoadAsset Parms{};

	Parms.Handle = Handle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameplayStatics.InheritMeshProperties
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   ParentMesh                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMeshComponent*                   ChildMesh                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameplayStatics::InheritMeshProperties(class UMeshComponent* ParentMesh, class UMeshComponent* ChildMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "InheritMeshProperties");

	Params::IndianaGameplayStatics_InheritMeshProperties Parms{};

	Parms.ParentMesh = ParentMesh;
	Parms.ChildMesh = ChildMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameplayStatics.InitiateTravel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AIndianaPlayerCharacter*          PlayerCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTravelDestinationData*           TravelDest                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTravelFromMapLedger                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTriggerAutosave                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameplayStatics::InitiateTravel(class AIndianaPlayerCharacter* PlayerCharacter, const class UTravelDestinationData* TravelDest, bool bTravelFromMapLedger, bool bTriggerAutosave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "InitiateTravel");

	Params::IndianaGameplayStatics_InitiateTravel Parms{};

	Parms.PlayerCharacter = PlayerCharacter;
	Parms.TravelDest = TravelDest;
	Parms.bTravelFromMapLedger = bTravelFromMapLedger;
	Parms.bTriggerAutosave = bTriggerAutosave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameplayStatics.IsCharacterInAnyBarkConversation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AIndianaCharacter*                Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameplayStatics::IsCharacterInAnyBarkConversation(class AIndianaCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "IsCharacterInAnyBarkConversation");

	Params::IndianaGameplayStatics_IsCharacterInAnyBarkConversation Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.IsGlobalValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           VariableName                                           (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EComparisonOperator                     Operator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBoolResult                             Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameplayStatics::IsGlobalValue(const class FString& VariableName, EComparisonOperator Operator, int32 Value, EBoolResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "IsGlobalValue");

	Params::IndianaGameplayStatics_IsGlobalValue Parms{};

	Parms.VariableName = std::move(VariableName);
	Parms.Operator = Operator;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.IsGlobalVariableValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGlobalVariable                  Variable                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EBoolResult                             Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameplayStatics::IsGlobalVariableValid(const struct FGlobalVariable& Variable, EBoolResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "IsGlobalVariableValid");

	Params::IndianaGameplayStatics_IsGlobalVariableValid Parms{};

	Parms.Variable = std::move(Variable);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.IsGlobalVariableValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGlobalVariable                  Variable                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EComparisonOperator                     Operator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBoolResult                             Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameplayStatics::IsGlobalVariableValue(const struct FGlobalVariable& Variable, EComparisonOperator Operator, int32 Value, EBoolResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "IsGlobalVariableValue");

	Params::IndianaGameplayStatics_IsGlobalVariableValue Parms{};

	Parms.Variable = std::move(Variable);
	Parms.Operator = Operator;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.IsItemOfClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UItem*                            Item                                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UItem>                ItemType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameplayStatics::IsItemOfClass(const class UItem* Item, TSubclassOf<class UItem> ItemType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "IsItemOfClass");

	Params::IndianaGameplayStatics_IsItemOfClass Parms{};

	Parms.Item = Item;
	Parms.ItemType = ItemType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.IsItemStackOfClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TSubclassOf<class UItem>                ItemType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameplayStatics::IsItemStackOfClass(const struct FItemStack& ItemStack, TSubclassOf<class UItem> ItemType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "IsItemStackOfClass");

	Params::IndianaGameplayStatics_IsItemStackOfClass Parms{};

	Parms.ItemStack = std::move(ItemStack);
	Parms.ItemType = ItemType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.IsQuestActive
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBoolResult                             Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameplayStatics::IsQuestActive(const struct FGuid& QuestID, EBoolResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "IsQuestActive");

	Params::IndianaGameplayStatics_IsQuestActive Parms{};

	Parms.QuestID = std::move(QuestID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.IsRunningAutomationTest
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EBoolResult                             Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameplayStatics::IsRunningAutomationTest(EBoolResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "IsRunningAutomationTest");

	Params::IndianaGameplayStatics_IsRunningAutomationTest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.SetFPVCameraFOV
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bOverrideCustomFOV                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameplayStatics::SetFPVCameraFOV(bool bOverrideCustomFOV)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "SetFPVCameraFOV");

	Params::IndianaGameplayStatics_SetFPVCameraFOV Parms{};

	Parms.bOverrideCustomFOV = bOverrideCustomFOV;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameplayStatics.SetIndianaActorGod
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGodMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameplayStatics::SetIndianaActorGod(class AActor* Actor, bool bGodMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "SetIndianaActorGod");

	Params::IndianaGameplayStatics_SetIndianaActorGod Parms{};

	Parms.Actor = Actor;
	Parms.bGodMode = bGodMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameplayStatics.SetIndianaActorInteractable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInteractable                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameplayStatics::SetIndianaActorInteractable(class AActor* Actor, bool bInteractable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "SetIndianaActorInteractable");

	Params::IndianaGameplayStatics_SetIndianaActorInteractable Parms{};

	Parms.Actor = Actor;
	Parms.bInteractable = bInteractable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameplayStatics.SetIndianaActorPseudoGod
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPseudoGodMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameplayStatics::SetIndianaActorPseudoGod(class AActor* Actor, bool bPseudoGodMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "SetIndianaActorPseudoGod");

	Params::IndianaGameplayStatics_SetIndianaActorPseudoGod Parms{};

	Parms.Actor = Actor;
	Parms.bPseudoGodMode = bPseudoGodMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameplayStatics.SetMoveIgnoreActorCollision
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ActorA                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ActorB                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnore                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameplayStatics::SetMoveIgnoreActorCollision(class AActor* ActorA, class AActor* ActorB, bool bIgnore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "SetMoveIgnoreActorCollision");

	Params::IndianaGameplayStatics_SetMoveIgnoreActorCollision Parms{};

	Parms.ActorA = ActorA;
	Parms.ActorB = ActorB;
	Parms.bIgnore = bIgnore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameplayStatics.SetMoveIgnoreComponentCollision
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              ComponentToIgnore                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnore                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameplayStatics::SetMoveIgnoreComponentCollision(class AActor* Actor, class UPrimitiveComponent* ComponentToIgnore, bool bIgnore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "SetMoveIgnoreComponentCollision");

	Params::IndianaGameplayStatics_SetMoveIgnoreComponentCollision Parms{};

	Parms.Actor = Actor;
	Parms.ComponentToIgnore = ComponentToIgnore;
	Parms.bIgnore = bIgnore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameplayStatics.SetParticleSystemEmittersEnabled
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UParticleSystemComponent*         ParticleSystem                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     EnabledEmitters                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameplayStatics::SetParticleSystemEmittersEnabled(class UParticleSystemComponent* ParticleSystem, const TArray<class FName>& EnabledEmitters, bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "SetParticleSystemEmittersEnabled");

	Params::IndianaGameplayStatics_SetParticleSystemEmittersEnabled Parms{};

	Parms.ParticleSystem = ParticleSystem;
	Parms.EnabledEmitters = std::move(EnabledEmitters);
	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameplayStatics.SpawnPooledEmitterAtLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UParticleSystem*                  EmitterTemplate                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystemComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleSystemComponent* UIndianaGameplayStatics::SpawnPooledEmitterAtLocation(class UParticleSystem* EmitterTemplate, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "SpawnPooledEmitterAtLocation");

	Params::IndianaGameplayStatics_SpawnPooledEmitterAtLocation Parms{};

	Parms.EmitterTemplate = EmitterTemplate;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.Scale = std::move(Scale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.SpawnPooledEmitterAttached
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UParticleSystem*                  EmitterTemplate                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  AttachToComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachPointName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachLocation                         LocationType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystemComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleSystemComponent* UIndianaGameplayStatics::SpawnPooledEmitterAttached(class UParticleSystem* EmitterTemplate, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, EAttachLocation LocationType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "SpawnPooledEmitterAttached");

	Params::IndianaGameplayStatics_SpawnPooledEmitterAttached Parms{};

	Parms.EmitterTemplate = EmitterTemplate;
	Parms.AttachToComponent = AttachToComponent;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.Scale = std::move(Scale);
	Parms.LocationType = LocationType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.SuicideActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameplayStatics::SuicideActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "SuicideActor");

	Params::IndianaGameplayStatics_SuicideActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameplayStatics.TeleportPlayerToStart
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AIndianaPlayerStart*              PlayerStart                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameplayStatics::TeleportPlayerToStart(class AIndianaPlayerStart* PlayerStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "TeleportPlayerToStart");

	Params::IndianaGameplayStatics_TeleportPlayerToStart Parms{};

	Parms.PlayerStart = PlayerStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameplayStatics.UndilateTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          ContextObject                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DilatedTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameplayStatics::UndilateTime(class UObject* ContextObject, float DilatedTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameplayStatics", "UndilateTime");

	Params::IndianaGameplayStatics_UndilateTime Parms{};

	Parms.ContextObject = ContextObject;
	Parms.DilatedTime = DilatedTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.HitEffectIndicatorComponent.HitEffectIndicatorEnableDebugKeys
// (Final, Exec, Native, Public)

void UHitEffectIndicatorComponent::HitEffectIndicatorEnableDebugKeys()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitEffectIndicatorComponent", "HitEffectIndicatorEnableDebugKeys");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.HitEffectIndicatorComponent.OnHit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NormalizedAmount                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   IncidentAngleRelativeToCameraDegrees                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHitEffectIndicatorComponent::OnHit(float NormalizedAmount, float IncidentAngleRelativeToCameraDegrees)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitEffectIndicatorComponent", "OnHit");

	Params::HitEffectIndicatorComponent_OnHit Parms{};

	Parms.NormalizedAmount = NormalizedAmount;
	Parms.IncidentAngleRelativeToCameraDegrees = IncidentAngleRelativeToCameraDegrees;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.HitEffectIndicatorComponent.OnTakeDamage
// (Final, Native, Public)
// Parameters:
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHitEffectIndicatorComponent::OnTakeDamage(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitEffectIndicatorComponent", "OnTakeDamage");

	Params::HitEffectIndicatorComponent_OnTakeDamage Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.Damage = Damage;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatModifierStatusEffect.OnSkillUpdated
// (Final, Native, Protected)
// Parameters:
// ESkill                                  UpdatedSkill                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatModifierStatusEffect::OnSkillUpdated(ESkill UpdatedSkill, int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatModifierStatusEffect", "OnSkillUpdated");

	Params::StatModifierStatusEffect_OnSkillUpdated Parms{};

	Parms.UpdatedSkill = UpdatedSkill;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.HUDWidget.QueueLevelUpNotification
// (Final, Native, Protected)
// Parameters:
// int32                                   NewLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHUDWidget::QueueLevelUpNotification(int32 NewLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDWidget", "QueueLevelUpNotification");

	Params::HUDWidget_QueueLevelUpNotification Parms{};

	Parms.NewLevel = NewLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.HUDWidget.GetCharacterOverview
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCharacterOverviewWidget*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCharacterOverviewWidget* UHUDWidget::GetCharacterOverview() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDWidget", "GetCharacterOverview");

	Params::HUDWidget_GetCharacterOverview Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaAiController.AIScriptAttack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AIndianaAiCharacter*              InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AIndianaCharacter*                InTargetCharacter                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaAiController::AIScriptAttack(class AIndianaAiCharacter* InCharacter, class AIndianaCharacter* InTargetCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaAiController", "AIScriptAttack");

	Params::IndianaAiController_AIScriptAttack Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InTargetCharacter = InTargetCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAiController.AIScriptAttackEncounter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AEncounter*                       InEncounter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AIndianaCharacter*                InTargetCharacter                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaAiController::AIScriptAttackEncounter(class AEncounter* InEncounter, class AIndianaCharacter* InTargetCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaAiController", "AIScriptAttackEncounter");

	Params::IndianaAiController_AIScriptAttackEncounter Parms{};

	Parms.InEncounter = InEncounter;
	Parms.InTargetCharacter = InTargetCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAiController.AIScriptCharactersAttackCharacters
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class AIndianaAiCharacter*>      InCharacters                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class AIndianaAiCharacter*>      InTargetCharacters                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void AIndianaAiController::AIScriptCharactersAttackCharacters(const TArray<class AIndianaAiCharacter*>& InCharacters, const TArray<class AIndianaAiCharacter*>& InTargetCharacters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaAiController", "AIScriptCharactersAttackCharacters");

	Params::IndianaAiController_AIScriptCharactersAttackCharacters Parms{};

	Parms.InCharacters = std::move(InCharacters);
	Parms.InTargetCharacters = std::move(InTargetCharacters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAiController.AIScriptClearScripts
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AIndianaAiCharacter*              InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaAiController::AIScriptClearScripts(class AIndianaAiCharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaAiController", "AIScriptClearScripts");

	Params::IndianaAiController_AIScriptClearScripts Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAiController.AIScriptEncounterAttack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AIndianaAiCharacter*              InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEncounter*                       InTargetEncounter                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaAiController::AIScriptEncounterAttack(class AIndianaAiCharacter* InCharacter, class AEncounter* InTargetEncounter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaAiController", "AIScriptEncounterAttack");

	Params::IndianaAiController_AIScriptEncounterAttack Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InTargetEncounter = InTargetEncounter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAiController.AIScriptEncounterAttackEncounter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AEncounter*                       InEncounter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEncounter*                       InTargetEncounter                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaAiController::AIScriptEncounterAttackEncounter(class AEncounter* InEncounter, class AEncounter* InTargetEncounter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaAiController", "AIScriptEncounterAttackEncounter");

	Params::IndianaAiController_AIScriptEncounterAttackEncounter Parms{};

	Parms.InEncounter = InEncounter;
	Parms.InTargetEncounter = InTargetEncounter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAiController.AIScriptFollowPlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AIndianaAiCharacter*              InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaAiController::AIScriptFollowPlayer(class AIndianaAiCharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaAiController", "AIScriptFollowPlayer");

	Params::IndianaAiController_AIScriptFollowPlayer Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAiController.AIScriptIdle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AIndianaAiCharacter*              InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaAiController::AIScriptIdle(class AIndianaAiCharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaAiController", "AIScriptIdle");

	Params::IndianaAiController_AIScriptIdle Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAiController.AIScriptPatrol
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AIndianaAiCharacter*              InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APatrolNode*                      InPatrolNode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaAiController::AIScriptPatrol(class AIndianaAiCharacter* InCharacter, class APatrolNode* InPatrolNode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaAiController", "AIScriptPatrol");

	Params::IndianaAiController_AIScriptPatrol Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InPatrolNode = InPatrolNode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAiController.AIScriptPatrolInterruptible
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AIndianaAiCharacter*              InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APatrolNode*                      InPatrolNode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaAiController::AIScriptPatrolInterruptible(class AIndianaAiCharacter* InCharacter, class APatrolNode* InPatrolNode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaAiController", "AIScriptPatrolInterruptible");

	Params::IndianaAiController_AIScriptPatrolInterruptible Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InPatrolNode = InPatrolNode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAiController.AIScriptWander
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AIndianaAiCharacter*              InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaAiController::AIScriptWander(class AIndianaAiCharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaAiController", "AIScriptWander");

	Params::IndianaAiController_AIScriptWander Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAiController.OnBehaviorStateChange
// (Final, Native, Protected)
// Parameters:
// class UBehaviorStateInfo*               OldBehaviorStateInfo                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBehaviorStateInfo*               NewBehaviorStateInfo                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaAiController::OnBehaviorStateChange(const class UBehaviorStateInfo* OldBehaviorStateInfo, const class UBehaviorStateInfo* NewBehaviorStateInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAiController", "OnBehaviorStateChange");

	Params::IndianaAiController_OnBehaviorStateChange Parms{};

	Parms.OldBehaviorStateInfo = OldBehaviorStateInfo;
	Parms.NewBehaviorStateInfo = NewBehaviorStateInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAiController.OnCombatStateChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bInCombat                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaAiController::OnCombatStateChange(bool bInCombat, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAiController", "OnCombatStateChange");

	Params::IndianaAiController_OnCombatStateChange Parms{};

	Parms.bInCombat = bInCombat;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAiController.OnMeleeActionEnd
// (Final, Native, Protected)
// Parameters:
// EMeleeAction                            ActionEnded                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaAiController::OnMeleeActionEnd(EMeleeAction ActionEnded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAiController", "OnMeleeActionEnd");

	Params::IndianaAiController_OnMeleeActionEnd Parms{};

	Parms.ActionEnded = ActionEnded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAiController.OnNewStateOfBeing
// (Native, Protected)
// Parameters:
// EStateOfBeing                           NewStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStateOfBeing                           OldStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaAiController::OnNewStateOfBeing(EStateOfBeing NewStateOfBeing, EStateOfBeing OldStateOfBeing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAiController", "OnNewStateOfBeing");

	Params::IndianaAiController_OnNewStateOfBeing Parms{};

	Parms.NewStateOfBeing = NewStateOfBeing;
	Parms.OldStateOfBeing = OldStateOfBeing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAiController.OnRestoredStateOfBeing
// (Native, Protected)
// Parameters:
// EStateOfBeing                           RestoredStateOfBeing                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaAiController::OnRestoredStateOfBeing(EStateOfBeing RestoredStateOfBeing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAiController", "OnRestoredStateOfBeing");

	Params::IndianaAiController_OnRestoredStateOfBeing Parms{};

	Parms.RestoredStateOfBeing = RestoredStateOfBeing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAiController.OnSwitchedTarget
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OldTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           NewTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaAiController::OnSwitchedTarget(class AActor* OldTarget, class AActor* NewTarget, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAiController", "OnSwitchedTarget");

	Params::IndianaAiController_OnSwitchedTarget Parms{};

	Parms.OldTarget = OldTarget;
	Parms.NewTarget = NewTarget;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAiController.OnTakeDamage
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FCauseDamageInfo                 CauseDamageInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AIndianaAiController::OnTakeDamage(const struct FCauseDamageInfo& CauseDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAiController", "OnTakeDamage");

	Params::IndianaAiController_OnTakeDamage Parms{};

	Parms.CauseDamageInfo = std::move(CauseDamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAiController.GetCurrentTargetDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AIndianaAiController::GetCurrentTargetDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAiController", "GetCurrentTargetDistance");

	Params::IndianaAiController_GetCurrentTargetDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaAiController.GetFootstepAwarenessIncrease
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                                    bIsStealthed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OwnerPerceptionSkill                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TargetSneakSkill                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAlertState                             InAlertState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseFootstepAwareness                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SoundRadius                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AIndianaAiController::GetFootstepAwarenessIncrease(bool bIsStealthed, int32 OwnerPerceptionSkill, int32 TargetSneakSkill, EAlertState InAlertState, float BaseFootstepAwareness, float Distance, float SoundRadius) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAiController", "GetFootstepAwarenessIncrease");

	Params::IndianaAiController_GetFootstepAwarenessIncrease Parms{};

	Parms.bIsStealthed = bIsStealthed;
	Parms.OwnerPerceptionSkill = OwnerPerceptionSkill;
	Parms.TargetSneakSkill = TargetSneakSkill;
	Parms.InAlertState = InAlertState;
	Parms.BaseFootstepAwareness = BaseFootstepAwareness;
	Parms.Distance = Distance;
	Parms.SoundRadius = SoundRadius;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaAiController.GetSightAwarenessDecreaseRate
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                                    bIsStealthed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OwnerPerceptionSkill                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TargetSneakSkill                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAlertState                             InAlertState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLost                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDeadBodyKiller                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AIndianaAiController::GetSightAwarenessDecreaseRate(bool bIsStealthed, int32 OwnerPerceptionSkill, int32 TargetSneakSkill, EAlertState InAlertState, bool bLost, bool bDeadBodyKiller) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAiController", "GetSightAwarenessDecreaseRate");

	Params::IndianaAiController_GetSightAwarenessDecreaseRate Parms{};

	Parms.bIsStealthed = bIsStealthed;
	Parms.OwnerPerceptionSkill = OwnerPerceptionSkill;
	Parms.TargetSneakSkill = TargetSneakSkill;
	Parms.InAlertState = InAlertState;
	Parms.bLost = bLost;
	Parms.bDeadBodyKiller = bDeadBodyKiller;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaAiController.GetSightAwarenessIncreaseRate
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                                    bIsStealthed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OwnerPerceptionSkill                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TargetSneakSkill                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAlertState                             InAlertState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SightRadius                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowTargeting                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AIndianaAiController::GetSightAwarenessIncreaseRate(bool bIsStealthed, int32 OwnerPerceptionSkill, int32 TargetSneakSkill, EAlertState InAlertState, float Distance, float SightRadius, bool bAllowTargeting) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAiController", "GetSightAwarenessIncreaseRate");

	Params::IndianaAiController_GetSightAwarenessIncreaseRate Parms{};

	Parms.bIsStealthed = bIsStealthed;
	Parms.OwnerPerceptionSkill = OwnerPerceptionSkill;
	Parms.TargetSneakSkill = TargetSneakSkill;
	Parms.InAlertState = InAlertState;
	Parms.Distance = Distance;
	Parms.SightRadius = SightRadius;
	Parms.bAllowTargeting = bAllowTargeting;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.IndianaAIPerceptionComponent.OnBehaviorTreeInitialized
// (Final, Native, Private)

void UIndianaAIPerceptionComponent::OnBehaviorTreeInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAIPerceptionComponent", "OnBehaviorTreeInitialized");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAIPerceptionComponent.OnCharacterDeath
// (Final, Native, Private, HasOutParams)
// Parameters:
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCauseDamageInfo                 CauseDamageInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UIndianaAIPerceptionComponent::OnCharacterDeath(class AActor* Instigator, const struct FCauseDamageInfo& CauseDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAIPerceptionComponent", "OnCharacterDeath");

	Params::IndianaAIPerceptionComponent_OnCharacterDeath Parms{};

	Parms.Instigator = Instigator;
	Parms.CauseDamageInfo = std::move(CauseDamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAIPerceptionComponent.OnCombatStateChanged
// (Final, Native, Private)
// Parameters:
// bool                                    bIsInCombat                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaAIPerceptionComponent::OnCombatStateChanged(bool bIsInCombat, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAIPerceptionComponent", "OnCombatStateChanged");

	Params::IndianaAIPerceptionComponent_OnCombatStateChanged Parms{};

	Parms.bIsInCombat = bIsInCombat;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAIPerceptionComponent.OnGodVisionChanged
// (Final, Native, Private)
// Parameters:
// bool                                    bGodVision                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaAIPerceptionComponent::OnGodVisionChanged(bool bGodVision)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAIPerceptionComponent", "OnGodVisionChanged");

	Params::IndianaAIPerceptionComponent_OnGodVisionChanged Parms{};

	Parms.bGodVision = bGodVision;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAIPerceptionComponent.OnPerceptionRangeScalarUpdated
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameplayTagContainer            CreatureType                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UIndianaAIPerceptionComponent::OnPerceptionRangeScalarUpdated(const struct FGameplayTagContainer& CreatureType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAIPerceptionComponent", "OnPerceptionRangeScalarUpdated");

	Params::IndianaAIPerceptionComponent_OnPerceptionRangeScalarUpdated Parms{};

	Parms.CreatureType = std::move(CreatureType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaAIPerceptionComponent.OnStatUpdated
// (Final, Native, Private)
// Parameters:
// class URpgStat*                         Stat                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaAIPerceptionComponent::OnStatUpdated(const class URpgStat* Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaAIPerceptionComponent", "OnStatUpdated");

	Params::IndianaAIPerceptionComponent_OnStatUpdated Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaCharacterDummy.CopyFromCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AIndianaCharacter*                Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaCharacterDummy::CopyFromCharacter(class AIndianaCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCharacterDummy", "CopyFromCharacter");

	Params::IndianaCharacterDummy_CopyFromCharacter Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaCharacterDummy.OnWeaponEndEquip
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaCharacterDummy::OnWeaponEndEquip(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCharacterDummy", "OnWeaponEndEquip");

	Params::IndianaCharacterDummy_OnWeaponEndEquip Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaCharacterDummy.SetUISelectionState
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// EUISelectionState                       InSelectionState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaCharacterDummy::SetUISelectionState(EUISelectionState InSelectionState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaCharacterDummy", "SetUISelectionState");

	Params::IndianaCharacterDummy_SetUISelectionState Parms{};

	Parms.InSelectionState = InSelectionState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaDamageType.SetupImpactFx
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UParticleSystemComponent*         ParentEffect                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGraze                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCritical                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWeakSpot                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRadial                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaDamageType::SetupImpactFx(class UParticleSystemComponent* ParentEffect, bool bGraze, bool bCritical, bool bWeakSpot, bool bRadial, float Radius) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaDamageType", "SetupImpactFx");

	Params::IndianaDamageType_SetupImpactFx Parms{};

	Parms.ParentEffect = ParentEffect;
	Parms.bGraze = bGraze;
	Parms.bCritical = bCritical;
	Parms.bWeakSpot = bWeakSpot;
	Parms.bRadial = bRadial;
	Parms.Radius = Radius;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.IndianaDamageType.SetupSecondaryImpactFx
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UParticleSystemComponent*         ParentEffect                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGraze                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCritical                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWeakSpot                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRadial                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaDamageType::SetupSecondaryImpactFx(class UParticleSystemComponent* ParentEffect, bool bGraze, bool bCritical, bool bWeakSpot, bool bRadial, float Radius) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaDamageType", "SetupSecondaryImpactFx");

	Params::IndianaDamageType_SetupSecondaryImpactFx Parms{};

	Parms.ParentEffect = ParentEffect;
	Parms.bGraze = bGraze;
	Parms.bCritical = bCritical;
	Parms.bWeakSpot = bWeakSpot;
	Parms.bRadial = bRadial;
	Parms.Radius = Radius;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.IndianaDamageType.TriggerMuzzleFx
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class USceneComponent*                  AttachComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsFirstPerson                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaDamageType::TriggerMuzzleFx(class USceneComponent* AttachComponent, bool IsFirstPerson) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaDamageType", "TriggerMuzzleFx");

	Params::IndianaDamageType_TriggerMuzzleFx Parms{};

	Parms.AttachComponent = AttachComponent;
	Parms.IsFirstPerson = IsFirstPerson;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.IndianaFlybyAkComponent.DeactivateEmitter
// (Final, Native, Public, BlueprintCallable)

void UIndianaFlybyAkComponent::DeactivateEmitter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFlybyAkComponent", "DeactivateEmitter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaFlybyAkComponent.InitializeEmitter
// (Final, Native, Public, BlueprintCallable)

void UIndianaFlybyAkComponent::InitializeEmitter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFlybyAkComponent", "InitializeEmitter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaFlybyAkComponent.UpdateEmitterLocation
// (Final, Native, Public, BlueprintCallable)

void UIndianaFlybyAkComponent::UpdateEmitterLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaFlybyAkComponent", "UpdateEmitterLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameInstance.IsINX1Installed
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameInstance::IsINX1Installed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameInstance", "IsINX1Installed");

	Params::IndianaGameInstance_IsINX1Installed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameInstance.IsINX2Installed
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameInstance::IsINX2Installed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameInstance", "IsINX2Installed");

	Params::IndianaGameInstance_IsINX2Installed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameInstance.IsINX2DLCInstalled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameInstance::IsINX2DLCInstalled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameInstance", "IsINX2DLCInstalled");

	Params::IndianaGameInstance_IsINX2DLCInstalled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameInstance.IsXFHDLCInstalled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameInstance::IsXFHDLCInstalled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameInstance", "IsXFHDLCInstalled");

	Params::IndianaGameInstance_IsXFHDLCInstalled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameInstance.LowMemoryLoad
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Map                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameInstance::LowMemoryLoad(const class FString& Map)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameInstance", "LowMemoryLoad");

	Params::IndianaGameInstance_LowMemoryLoad Parms{};

	Parms.Map = std::move(Map);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameInstance.QueueCredits
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldQueue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameInstance::QueueCredits(bool bShouldQueue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameInstance", "QueueCredits");

	Params::IndianaGameInstance_QueueCredits Parms{};

	Parms.bShouldQueue = bShouldQueue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameInstance.QueueEndGameLoadingScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEndGameImageType                       EndGameType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameInstance::QueueEndGameLoadingScreen(EEndGameImageType EndGameType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameInstance", "QueueEndGameLoadingScreen");

	Params::IndianaGameInstance_QueueEndGameLoadingScreen Parms{};

	Parms.EndGameType = EndGameType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameInstance.ResetEULA
// (Final, Exec, Native, Private)

void UIndianaGameInstance::ResetEULA()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameInstance", "ResetEULA");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameInstance.SetOverridePlayerClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                           Override                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameInstance::SetOverridePlayerClass(class UClass* Override)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameInstance", "SetOverridePlayerClass");

	Params::IndianaGameInstance_SetOverridePlayerClass Parms{};

	Parms.Override = Override;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameInstance.AreCreditsPlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameInstance::AreCreditsPlaying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameInstance", "AreCreditsPlaying");

	Params::IndianaGameInstance_AreCreditsPlaying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameInstance.AreCreditsQueued
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameInstance::AreCreditsQueued() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameInstance", "AreCreditsQueued");

	Params::IndianaGameInstance_AreCreditsQueued Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameInstance.HasVisitedMainMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameInstance::HasVisitedMainMenu() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameInstance", "HasVisitedMainMenu");

	Params::IndianaGameInstance_HasVisitedMainMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetDefaultSSGIQualityForLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   InQualityLevel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIndianaGameUserSettings::GetDefaultSSGIQualityForLevel(int32 InQualityLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGameUserSettings", "GetDefaultSSGIQualityForLevel");

	Params::IndianaGameUserSettings_GetDefaultSSGIQualityForLevel Parms{};

	Parms.InQualityLevel = InQualityLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetActionKeyBinds
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FInputActionKeyMapping>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FInputActionKeyMapping> UIndianaGameUserSettings::GetActionKeyBinds(class FName ActionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetActionKeyBinds");

	Params::IndianaGameUserSettings_GetActionKeyBinds Parms{};

	Parms.ActionName = ActionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetAxisKeyBinds
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             AxisName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FInputAxisKeyMapping>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FInputAxisKeyMapping> UIndianaGameUserSettings::GetAxisKeyBinds(class FName AxisName, float Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetAxisKeyBinds");

	Params::IndianaGameUserSettings_GetAxisKeyBinds Parms{};

	Parms.AxisName = AxisName;
	Parms.Scale = Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetControllerAutoSprintEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetControllerAutoSprintEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetControllerAutoSprintEnabled");

	Params::IndianaGameUserSettings_GetControllerAutoSprintEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetControllerRumbleEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetControllerRumbleEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetControllerRumbleEnabled");

	Params::IndianaGameUserSettings_GetControllerRumbleEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetControllerXAxisInverted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetControllerXAxisInverted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetControllerXAxisInverted");

	Params::IndianaGameUserSettings_GetControllerXAxisInverted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetControllerYAxisInverted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetControllerYAxisInverted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetControllerYAxisInverted");

	Params::IndianaGameUserSettings_GetControllerYAxisInverted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetEffectsSoundVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameUserSettings::GetEffectsSoundVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetEffectsSoundVolume");

	Params::IndianaGameUserSettings_GetEffectsSoundVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetGodMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetGodMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetGodMode");

	Params::IndianaGameUserSettings_GetGodMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetInfiniteAmmo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetInfiniteAmmo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetInfiniteAmmo");

	Params::IndianaGameUserSettings_GetInfiniteAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetMasterSoundVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameUserSettings::GetMasterSoundVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetMasterSoundVolume");

	Params::IndianaGameUserSettings_GetMasterSoundVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetMouseSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameUserSettings::GetMouseSensitivity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetMouseSensitivity");

	Params::IndianaGameUserSettings_GetMouseSensitivity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetMusicSoundVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameUserSettings::GetMusicSoundVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetMusicSoundVolume");

	Params::IndianaGameUserSettings_GetMusicSoundVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetPseudoGodMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetPseudoGodMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetPseudoGodMode");

	Params::IndianaGameUserSettings_GetPseudoGodMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetRadialSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameUserSettings::GetRadialSensitivity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetRadialSensitivity");

	Params::IndianaGameUserSettings_GetRadialSensitivity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetUISoundVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameUserSettings::GetUISoundVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetUISoundVolume");

	Params::IndianaGameUserSettings_GetUISoundVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetViewBaseStats
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetViewBaseStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetViewBaseStats");

	Params::IndianaGameUserSettings_GetViewBaseStats Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetVoiceSoundVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameUserSettings::GetVoiceSoundVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetVoiceSoundVolume");

	Params::IndianaGameUserSettings_GetVoiceSoundVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetXAxisInverted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetXAxisInverted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetXAxisInverted");

	Params::IndianaGameUserSettings_GetXAxisInverted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetYAxisInverted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetYAxisInverted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetYAxisInverted");

	Params::IndianaGameUserSettings_GetYAxisInverted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.OnDetectGraphics
// (Final, Native, Public, BlueprintCallable)

void UIndianaGameUserSettings::OnDetectGraphics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "OnDetectGraphics");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.ResetAllKeyBinds
// (Final, Native, Public, BlueprintCallable)

void UIndianaGameUserSettings::ResetAllKeyBinds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "ResetAllKeyBinds");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.Set3DResolution
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ResolutionIn                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::Set3DResolution(float ResolutionIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "Set3DResolution");

	Params::IndianaGameUserSettings_Set3DResolution Parms{};

	Parms.ResolutionIn = ResolutionIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetAbilityControlUIMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAbilityControlMode                     ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetAbilityControlUIMode(EAbilityControlMode ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetAbilityControlUIMode");

	Params::IndianaGameUserSettings_SetAbilityControlUIMode Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetActionKeyBinds
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FInputActionKeyMapping>   OldValues                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FInputActionKeyMapping>   NewValues                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetActionKeyBinds(const TArray<struct FInputActionKeyMapping>& OldValues, const TArray<struct FInputActionKeyMapping>& NewValues)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetActionKeyBinds");

	Params::IndianaGameUserSettings_SetActionKeyBinds Parms{};

	Parms.OldValues = std::move(OldValues);
	Parms.NewValues = std::move(NewValues);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetAimingReticleMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EReticleMode                            ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetAimingReticleMode(EReticleMode ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetAimingReticleMode");

	Params::IndianaGameUserSettings_SetAimingReticleMode Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetAntiAliasingMethod
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Method                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetAntiAliasingMethod(int32 Method)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetAntiAliasingMethod");

	Params::IndianaGameUserSettings_SetAntiAliasingMethod Parms{};

	Parms.Method = Method;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetAreaNameMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAreaNameMode                           AreaModeIn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetAreaNameMode(EAreaNameMode AreaModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetAreaNameMode");

	Params::IndianaGameUserSettings_SetAreaNameMode Parms{};

	Parms.AreaModeIn = AreaModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetAutoCollapseItemViewers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetAutoCollapseItemViewers(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetAutoCollapseItemViewers");

	Params::IndianaGameUserSettings_SetAutoCollapseItemViewers Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetAxisKeyBinds
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FInputAxisKeyMapping>     OldValues                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FInputAxisKeyMapping>     NewValues                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetAxisKeyBinds(const TArray<struct FInputAxisKeyMapping>& OldValues, const TArray<struct FInputAxisKeyMapping>& NewValues)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetAxisKeyBinds");

	Params::IndianaGameUserSettings_SetAxisKeyBinds Parms{};

	Parms.OldValues = std::move(OldValues);
	Parms.NewValues = std::move(NewValues);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetBarkSubtitleMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetBarkSubtitleMode(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetBarkSubtitleMode");

	Params::IndianaGameUserSettings_SetBarkSubtitleMode Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetChromaticAberration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bUseChromaticAberration                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetChromaticAberration(bool bUseChromaticAberration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetChromaticAberration");

	Params::IndianaGameUserSettings_SetChromaticAberration Parms{};

	Parms.bUseChromaticAberration = bUseChromaticAberration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetCinematicKillCam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabledIn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetCinematicKillCam(bool bEnabledIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetCinematicKillCam");

	Params::IndianaGameUserSettings_SetCinematicKillCam Parms{};

	Parms.bEnabledIn = bEnabledIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetCinematicSubtitlesVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetCinematicSubtitlesVisible(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetCinematicSubtitlesVisible");

	Params::IndianaGameUserSettings_SetCinematicSubtitlesVisible Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetColorblindModeEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetColorblindModeEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetColorblindModeEnabled");

	Params::IndianaGameUserSettings_SetColorblindModeEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetCompanionAbilityBindingMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECompanionAbilityBindingMode            ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetCompanionAbilityBindingMode(ECompanionAbilityBindingMode ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetCompanionAbilityBindingMode");

	Params::IndianaGameUserSettings_SetCompanionAbilityBindingMode Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetCompanionAbilityUIMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECompanionAbilityUIMode                 ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetCompanionAbilityUIMode(ECompanionAbilityUIMode ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetCompanionAbilityUIMode");

	Params::IndianaGameUserSettings_SetCompanionAbilityUIMode Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetCompanionOutlineMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECompanionOutlineMode                   Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetCompanionOutlineMode(ECompanionOutlineMode Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetCompanionOutlineMode");

	Params::IndianaGameUserSettings_SetCompanionOutlineMode Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetCompanionPassiveCDNotificationMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECompanionAbilityPassiveNotificationModeModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetCompanionPassiveCDNotificationMode(ECompanionAbilityPassiveNotificationMode ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetCompanionPassiveCDNotificationMode");

	Params::IndianaGameUserSettings_SetCompanionPassiveCDNotificationMode Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetCompanionStatusUIMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECompanionStatusMode                    ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetCompanionStatusUIMode(ECompanionStatusMode ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetCompanionStatusUIMode");

	Params::IndianaGameUserSettings_SetCompanionStatusUIMode Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetControllerADSSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetControllerADSSensitivity(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetControllerADSSensitivity");

	Params::IndianaGameUserSettings_SetControllerADSSensitivity Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetControllerAutoSprintEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetControllerAutoSprintEnabled(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetControllerAutoSprintEnabled");

	Params::IndianaGameUserSettings_SetControllerAutoSprintEnabled Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetControllerEnableImpulseTriggers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetControllerEnableImpulseTriggers(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetControllerEnableImpulseTriggers");

	Params::IndianaGameUserSettings_SetControllerEnableImpulseTriggers Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetControllerLeftInnerDeadZone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetControllerLeftInnerDeadZone(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetControllerLeftInnerDeadZone");

	Params::IndianaGameUserSettings_SetControllerLeftInnerDeadZone Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetControllerLeftOuterDeadZone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetControllerLeftOuterDeadZone(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetControllerLeftOuterDeadZone");

	Params::IndianaGameUserSettings_SetControllerLeftOuterDeadZone Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetControllerRightInnerDeadZone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetControllerRightInnerDeadZone(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetControllerRightInnerDeadZone");

	Params::IndianaGameUserSettings_SetControllerRightInnerDeadZone Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetControllerRightOuterDeadZone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetControllerRightOuterDeadZone(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetControllerRightOuterDeadZone");

	Params::IndianaGameUserSettings_SetControllerRightOuterDeadZone Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetControllerRumbleEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetControllerRumbleEnabled(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetControllerRumbleEnabled");

	Params::IndianaGameUserSettings_SetControllerRumbleEnabled Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetControllerSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetControllerSensitivity(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetControllerSensitivity");

	Params::IndianaGameUserSettings_SetControllerSensitivity Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetControllerXAxisInverted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetControllerXAxisInverted(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetControllerXAxisInverted");

	Params::IndianaGameUserSettings_SetControllerXAxisInverted Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetControllerYAxisInverted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetControllerYAxisInverted(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetControllerYAxisInverted");

	Params::IndianaGameUserSettings_SetControllerYAxisInverted Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetConversationContinueOnVOEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetConversationContinueOnVOEnd(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetConversationContinueOnVOEnd");

	Params::IndianaGameUserSettings_SetConversationContinueOnVOEnd Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetConversationResponseVisibleDuringVO
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetConversationResponseVisibleDuringVO(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetConversationResponseVisibleDuringVO");

	Params::IndianaGameUserSettings_SetConversationResponseVisibleDuringVO Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetConversationSubtitleMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EConversationSubtitleMode               Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetConversationSubtitleMode(EConversationSubtitleMode Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetConversationSubtitleMode");

	Params::IndianaGameUserSettings_SetConversationSubtitleMode Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetDialogSkillMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDialogSkillMode                        ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetDialogSkillMode(EDialogSkillMode ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetDialogSkillMode");

	Params::IndianaGameUserSettings_SetDialogSkillMode Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetDodgeDisplayMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDodgeDisplayMode                       ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetDodgeDisplayMode(EDodgeDisplayMode ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetDodgeDisplayMode");

	Params::IndianaGameUserSettings_SetDodgeDisplayMode Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetEffectsSoundVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetEffectsSoundVolume(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetEffectsSoundVolume");

	Params::IndianaGameUserSettings_SetEffectsSoundVolume Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetFontSizeModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ModifierIn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetFontSizeModifier(int32 ModifierIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetFontSizeModifier");

	Params::IndianaGameUserSettings_SetFontSizeModifier Parms{};

	Parms.ModifierIn = ModifierIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetFOV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FOVIn                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetFOV(float FOVIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetFOV");

	Params::IndianaGameUserSettings_SetFOV Parms{};

	Parms.FOVIn = FOVIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetFPSIndicatorMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFPSIndicatorMode                       ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetFPSIndicatorMode(EFPSIndicatorMode ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetFPSIndicatorMode");

	Params::IndianaGameUserSettings_SetFPSIndicatorMode Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetFPSLimit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFPSLimit                               FPSLimitIn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetFPSLimit(EFPSLimit FPSLimitIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetFPSLimit");

	Params::IndianaGameUserSettings_SetFPSLimit Parms{};

	Parms.FPSLimitIn = FPSLimitIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetFSR2Enabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetFSR2Enabled(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetFSR2Enabled");

	Params::IndianaGameUserSettings_SetFSR2Enabled Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetFSR2Mode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFSR2Mode                               Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetFSR2Mode(EFSR2Mode Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetFSR2Mode");

	Params::IndianaGameUserSettings_SetFSR2Mode Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetFullscreenModeThenBroadcast
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EWindowMode                             Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetFullscreenModeThenBroadcast(EWindowMode Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetFullscreenModeThenBroadcast");

	Params::IndianaGameUserSettings_SetFullscreenModeThenBroadcast Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetGammaLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   GammaLevelIn                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetGammaLevel(float GammaLevelIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetGammaLevel");

	Params::IndianaGameUserSettings_SetGammaLevel Parms{};

	Parms.GammaLevelIn = GammaLevelIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetGodMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetGodMode(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetGodMode");

	Params::IndianaGameUserSettings_SetGodMode Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetGraphicsQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetGraphicsQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetGraphicsQuality");

	Params::IndianaGameUserSettings_SetGraphicsQuality Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetHeadbobbing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabledIn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetHeadbobbing(bool bEnabledIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetHeadbobbing");

	Params::IndianaGameUserSettings_SetHeadbobbing Parms{};

	Parms.bEnabledIn = bEnabledIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetHeldWeaponDisplayMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHeldWeaponDisplayMode                  ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetHeldWeaponDisplayMode(EHeldWeaponDisplayMode ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetHeldWeaponDisplayMode");

	Params::IndianaGameUserSettings_SetHeldWeaponDisplayMode Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetHeldWeaponDisplayTextMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHeldWeaponDisplayText                  ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetHeldWeaponDisplayTextMode(EHeldWeaponDisplayText ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetHeldWeaponDisplayTextMode");

	Params::IndianaGameUserSettings_SetHeldWeaponDisplayTextMode Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetHUDMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHUDMode                                ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetHUDMode(EHUDMode ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetHUDMode");

	Params::IndianaGameUserSettings_SetHUDMode Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetHUDVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisibilityIn                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetHUDVisibility(bool bVisibilityIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetHUDVisibility");

	Params::IndianaGameUserSettings_SetHUDVisibility Parms{};

	Parms.bVisibilityIn = bVisibilityIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetImpulseTriggerIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetImpulseTriggerIntensity(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetImpulseTriggerIntensity");

	Params::IndianaGameUserSettings_SetImpulseTriggerIntensity Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetInfiniteAmmo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetInfiniteAmmo(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetInfiniteAmmo");

	Params::IndianaGameUserSettings_SetInfiniteAmmo Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetIsFreshUserSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetIsFreshUserSettings(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetIsFreshUserSettings");

	Params::IndianaGameUserSettings_SetIsFreshUserSettings Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetIsSimplifiedEquipmentRepairWarning
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetIsSimplifiedEquipmentRepairWarning(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetIsSimplifiedEquipmentRepairWarning");

	Params::IndianaGameUserSettings_SetIsSimplifiedEquipmentRepairWarning Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetIsSimplifiedLockpickHackingMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESimplifiedLockpickHackingMode          ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetIsSimplifiedLockpickHackingMode(ESimplifiedLockpickHackingMode ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetIsSimplifiedLockpickHackingMode");

	Params::IndianaGameUserSettings_SetIsSimplifiedLockpickHackingMode Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetLanguageMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELanguageMode                           LanguageModeIn                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPending                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetLanguageMode(ELanguageMode LanguageModeIn, bool bPending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetLanguageMode");

	Params::IndianaGameUserSettings_SetLanguageMode Parms{};

	Parms.LanguageModeIn = LanguageModeIn;
	Parms.bPending = bPending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetMasterSoundVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetMasterSoundVolume(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetMasterSoundVolume");

	Params::IndianaGameUserSettings_SetMasterSoundVolume Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetMedicalInhalerUIMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMedicalInhalerMode                     InhalerModeIn                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetMedicalInhalerUIMode(EMedicalInhalerMode InhalerModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetMedicalInhalerUIMode");

	Params::IndianaGameUserSettings_SetMedicalInhalerUIMode Parms{};

	Parms.InhalerModeIn = InhalerModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetMotionBlurScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewMotionBlurScale                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetMotionBlurScale(float NewMotionBlurScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetMotionBlurScale");

	Params::IndianaGameUserSettings_SetMotionBlurScale Parms{};

	Parms.NewMotionBlurScale = NewMotionBlurScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetMouseADSSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetMouseADSSensitivity(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetMouseADSSensitivity");

	Params::IndianaGameUserSettings_SetMouseADSSensitivity Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetMouseSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetMouseSensitivity(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetMouseSensitivity");

	Params::IndianaGameUserSettings_SetMouseSensitivity Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetMusicSoundVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetMusicSoundVolume(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetMusicSoundVolume");

	Params::IndianaGameUserSettings_SetMusicSoundVolume Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetNotificationDuration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DurationIn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetNotificationDuration(float DurationIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetNotificationDuration");

	Params::IndianaGameUserSettings_SetNotificationDuration Parms{};

	Parms.DurationIn = DurationIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetOffsetReticle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bUseOffset                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetOffsetReticle(bool bUseOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetOffsetReticle");

	Params::IndianaGameUserSettings_SetOffsetReticle Parms{};

	Parms.bUseOffset = bUseOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetPerformanceMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPerformanceMode                        PerformanceModeIn                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetPerformanceMode(EPerformanceMode PerformanceModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetPerformanceMode");

	Params::IndianaGameUserSettings_SetPerformanceMode Parms{};

	Parms.PerformanceModeIn = PerformanceModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetPlayerStatusBarMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPlayerStatusBarMode                    ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetPlayerStatusBarMode(EPlayerStatusBarMode ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetPlayerStatusBarMode");

	Params::IndianaGameUserSettings_SetPlayerStatusBarMode Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetPlayerStatusEffectTextMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPlayerStatusEffectTextMode             ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetPlayerStatusEffectTextMode(EPlayerStatusEffectTextMode ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetPlayerStatusEffectTextMode");

	Params::IndianaGameUserSettings_SetPlayerStatusEffectTextMode Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetPseudoGodMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetPseudoGodMode(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetPseudoGodMode");

	Params::IndianaGameUserSettings_SetPseudoGodMode Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetQuestUpdateMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EQuestUpdateMode                        bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetQuestUpdateMode(EQuestUpdateMode bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetQuestUpdateMode");

	Params::IndianaGameUserSettings_SetQuestUpdateMode Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetRadialSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetRadialSensitivity(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetRadialSensitivity");

	Params::IndianaGameUserSettings_SetRadialSensitivity Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetShowCombatIndicator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetShowCombatIndicator(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetShowCombatIndicator");

	Params::IndianaGameUserSettings_SetShowCombatIndicator Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetShowCompanionHelmets
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetShowCompanionHelmets(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetShowCompanionHelmets");

	Params::IndianaGameUserSettings_SetShowCompanionHelmets Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetShowCompanionPassiveCD
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECompanionAbilityPassiveCDMode          ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetShowCompanionPassiveCD(ECompanionAbilityPassiveCDMode ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetShowCompanionPassiveCD");

	Params::IndianaGameUserSettings_SetShowCompanionPassiveCD Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetShowCompass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECompassVisibilityMode                  ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetShowCompass(ECompassVisibilityMode ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetShowCompass");

	Params::IndianaGameUserSettings_SetShowCompass Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetShowDirectionalDamageIndicators
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDirectionalDamageIndicatorMode         ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetShowDirectionalDamageIndicators(EDirectionalDamageIndicatorMode ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetShowDirectionalDamageIndicators");

	Params::IndianaGameUserSettings_SetShowDirectionalDamageIndicators Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetShowDisguiseMeter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetShowDisguiseMeter(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetShowDisguiseMeter");

	Params::IndianaGameUserSettings_SetShowDisguiseMeter Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetShowEnemyAwarenessMeters
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetShowEnemyAwarenessMeters(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetShowEnemyAwarenessMeters");

	Params::IndianaGameUserSettings_SetShowEnemyAwarenessMeters Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetShowEnemyHealthBars
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEnemyHealthBarMode                     ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetShowEnemyHealthBars(EEnemyHealthBarMode ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetShowEnemyHealthBars");

	Params::IndianaGameUserSettings_SetShowEnemyHealthBars Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetShowEquipmentRepairWarning
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetShowEquipmentRepairWarning(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetShowEquipmentRepairWarning");

	Params::IndianaGameUserSettings_SetShowEquipmentRepairWarning Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetShowFloatingDamageText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetShowFloatingDamageText(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetShowFloatingDamageText");

	Params::IndianaGameUserSettings_SetShowFloatingDamageText Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetShowInteractionControls
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetShowInteractionControls(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetShowInteractionControls");

	Params::IndianaGameUserSettings_SetShowInteractionControls Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetShowInteractionOutlines
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetShowInteractionOutlines(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetShowInteractionOutlines");

	Params::IndianaGameUserSettings_SetShowInteractionOutlines Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetShowLevelUpNotification
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetShowLevelUpNotification(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetShowLevelUpNotification");

	Params::IndianaGameUserSettings_SetShowLevelUpNotification Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetShowLevelUpReminders
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetShowLevelUpReminders(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetShowLevelUpReminders");

	Params::IndianaGameUserSettings_SetShowLevelUpReminders Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetShowLootControls
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetShowLootControls(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetShowLootControls");

	Params::IndianaGameUserSettings_SetShowLootControls Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetShowLootTooltips
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetShowLootTooltips(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetShowLootTooltips");

	Params::IndianaGameUserSettings_SetShowLootTooltips Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetShowPlayerHelmet
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetShowPlayerHelmet(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetShowPlayerHelmet");

	Params::IndianaGameUserSettings_SetShowPlayerHelmet Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetShowPlayerStatusEffects
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetShowPlayerStatusEffects(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetShowPlayerStatusEffects");

	Params::IndianaGameUserSettings_SetShowPlayerStatusEffects Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetShowReticleFeedback
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetShowReticleFeedback(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetShowReticleFeedback");

	Params::IndianaGameUserSettings_SetShowReticleFeedback Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetShowTTDReticleMeter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETTDReticleMeterMode                    ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetShowTTDReticleMeter(ETTDReticleMeterMode ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetShowTTDReticleMeter");

	Params::IndianaGameUserSettings_SetShowTTDReticleMeter Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetShowTTDScanner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetShowTTDScanner(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetShowTTDScanner");

	Params::IndianaGameUserSettings_SetShowTTDScanner Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetShowTTDStatusEffectPreview
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetShowTTDStatusEffectPreview(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetShowTTDStatusEffectPreview");

	Params::IndianaGameUserSettings_SetShowTTDStatusEffectPreview Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetShowTutorialNotifications
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetShowTutorialNotifications(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetShowTutorialNotifications");

	Params::IndianaGameUserSettings_SetShowTutorialNotifications Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetShowWaypointMarkers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetShowWaypointMarkers(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetShowWaypointMarkers");

	Params::IndianaGameUserSettings_SetShowWaypointMarkers Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetSSGIMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESSGIMode                               Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetSSGIMode(ESSGIMode Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetSSGIMode");

	Params::IndianaGameUserSettings_SetSSGIMode Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetSSGIQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetSSGIQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetSSGIQuality");

	Params::IndianaGameUserSettings_SetSSGIQuality Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetSurvivalMeterMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisibleIn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetSurvivalMeterMode(bool bVisibleIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetSurvivalMeterMode");

	Params::IndianaGameUserSettings_SetSurvivalMeterMode Parms{};

	Parms.bVisibleIn = bVisibleIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetTooltipDelay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetTooltipDelay(float Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetTooltipDelay");

	Params::IndianaGameUserSettings_SetTooltipDelay Parms{};

	Parms.Delay = Delay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetTTDDisplayMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETTDDisplayMode                         ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetTTDDisplayMode(ETTDDisplayMode ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetTTDDisplayMode");

	Params::IndianaGameUserSettings_SetTTDDisplayMode Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetTutorialsEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetTutorialsEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetTutorialsEnabled");

	Params::IndianaGameUserSettings_SetTutorialsEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetUISoundVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetUISoundVolume(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetUISoundVolume");

	Params::IndianaGameUserSettings_SetUISoundVolume Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetViewBaseStats
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetViewBaseStats(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetViewBaseStats");

	Params::IndianaGameUserSettings_SetViewBaseStats Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetVoiceSoundVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetVoiceSoundVolume(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetVoiceSoundVolume");

	Params::IndianaGameUserSettings_SetVoiceSoundVolume Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetVSyncWrapper
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetVSyncWrapper(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetVSyncWrapper");

	Params::IndianaGameUserSettings_SetVSyncWrapper Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetWeaponSelectAxisMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EWeaponSelectAxisMode                   ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetWeaponSelectAxisMode(EWeaponSelectAxisMode ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetWeaponSelectAxisMode");

	Params::IndianaGameUserSettings_SetWeaponSelectAxisMode Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetWeaponSelectMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EWeaponSelectMode                       ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetWeaponSelectMode(EWeaponSelectMode ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetWeaponSelectMode");

	Params::IndianaGameUserSettings_SetWeaponSelectMode Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetWeaponTooltipStatMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EWeaponTooltipStatMode                  Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetWeaponTooltipStatMode(EWeaponTooltipStatMode Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetWeaponTooltipStatMode");

	Params::IndianaGameUserSettings_SetWeaponTooltipStatMode Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetXAxisInverted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetXAxisInverted(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetXAxisInverted");

	Params::IndianaGameUserSettings_SetXAxisInverted Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.SetYAxisInverted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaGameUserSettings::SetYAxisInverted(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "SetYAxisInverted");

	Params::IndianaGameUserSettings_SetYAxisInverted Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGameUserSettings.Get3DResolution
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameUserSettings::Get3DResolution() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "Get3DResolution");

	Params::IndianaGameUserSettings_Get3DResolution Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetAbilityControlUIMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAbilityControlMode                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAbilityControlMode UIndianaGameUserSettings::GetAbilityControlUIMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetAbilityControlUIMode");

	Params::IndianaGameUserSettings_GetAbilityControlUIMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetAimingReticleMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EReticleMode                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EReticleMode UIndianaGameUserSettings::GetAimingReticleMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetAimingReticleMode");

	Params::IndianaGameUserSettings_GetAimingReticleMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetAntiAliasingMethod
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIndianaGameUserSettings::GetAntiAliasingMethod() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetAntiAliasingMethod");

	Params::IndianaGameUserSettings_GetAntiAliasingMethod Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetAreaNameMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAreaNameMode                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAreaNameMode UIndianaGameUserSettings::GetAreaNameMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetAreaNameMode");

	Params::IndianaGameUserSettings_GetAreaNameMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetAutoCollapseItemViewers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetAutoCollapseItemViewers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetAutoCollapseItemViewers");

	Params::IndianaGameUserSettings_GetAutoCollapseItemViewers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetBarkSubtitlesVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetBarkSubtitlesVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetBarkSubtitlesVisible");

	Params::IndianaGameUserSettings_GetBarkSubtitlesVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetChromaticAberration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetChromaticAberration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetChromaticAberration");

	Params::IndianaGameUserSettings_GetChromaticAberration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetCinematicKillCam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetCinematicKillCam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetCinematicKillCam");

	Params::IndianaGameUserSettings_GetCinematicKillCam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetCinematicSubtitlesVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetCinematicSubtitlesVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetCinematicSubtitlesVisible");

	Params::IndianaGameUserSettings_GetCinematicSubtitlesVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetColorblindModeEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetColorblindModeEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetColorblindModeEnabled");

	Params::IndianaGameUserSettings_GetColorblindModeEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetCompanionAbilityBindingMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECompanionAbilityBindingMode            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECompanionAbilityBindingMode UIndianaGameUserSettings::GetCompanionAbilityBindingMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetCompanionAbilityBindingMode");

	Params::IndianaGameUserSettings_GetCompanionAbilityBindingMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetCompanionAbilityUIMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECompanionAbilityUIMode                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECompanionAbilityUIMode UIndianaGameUserSettings::GetCompanionAbilityUIMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetCompanionAbilityUIMode");

	Params::IndianaGameUserSettings_GetCompanionAbilityUIMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetCompanionOutlineMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECompanionOutlineMode                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECompanionOutlineMode UIndianaGameUserSettings::GetCompanionOutlineMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetCompanionOutlineMode");

	Params::IndianaGameUserSettings_GetCompanionOutlineMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetCompanionPassiveCDNotificationMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECompanionAbilityPassiveNotificationModeReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECompanionAbilityPassiveNotificationMode UIndianaGameUserSettings::GetCompanionPassiveCDNotificationMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetCompanionPassiveCDNotificationMode");

	Params::IndianaGameUserSettings_GetCompanionPassiveCDNotificationMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetCompanionStatusUIMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECompanionStatusMode                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECompanionStatusMode UIndianaGameUserSettings::GetCompanionStatusUIMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetCompanionStatusUIMode");

	Params::IndianaGameUserSettings_GetCompanionStatusUIMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetControllerADSSensitivity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameUserSettings::GetControllerADSSensitivity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetControllerADSSensitivity");

	Params::IndianaGameUserSettings_GetControllerADSSensitivity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetControllerEnableImpulseTriggers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetControllerEnableImpulseTriggers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetControllerEnableImpulseTriggers");

	Params::IndianaGameUserSettings_GetControllerEnableImpulseTriggers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetControllerLeftInnerDeadZone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameUserSettings::GetControllerLeftInnerDeadZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetControllerLeftInnerDeadZone");

	Params::IndianaGameUserSettings_GetControllerLeftInnerDeadZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetControllerLeftOuterDeadZone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameUserSettings::GetControllerLeftOuterDeadZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetControllerLeftOuterDeadZone");

	Params::IndianaGameUserSettings_GetControllerLeftOuterDeadZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetControllerRightInnerDeadZone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameUserSettings::GetControllerRightInnerDeadZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetControllerRightInnerDeadZone");

	Params::IndianaGameUserSettings_GetControllerRightInnerDeadZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetControllerRightOuterDeadZone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameUserSettings::GetControllerRightOuterDeadZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetControllerRightOuterDeadZone");

	Params::IndianaGameUserSettings_GetControllerRightOuterDeadZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetControllerSensitivity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameUserSettings::GetControllerSensitivity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetControllerSensitivity");

	Params::IndianaGameUserSettings_GetControllerSensitivity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetConversationContinueOnVOEnd
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetConversationContinueOnVOEnd() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetConversationContinueOnVOEnd");

	Params::IndianaGameUserSettings_GetConversationContinueOnVOEnd Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetConversationSubtitleMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EConversationSubtitleMode               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EConversationSubtitleMode UIndianaGameUserSettings::GetConversationSubtitleMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetConversationSubtitleMode");

	Params::IndianaGameUserSettings_GetConversationSubtitleMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetDialogSkillMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDialogSkillMode                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDialogSkillMode UIndianaGameUserSettings::GetDialogSkillMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetDialogSkillMode");

	Params::IndianaGameUserSettings_GetDialogSkillMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetDodgeDisplayMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDodgeDisplayMode                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDodgeDisplayMode UIndianaGameUserSettings::GetDodgeDisplayMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetDodgeDisplayMode");

	Params::IndianaGameUserSettings_GetDodgeDisplayMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetFontSizeModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIndianaGameUserSettings::GetFontSizeModifier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetFontSizeModifier");

	Params::IndianaGameUserSettings_GetFontSizeModifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetFOV
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameUserSettings::GetFOV() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetFOV");

	Params::IndianaGameUserSettings_GetFOV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetFPSIndicatorMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFPSIndicatorMode                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFPSIndicatorMode UIndianaGameUserSettings::GetFPSIndicatorMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetFPSIndicatorMode");

	Params::IndianaGameUserSettings_GetFPSIndicatorMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetFPSLimit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFPSLimit                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFPSLimit UIndianaGameUserSettings::GetFPSLimit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetFPSLimit");

	Params::IndianaGameUserSettings_GetFPSLimit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetFSR2Enabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetFSR2Enabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetFSR2Enabled");

	Params::IndianaGameUserSettings_GetFSR2Enabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetFSR2Mode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFSR2Mode                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFSR2Mode UIndianaGameUserSettings::GetFSR2Mode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetFSR2Mode");

	Params::IndianaGameUserSettings_GetFSR2Mode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetGammaLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameUserSettings::GetGammaLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetGammaLevel");

	Params::IndianaGameUserSettings_GetGammaLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetGraphicsQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIndianaGameUserSettings::GetGraphicsQuality() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetGraphicsQuality");

	Params::IndianaGameUserSettings_GetGraphicsQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetHeadbobbing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetHeadbobbing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetHeadbobbing");

	Params::IndianaGameUserSettings_GetHeadbobbing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetHeldWeaponDisplayMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EHeldWeaponDisplayMode                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EHeldWeaponDisplayMode UIndianaGameUserSettings::GetHeldWeaponDisplayMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetHeldWeaponDisplayMode");

	Params::IndianaGameUserSettings_GetHeldWeaponDisplayMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetHeldWeaponDisplayTextMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EHeldWeaponDisplayText                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EHeldWeaponDisplayText UIndianaGameUserSettings::GetHeldWeaponDisplayTextMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetHeldWeaponDisplayTextMode");

	Params::IndianaGameUserSettings_GetHeldWeaponDisplayTextMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetHUDMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EHUDMode                                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EHUDMode UIndianaGameUserSettings::GetHUDMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetHUDMode");

	Params::IndianaGameUserSettings_GetHUDMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetHUDVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetHUDVisibility() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetHUDVisibility");

	Params::IndianaGameUserSettings_GetHUDVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetImpulseTriggerIntensity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameUserSettings::GetImpulseTriggerIntensity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetImpulseTriggerIntensity");

	Params::IndianaGameUserSettings_GetImpulseTriggerIntensity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetIsFreshUserSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetIsFreshUserSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetIsFreshUserSettings");

	Params::IndianaGameUserSettings_GetIsFreshUserSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetIsSimplifiedEquipmentRepairWarning
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetIsSimplifiedEquipmentRepairWarning() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetIsSimplifiedEquipmentRepairWarning");

	Params::IndianaGameUserSettings_GetIsSimplifiedEquipmentRepairWarning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetIsSimplifiedLockpickHackingMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESimplifiedLockpickHackingMode          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESimplifiedLockpickHackingMode UIndianaGameUserSettings::GetIsSimplifiedLockpickHackingMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetIsSimplifiedLockpickHackingMode");

	Params::IndianaGameUserSettings_GetIsSimplifiedLockpickHackingMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetLanguageMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELanguageMode                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELanguageMode UIndianaGameUserSettings::GetLanguageMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetLanguageMode");

	Params::IndianaGameUserSettings_GetLanguageMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetMedicalInhalerUIMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMedicalInhalerMode                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMedicalInhalerMode UIndianaGameUserSettings::GetMedicalInhalerUIMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetMedicalInhalerUIMode");

	Params::IndianaGameUserSettings_GetMedicalInhalerUIMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetMotionBlurScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameUserSettings::GetMotionBlurScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetMotionBlurScale");

	Params::IndianaGameUserSettings_GetMotionBlurScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetMouseADSSensitivity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameUserSettings::GetMouseADSSensitivity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetMouseADSSensitivity");

	Params::IndianaGameUserSettings_GetMouseADSSensitivity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetNotificationDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameUserSettings::GetNotificationDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetNotificationDuration");

	Params::IndianaGameUserSettings_GetNotificationDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetOffsetReticle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetOffsetReticle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetOffsetReticle");

	Params::IndianaGameUserSettings_GetOffsetReticle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetPerformanceMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPerformanceMode                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPerformanceMode UIndianaGameUserSettings::GetPerformanceMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetPerformanceMode");

	Params::IndianaGameUserSettings_GetPerformanceMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetPlayerStatusBarMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerStatusBarMode                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerStatusBarMode UIndianaGameUserSettings::GetPlayerStatusBarMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetPlayerStatusBarMode");

	Params::IndianaGameUserSettings_GetPlayerStatusBarMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetPlayerStatusEffectTextMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerStatusEffectTextMode             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerStatusEffectTextMode UIndianaGameUserSettings::GetPlayerStatusEffectTextMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetPlayerStatusEffectTextMode");

	Params::IndianaGameUserSettings_GetPlayerStatusEffectTextMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetQuestUpdateMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EQuestUpdateMode                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EQuestUpdateMode UIndianaGameUserSettings::GetQuestUpdateMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetQuestUpdateMode");

	Params::IndianaGameUserSettings_GetQuestUpdateMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetShowCombatIndicator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetShowCombatIndicator() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetShowCombatIndicator");

	Params::IndianaGameUserSettings_GetShowCombatIndicator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetShowCompanionHelmets
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetShowCompanionHelmets() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetShowCompanionHelmets");

	Params::IndianaGameUserSettings_GetShowCompanionHelmets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetShowCompanionPassiveCD
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECompanionAbilityPassiveCDMode          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECompanionAbilityPassiveCDMode UIndianaGameUserSettings::GetShowCompanionPassiveCD() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetShowCompanionPassiveCD");

	Params::IndianaGameUserSettings_GetShowCompanionPassiveCD Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetShowCompass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECompassVisibilityMode                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECompassVisibilityMode UIndianaGameUserSettings::GetShowCompass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetShowCompass");

	Params::IndianaGameUserSettings_GetShowCompass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetShowDirectionalDamageIndicators
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDirectionalDamageIndicatorMode         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDirectionalDamageIndicatorMode UIndianaGameUserSettings::GetShowDirectionalDamageIndicators() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetShowDirectionalDamageIndicators");

	Params::IndianaGameUserSettings_GetShowDirectionalDamageIndicators Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetShowDisguiseMeter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetShowDisguiseMeter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetShowDisguiseMeter");

	Params::IndianaGameUserSettings_GetShowDisguiseMeter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetShowEnemyAwarenessMeters
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetShowEnemyAwarenessMeters() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetShowEnemyAwarenessMeters");

	Params::IndianaGameUserSettings_GetShowEnemyAwarenessMeters Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetShowEnemyHealthBars
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEnemyHealthBarMode                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EEnemyHealthBarMode UIndianaGameUserSettings::GetShowEnemyHealthBars() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetShowEnemyHealthBars");

	Params::IndianaGameUserSettings_GetShowEnemyHealthBars Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetShowEquipmentRepairWarning
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetShowEquipmentRepairWarning() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetShowEquipmentRepairWarning");

	Params::IndianaGameUserSettings_GetShowEquipmentRepairWarning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetShowFloatingDamageText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetShowFloatingDamageText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetShowFloatingDamageText");

	Params::IndianaGameUserSettings_GetShowFloatingDamageText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetShowInteractionControls
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetShowInteractionControls() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetShowInteractionControls");

	Params::IndianaGameUserSettings_GetShowInteractionControls Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetShowInteractionOutlines
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetShowInteractionOutlines() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetShowInteractionOutlines");

	Params::IndianaGameUserSettings_GetShowInteractionOutlines Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetShowLevelUpNotification
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetShowLevelUpNotification() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetShowLevelUpNotification");

	Params::IndianaGameUserSettings_GetShowLevelUpNotification Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetShowLevelUpReminders
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetShowLevelUpReminders() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetShowLevelUpReminders");

	Params::IndianaGameUserSettings_GetShowLevelUpReminders Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetShowLootControls
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetShowLootControls() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetShowLootControls");

	Params::IndianaGameUserSettings_GetShowLootControls Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetShowLootTooltips
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetShowLootTooltips() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetShowLootTooltips");

	Params::IndianaGameUserSettings_GetShowLootTooltips Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetShowPlayerHelmet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetShowPlayerHelmet() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetShowPlayerHelmet");

	Params::IndianaGameUserSettings_GetShowPlayerHelmet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetShowPlayerStatusEffects
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetShowPlayerStatusEffects() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetShowPlayerStatusEffects");

	Params::IndianaGameUserSettings_GetShowPlayerStatusEffects Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetShowReticleFeedback
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetShowReticleFeedback() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetShowReticleFeedback");

	Params::IndianaGameUserSettings_GetShowReticleFeedback Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetShowTTDReticleMeter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETTDReticleMeterMode                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETTDReticleMeterMode UIndianaGameUserSettings::GetShowTTDReticleMeter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetShowTTDReticleMeter");

	Params::IndianaGameUserSettings_GetShowTTDReticleMeter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetShowTTDScanner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetShowTTDScanner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetShowTTDScanner");

	Params::IndianaGameUserSettings_GetShowTTDScanner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetShowTTDStatusEffectPreview
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetShowTTDStatusEffectPreview() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetShowTTDStatusEffectPreview");

	Params::IndianaGameUserSettings_GetShowTTDStatusEffectPreview Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetShowTutorialNotifications
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetShowTutorialNotifications() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetShowTutorialNotifications");

	Params::IndianaGameUserSettings_GetShowTutorialNotifications Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetShowWaypointMarkers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetShowWaypointMarkers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetShowWaypointMarkers");

	Params::IndianaGameUserSettings_GetShowWaypointMarkers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetSSGIQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIndianaGameUserSettings::GetSSGIQuality() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetSSGIQuality");

	Params::IndianaGameUserSettings_GetSSGIQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetSurvivalMeterMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetSurvivalMeterMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetSurvivalMeterMode");

	Params::IndianaGameUserSettings_GetSurvivalMeterMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetTooltipDelay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaGameUserSettings::GetTooltipDelay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetTooltipDelay");

	Params::IndianaGameUserSettings_GetTooltipDelay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetTTDDisplayMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETTDDisplayMode                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETTDDisplayMode UIndianaGameUserSettings::GetTTDDisplayMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetTTDDisplayMode");

	Params::IndianaGameUserSettings_GetTTDDisplayMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetTutorialsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetTutorialsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetTutorialsEnabled");

	Params::IndianaGameUserSettings_GetTutorialsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetVSyncWrapper
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::GetVSyncWrapper() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetVSyncWrapper");

	Params::IndianaGameUserSettings_GetVSyncWrapper Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetWeaponSelectAxisMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponSelectAxisMode                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWeaponSelectAxisMode UIndianaGameUserSettings::GetWeaponSelectAxisMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetWeaponSelectAxisMode");

	Params::IndianaGameUserSettings_GetWeaponSelectAxisMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetWeaponSelectMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponSelectMode                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWeaponSelectMode UIndianaGameUserSettings::GetWeaponSelectMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetWeaponSelectMode");

	Params::IndianaGameUserSettings_GetWeaponSelectMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.GetWeaponTooltipStatMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponTooltipStatMode                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWeaponTooltipStatMode UIndianaGameUserSettings::GetWeaponTooltipStatMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "GetWeaponTooltipStatMode");

	Params::IndianaGameUserSettings_GetWeaponTooltipStatMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.IsConversationResponseVisibleDuringVO
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::IsConversationResponseVisibleDuringVO() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "IsConversationResponseVisibleDuringVO");

	Params::IndianaGameUserSettings_IsConversationResponseVisibleDuringVO Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameUserSettings.IsLegalSigned
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndianaGameUserSettings::IsLegalSigned() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameUserSettings", "IsLegalSigned");

	Params::IndianaGameUserSettings_IsLegalSigned Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaGameViewportClient.SetSoundOverride
// (Final, Native, Public)

void UIndianaGameViewportClient::SetSoundOverride()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaGameViewportClient", "SetSoundOverride");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaGlobals.GetTutorialManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UTutorialManager*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTutorialManager* UIndianaGlobals::GetTutorialManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaGlobals", "GetTutorialManager");

	Params::IndianaGlobals_GetTutorialManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaLoadingScreenManager.DebugShowLoadingScreen
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             MapName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndianaLoadingScreenManager::DebugShowLoadingScreen(const class FName& MapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaLoadingScreenManager", "DebugShowLoadingScreen");

	Params::IndianaLoadingScreenManager_DebugShowLoadingScreen Parms{};

	Parms.MapName = MapName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPathFollowingComponent.EndStationaryRotate
// (Final, Native, Private)

void UIndianaPathFollowingComponent::EndStationaryRotate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPathFollowingComponent", "EndStationaryRotate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPathFollowingComponent.OnCapsuleSizeChange
// (Final, Native, Private)

void UIndianaPathFollowingComponent::OnCapsuleSizeChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPathFollowingComponent", "OnCapsuleSizeChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.GetIndianaPC
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AIndianaPlayerCharacter*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AIndianaPlayerCharacter* AIndianaPlayerCharacter::GetIndianaPC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaPlayerCharacter", "GetIndianaPC");

	Params::IndianaPlayerCharacter_GetIndianaPC Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaPlayerCharacter.ToggleUnlockTravelPoints
// (Final, Exec, Native, Static, Public)

void AIndianaPlayerCharacter::ToggleUnlockTravelPoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaPlayerCharacter", "ToggleUnlockTravelPoints");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.AdjustWeaponHealth
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::AdjustWeaponHealth(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "AdjustWeaponHealth");

	Params::IndianaPlayerCharacter_AdjustWeaponHealth Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.CanAccessTravelDestination
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTravelDestinationData*           TravelDest                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AIndianaPlayerCharacter::CanAccessTravelDestination(const class UTravelDestinationData* TravelDest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "CanAccessTravelDestination");

	Params::IndianaPlayerCharacter_CanAccessTravelDestination Parms{};

	Parms.TravelDest = TravelDest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaPlayerCharacter.CanDiscoverPointOfInterest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPointOfInterestData*             POIData                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AIndianaPlayerCharacter::CanDiscoverPointOfInterest(const class UPointOfInterestData* POIData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "CanDiscoverPointOfInterest");

	Params::IndianaPlayerCharacter_CanDiscoverPointOfInterest Parms{};

	Parms.POIData = POIData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaPlayerCharacter.DebugSoftCoverEntered
// (Final, Exec, Native, Public)

void AIndianaPlayerCharacter::DebugSoftCoverEntered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "DebugSoftCoverEntered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.DebugSoftCoverExited
// (Final, Exec, Native, Public)

void AIndianaPlayerCharacter::DebugSoftCoverExited()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "DebugSoftCoverExited");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.DebugTravel_SetAwareDestination
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             TravelDestination                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewAware                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::DebugTravel_SetAwareDestination(const class FName& TravelDestination, bool bNewAware)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "DebugTravel_SetAwareDestination");

	Params::IndianaPlayerCharacter_DebugTravel_SetAwareDestination Parms{};

	Parms.TravelDestination = TravelDestination;
	Parms.bNewAware = bNewAware;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.DebugTravel_SetAwareRegion
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             Region                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewAware                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::DebugTravel_SetAwareRegion(const class FName& Region, bool bNewAware)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "DebugTravel_SetAwareRegion");

	Params::IndianaPlayerCharacter_DebugTravel_SetAwareRegion Parms{};

	Parms.Region = Region;
	Parms.bNewAware = bNewAware;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.DebugTravel_SetDestinationHidden
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             TravelDestination                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewHidden                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::DebugTravel_SetDestinationHidden(const class FName& TravelDestination, bool bNewHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "DebugTravel_SetDestinationHidden");

	Params::IndianaPlayerCharacter_DebugTravel_SetDestinationHidden Parms{};

	Parms.TravelDestination = TravelDestination;
	Parms.bNewHidden = bNewHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.DebugTravel_SetDestinationLocked
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             TravelDestination                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewLocked                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::DebugTravel_SetDestinationLocked(const class FName& TravelDestination, bool bNewLocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "DebugTravel_SetDestinationLocked");

	Params::IndianaPlayerCharacter_DebugTravel_SetDestinationLocked Parms{};

	Parms.TravelDestination = TravelDestination;
	Parms.bNewLocked = bNewLocked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.DebugTravel_SetShipLocation
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             ShipLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::DebugTravel_SetShipLocation(const class FName& ShipLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "DebugTravel_SetShipLocation");

	Params::IndianaPlayerCharacter_DebugTravel_SetShipLocation Parms{};

	Parms.ShipLocation = ShipLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.DebugTravel_SetVisitedDestination
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             TravelDestination                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewVisited                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::DebugTravel_SetVisitedDestination(const class FName& TravelDestination, bool bNewVisited)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "DebugTravel_SetVisitedDestination");

	Params::IndianaPlayerCharacter_DebugTravel_SetVisitedDestination Parms{};

	Parms.TravelDestination = TravelDestination;
	Parms.bNewVisited = bNewVisited;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.DebugTravel_SetVisitedRegion
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             Region                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewVisited                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::DebugTravel_SetVisitedRegion(const class FName& Region, bool bNewVisited)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "DebugTravel_SetVisitedRegion");

	Params::IndianaPlayerCharacter_DebugTravel_SetVisitedRegion Parms{};

	Parms.Region = Region;
	Parms.bNewVisited = bNewVisited;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.DebugTravel_TravelToDestination
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             TravelDestination                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::DebugTravel_TravelToDestination(const class FName& TravelDestination)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "DebugTravel_TravelToDestination");

	Params::IndianaPlayerCharacter_DebugTravel_TravelToDestination Parms{};

	Parms.TravelDestination = TravelDestination;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.DiscoverPointOfInterest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPointOfInterestData*             POIData                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCanAwardXP                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::DiscoverPointOfInterest(const class UPointOfInterestData* POIData, bool bCanAwardXP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "DiscoverPointOfInterest");

	Params::IndianaPlayerCharacter_DiscoverPointOfInterest Parms{};

	Parms.POIData = POIData;
	Parms.bCanAwardXP = bCanAwardXP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.EquippedWeaponChanged
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          NewlyEquippedWeapon                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::EquippedWeaponChanged(class UWeapon* NewlyEquippedWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "EquippedWeaponChanged");

	Params::IndianaPlayerCharacter_EquippedWeaponChanged Parms{};

	Parms.NewlyEquippedWeapon = NewlyEquippedWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.EvidenceScannerActivated
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bActivated                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::EvidenceScannerActivated(bool bActivated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "EvidenceScannerActivated");

	Params::IndianaPlayerCharacter_EvidenceScannerActivated Parms{};

	Parms.bActivated = bActivated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.HasDiscoveredPointOfInterest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPointOfInterestData*             POIData                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AIndianaPlayerCharacter::HasDiscoveredPointOfInterest(const class UPointOfInterestData* POIData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "HasDiscoveredPointOfInterest");

	Params::IndianaPlayerCharacter_HasDiscoveredPointOfInterest Parms{};

	Parms.POIData = POIData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaPlayerCharacter.HasOnlyHeardAboutPointOfInterest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPointOfInterestData*             POIData                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AIndianaPlayerCharacter::HasOnlyHeardAboutPointOfInterest(const class UPointOfInterestData* POIData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "HasOnlyHeardAboutPointOfInterest");

	Params::IndianaPlayerCharacter_HasOnlyHeardAboutPointOfInterest Parms{};

	Parms.POIData = POIData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaPlayerCharacter.HasVisitedRegion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTravelRegionData*                Region                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AIndianaPlayerCharacter::HasVisitedRegion(const class UTravelRegionData* Region)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "HasVisitedRegion");

	Params::IndianaPlayerCharacter_HasVisitedRegion Parms{};

	Parms.Region = Region;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaPlayerCharacter.HasVisitedTravelDestination
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTravelDestinationData*           TravelDest                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AIndianaPlayerCharacter::HasVisitedTravelDestination(const class UTravelDestinationData* TravelDest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "HasVisitedTravelDestination");

	Params::IndianaPlayerCharacter_HasVisitedTravelDestination Parms{};

	Parms.TravelDest = TravelDest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaPlayerCharacter.HeadbobbingChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bHeadbobbing                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::HeadbobbingChanged(bool bHeadbobbing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "HeadbobbingChanged");

	Params::IndianaPlayerCharacter_HeadbobbingChanged Parms{};

	Parms.bHeadbobbing = bHeadbobbing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.HidePointOfInterest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPointOfInterestData*             POIData                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::HidePointOfInterest(const class UPointOfInterestData* POIData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "HidePointOfInterest");

	Params::IndianaPlayerCharacter_HidePointOfInterest Parms{};

	Parms.POIData = POIData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.InitiateTravelToShipLocation
// (Final, Native, Public, BlueprintCallable)

void AIndianaPlayerCharacter::InitiateTravelToShipLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "InitiateTravelToShipLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.IsAwareOfPointOfInterest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPointOfInterestData*             POIData                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AIndianaPlayerCharacter::IsAwareOfPointOfInterest(const class UPointOfInterestData* POIData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "IsAwareOfPointOfInterest");

	Params::IndianaPlayerCharacter_IsAwareOfPointOfInterest Parms{};

	Parms.POIData = POIData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaPlayerCharacter.IsAwareOfRegion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTravelRegionData*                Region                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AIndianaPlayerCharacter::IsAwareOfRegion(const class UTravelRegionData* Region)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "IsAwareOfRegion");

	Params::IndianaPlayerCharacter_IsAwareOfRegion Parms{};

	Parms.Region = Region;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaPlayerCharacter.IsAwareOfTravelDestination
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTravelDestinationData*           TravelDest                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AIndianaPlayerCharacter::IsAwareOfTravelDestination(const class UTravelDestinationData* TravelDest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "IsAwareOfTravelDestination");

	Params::IndianaPlayerCharacter_IsAwareOfTravelDestination Parms{};

	Parms.TravelDest = TravelDest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaPlayerCharacter.IsTravelDestinationHidden
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTravelDestinationData*           TravelDest                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AIndianaPlayerCharacter::IsTravelDestinationHidden(const class UTravelDestinationData* TravelDest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "IsTravelDestinationHidden");

	Params::IndianaPlayerCharacter_IsTravelDestinationHidden Parms{};

	Parms.TravelDest = TravelDest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaPlayerCharacter.IsTravelDestinationLocked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTravelDestinationData*           TravelDest                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AIndianaPlayerCharacter::IsTravelDestinationLocked(const class UTravelDestinationData* TravelDest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "IsTravelDestinationLocked");

	Params::IndianaPlayerCharacter_IsTravelDestinationLocked Parms{};

	Parms.TravelDest = TravelDest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaPlayerCharacter.MakePointOfInterestDiscoverable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPointOfInterestData*             POIData                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStillHidden                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::MakePointOfInterestDiscoverable(const class UPointOfInterestData* POIData, bool bStillHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "MakePointOfInterestDiscoverable");

	Params::IndianaPlayerCharacter_MakePointOfInterestDiscoverable Parms{};

	Parms.POIData = POIData;
	Parms.bStillHidden = bStillHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.MentionPointOfInterest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPointOfInterestData*             POIData                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::MentionPointOfInterest(const class UPointOfInterestData* POIData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "MentionPointOfInterest");

	Params::IndianaPlayerCharacter_MentionPointOfInterest Parms{};

	Parms.POIData = POIData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.OffsetReticleChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bUseOffsetReticle                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::OffsetReticleChanged(bool bUseOffsetReticle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "OffsetReticleChanged");

	Params::IndianaPlayerCharacter_OffsetReticleChanged Parms{};

	Parms.bUseOffsetReticle = bUseOffsetReticle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.OnCrouchComplete
// (Final, Native, Protected)

void AIndianaPlayerCharacter::OnCrouchComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "OnCrouchComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.OnDetected
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Detector                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::OnDetected(class AActor* Detector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "OnDetected");

	Params::IndianaPlayerCharacter_OnDetected Parms{};

	Parms.Detector = Detector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.OnDodged
// (Final, Native, Protected)
// Parameters:
// EDodgeDirection                         EDodgeDirection                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::OnDodged(EDodgeDirection EDodgeDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "OnDodged");

	Params::IndianaPlayerCharacter_OnDodged Parms{};

	Parms.EDodgeDirection = EDodgeDirection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.OnHit
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComp                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::OnHit(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "OnHit");

	Params::IndianaPlayerCharacter_OnHit Parms{};

	Parms.HitComp = HitComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.OnJumpLanded
// (Final, Native, Protected)
// Parameters:
// float                                   FallDistance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::OnJumpLanded(float FallDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "OnJumpLanded");

	Params::IndianaPlayerCharacter_OnJumpLanded Parms{};

	Parms.FallDistance = FallDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.OnPartyCombatDamageTaken
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FCauseDamageInfo                 DamageInfo                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::OnPartyCombatDamageTaken(const struct FCauseDamageInfo& DamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "OnPartyCombatDamageTaken");

	Params::IndianaPlayerCharacter_OnPartyCombatDamageTaken Parms{};

	Parms.DamageInfo = std::move(DamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.OnPauseStateChanged
// (Final, Native, Private)
// Parameters:
// bool                                    bIsPaused                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::OnPauseStateChanged(bool bIsPaused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "OnPauseStateChanged");

	Params::IndianaPlayerCharacter_OnPauseStateChanged Parms{};

	Parms.bIsPaused = bIsPaused;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.OnPlayerInventoryItemAdded
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::OnPlayerInventoryItemAdded(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "OnPlayerInventoryItemAdded");

	Params::IndianaPlayerCharacter_OnPlayerInventoryItemAdded Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.OnPlayerInventoryItemConsumed
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::OnPlayerInventoryItemConsumed(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "OnPlayerInventoryItemConsumed");

	Params::IndianaPlayerCharacter_OnPlayerInventoryItemConsumed Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.OnPlayerSoftCoverEnteredBP
// (Event, Protected, BlueprintEvent)

void AIndianaPlayerCharacter::OnPlayerSoftCoverEnteredBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "OnPlayerSoftCoverEnteredBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.IndianaPlayerCharacter.OnPlayerSoftCoverExitedBP
// (Event, Protected, BlueprintEvent)

void AIndianaPlayerCharacter::OnPlayerSoftCoverExitedBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "OnPlayerSoftCoverExitedBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.IndianaPlayerCharacter.OnPlayerStealthEnteredBP
// (Event, Protected, BlueprintEvent)

void AIndianaPlayerCharacter::OnPlayerStealthEnteredBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "OnPlayerStealthEnteredBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.IndianaPlayerCharacter.OnPlayerStealthExitedBP
// (Event, Protected, BlueprintEvent)

void AIndianaPlayerCharacter::OnPlayerStealthExitedBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "OnPlayerStealthExitedBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.IndianaPlayerCharacter.OnSoftCoverEntered
// (Final, Native, Protected)

void AIndianaPlayerCharacter::OnSoftCoverEntered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "OnSoftCoverEntered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.OnSoftCoverExited
// (Final, Native, Protected)

void AIndianaPlayerCharacter::OnSoftCoverExited()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "OnSoftCoverExited");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.OnStopCrouch
// (Final, Native, Protected)

void AIndianaPlayerCharacter::OnStopCrouch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "OnStopCrouch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.OnUndetected
// (Final, Native, Protected)

void AIndianaPlayerCharacter::OnUndetected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "OnUndetected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.PointOfNoReturnFixConversations
// (Final, Exec, Native, Protected)

void AIndianaPlayerCharacter::PointOfNoReturnFixConversations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "PointOfNoReturnFixConversations");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.PointOfNoReturnFixGlobalVars
// (Final, Exec, Native, Protected)

void AIndianaPlayerCharacter::PointOfNoReturnFixGlobalVars()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "PointOfNoReturnFixGlobalVars");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.PointOfNoReturnFixItems
// (Final, Exec, Native, Protected)

void AIndianaPlayerCharacter::PointOfNoReturnFixItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "PointOfNoReturnFixItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.PointOfNoReturnFixQuests
// (Final, Exec, Native, Protected)

void AIndianaPlayerCharacter::PointOfNoReturnFixQuests()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "PointOfNoReturnFixQuests");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.PointOfNoReturnRollback
// (Final, Exec, Native, Public)

void AIndianaPlayerCharacter::PointOfNoReturnRollback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "PointOfNoReturnRollback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.SetAllLevels
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::SetAllLevels(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "SetAllLevels");

	Params::IndianaPlayerCharacter_SetAllLevels Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.SetAwareOfRegion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTravelRegionData*                Region                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::SetAwareOfRegion(const class UTravelRegionData* Region)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "SetAwareOfRegion");

	Params::IndianaPlayerCharacter_SetAwareOfRegion Parms{};

	Parms.Region = Region;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.SetAwareOfTravelDestination
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTravelDestinationData*           TravelDest                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::SetAwareOfTravelDestination(const class UTravelDestinationData* TravelDest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "SetAwareOfTravelDestination");

	Params::IndianaPlayerCharacter_SetAwareOfTravelDestination Parms{};

	Parms.TravelDest = TravelDest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.SetCurrentShipLocation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UShipDestinationData*             ShipDest                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::SetCurrentShipLocation(const class UShipDestinationData* ShipDest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "SetCurrentShipLocation");

	Params::IndianaPlayerCharacter_SetCurrentShipLocation Parms{};

	Parms.ShipDest = ShipDest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.SetIsInLowGravity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewIsInLowGravity                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::SetIsInLowGravity(bool bNewIsInLowGravity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "SetIsInLowGravity");

	Params::IndianaPlayerCharacter_SetIsInLowGravity Parms{};

	Parms.bNewIsInLowGravity = bNewIsInLowGravity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.SetMovementEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewIsMovementEnabled                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::SetMovementEnabled(bool bNewIsMovementEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "SetMovementEnabled");

	Params::IndianaPlayerCharacter_SetMovementEnabled Parms{};

	Parms.bNewIsMovementEnabled = bNewIsMovementEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.SetTravelDestinationHidden
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTravelDestinationData*           TravelDest                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSetHidden                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::SetTravelDestinationHidden(const class UTravelDestinationData* TravelDest, bool bSetHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "SetTravelDestinationHidden");

	Params::IndianaPlayerCharacter_SetTravelDestinationHidden Parms{};

	Parms.TravelDest = TravelDest;
	Parms.bSetHidden = bSetHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.SetTravelDestinationLocked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTravelDestinationData*           TravelDest                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLocked                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::SetTravelDestinationLocked(const class UTravelDestinationData* TravelDest, bool bLocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "SetTravelDestinationLocked");

	Params::IndianaPlayerCharacter_SetTravelDestinationLocked Parms{};

	Parms.TravelDest = TravelDest;
	Parms.bLocked = bLocked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.SetTutorialsEnabled
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::SetTutorialsEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "SetTutorialsEnabled");

	Params::IndianaPlayerCharacter_SetTutorialsEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.SetVisitedRegion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTravelRegionData*                Region                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::SetVisitedRegion(const class UTravelRegionData* Region)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "SetVisitedRegion");

	Params::IndianaPlayerCharacter_SetVisitedRegion Parms{};

	Parms.Region = Region;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.SetVisitedTravelDestination
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTravelDestinationData*           TravelDest                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::SetVisitedTravelDestination(const class UTravelDestinationData* TravelDest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "SetVisitedTravelDestination");

	Params::IndianaPlayerCharacter_SetVisitedTravelDestination Parms{};

	Parms.TravelDest = TravelDest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.SuppressInput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSuppress                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::SuppressInput(bool bSuppress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "SuppressInput");

	Params::IndianaPlayerCharacter_SuppressInput Parms{};

	Parms.bSuppress = bSuppress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.TinkerAdvanceWeapon
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bIgnoreCost                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::TinkerAdvanceWeapon(bool bIgnoreCost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "TinkerAdvanceWeapon");

	Params::IndianaPlayerCharacter_TinkerAdvanceWeapon Parms{};

	Parms.bIgnoreCost = bIgnoreCost;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.TravelToDestination
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTravelDestinationData*           Destination                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTriggerAutosave                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::TravelToDestination(class UTravelDestinationData* Destination, bool bTriggerAutosave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "TravelToDestination");

	Params::IndianaPlayerCharacter_TravelToDestination Parms{};

	Parms.Destination = Destination;
	Parms.bTriggerAutosave = bTriggerAutosave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.WasPONRRollbackRecentlyPerformed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AIndianaPlayerCharacter::WasPONRRollbackRecentlyPerformed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "WasPONRRollbackRecentlyPerformed");

	Params::IndianaPlayerCharacter_WasPONRRollbackRecentlyPerformed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaPlayerCharacter.WeaponHolstered
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          InWeapon                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::WeaponHolstered(class UWeapon* InWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "WeaponHolstered");

	Params::IndianaPlayerCharacter_WeaponHolstered Parms{};

	Parms.InWeapon = InWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.WeaponUnholstered
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          InWeapon                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaPlayerCharacter::WeaponUnholstered(class UWeapon* InWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "WeaponUnholstered");

	Params::IndianaPlayerCharacter_WeaponUnholstered Parms{};

	Parms.InWeapon = InWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaPlayerCharacter.IsShipCurrentlyAt
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTravelDestinationData*           ShipDest                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AIndianaPlayerCharacter::IsShipCurrentlyAt(const class UTravelDestinationData* ShipDest) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaPlayerCharacter", "IsShipCurrentlyAt");

	Params::IndianaPlayerCharacter_IsShipCurrentlyAt Parms{};

	Parms.ShipDest = ShipDest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaUI.ShowItemOnDisplay
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UItem>                ItemIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaUI::ShowItemOnDisplay(TSubclassOf<class UItem> ItemIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaUI", "ShowItemOnDisplay");

	Params::IndianaUI_ShowItemOnDisplay Parms{};

	Parms.ItemIn = ItemIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUI.CloseGenericMoviePlayer
// (Final, Native, Public, BlueprintCallable)

void AIndianaUI::CloseGenericMoviePlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUI", "CloseGenericMoviePlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUI.CloseWorkbench
// (Final, Native, Public)

void AIndianaUI::CloseWorkbench()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUI", "CloseWorkbench");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUI.ColorblindMode
// (Final, Exec, Native, Public)
// Parameters:
// EColorVisionDeficiency                  Deficiency                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Severity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCorrection                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCorrectionPreview                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaUI::ColorblindMode(EColorVisionDeficiency Deficiency, int32 Severity, bool bCorrection, bool bCorrectionPreview)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUI", "ColorblindMode");

	Params::IndianaUI_ColorblindMode Parms{};

	Parms.Deficiency = Deficiency;
	Parms.Severity = Severity;
	Parms.bCorrection = bCorrection;
	Parms.bCorrectionPreview = bCorrectionPreview;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUI.ConstructUserWidget
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ECheckBranches                          Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UIndianaInterfaceUserWidget>WidgetClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UIndianaInterfaceUserWidget*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UIndianaInterfaceUserWidget* AIndianaUI::ConstructUserWidget(ECheckBranches* Branches, TSubclassOf<class UIndianaInterfaceUserWidget> WidgetClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUI", "ConstructUserWidget");

	Params::IndianaUI_ConstructUserWidget Parms{};

	Parms.WidgetClass = WidgetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaUI.CreateCinematicPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCinematicPlayerWidget*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCinematicPlayerWidget* AIndianaUI::CreateCinematicPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUI", "CreateCinematicPlayer");

	Params::IndianaUI_CreateCinematicPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaUI.CreateExaminable
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLocString                       NameString                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLocString                       DescriptionString                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLocString                       ActionString                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RemoteEventOnExaminationEnd                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaUI::CreateExaminable(const struct FLocString& NameString, const struct FLocString& DescriptionString, const struct FLocString& ActionString, const class FName& RemoteEventOnExaminationEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUI", "CreateExaminable");

	Params::IndianaUI_CreateExaminable Parms{};

	Parms.NameString = std::move(NameString);
	Parms.DescriptionString = std::move(DescriptionString);
	Parms.ActionString = std::move(ActionString);
	Parms.RemoteEventOnExaminationEnd = RemoteEventOnExaminationEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUI.CreateGenericMoviePlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMoviePlayerWidget*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMoviePlayerWidget* AIndianaUI::CreateGenericMoviePlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUI", "CreateGenericMoviePlayer");

	Params::IndianaUI_CreateGenericMoviePlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaUI.CreateSubtitleManagerInstance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMediaPlayer*                     MediaPlayer                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USubtitleManagerWidget*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USubtitleManagerWidget* AIndianaUI::CreateSubtitleManagerInstance(class UMediaPlayer* MediaPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUI", "CreateSubtitleManagerInstance");

	Params::IndianaUI_CreateSubtitleManagerInstance Parms{};

	Parms.MediaPlayer = MediaPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaUI.CreateSubtitleManagerInstanceForMSSP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMovieSceneSequencePlayer*        MovieSceneSequencePlayer                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USubtitleManagerWidget*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USubtitleManagerWidget* AIndianaUI::CreateSubtitleManagerInstanceForMSSP(class UMovieSceneSequencePlayer* MovieSceneSequencePlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUI", "CreateSubtitleManagerInstanceForMSSP");

	Params::IndianaUI_CreateSubtitleManagerInstanceForMSSP Parms{};

	Parms.MovieSceneSequencePlayer = MovieSceneSequencePlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaUI.DebugSetFontScaling
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   ModifierIn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaUI::DebugSetFontScaling(int32 ModifierIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUI", "DebugSetFontScaling");

	Params::IndianaUI_DebugSetFontScaling Parms{};

	Parms.ModifierIn = ModifierIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUI.DebugStringIDs
// (Final, Exec, Native, Public)

void AIndianaUI::DebugStringIDs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUI", "DebugStringIDs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUI.DebugStringIDsAndTables
// (Final, Exec, Native, Public)

void AIndianaUI::DebugStringIDsAndTables()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUI", "DebugStringIDsAndTables");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUI.DebugStringTables
// (Final, Exec, Native, Public)

void AIndianaUI::DebugStringTables()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUI", "DebugStringTables");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUI.DebugToggleDLC
// (Final, Exec, Native, Public)

void AIndianaUI::DebugToggleDLC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUI", "DebugToggleDLC");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUI.FontSizeModifierChanged
// (Final, Native, Public)
// Parameters:
// int32                                   ModifierIn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaUI::FontSizeModifierChanged(int32 ModifierIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUI", "FontSizeModifierChanged");

	Params::IndianaUI_FontSizeModifierChanged Parms{};

	Parms.ModifierIn = ModifierIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUI.ForceHUDHidden
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bForceHidden                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaUI::ForceHUDHidden(bool bForceHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUI", "ForceHUDHidden");

	Params::IndianaUI_ForceHUDHidden Parms{};

	Parms.bForceHidden = bForceHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUI.OverlayCycle
// (Final, Exec, Native, Public)

void AIndianaUI::OverlayCycle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUI", "OverlayCycle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUI.RemoveSubtitleManagerInstance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USubtitleManagerWidget*           ManagerWidget                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaUI::RemoveSubtitleManagerInstance(class USubtitleManagerWidget* ManagerWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUI", "RemoveSubtitleManagerInstance");

	Params::IndianaUI_RemoveSubtitleManagerInstance Parms{};

	Parms.ManagerWidget = ManagerWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUI.SetHudVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewVisible                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaUI::SetHudVisible(bool bNewVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUI", "SetHudVisible");

	Params::IndianaUI_SetHudVisible Parms{};

	Parms.bNewVisible = bNewVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUI.SetSoundMixVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USoundMix*                        SoundMix                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndianaUI::SetSoundMixVolume(class USoundMix* SoundMix, float Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUI", "SetSoundMixVolume");

	Params::IndianaUI_SetSoundMixVolume Parms{};

	Parms.SoundMix = SoundMix;
	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUI.StartWorkbench
// (Final, Exec, Native, Public)

void AIndianaUI::StartWorkbench()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUI", "StartWorkbench");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUI.ToggleDamageTextVisibility
// (Final, Exec, Native, Public)

void AIndianaUI::ToggleDamageTextVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUI", "ToggleDamageTextVisibility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUI.ToggleResurrect
// (Final, Exec, Native, Public)

void AIndianaUI::ToggleResurrect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUI", "ToggleResurrect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUI.ToggleSafeSpace
// (Final, Exec, Native, Public)

void AIndianaUI::ToggleSafeSpace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUI", "ToggleSafeSpace");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.IndianaUI.GetHUD
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UHUDWidget*                       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHUDWidget* AIndianaUI::GetHUD() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUI", "GetHUD");

	Params::IndianaUI_GetHUD Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaUI.GetSlideshowWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USlideshowWidget*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USlideshowWidget* AIndianaUI::GetSlideshowWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUI", "GetSlideshowWidget");

	Params::IndianaUI_GetSlideshowWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaUI.GetUserWidget
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECheckBranches                          Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UIndianaInterfaceUserWidget>WidgetClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UIndianaInterfaceUserWidget*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UIndianaInterfaceUserWidget* AIndianaUI::GetUserWidget(ECheckBranches* Branches, TSubclassOf<class UIndianaInterfaceUserWidget> WidgetClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndianaUI", "GetUserWidget");

	Params::IndianaUI_GetUserWidget Parms{};

	Parms.WidgetClass = WidgetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaUIFunctionLibrary.GetColorByType
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// EIndianaUIColorType                     Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UIndianaUIFunctionLibrary::GetColorByType(EIndianaUIColorType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaUIFunctionLibrary", "GetColorByType");

	Params::IndianaUIFunctionLibrary_GetColorByType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaUIFunctionLibrary.GetIndianaUI
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ECheckBranches                          Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AIndianaUI*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AIndianaUI* UIndianaUIFunctionLibrary::GetIndianaUI(ECheckBranches* Branches, class APlayerController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaUIFunctionLibrary", "GetIndianaUI");

	Params::IndianaUIFunctionLibrary_GetIndianaUI Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaUIFunctionLibrary.GetOpacityForComponentByType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EIndianaUIOpacityType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIndianaUIFunctionLibrary::GetOpacityForComponentByType(EIndianaUIOpacityType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaUIFunctionLibrary", "GetOpacityForComponentByType");

	Params::IndianaUIFunctionLibrary_GetOpacityForComponentByType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.IndianaWorldSettings.K2_IsCurrentMap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UMapInformation*                  MapInfo                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AIndianaWorldSettings::K2_IsCurrentMap(const class UMapInformation* MapInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndianaWorldSettings", "K2_IsCurrentMap");

	Params::IndianaWorldSettings_K2_IsCurrentMap Parms{};

	Parms.MapInfo = MapInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.InputLabelHoldWidget.SetRadialFill
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   FillRatio                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Opacity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputLabelHoldWidget::SetRadialFill(float FillRatio, float Opacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputLabelHoldWidget", "SetRadialFill");

	Params::InputLabelHoldWidget_SetRadialFill Parms{};

	Parms.FillRatio = FillRatio;
	Parms.Opacity = Opacity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.InputLabelHoldWidget.SetWidth
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputLabelHoldWidget::SetWidth(float Width)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputLabelHoldWidget", "SetWidth");

	Params::InputLabelHoldWidget_SetWidth Parms{};

	Parms.Width = Width;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.InputLabelHoldWidget.UpdateFill
// (Final, Native, Protected, BlueprintCallable)

void UInputLabelHoldWidget::UpdateFill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputLabelHoldWidget", "UpdateFill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InteractableComponent.GetInteractableComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UChildActorComponent*             ChildActorComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractableComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractableComponent* UInteractableComponent::GetInteractableComponent(class UChildActorComponent* ChildActorComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractableComponent", "GetInteractableComponent");

	Params::InteractableComponent_GetInteractableComponent Parms{};

	Parms.ChildActorComponent = ChildActorComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.InteractionInterface.CanInteract
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AIndianaCharacter*                Initiator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInteractPayload                 Payload                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IInteractionInterface::CanInteract(class AIndianaCharacter* Initiator, const struct FInteractPayload& Payload) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInterface", "CanInteract");

	Params::InteractionInterface_CanInteract Parms{};

	Parms.Initiator = Initiator;
	Parms.Payload = std::move(Payload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.InteractionInterface.GetInteraction
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FInteractionDescription          Description                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FInteractPayload                 Payload                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   InteractDistance                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInteractionType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInteractionType IInteractionInterface::GetInteraction(const struct FInteractionDescription& Description, const struct FInteractPayload& Payload, float InteractDistance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInterface", "GetInteraction");

	Params::InteractionInterface_GetInteraction Parms{};

	Parms.Description = std::move(Description);
	Parms.Payload = std::move(Payload);
	Parms.InteractDistance = InteractDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.InteractionInterface.GetInteractLocString
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// struct FLocString                       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLocString IInteractionInterface::GetInteractLocString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInterface", "GetInteractLocString");

	Params::InteractionInterface_GetInteractLocString Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.InventoryArmorPageWidget.SetEquippedArmorSlot
// (Final, Native, Protected)
// Parameters:
// EArmorSlot                              ArmorSlotIn                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryArmorPageWidget::SetEquippedArmorSlot(EArmorSlot ArmorSlotIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryArmorPageWidget", "SetEquippedArmorSlot");

	Params::InventoryArmorPageWidget_SetEquippedArmorSlot Parms{};

	Parms.ArmorSlotIn = ArmorSlotIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemViewerItemWidget.OnButtonClicked
// (Event, Protected, BlueprintEvent)

void UItemViewerItemWidget::OnButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemViewerItemWidget", "OnButtonClicked");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.ItemViewerItemWidget.OnButtonFocused
// (Event, Protected, BlueprintEvent)

void UItemViewerItemWidget::OnButtonFocused()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemViewerItemWidget", "OnButtonFocused");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.ItemViewerItemWidget.OnButtonFocusLost
// (Event, Protected, BlueprintEvent)

void UItemViewerItemWidget::OnButtonFocusLost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemViewerItemWidget", "OnButtonFocusLost");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.ItemViewerItemWidget.OnButtonHovered
// (Event, Protected, BlueprintEvent)

void UItemViewerItemWidget::OnButtonHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemViewerItemWidget", "OnButtonHovered");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.ItemViewerItemWidget.OnButtonPressed
// (Event, Protected, BlueprintEvent)

void UItemViewerItemWidget::OnButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemViewerItemWidget", "OnButtonPressed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.ItemViewerItemWidget.OnButtonUnhovered
// (Event, Protected, BlueprintEvent)

void UItemViewerItemWidget::OnButtonUnhovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemViewerItemWidget", "OnButtonUnhovered");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.InventoryItemWidget.GetDamageType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UIndianaDamageType>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UIndianaDamageType> UInventoryItemWidget::GetDamageType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryItemWidget", "GetDamageType");

	Params::InventoryItemWidget_GetDamageType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.InventoryWeaponAmmoGroupWidget.OnHighlightChange
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bHighlight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryWeaponAmmoGroupWidget::OnHighlightChange(bool bHighlight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryWeaponAmmoGroupWidget", "OnHighlightChange");

	Params::InventoryWeaponAmmoGroupWidget_OnHighlightChange Parms{};

	Parms.bHighlight = bHighlight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.InventoryWeaponAmmoWidget.SetIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTexture2D*                       Icon                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryWeaponAmmoWidget::SetIcon(class UTexture2D* Icon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryWeaponAmmoWidget", "SetIcon");

	Params::InventoryWeaponAmmoWidget_SetIcon Parms{};

	Parms.Icon = Icon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryWidget.AfterSettingCurrentPage
// (Final, Native, Protected)
// Parameters:
// class UIndianaUserWidget*               UserWidget                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCanChangePage                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bActivate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryWidget::AfterSettingCurrentPage(class UIndianaUserWidget* UserWidget, int32 Index_0, bool bAnimate, bool bCanChangePage, bool bActivate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryWidget", "AfterSettingCurrentPage");

	Params::InventoryWidget_AfterSettingCurrentPage Parms{};

	Parms.UserWidget = UserWidget;
	Parms.Index_0 = Index_0;
	Parms.bAnimate = bAnimate;
	Parms.bCanChangePage = bCanChangePage;
	Parms.bActivate = bActivate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryWidget.OnDragDrop_AssignDrugSlot
// (Final, Native, Protected)
// Parameters:
// class UIndianaDragDropOperation*        Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryWidget::OnDragDrop_AssignDrugSlot(class UIndianaDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryWidget", "OnDragDrop_AssignDrugSlot");

	Params::InventoryWidget_OnDragDrop_AssignDrugSlot Parms{};

	Parms.Operation = Operation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryWidget.OnDragDrop_AssignGadgetSlot
// (Final, Native, Protected)
// Parameters:
// class UIndianaDragDropOperation*        Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryWidget::OnDragDrop_AssignGadgetSlot(class UIndianaDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryWidget", "OnDragDrop_AssignGadgetSlot");

	Params::InventoryWidget_OnDragDrop_AssignGadgetSlot Parms{};

	Parms.Operation = Operation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryWidget.OnDragDrop_ClearDrugSlot
// (Final, Native, Protected)
// Parameters:
// class UIndianaDragDropOperation*        Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryWidget::OnDragDrop_ClearDrugSlot(class UIndianaDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryWidget", "OnDragDrop_ClearDrugSlot");

	Params::InventoryWidget_OnDragDrop_ClearDrugSlot Parms{};

	Parms.Operation = Operation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryWidget.OnDragDrop_ClearGadgetSlot
// (Final, Native, Protected)
// Parameters:
// class UIndianaDragDropOperation*        Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryWidget::OnDragDrop_ClearGadgetSlot(class UIndianaDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryWidget", "OnDragDrop_ClearGadgetSlot");

	Params::InventoryWidget_OnDragDrop_ClearGadgetSlot Parms{};

	Parms.Operation = Operation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryWidget.OnDragDrop_DropItem
// (Final, Native, Protected)
// Parameters:
// class UIndianaDragDropOperation*        Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryWidget::OnDragDrop_DropItem(class UIndianaDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryWidget", "OnDragDrop_DropItem");

	Params::InventoryWidget_OnDragDrop_DropItem Parms{};

	Parms.Operation = Operation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryWidget.OnDragDrop_ItemViewerArmorSwap
// (Final, Native, Protected)
// Parameters:
// class UIndianaDragDropOperation*        Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryWidget::OnDragDrop_ItemViewerArmorSwap(class UIndianaDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryWidget", "OnDragDrop_ItemViewerArmorSwap");

	Params::InventoryWidget_OnDragDrop_ItemViewerArmorSwap Parms{};

	Parms.Operation = Operation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryWidget.OnDragDrop_ItemViewerInternalSwap
// (Final, Native, Protected)
// Parameters:
// class UIndianaDragDropOperation*        Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryWidget::OnDragDrop_ItemViewerInternalSwap(class UIndianaDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryWidget", "OnDragDrop_ItemViewerInternalSwap");

	Params::InventoryWidget_OnDragDrop_ItemViewerInternalSwap Parms{};

	Parms.Operation = Operation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryWidget.OnDragDrop_ItemViewerWeaponSwap
// (Final, Native, Protected)
// Parameters:
// class UIndianaDragDropOperation*        Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryWidget::OnDragDrop_ItemViewerWeaponSwap(class UIndianaDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryWidget", "OnDragDrop_ItemViewerWeaponSwap");

	Params::InventoryWidget_OnDragDrop_ItemViewerWeaponSwap Parms{};

	Parms.Operation = Operation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryWidget.OnDragDrop_SetWeaponSlot
// (Final, Native, Protected)
// Parameters:
// class UIndianaDragDropOperation*        Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryWidget::OnDragDrop_SetWeaponSlot(class UIndianaDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryWidget", "OnDragDrop_SetWeaponSlot");

	Params::InventoryWidget_OnDragDrop_SetWeaponSlot Parms{};

	Parms.Operation = Operation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryWidget.OnDragDrop_SwapDrugSlot
// (Final, Native, Protected)
// Parameters:
// class UIndianaDragDropOperation*        Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryWidget::OnDragDrop_SwapDrugSlot(class UIndianaDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryWidget", "OnDragDrop_SwapDrugSlot");

	Params::InventoryWidget_OnDragDrop_SwapDrugSlot Parms{};

	Parms.Operation = Operation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryWidget.OnDragDrop_SwapGadgetSlot
// (Final, Native, Protected)
// Parameters:
// class UIndianaDragDropOperation*        Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryWidget::OnDragDrop_SwapGadgetSlot(class UIndianaDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryWidget", "OnDragDrop_SwapGadgetSlot");

	Params::InventoryWidget_OnDragDrop_SwapGadgetSlot Parms{};

	Parms.Operation = Operation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryWidget.OnDragDrop_SwapWeaponSlot
// (Final, Native, Protected)
// Parameters:
// class UIndianaDragDropOperation*        Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryWidget::OnDragDrop_SwapWeaponSlot(class UIndianaDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryWidget", "OnDragDrop_SwapWeaponSlot");

	Params::InventoryWidget_OnDragDrop_SwapWeaponSlot Parms{};

	Parms.Operation = Operation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryWidget.OnItemAdded
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UInventoryWidget::OnItemAdded(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryWidget", "OnItemAdded");

	Params::InventoryWidget_OnItemAdded Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryWidget.OnItemCountChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UInventoryWidget::OnItemCountChanged(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryWidget", "OnItemCountChanged");

	Params::InventoryWidget_OnItemCountChanged Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryWidget.OnItemJunkStatusChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UInventoryWidget::OnItemJunkStatusChanged(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryWidget", "OnItemJunkStatusChanged");

	Params::InventoryWidget_OnItemJunkStatusChanged Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryWidget.OnItemRemoved
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UInventoryWidget::OnItemRemoved(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryWidget", "OnItemRemoved");

	Params::InventoryWidget_OnItemRemoved Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryWidget.OnScrollingPageChangeComplete
// (Final, Native, Protected)
// Parameters:
// class UIndianaUserWidget*               UserWidget                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryWidget::OnScrollingPageChangeComplete(class UIndianaUserWidget* UserWidget, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryWidget", "OnScrollingPageChangeComplete");

	Params::InventoryWidget_OnScrollingPageChangeComplete Parms{};

	Parms.UserWidget = UserWidget;
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryWidget.OnScrollingPageChangeStart
// (Final, Native, Protected)
// Parameters:
// class UIndianaUserWidget*               UserWidget                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryWidget::OnScrollingPageChangeStart(class UIndianaUserWidget* UserWidget, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryWidget", "OnScrollingPageChangeStart");

	Params::InventoryWidget_OnScrollingPageChangeStart Parms{};

	Parms.UserWidget = UserWidget;
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.InventoryWidget.OnWeaponStartEquip
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryWidget::OnWeaponStartEquip(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryWidget", "OnWeaponStartEquip");

	Params::InventoryWidget_OnWeaponStartEquip Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemContainerWidget.HideContainer
// (Event, Protected, BlueprintEvent)

void UItemContainerWidget::HideContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemContainerWidget", "HideContainer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.ItemContainerWidget.OnItemAdded
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UItemContainerWidget::OnItemAdded(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemContainerWidget", "OnItemAdded");

	Params::ItemContainerWidget_OnItemAdded Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemContainerWidget.OnItemCountChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UItemContainerWidget::OnItemCountChanged(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemContainerWidget", "OnItemCountChanged");

	Params::ItemContainerWidget_OnItemCountChanged Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemContainerWidget.OnItemRemoved
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UItemContainerWidget::OnItemRemoved(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemContainerWidget", "OnItemRemoved");

	Params::ItemContainerWidget_OnItemRemoved Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemContainerWidget.ShowContainer
// (Event, Protected, BlueprintEvent)

void UItemContainerWidget::ShowContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemContainerWidget", "ShowContainer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.ItemDegradationAlertWidget.BodyArmorDamageStatusChanged
// (Final, Native, Protected)
// Parameters:
// EItemDegradationState                   DegradationState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemDegradationAlertWidget::BodyArmorDamageStatusChanged(EItemDegradationState DegradationState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemDegradationAlertWidget", "BodyArmorDamageStatusChanged");

	Params::ItemDegradationAlertWidget_BodyArmorDamageStatusChanged Parms{};

	Parms.DegradationState = DegradationState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemDegradationAlertWidget.HeadArmorDamageStatusChanged
// (Final, Native, Protected)
// Parameters:
// EItemDegradationState                   DegradationState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemDegradationAlertWidget::HeadArmorDamageStatusChanged(EItemDegradationState DegradationState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemDegradationAlertWidget", "HeadArmorDamageStatusChanged");

	Params::ItemDegradationAlertWidget_HeadArmorDamageStatusChanged Parms{};

	Parms.DegradationState = DegradationState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemDegradationAlertWidget.OnEquipmentRepairVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemDegradationAlertWidget::OnEquipmentRepairVisibilityChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemDegradationAlertWidget", "OnEquipmentRepairVisibilityChanged");

	Params::ItemDegradationAlertWidget_OnEquipmentRepairVisibilityChanged Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemDegradationAlertWidget.OnHUDVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemDegradationAlertWidget::OnHUDVisibilityChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemDegradationAlertWidget", "OnHUDVisibilityChanged");

	Params::ItemDegradationAlertWidget_OnHUDVisibilityChanged Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemDegradationAlertWidget.OnUnequippedArmor
// (Final, Native, Protected)
// Parameters:
// EArmorSlot                              ArmorSlotIn                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemDegradationAlertWidget::OnUnequippedArmor(EArmorSlot ArmorSlotIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemDegradationAlertWidget", "OnUnequippedArmor");

	Params::ItemDegradationAlertWidget_OnUnequippedArmor Parms{};

	Parms.ArmorSlotIn = ArmorSlotIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemDegradationAlertWidget.WeaponDamageStatusChanged
// (Final, Native, Protected)
// Parameters:
// EItemDegradationState                   DegradationState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemDegradationAlertWidget::WeaponDamageStatusChanged(EItemDegradationState DegradationState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemDegradationAlertWidget", "WeaponDamageStatusChanged");

	Params::ItemDegradationAlertWidget_WeaponDamageStatusChanged Parms{};

	Parms.DegradationState = DegradationState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemInspectorWidget.GamepadScroll
// (Final, Native, Protected)
// Parameters:
// float                                   GamepadInput                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemInspectorWidget::GamepadScroll(float GamepadInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemInspectorWidget", "GamepadScroll");

	Params::ItemInspectorWidget_GamepadScroll Parms{};

	Parms.GamepadInput = GamepadInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemInspectorWidget.MouseScroll
// (Final, Native, Protected)
// Parameters:
// float                                   MouseInput                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemInspectorWidget::MouseScroll(float MouseInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemInspectorWidget", "MouseScroll");

	Params::ItemInspectorWidget_MouseScroll Parms{};

	Parms.MouseInput = MouseInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemInspectorWidget.OnInputBack
// (Final, Native, Protected)

void UItemInspectorWidget::OnInputBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemInspectorWidget", "OnInputBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemInspectorWidget.OnZoomToggled
// (Final, Native, Protected)
// Parameters:
// bool                                    bFullZoom                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemInspectorWidget::OnZoomToggled(bool bFullZoom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemInspectorWidget", "OnZoomToggled");

	Params::ItemInspectorWidget_OnZoomToggled Parms{};

	Parms.bFullZoom = bFullZoom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemInspectorWidget.ZoomToggled
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bFullZoom                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemInspectorWidget::ZoomToggled(bool bFullZoom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemInspectorWidget", "ZoomToggled");

	Params::ItemInspectorWidget_ZoomToggled Parms{};

	Parms.bFullZoom = bFullZoom;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.ItemModdingWidget.OnInputBack
// (Final, Native, Protected)

void UItemModdingWidget::OnInputBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemModdingWidget", "OnInputBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemModdingWidget.OnInstallMod
// (Final, Native, Protected)

void UItemModdingWidget::OnInstallMod()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemModdingWidget", "OnInstallMod");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemRepairWidget.OnInputBack
// (Final, Native, Protected)

void UItemRepairWidget::OnInputBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemRepairWidget", "OnInputBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemRepairWidget.OnRepair
// (Final, Native, Protected)

void UItemRepairWidget::OnRepair()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemRepairWidget", "OnRepair");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemToolTipWidget.FontSizeChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   NewModifier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemToolTipWidget::FontSizeChanged(int32 NewModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemToolTipWidget", "FontSizeChanged");

	Params::ItemToolTipWidget_FontSizeChanged Parms{};

	Parms.NewModifier = NewModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemToolTipWidget.SetBackgroundBrush
// (Event, Protected, BlueprintEvent)

void UItemToolTipWidget::SetBackgroundBrush()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemToolTipWidget", "SetBackgroundBrush");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.ItemTransferWidget.OnInventoryItemAdded
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       Item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UItemTransferWidget::OnInventoryItemAdded(const struct FItemStack& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemTransferWidget", "OnInventoryItemAdded");

	Params::ItemTransferWidget_OnInventoryItemAdded Parms{};

	Parms.Item = std::move(Item);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemTransferWidget.OnInventoryItemRemoved
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       Item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UItemTransferWidget::OnInventoryItemRemoved(const struct FItemStack& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemTransferWidget", "OnInventoryItemRemoved");

	Params::ItemTransferWidget_OnInventoryItemRemoved Parms{};

	Parms.Item = std::move(Item);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemTransferWidget.OnItemCountChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UItemTransferWidget::OnItemCountChanged(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemTransferWidget", "OnItemCountChanged");

	Params::ItemTransferWidget_OnItemCountChanged Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemTransferWidget.OnPlayerCountChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       ItemStack                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UItemTransferWidget::OnPlayerCountChanged(const struct FItemStack& ItemStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemTransferWidget", "OnPlayerCountChanged");

	Params::ItemTransferWidget_OnPlayerCountChanged Parms{};

	Parms.ItemStack = std::move(ItemStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemTransferWidget.OnPlayerItemAdded
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       Item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UItemTransferWidget::OnPlayerItemAdded(const struct FItemStack& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemTransferWidget", "OnPlayerItemAdded");

	Params::ItemTransferWidget_OnPlayerItemAdded Parms{};

	Parms.Item = std::move(Item);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemTransferWidget.OnPlayerItemRemoved
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FItemStack                       Item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UItemTransferWidget::OnPlayerItemRemoved(const struct FItemStack& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemTransferWidget", "OnPlayerItemRemoved");

	Params::ItemTransferWidget_OnPlayerItemRemoved Parms{};

	Parms.Item = std::move(Item);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ItemViewerWidget.OnScrollingComplete
// (Final, Native, Protected)

void UItemViewerWidget::OnScrollingComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemViewerWidget", "OnScrollingComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.KeybindDialogBoxWidget.OnInputBack
// (Final, Native, Protected)

void UKeybindDialogBoxWidget::OnInputBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeybindDialogBoxWidget", "OnInputBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.KeybindDialogBoxWidget.OnInputPress
// (Final, Native, Protected)

void UKeybindDialogBoxWidget::OnInputPress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeybindDialogBoxWidget", "OnInputPress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.KeybindDialogBoxWidget.SetNewBackingMaterialHeight
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   NewHeight                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKeybindDialogBoxWidget::SetNewBackingMaterialHeight(float NewHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeybindDialogBoxWidget", "SetNewBackingMaterialHeight");

	Params::KeybindDialogBoxWidget_SetNewBackingMaterialHeight Parms{};

	Parms.NewHeight = NewHeight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.KeyBindsMenuWidget.CreateRestoreDefaultsDialogBox
// (Final, Native, Protected)

void UKeyBindsMenuWidget::CreateRestoreDefaultsDialogBox()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeyBindsMenuWidget", "CreateRestoreDefaultsDialogBox");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.KeyBindsMenuWidget.OnBackButtonClicked
// (Final, Native, Protected)

void UKeyBindsMenuWidget::OnBackButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeyBindsMenuWidget", "OnBackButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.LedgerMapWidget.ActiveQuestChanged
// (Final, Native, Protected)

void ULedgerMapWidget::ActiveQuestChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LedgerMapWidget", "ActiveQuestChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.LedgerMapWidget.InitiateFastTravelFromCompanionSelect
// (Final, Native, Protected)

void ULedgerMapWidget::InitiateFastTravelFromCompanionSelect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LedgerMapWidget", "InitiateFastTravelFromCompanionSelect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.LedgerMapWidget.OnBorderMouseDown
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    MouseEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply ULedgerMapWidget::OnBorderMouseDown(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LedgerMapWidget", "OnBorderMouseDown");

	Params::LedgerMapWidget_OnBorderMouseDown Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.MouseEvent = std::move(MouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.LedgerMapWidget.OnCompanionSelectionClosed
// (Final, Native, Protected)

void ULedgerMapWidget::OnCompanionSelectionClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LedgerMapWidget", "OnCompanionSelectionClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.LegalWidget.ExecuteAbort
// (Native, Public, BlueprintCallable)

void ULegalWidget::ExecuteAbort()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegalWidget", "ExecuteAbort");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.LegalWidget.ExecuteCancel
// (Native, Public, BlueprintCallable)

void ULegalWidget::ExecuteCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegalWidget", "ExecuteCancel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.LegalWidget.ExecuteConfirm
// (Native, Public, BlueprintCallable)

void ULegalWidget::ExecuteConfirm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegalWidget", "ExecuteConfirm");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.LegalWidget.InitializeMechanicOfConfirmButton
// (Final, Native, Public, BlueprintCallable)

void ULegalWidget::InitializeMechanicOfConfirmButton()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegalWidget", "InitializeMechanicOfConfirmButton");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.LegalWidget.ResetScrollOffset
// (Final, Native, Public, BlueprintCallable)

void ULegalWidget::ResetScrollOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegalWidget", "ResetScrollOffset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.LegalWidget.SetEnabledConfirmButton
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULegalWidget::SetEnabledConfirmButton(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegalWidget", "SetEnabledConfirmButton");

	Params::LegalWidget_SetEnabledConfirmButton Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.LegalWidget.ShowLegal
// (Final, Native, Public, BlueprintCallable)

void ULegalWidget::ShowLegal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegalWidget", "ShowLegal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.LegalWidget.UpdateConfirmButtonState
// (Final, Native, Private)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULegalWidget::UpdateConfirmButtonState(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegalWidget", "UpdateConfirmButtonState");

	Params::LegalWidget_UpdateConfirmButtonState Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.LegalWidget.IsLegalSigned
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULegalWidget::IsLegalSigned() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegalWidget", "IsLegalSigned");

	Params::LegalWidget_IsLegalSigned Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.LevelUpNotificationWidget.GetGlowballAnimation
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UWidgetAnimation*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetAnimation* ULevelUpNotificationWidget::GetGlowballAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpNotificationWidget", "GetGlowballAnimation");

	Params::LevelUpNotificationWidget_GetGlowballAnimation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.LevelUpNotificationWidget.GetGlowFadeAnimation
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UWidgetAnimation*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetAnimation* ULevelUpNotificationWidget::GetGlowFadeAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpNotificationWidget", "GetGlowFadeAnimation");

	Params::LevelUpNotificationWidget_GetGlowFadeAnimation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.LevelUpNotificationWidget.GetGlowGrowAnimation
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UWidgetAnimation*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetAnimation* ULevelUpNotificationWidget::GetGlowGrowAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpNotificationWidget", "GetGlowGrowAnimation");

	Params::LevelUpNotificationWidget_GetGlowGrowAnimation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.LevelUpNotificationWidget.GetGlowShrinkAnimation
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UWidgetAnimation*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetAnimation* ULevelUpNotificationWidget::GetGlowShrinkAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpNotificationWidget", "GetGlowShrinkAnimation");

	Params::LevelUpNotificationWidget_GetGlowShrinkAnimation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.LevelUpNotificationWidget.GetLevelUpReminderAnimation
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UWidgetAnimation*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetAnimation* ULevelUpNotificationWidget::GetLevelUpReminderAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpNotificationWidget", "GetLevelUpReminderAnimation");

	Params::LevelUpNotificationWidget_GetLevelUpReminderAnimation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.LevelUpNotificationWidget.GetPrimaryTextAndSunFadeInAnimation
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UWidgetAnimation*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetAnimation* ULevelUpNotificationWidget::GetPrimaryTextAndSunFadeInAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpNotificationWidget", "GetPrimaryTextAndSunFadeInAnimation");

	Params::LevelUpNotificationWidget_GetPrimaryTextAndSunFadeInAnimation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.LevelUpNotificationWidget.GetPrimaryTextGrowAnimation
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UWidgetAnimation*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetAnimation* ULevelUpNotificationWidget::GetPrimaryTextGrowAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpNotificationWidget", "GetPrimaryTextGrowAnimation");

	Params::LevelUpNotificationWidget_GetPrimaryTextGrowAnimation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.LevelUpNotificationWidget.GetSecondaryTextFadeInAnimation
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UWidgetAnimation*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetAnimation* ULevelUpNotificationWidget::GetSecondaryTextFadeInAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpNotificationWidget", "GetSecondaryTextFadeInAnimation");

	Params::LevelUpNotificationWidget_GetSecondaryTextFadeInAnimation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.LevelUpNotificationWidget.GetSunSpinAnimation
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UWidgetAnimation*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetAnimation* ULevelUpNotificationWidget::GetSunSpinAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpNotificationWidget", "GetSunSpinAnimation");

	Params::LevelUpNotificationWidget_GetSunSpinAnimation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.LevelUpNotificationWidget.GetTextAndSunFadeOutAnimation
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UWidgetAnimation*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetAnimation* ULevelUpNotificationWidget::GetTextAndSunFadeOutAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpNotificationWidget", "GetTextAndSunFadeOutAnimation");

	Params::LevelUpNotificationWidget_GetTextAndSunFadeOutAnimation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Indiana.LevelUpNotificationWidget.OnGlowballComplete
// (Final, Native, Protected)

void ULevelUpNotificationWidget::OnGlowballComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpNotificationWidget", "OnGlowballComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.LevelUpNotificationWidget.OnGlowGrowComplete
// (Final, Native, Protected)

void ULevelUpNotificationWidget::OnGlowGrowComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpNotificationWidget", "OnGlowGrowComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.LevelUpNotificationWidget.OnGlowShrinkComplete
// (Final, Native, Protected)

void ULevelUpNotificationWidget::OnGlowShrinkComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpNotificationWidget", "OnGlowShrinkComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.LevelUpNotificationWidget.OnHUDVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelUpNotificationWidget::OnHUDVisibilityChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpNotificationWidget", "OnHUDVisibilityChanged");

	Params::LevelUpNotificationWidget_OnHUDVisibilityChanged Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.LevelUpNotificationWidget.OnLevelUpComplete
// (Event, Protected, BlueprintEvent)

void ULevelUpNotificationWidget::OnLevelUpComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpNotificationWidget", "OnLevelUpComplete");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.LevelUpNotificationWidget.OnLevelUpNotificationVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelUpNotificationWidget::OnLevelUpNotificationVisibilityChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpNotificationWidget", "OnLevelUpNotificationVisibilityChanged");

	Params::LevelUpNotificationWidget_OnLevelUpNotificationVisibilityChanged Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.LevelUpNotificationWidget.OnLevelUpReminderVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelUpNotificationWidget::OnLevelUpReminderVisibilityChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpNotificationWidget", "OnLevelUpReminderVisibilityChanged");

	Params::LevelUpNotificationWidget_OnLevelUpReminderVisibilityChanged Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.LevelUpNotificationWidget.OnPerkAdded
// (Final, Native, Protected)

void ULevelUpNotificationWidget::OnPerkAdded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpNotificationWidget", "OnPerkAdded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.LevelUpNotificationWidget.OnPrimaryTextAndSunFadeInComplete
// (Final, Native, Protected)

void ULevelUpNotificationWidget::OnPrimaryTextAndSunFadeInComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpNotificationWidget", "OnPrimaryTextAndSunFadeInComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.LevelUpNotificationWidget.OnProgressToPerksPage
// (Final, Native, Protected)

void ULevelUpNotificationWidget::OnProgressToPerksPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpNotificationWidget", "OnProgressToPerksPage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.LevelUpNotificationWidget.OnProgressToSkillsPage
// (Final, Native, Protected)

void ULevelUpNotificationWidget::OnProgressToSkillsPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpNotificationWidget", "OnProgressToSkillsPage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.LevelUpNotificationWidget.OnSkillUpdated
// (Final, Native, Protected)
// Parameters:
// ESkill                                  Skill                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelUpNotificationWidget::OnSkillUpdated(ESkill Skill, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpNotificationWidget", "OnSkillUpdated");

	Params::LevelUpNotificationWidget_OnSkillUpdated Parms{};

	Parms.Skill = Skill;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.LevelUpNotificationWidget.OnTextAndSunFadeOutComplete
// (Final, Native, Protected)

void ULevelUpNotificationWidget::OnTextAndSunFadeOutComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpNotificationWidget", "OnTextAndSunFadeOutComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.LevelUpNotificationWidget.PlayerCombatStateChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bIsInCombat                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelUpNotificationWidget::PlayerCombatStateChanged(bool bIsInCombat, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelUpNotificationWidget", "PlayerCombatStateChanged");

	Params::LevelUpNotificationWidget_PlayerCombatStateChanged Parms{};

	Parms.bIsInCombat = bIsInCombat;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainMenuDLCManagerWidget.RefreshEntitlements
// (Final, Native, Public)

void UMainMenuDLCManagerWidget::RefreshEntitlements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuDLCManagerWidget", "RefreshEntitlements");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainMenuWidget.OnActiveUserChanged
// (Final, Native, Protected)
// Parameters:
// EActiveUserChangeType                   ChangeType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMainMenuWidget::OnActiveUserChanged(EActiveUserChangeType ChangeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OnActiveUserChanged");

	Params::MainMenuWidget_OnActiveUserChanged Parms{};

	Parms.ChangeType = ChangeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainMenuWidget.OnAnyTextPromptHideComplete
// (Final, Native, Protected, BlueprintCallable)

void UMainMenuWidget::OnAnyTextPromptHideComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OnAnyTextPromptHideComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainMenuWidget.OnAutosaveSplashComplete
// (Final, Native, Protected, BlueprintCallable)

void UMainMenuWidget::OnAutosaveSplashComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OnAutosaveSplashComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainMenuWidget.OnCreditsInterfaceClosed
// (Final, Native, Protected)
// Parameters:
// bool                                    bForced                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMainMenuWidget::OnCreditsInterfaceClosed(bool bForced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OnCreditsInterfaceClosed");

	Params::MainMenuWidget_OnCreditsInterfaceClosed Parms{};

	Parms.bForced = bForced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainMenuWidget.OnCreditsInterfaceOpened
// (Final, Native, Protected)

void UMainMenuWidget::OnCreditsInterfaceOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OnCreditsInterfaceOpened");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainMenuWidget.OnDLCCheckComplete
// (Final, Native, Protected, BlueprintCallable)

void UMainMenuWidget::OnDLCCheckComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OnDLCCheckComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainMenuWidget.OnExternalMenuClosed
// (Final, Native, Protected)
// Parameters:
// bool                                    bForced                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMainMenuWidget::OnExternalMenuClosed(bool bForced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OnExternalMenuClosed");

	Params::MainMenuWidget_OnExternalMenuClosed Parms{};

	Parms.bForced = bForced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainMenuWidget.OnExternalMenuOpened
// (Final, Native, Protected)

void UMainMenuWidget::OnExternalMenuOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OnExternalMenuOpened");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainMenuWidget.OnGammaSelectionClosed
// (Final, Native, Protected, BlueprintCallable)

void UMainMenuWidget::OnGammaSelectionClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OnGammaSelectionClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainMenuWidget.OnGammaSelectionOpened
// (Final, Native, Protected, BlueprintCallable)

void UMainMenuWidget::OnGammaSelectionOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OnGammaSelectionOpened");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainMenuWidget.OnHideInterface
// (Event, Protected, BlueprintEvent)

void UMainMenuWidget::OnHideInterface()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OnHideInterface");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.MainMenuWidget.OnHideLogo
// (Event, Protected, BlueprintEvent)

void UMainMenuWidget::OnHideLogo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OnHideLogo");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.MainMenuWidget.OnHideMainOptionsComplete
// (Final, Native, Protected, BlueprintCallable)

void UMainMenuWidget::OnHideMainOptionsComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OnHideMainOptionsComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainMenuWidget.OnHideMainOptionsStart
// (Final, Native, Protected, BlueprintCallable)

void UMainMenuWidget::OnHideMainOptionsStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OnHideMainOptionsStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainMenuWidget.OnLoadUserGameSettingsComplete
// (Final, Native, Protected)

void UMainMenuWidget::OnLoadUserGameSettingsComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OnLoadUserGameSettingsComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainMenuWidget.OnOfflineDLCCheckComplete
// (Final, Native, Protected, BlueprintCallable)

void UMainMenuWidget::OnOfflineDLCCheckComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OnOfflineDLCCheckComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainMenuWidget.OnShowAnyTextPrompt
// (Event, Protected, BlueprintEvent)

void UMainMenuWidget::OnShowAnyTextPrompt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OnShowAnyTextPrompt");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.MainMenuWidget.OnShowInterface
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bShouldChangeLogo                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMainMenuWidget::OnShowInterface(bool bShouldChangeLogo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OnShowInterface");

	Params::MainMenuWidget_OnShowInterface Parms{};

	Parms.bShouldChangeLogo = bShouldChangeLogo;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.MainMenuWidget.OnShowLogo
// (Event, Protected, BlueprintEvent)

void UMainMenuWidget::OnShowLogo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OnShowLogo");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.MainMenuWidget.OnShowMainOptions
// (Final, Native, Protected, BlueprintCallable)

void UMainMenuWidget::OnShowMainOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OnShowMainOptions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainMenuWidget.OnShowMainOptionsComplete
// (Final, Native, Protected, BlueprintCallable)

void UMainMenuWidget::OnShowMainOptionsComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OnShowMainOptionsComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainMenuWidget.OnStartHideAnyTextPrompt
// (Event, Protected, BlueprintEvent)

void UMainMenuWidget::OnStartHideAnyTextPrompt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OnStartHideAnyTextPrompt");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.MainMenuWidget.OnStartHideGammaSelection
// (Event, Protected, BlueprintEvent)

void UMainMenuWidget::OnStartHideGammaSelection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OnStartHideGammaSelection");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.MainMenuWidget.OnStartShowGammaSelection
// (Event, Protected, BlueprintEvent)

void UMainMenuWidget::OnStartShowGammaSelection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OnStartShowGammaSelection");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.MainMenuWidget.OnStartShowMainOptions
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UMainMenuWidget::OnStartShowMainOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OnStartShowMainOptions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.MainMenuWidget.OpenCredits
// (Final, Native, Public, BlueprintCallable)

void UMainMenuWidget::OpenCredits()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OpenCredits");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainMenuWidget.OpenDeliverablesScreen
// (Final, Native, Protected)

void UMainMenuWidget::OpenDeliverablesScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OpenDeliverablesScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainMenuWidget.OpenExtrasScreen
// (Final, Native, Protected)

void UMainMenuWidget::OpenExtrasScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OpenExtrasScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainMenuWidget.OpenMainScreen
// (Final, Native, Protected)

void UMainMenuWidget::OpenMainScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "OpenMainScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainMenuWidget.StartAutosaveSplash
// (Event, Protected, BlueprintEvent)

void UMainMenuWidget::StartAutosaveSplash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "StartAutosaveSplash");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.MainMenuWidget.TryInitializeDLC
// (Final, Native, Private)

void UMainMenuWidget::TryInitializeDLC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuWidget", "TryInitializeDLC");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainOptionsWidget.InquireDLC1
// (Final, Native, Protected)

void UMainOptionsWidget::InquireDLC1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainOptionsWidget", "InquireDLC1");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainOptionsWidget.InquireDLC2
// (Final, Native, Protected)

void UMainOptionsWidget::InquireDLC2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainOptionsWidget", "InquireDLC2");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainOptionsWidget.OnActiveUserChanged
// (Final, Native, Protected)
// Parameters:
// EActiveUserChangeType                   ChangeType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMainOptionsWidget::OnActiveUserChanged(EActiveUserChangeType ChangeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainOptionsWidget", "OnActiveUserChanged");

	Params::MainOptionsWidget_OnActiveUserChanged Parms{};

	Parms.ChangeType = ChangeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainOptionsWidget.OnLoadComplete
// (Final, Native, Protected)
// Parameters:
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELoadGameResult                         Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMainOptionsWidget::OnLoadComplete(const class FString& Filename, ELoadGameResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainOptionsWidget", "OnLoadComplete");

	Params::MainOptionsWidget_OnLoadComplete Parms{};

	Parms.Filename = std::move(Filename);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainOptionsWidget.OnLoadSaveMenuClosed
// (Final, Native, Protected)
// Parameters:
// bool                                    bForced                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMainOptionsWidget::OnLoadSaveMenuClosed(bool bForced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainOptionsWidget", "OnLoadSaveMenuClosed");

	Params::MainOptionsWidget_OnLoadSaveMenuClosed Parms{};

	Parms.bForced = bForced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainOptionsWidget.OnQueryLatestSaveFinished
// (Final, Native, Protected)
// Parameters:
// class FString                           LatestSaveName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHasSaves                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMainOptionsWidget::OnQueryLatestSaveFinished(const class FString& LatestSaveName, bool bHasSaves)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainOptionsWidget", "OnQueryLatestSaveFinished");

	Params::MainOptionsWidget_OnQueryLatestSaveFinished Parms{};

	Parms.LatestSaveName = std::move(LatestSaveName);
	Parms.bHasSaves = bHasSaves;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MainOptionsWidget.OnSettingsMenuClosed
// (Final, Native, Protected)

void UMainOptionsWidget::OnSettingsMenuClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainOptionsWidget", "OnSettingsMenuClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MapRenderer.TakeRender
// (Final, Native, Public, BlueprintCallable)

void AMapRenderer::TakeRender()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapRenderer", "TakeRender");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MedKitComponent.OnAbilityMontageEnded
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMedKitComponent::OnAbilityMontageEnded(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MedKitComponent", "OnAbilityMontageEnded");

	Params::MedKitComponent_OnAbilityMontageEnded Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MedKitComponent.OnAnimNotifyEvent
// (Final, Native, Protected)
// Parameters:
// EAnimNotify                             AnimNotifyEvent                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMedKitComponent::OnAnimNotifyEvent(EAnimNotify AnimNotifyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MedKitComponent", "OnAnimNotifyEvent");

	Params::MedKitComponent_OnAnimNotifyEvent Parms{};

	Parms.AnimNotifyEvent = AnimNotifyEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MedKitComponent.StartMedkit
// (Final, Native, Protected)
// Parameters:
// class UWeapon*                          Weapon                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMedKitComponent::StartMedkit(class UWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MedKitComponent", "StartMedkit");

	Params::MedKitComponent_StartMedkit Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.WaitTimeSliderWidget.OnValueChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FSliderEvent                     Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UWaitTimeSliderWidget::OnValueChanged(const struct FSliderEvent& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaitTimeSliderWidget", "OnValueChanged");

	Params::WaitTimeSliderWidget_OnValueChanged Parms{};

	Parms.Event = std::move(Event);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MeleeSequencer.OnAbilityUnlocked
// (Final, Native, Protected)
// Parameters:
// EUnlockAbility                          Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMeleeSequencer::OnAbilityUnlocked(EUnlockAbility Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeleeSequencer", "OnAbilityUnlocked");

	Params::MeleeSequencer_OnAbilityUnlocked Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MeleeSequencer.OnStatUpdated
// (Final, Native, Protected)
// Parameters:
// class URpgStat*                         Stat                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMeleeSequencer::OnStatUpdated(const class URpgStat* Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeleeSequencer", "OnStatUpdated");

	Params::MeleeSequencer_OnStatUpdated Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TacticalTimeDilationComponent.AttributeUpdated
// (Final, Native, Protected)
// Parameters:
// EAttribute                              Attribute                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTacticalTimeDilationComponent::AttributeUpdated(EAttribute Attribute, int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TacticalTimeDilationComponent", "AttributeUpdated");

	Params::TacticalTimeDilationComponent_AttributeUpdated Parms{};

	Parms.Attribute = Attribute;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TacticalTimeDilationComponent.EnableTimeDilation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForce                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTacticalTimeDilationComponent::EnableTimeDilation(bool bEnabled, bool bInstant, bool bForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TacticalTimeDilationComponent", "EnableTimeDilation");

	Params::TacticalTimeDilationComponent_EnableTimeDilation Parms{};

	Parms.bEnabled = bEnabled;
	Parms.bInstant = bInstant;
	Parms.bForce = bForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TacticalTimeDilationComponent.OnAttack
// (Final, Native, Protected)
// Parameters:
// float                                   DurationScalar                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTacticalTimeDilationComponent::OnAttack(float DurationScalar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TacticalTimeDilationComponent", "OnAttack");

	Params::TacticalTimeDilationComponent_OnAttack Parms{};

	Parms.DurationScalar = DurationScalar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TacticalTimeDilationComponent.OnDeath
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FCauseDamageInfo                 CauseDamageInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UTacticalTimeDilationComponent::OnDeath(const struct FCauseDamageInfo& CauseDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TacticalTimeDilationComponent", "OnDeath");

	Params::TacticalTimeDilationComponent_OnDeath Parms{};

	Parms.CauseDamageInfo = std::move(CauseDamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TacticalTimeDilationComponent.OnPlayerConversationChange
// (Final, Native, Protected)
// Parameters:
// class UConversationInstance*            Instance                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEntered                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTacticalTimeDilationComponent::OnPlayerConversationChange(const class UConversationInstance* Instance, bool bEntered)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TacticalTimeDilationComponent", "OnPlayerConversationChange");

	Params::TacticalTimeDilationComponent_OnPlayerConversationChange Parms{};

	Parms.Instance = Instance;
	Parms.bEntered = bEntered;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TacticalTimeDilationComponent.OnStatUpdated
// (Final, Native, Protected)
// Parameters:
// class URpgStat*                         Stat                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTacticalTimeDilationComponent::OnStatUpdated(const class URpgStat* Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TacticalTimeDilationComponent", "OnStatUpdated");

	Params::TacticalTimeDilationComponent_OnStatUpdated Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TacticalTimeDilationComponent.PreventTTD
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bPrevent                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTacticalTimeDilationComponent::PreventTTD(bool bPrevent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TacticalTimeDilationComponent", "PreventTTD");

	Params::TacticalTimeDilationComponent_PreventTTD Parms{};

	Parms.bPrevent = bPrevent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TeamComponent.BPClearRelationshipToPlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AIndianaAiCharacter*              Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTeamComponent::BPClearRelationshipToPlayer(class AIndianaAiCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TeamComponent", "BPClearRelationshipToPlayer");

	Params::TeamComponent_BPClearRelationshipToPlayer Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TeamComponent.BPSetRelationshipToPlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AIndianaAiCharacter*              Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETeamAttitude                           Relationship                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTeamComponent::BPSetRelationshipToPlayer(class AIndianaAiCharacter* Character, ETeamAttitude Relationship)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TeamComponent", "BPSetRelationshipToPlayer");

	Params::TeamComponent_BPSetRelationshipToPlayer Parms{};

	Parms.Character = Character;
	Parms.Relationship = Relationship;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TeamComponent.ClearRelationshipToPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EChangeRelationshipSource               InSource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTeamComponent::ClearRelationshipToPlayer(EChangeRelationshipSource InSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamComponent", "ClearRelationshipToPlayer");

	Params::TeamComponent_ClearRelationshipToPlayer Parms{};

	Parms.InSource = InSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TeamComponent.OnDeath
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FCauseDamageInfo                 DamageInfo                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UTeamComponent::OnDeath(const struct FCauseDamageInfo& DamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamComponent", "OnDeath");

	Params::TeamComponent_OnDeath Parms{};

	Parms.DamageInfo = std::move(DamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TeamComponent.OnDetectedPlayerCrime
// (Final, Native, Protected)
// Parameters:
// ECrimeType                              InCrimeType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayerDisguised                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInterrogationResult                    InInterrogationResult                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTeamComponent::OnDetectedPlayerCrime(ECrimeType InCrimeType, bool bPlayerDisguised, EInterrogationResult InInterrogationResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamComponent", "OnDetectedPlayerCrime");

	Params::TeamComponent_OnDetectedPlayerCrime Parms{};

	Parms.InCrimeType = InCrimeType;
	Parms.bPlayerDisguised = bPlayerDisguised;
	Parms.InInterrogationResult = InInterrogationResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TeamComponent.OnTakeDamage
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FCauseDamageInfo                 DamageInfo                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UTeamComponent::OnTakeDamage(const struct FCauseDamageInfo& DamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamComponent", "OnTakeDamage");

	Params::TeamComponent_OnTakeDamage Parms{};

	Parms.DamageInfo = std::move(DamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TeamComponent.SetRelationshipToPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETeamAttitude                           InRelationship                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EChangeRelationshipSource               InSource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrimeType                              InCrimeType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTeamComponent::SetRelationshipToPlayer(ETeamAttitude InRelationship, EChangeRelationshipSource InSource, ECrimeType InCrimeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamComponent", "SetRelationshipToPlayer");

	Params::TeamComponent_SetRelationshipToPlayer Parms{};

	Parms.InRelationship = InRelationship;
	Parms.InSource = InSource;
	Parms.InCrimeType = InCrimeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TeamComponent.GetRelationship
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           InActor                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETeamAttitude                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETeamAttitude UTeamComponent::GetRelationship(const class AActor* InActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamComponent", "GetRelationship");

	Params::TeamComponent_GetRelationship Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.TeamComponent.GetRelationshipWithPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETeamAttitude                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETeamAttitude UTeamComponent::GetRelationshipWithPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamComponent", "GetRelationshipWithPlayer");

	Params::TeamComponent_GetRelationshipWithPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.TeamComponent.GetRelationshipWithTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UTeamData>            InTeamData                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETeamAttitude                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETeamAttitude UTeamComponent::GetRelationshipWithTeam(TSubclassOf<class UTeamData> InTeamData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamComponent", "GetRelationshipWithTeam");

	Params::TeamComponent_GetRelationshipWithTeam Parms{};

	Parms.InTeamData = InTeamData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.TelemetryManager.SendDataKeys
// (Final, Exec, Native, Public)

void UTelemetryManager::SendDataKeys()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TelemetryManager", "SendDataKeys");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TestAudioDataTypeReference.GetTestAudioBank
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTestAudioDataTypeReference::GetTestAudioBank() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestAudioDataTypeReference", "GetTestAudioBank");

	Params::TestAudioDataTypeReference_GetTestAudioBank Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.TestAudioDataTypeReference.GetTestAudioEnvironment
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTestAudioDataTypeReference::GetTestAudioEnvironment() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestAudioDataTypeReference", "GetTestAudioEnvironment");

	Params::TestAudioDataTypeReference_GetTestAudioEnvironment Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.TestAudioDataTypeReference.GetTestAudioEvent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTestAudioDataTypeReference::GetTestAudioEvent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestAudioDataTypeReference", "GetTestAudioEvent");

	Params::TestAudioDataTypeReference_GetTestAudioEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.TestAudioDataTypeReference.GetTestAudioState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTestAudioDataTypeReference::GetTestAudioState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestAudioDataTypeReference", "GetTestAudioState");

	Params::TestAudioDataTypeReference_GetTestAudioState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.MoveToBehaviorStateInfo.OnTakeDamage
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FCauseDamageInfo                 CauseDamageInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMoveToBehaviorStateInfo::OnTakeDamage(const struct FCauseDamageInfo& CauseDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoveToBehaviorStateInfo", "OnTakeDamage");

	Params::MoveToBehaviorStateInfo_OnTakeDamage Parms{};

	Parms.CauseDamageInfo = std::move(CauseDamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusEffectBarEntryWidget.AnimateIn
// (Event, Protected, BlueprintEvent)

void UStatusEffectBarEntryWidget::AnimateIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectBarEntryWidget", "AnimateIn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.StatusEffectBarEntryWidget.AnimateOut
// (Event, Protected, BlueprintEvent)

void UStatusEffectBarEntryWidget::AnimateOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectBarEntryWidget", "AnimateOut");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.StatusEffectBarEntryWidget.OnAnimComplete
// (Final, Native, Protected, BlueprintCallable)

void UStatusEffectBarEntryWidget::OnAnimComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectBarEntryWidget", "OnAnimComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusEffectBarEntryWidget.ResetWidgetState
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   DesiredRenderOpacity                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffectBarEntryWidget::ResetWidgetState(float DesiredRenderOpacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectBarEntryWidget", "ResetWidgetState");

	Params::StatusEffectBarEntryWidget_ResetWidgetState Parms{};

	Parms.DesiredRenderOpacity = DesiredRenderOpacity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.MusicManager.SetMusicOverride_BP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UMusicTrackData*                  OverrideTrack                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMusicManager::SetMusicOverride_BP(const class UMusicTrackData* OverrideTrack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MusicManager", "SetMusicOverride_BP");

	Params::MusicManager_SetMusicOverride_BP Parms{};

	Parms.OverrideTrack = OverrideTrack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MusicManager.OnPostMapLoad
// (Final, Native, Protected)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMusicManager::OnPostMapLoad(class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicManager", "OnPostMapLoad");

	Params::MusicManager_OnPostMapLoad Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.MusicManager.OnPreMapLoad
// (Final, Native, Protected)
// Parameters:
// class FString                           MapName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMusicManager::OnPreMapLoad(const class FString& MapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicManager", "OnPreMapLoad");

	Params::MusicManager_OnPreMapLoad Parms{};

	Parms.MapName = std::move(MapName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ObjectiveWaypointGameDataReference.GetDisplayOverride
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UObjectiveWaypointGameDataReference::GetDisplayOverride() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveWaypointGameDataReference", "GetDisplayOverride");

	Params::ObjectiveWaypointGameDataReference_GetDisplayOverride Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ObjectiveWaypointGameDataReference.GetDisplayOverrideID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UObjectiveWaypointGameDataReference::GetDisplayOverrideID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveWaypointGameDataReference", "GetDisplayOverrideID");

	Params::ObjectiveWaypointGameDataReference_GetDisplayOverrideID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ObjectiveWaypointGameDataReference.GetDisplayOverrideWithGender
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGender                                 CharacterGender                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UObjectiveWaypointGameDataReference::GetDisplayOverrideWithGender(EGender CharacterGender) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveWaypointGameDataReference", "GetDisplayOverrideWithGender");

	Params::ObjectiveWaypointGameDataReference_GetDisplayOverrideWithGender Parms{};

	Parms.CharacterGender = CharacterGender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ObjectiveWaypointGameDataReference.GetGameObject
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGuid                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGuid UObjectiveWaypointGameDataReference::GetGameObject() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveWaypointGameDataReference", "GetGameObject");

	Params::ObjectiveWaypointGameDataReference_GetGameObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.ObjectiveWaypointGameDataReference.GetOverridesPreviousWaypoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UObjectiveWaypointGameDataReference::GetOverridesPreviousWaypoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveWaypointGameDataReference", "GetOverridesPreviousWaypoint");

	Params::ObjectiveWaypointGameDataReference_GetOverridesPreviousWaypoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OCLComponent.AttemptClose
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Initiator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForce                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Block                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSeal                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreLockStatus                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreStartEvent                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreEndEvent                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSound                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInstantAnimation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOCLResult                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOCLResult UOCLComponent::AttemptClose(class AActor* Initiator, bool bForce, bool Block, bool bSeal, bool bIgnoreLockStatus, bool bIgnoreStartEvent, bool bIgnoreEndEvent, bool bIgnoreSound, bool bInstantAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OCLComponent", "AttemptClose");

	Params::OCLComponent_AttemptClose Parms{};

	Parms.Initiator = Initiator;
	Parms.bForce = bForce;
	Parms.Block = Block;
	Parms.bSeal = bSeal;
	Parms.bIgnoreLockStatus = bIgnoreLockStatus;
	Parms.bIgnoreStartEvent = bIgnoreStartEvent;
	Parms.bIgnoreEndEvent = bIgnoreEndEvent;
	Parms.bIgnoreSound = bIgnoreSound;
	Parms.bInstantAnimation = bInstantAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OCLComponent.AttemptOpen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Initiator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForce                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSeal                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreLockStatus                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreStartEvent                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreEndEvent                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSound                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInstantAnimation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOCLResult                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOCLResult UOCLComponent::AttemptOpen(class AActor* Initiator, bool bForce, bool bSeal, bool bIgnoreLockStatus, bool bIgnoreStartEvent, bool bIgnoreEndEvent, bool bIgnoreSound, bool bInstantAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OCLComponent", "AttemptOpen");

	Params::OCLComponent_AttemptOpen Parms{};

	Parms.Initiator = Initiator;
	Parms.bForce = bForce;
	Parms.bSeal = bSeal;
	Parms.bIgnoreLockStatus = bIgnoreLockStatus;
	Parms.bIgnoreStartEvent = bIgnoreStartEvent;
	Parms.bIgnoreEndEvent = bIgnoreEndEvent;
	Parms.bIgnoreSound = bIgnoreSound;
	Parms.bInstantAnimation = bInstantAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OCLComponent.AttemptUnlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Initiator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOCLResult                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOCLResult UOCLComponent::AttemptUnlock(class AActor* Initiator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OCLComponent", "AttemptUnlock");

	Params::OCLComponent_AttemptUnlock Parms{};

	Parms.Initiator = Initiator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OCLComponent.BarOCL
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFireOCLBarredEvent                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOCLComponent::BarOCL(bool bFireOCLBarredEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OCLComponent", "BarOCL");

	Params::OCLComponent_BarOCL Parms{};

	Parms.bFireOCLBarredEvent = bFireOCLBarredEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OCLComponent.LockOCL
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFireOCLLockedEvent                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOCLComponent::LockOCL(bool bFireOCLLockedEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OCLComponent", "LockOCL");

	Params::OCLComponent_LockOCL Parms{};

	Parms.bFireOCLLockedEvent = bFireOCLLockedEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OCLComponent.SealOCL
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFireOCLSealedEvent                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOCLComponent::SealOCL(bool bFireOCLSealedEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OCLComponent", "SealOCL");

	Params::OCLComponent_SealOCL Parms{};

	Parms.bFireOCLSealedEvent = bFireOCLSealedEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OCLComponent.SignalOCLAnimationComplete
// (Final, Native, Public, BlueprintCallable)

void UOCLComponent::SignalOCLAnimationComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OCLComponent", "SignalOCLAnimationComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OCLComponent.UnbarOCL
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFireOCLUnbarredEvent                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnterLockedState                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOCLComponent::UnbarOCL(bool bFireOCLUnbarredEvent, bool bEnterLockedState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OCLComponent", "UnbarOCL");

	Params::OCLComponent_UnbarOCL Parms{};

	Parms.bFireOCLUnbarredEvent = bFireOCLUnbarredEvent;
	Parms.bEnterLockedState = bEnterLockedState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OCLComponent.UnlockOCL
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFireOCLUnlockedEvent                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOCLComponent::UnlockOCL(bool bFireOCLUnlockedEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OCLComponent", "UnlockOCL");

	Params::OCLComponent_UnlockOCL Parms{};

	Parms.bFireOCLUnlockedEvent = bFireOCLUnlockedEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OCLComponent.UnsealOCL
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFireOCLUnsealedEvent                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOCLComponent::UnsealOCL(bool bFireOCLUnsealedEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OCLComponent", "UnsealOCL");

	Params::OCLComponent_UnsealOCL Parms{};

	Parms.bFireOCLUnsealedEvent = bFireOCLUnsealedEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OCLComponent.GetCurrentState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOCLState                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOCLState UOCLComponent::GetCurrentState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OCLComponent", "GetCurrentState");

	Params::OCLComponent_GetCurrentState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OCLComponent.GetExactLockpickDifficulty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UOCLComponent::GetExactLockpickDifficulty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OCLComponent", "GetExactLockpickDifficulty");

	Params::OCLComponent_GetExactLockpickDifficulty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OCLComponent.IsBarred
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOCLComponent::IsBarred() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OCLComponent", "IsBarred");

	Params::OCLComponent_IsBarred Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OCLComponent.IsClosed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOCLComponent::IsClosed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OCLComponent", "IsClosed");

	Params::OCLComponent_IsClosed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OCLComponent.IsClosing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOCLComponent::IsClosing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OCLComponent", "IsClosing");

	Params::OCLComponent_IsClosing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OCLComponent.IsLocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOCLComponent::IsLocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OCLComponent", "IsLocked");

	Params::OCLComponent_IsLocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OCLComponent.IsOpen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOCLComponent::IsOpen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OCLComponent", "IsOpen");

	Params::OCLComponent_IsOpen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OCLComponent.IsOpening
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOCLComponent::IsOpening() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OCLComponent", "IsOpening");

	Params::OCLComponent_IsOpening Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OCLComponent.IsSealed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOCLComponent::IsSealed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OCLComponent", "IsSealed");

	Params::OCLComponent_IsSealed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OCLComponent.IsSealing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOCLComponent::IsSealing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OCLComponent", "IsSealing");

	Params::OCLComponent_IsSealing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OnRailsComponent.FindVantageForActor
// (Final, Native, Public, HasDefaults)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UOnRailsComponent::FindVantageForActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnRailsComponent", "FindVantageForActor");

	Params::OnRailsComponent_FindVantageForActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OnRailsComponent.FindVantageForLocation
// (Final, Native, Public, HasDefaults)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UOnRailsComponent::FindVantageForLocation(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnRailsComponent", "FindVantageForLocation");

	Params::OnRailsComponent_FindVantageForLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OnRailsComponent.FurthestLocationOnSpline
// (Final, Native, Public, HasDefaults)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UOnRailsComponent::FurthestLocationOnSpline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnRailsComponent", "FurthestLocationOnSpline");

	Params::OnRailsComponent_FurthestLocationOnSpline Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OnRailsComponent.HasVantageForActor
// (Final, Native, Public)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOnRailsComponent::HasVantageForActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnRailsComponent", "HasVantageForActor");

	Params::OnRailsComponent_HasVantageForActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OnRailsComponent.IsMoving
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOnRailsComponent::IsMoving()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnRailsComponent", "IsMoving");

	Params::OnRailsComponent_IsMoving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OnRailsComponent.IsMovingForward
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOnRailsComponent::IsMovingForward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnRailsComponent", "IsMovingForward");

	Params::OnRailsComponent_IsMovingForward Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.OnRailsComponent.OnCharacterDeath
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FCauseDamageInfo                 CDI                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UOnRailsComponent::OnCharacterDeath(const struct FCauseDamageInfo& CDI)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnRailsComponent", "OnCharacterDeath");

	Params::OnRailsComponent_OnCharacterDeath Parms{};

	Parms.CDI = std::move(CDI);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.OnRailsComponent.OnCompHit
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComp                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UOnRailsComponent::OnCompHit(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnRailsComponent", "OnCompHit");

	Params::OnRailsComponent_OnCompHit Parms{};

	Parms.HitComp = HitComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ParticlePool.ParticleFreed
// (Final, Native, Protected)
// Parameters:
// class UParticleSystemComponent*         Particle                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticlePool::ParticleFreed(class UParticleSystemComponent* Particle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParticlePool", "ParticleFreed");

	Params::ParticlePool_ParticleFreed Parms{};

	Parms.Particle = Particle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SpeakerGameDataReference.GetCharacterGrouping
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECharacterGrouping                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECharacterGrouping USpeakerGameDataReference::GetCharacterGrouping() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpeakerGameDataReference", "GetCharacterGrouping");

	Params::SpeakerGameDataReference_GetCharacterGrouping Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.SpeakerGameDataReference.GetChatterFile
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGuid                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGuid USpeakerGameDataReference::GetChatterFile() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpeakerGameDataReference", "GetChatterFile");

	Params::SpeakerGameDataReference_GetChatterFile Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.SpeakerGameDataReference.GetChatterPrefix
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USpeakerGameDataReference::GetChatterPrefix() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpeakerGameDataReference", "GetChatterPrefix");

	Params::SpeakerGameDataReference_GetChatterPrefix Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.SpeakerGameDataReference.GetGender
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGender                                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGender USpeakerGameDataReference::GetGender() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpeakerGameDataReference", "GetGender");

	Params::SpeakerGameDataReference_GetGender Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.SpeakerGameDataReference.GetInGameName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USpeakerGameDataReference::GetInGameName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpeakerGameDataReference", "GetInGameName");

	Params::SpeakerGameDataReference_GetInGameName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.SpeakerGameDataReference.GetInGameNameID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USpeakerGameDataReference::GetInGameNameID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpeakerGameDataReference", "GetInGameNameID");

	Params::SpeakerGameDataReference_GetInGameNameID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.SpeakerGameDataReference.GetInGameNameWithGender
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGender                                 CharacterGender                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USpeakerGameDataReference::GetInGameNameWithGender(EGender CharacterGender) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpeakerGameDataReference", "GetInGameNameWithGender");

	Params::SpeakerGameDataReference_GetInGameNameWithGender Parms{};

	Parms.CharacterGender = CharacterGender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.SpeakerGameDataReference.GetWwiseChatterEventOverride
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USpeakerGameDataReference::GetWwiseChatterEventOverride() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpeakerGameDataReference", "GetWwiseChatterEventOverride");

	Params::SpeakerGameDataReference_GetWwiseChatterEventOverride Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.SpeakerGameDataReference.GetWwiseChatterVoiceOverride
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USpeakerGameDataReference::GetWwiseChatterVoiceOverride() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpeakerGameDataReference", "GetWwiseChatterVoiceOverride");

	Params::SpeakerGameDataReference_GetWwiseChatterVoiceOverride Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.PauseMenuWidget.OnInputBack
// (Final, Native, Protected)

void UPauseMenuWidget::OnInputBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuWidget", "OnInputBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PauseMenuWidget.OnSaveGameComplete
// (Final, Native, Protected)
// Parameters:
// ESaveGameResult                         SaveResult                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESaveGameType                           SaveType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPauseMenuWidget::OnSaveGameComplete(ESaveGameResult SaveResult, ESaveGameType SaveType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuWidget", "OnSaveGameComplete");

	Params::PauseMenuWidget_OnSaveGameComplete Parms{};

	Parms.SaveResult = SaveResult;
	Parms.SaveType = SaveType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PauseMenuWidget.OnSaveLoadMenuClosed
// (Final, Native, Protected)
// Parameters:
// bool                                    bForced                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPauseMenuWidget::OnSaveLoadMenuClosed(bool bForced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuWidget", "OnSaveLoadMenuClosed");

	Params::PauseMenuWidget_OnSaveLoadMenuClosed Parms{};

	Parms.bForced = bForced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PauseMenuWidget.OnSettingsMenuClosed
// (Final, Native, Protected)

void UPauseMenuWidget::OnSettingsMenuClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuWidget", "OnSettingsMenuClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Weapon.IsFirstPersonEquipMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EWeaponEquipMode                        EquipMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeapon::IsFirstPersonEquipMode(EWeaponEquipMode EquipMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Weapon", "IsFirstPersonEquipMode");

	Params::Weapon_IsFirstPersonEquipMode Parms{};

	Parms.EquipMode = EquipMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Weapon.IsPreviewEquipMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EWeaponEquipMode                        EquipMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeapon::IsPreviewEquipMode(EWeaponEquipMode EquipMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Weapon", "IsPreviewEquipMode");

	Params::Weapon_IsPreviewEquipMode Parms{};

	Parms.EquipMode = EquipMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Weapon.IsThirdPersonEquipMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EWeaponEquipMode                        EquipMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeapon::IsThirdPersonEquipMode(EWeaponEquipMode EquipMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Weapon", "IsThirdPersonEquipMode");

	Params::Weapon_IsThirdPersonEquipMode Parms{};

	Parms.EquipMode = EquipMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Weapon.IsOnActiveWorld
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeapon::IsOnActiveWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "IsOnActiveWorld");

	Params::Weapon_IsOnActiveWorld Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Weapon.OnAnimNotifyEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAnimNotify                             AnimNotifyEvent                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeapon::OnAnimNotifyEvent(EAnimNotify AnimNotifyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "OnAnimNotifyEvent");

	Params::Weapon_OnAnimNotifyEvent Parms{};

	Parms.AnimNotifyEvent = AnimNotifyEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Weapon.OnStatUpdated
// (Final, Native, Protected)
// Parameters:
// class URpgStat*                         Stat                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeapon::OnStatUpdated(const class URpgStat* Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "OnStatUpdated");

	Params::Weapon_OnStatUpdated Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Weapon.StartUnequip
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInstantUnequip                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeapon::StartUnequip(bool bInstantUnequip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "StartUnequip");

	Params::Weapon_StartUnequip Parms{};

	Parms.bInstantUnequip = bInstantUnequip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Weapon.GetAISettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AIndianaAiCharacter*              InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAISettings_Weapon*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAISettings_Weapon* UWeapon::GetAISettings(class AIndianaAiCharacter* InOwner) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetAISettings");

	Params::Weapon_GetAISettings Parms{};

	Parms.InOwner = InOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Weapon.GetAmmoPool
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAmmoPoolBase*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAmmoPoolBase* UWeapon::GetAmmoPool() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetAmmoPool");

	Params::Weapon_GetAmmoPool Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Weapon.GetCharacterInfoComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCharacterInfoComponent*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCharacterInfoComponent* UWeapon::GetCharacterInfoComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetCharacterInfoComponent");

	Params::Weapon_GetCharacterInfoComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Weapon.GetCurrentMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWeaponMode*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWeaponMode* UWeapon::GetCurrentMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetCurrentMode");

	Params::Weapon_GetCurrentMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Weapon.GetCurrentVisuals
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPrimaryWeaponVisuals*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimaryWeaponVisuals* UWeapon::GetCurrentVisuals() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetCurrentVisuals");

	Params::Weapon_GetCurrentVisuals Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Weapon.GetMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UFPVSkeletalMeshComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFPVSkeletalMeshComponent* UWeapon::GetMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetMesh");

	Params::Weapon_GetMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Weapon.GetPrimaryMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWeaponMode*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWeaponMode* UWeapon::GetPrimaryMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetPrimaryMode");

	Params::Weapon_GetPrimaryMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Weapon.GetProjectileCollisionRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWeapon::GetProjectileCollisionRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetProjectileCollisionRadius");

	Params::Weapon_GetProjectileCollisionRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Weapon.GetRadialDamageOuterRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWeapon::GetRadialDamageOuterRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetRadialDamageOuterRadius");

	Params::Weapon_GetRadialDamageOuterRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Weapon.GetStats
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URpgStatComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URpgStatComponent* UWeapon::GetStats() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetStats");

	Params::Weapon_GetStats Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Weapon.GetWeaponEquipMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponEquipMode                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWeaponEquipMode UWeapon::GetWeaponEquipMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetWeaponEquipMode");

	Params::Weapon_GetWeaponEquipMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Weapon.GetWeaponModContainer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWeaponModContainer*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWeaponModContainer* UWeapon::GetWeaponModContainer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "GetWeaponModContainer");

	Params::Weapon_GetWeaponModContainer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Weapon.IsEquipping
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeapon::IsEquipping() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "IsEquipping");

	Params::Weapon_IsEquipping Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Weapon.IsHealGun
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeapon::IsHealGun() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "IsHealGun");

	Params::Weapon_IsHealGun Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Weapon.IsNearbyEvidence
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeapon::IsNearbyEvidence() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "IsNearbyEvidence");

	Params::Weapon_IsNearbyEvidence Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Weapon.IsUnequipping
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeapon::IsUnequipping() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Weapon", "IsUnequipping");

	Params::Weapon_IsUnequipping Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.PerksListEntry.OnPerkClickedValid
// (Event, Public, BlueprintEvent)

void UPerksListEntry::OnPerkClickedValid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerksListEntry", "OnPerkClickedValid");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.PerksListEntry.UpdateButtonBrush
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bPendingPurchase                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bActuallyPurchased                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuppressed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerksListEntry::UpdateButtonBrush(bool bPendingPurchase, bool bActuallyPurchased, bool bSuppressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerksListEntry", "UpdateButtonBrush");

	Params::PerksListEntry_UpdateButtonBrush Parms{};

	Parms.bPendingPurchase = bPendingPurchase;
	Parms.bActuallyPurchased = bActuallyPurchased;
	Parms.bSuppressed = bSuppressed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.PerksListEntry.GetPurchasedIcon
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UPerksListEntry::GetPurchasedIcon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerksListEntry", "GetPurchasedIcon");

	Params::PerksListEntry_GetPurchasedIcon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.PerksListEntry.GetSuppressedIcon
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UPerksListEntry::GetSuppressedIcon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerksListEntry", "GetSuppressedIcon");

	Params::PerksListEntry_GetSuppressedIcon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.PerksListEntry.GetUnpurchasedIcon
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UPerksListEntry::GetUnpurchasedIcon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerksListEntry", "GetUnpurchasedIcon");

	Params::PerksListEntry_GetUnpurchasedIcon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.PersuadeBehaviorStateInfo.OnTakeDamage
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FCauseDamageInfo                 CauseDamageInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UPersuadeBehaviorStateInfo::OnTakeDamage(const struct FCauseDamageInfo& CauseDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PersuadeBehaviorStateInfo", "OnTakeDamage");

	Params::PersuadeBehaviorStateInfo_OnTakeDamage Parms{};

	Parms.CauseDamageInfo = std::move(CauseDamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Pickup.GetItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UItem*                            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItem* APickup::GetItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pickup", "GetItem");

	Params::Pickup_GetItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Pickup.OnPhysicsSleep
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              SleepingComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APickup::OnPhysicsSleep(class UPrimitiveComponent* SleepingComponent, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pickup", "OnPhysicsSleep");

	Params::Pickup_OnPhysicsSleep Parms{};

	Parms.SleepingComponent = SleepingComponent;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Pickup.OnPhysicsWake
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              WakingComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APickup::OnPhysicsWake(class UPrimitiveComponent* WakingComponent, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pickup", "OnPhysicsWake");

	Params::Pickup_OnPhysicsWake Parms{};

	Parms.WakingComponent = WakingComponent;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Pickup.SetupDropPhysics
// (Final, Native, Protected)

void APickup::SetupDropPhysics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pickup", "SetupDropPhysics");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Pickup.ShutdownDropPhysics
// (Final, Native, Protected)
// Parameters:
// bool                                    bUpdateTransforms                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APickup::ShutdownDropPhysics(bool bUpdateTransforms)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pickup", "ShutdownDropPhysics");

	Params::Pickup_ShutdownDropPhysics Parms{};

	Parms.bUpdateTransforms = bUpdateTransforms;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayAnimationAction.OnMontageBlendingOut
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayAnimationAction::OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayAnimationAction", "OnMontageBlendingOut");

	Params::PlayAnimationAction_OnMontageBlendingOut Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerEnvironmentInteractionComponent.OnCombatStateChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bIsInCombat                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerEnvironmentInteractionComponent::OnCombatStateChange(bool bIsInCombat, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEnvironmentInteractionComponent", "OnCombatStateChange");

	Params::PlayerEnvironmentInteractionComponent_OnCombatStateChange Parms{};

	Parms.bIsInCombat = bIsInCombat;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerEnvironmentInteractionComponent.OnOccupiedNavAreaChanged
// (Final, Native, Protected)
// Parameters:
// class UClass*                           PrevOccupiedArea                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           CurrentOccupiedArea                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerEnvironmentInteractionComponent::OnOccupiedNavAreaChanged(const class UClass* PrevOccupiedArea, const class UClass* CurrentOccupiedArea)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEnvironmentInteractionComponent", "OnOccupiedNavAreaChanged");

	Params::PlayerEnvironmentInteractionComponent_OnOccupiedNavAreaChanged Parms{};

	Parms.PrevOccupiedArea = PrevOccupiedArea;
	Parms.CurrentOccupiedArea = CurrentOccupiedArea;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerHealthComponent.AddExhaustion
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Exhaustion                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerHealthComponent::AddExhaustion(float Exhaustion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerHealthComponent", "AddExhaustion");

	Params::PlayerHealthComponent_AddExhaustion Parms{};

	Parms.Exhaustion = Exhaustion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerHealthComponent.AddHunger
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Hunger                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerHealthComponent::AddHunger(float Hunger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerHealthComponent", "AddHunger");

	Params::PlayerHealthComponent_AddHunger Parms{};

	Parms.Hunger = Hunger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerHealthComponent.AddThirst
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Thirst                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerHealthComponent::AddThirst(float Thirst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerHealthComponent", "AddThirst");

	Params::PlayerHealthComponent_AddThirst Parms{};

	Parms.Thirst = Thirst;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerHealthComponent.AdjustExhaustion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromFastTravel                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTravelFromMapLedger                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerHealthComponent::AdjustExhaustion(float Amount, bool bFromFastTravel, bool bTravelFromMapLedger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerHealthComponent", "AdjustExhaustion");

	Params::PlayerHealthComponent_AdjustExhaustion Parms{};

	Parms.Amount = Amount;
	Parms.bFromFastTravel = bFromFastTravel;
	Parms.bTravelFromMapLedger = bTravelFromMapLedger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerHealthComponent.AdjustHunger
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromFastTravel                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTravelFromMapLedger                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerHealthComponent::AdjustHunger(float Amount, bool bFromFastTravel, bool bTravelFromMapLedger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerHealthComponent", "AdjustHunger");

	Params::PlayerHealthComponent_AdjustHunger Parms{};

	Parms.Amount = Amount;
	Parms.bFromFastTravel = bFromFastTravel;
	Parms.bTravelFromMapLedger = bTravelFromMapLedger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerHealthComponent.AdjustSurvivalStats
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   HungerGained                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ThirstGained                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ExhaustionGained                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromFastTravel                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTravelFromMapLedger                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForced                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerHealthComponent::AdjustSurvivalStats(float HungerGained, float ThirstGained, float ExhaustionGained, bool bFromFastTravel, bool bTravelFromMapLedger, bool bForced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerHealthComponent", "AdjustSurvivalStats");

	Params::PlayerHealthComponent_AdjustSurvivalStats Parms{};

	Parms.HungerGained = HungerGained;
	Parms.ThirstGained = ThirstGained;
	Parms.ExhaustionGained = ExhaustionGained;
	Parms.bFromFastTravel = bFromFastTravel;
	Parms.bTravelFromMapLedger = bTravelFromMapLedger;
	Parms.bForced = bForced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerHealthComponent.AdjustThirst
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromFastTravel                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTravelFromMapLedger                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerHealthComponent::AdjustThirst(float Amount, bool bFromFastTravel, bool bTravelFromMapLedger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerHealthComponent", "AdjustThirst");

	Params::PlayerHealthComponent_AdjustThirst Parms{};

	Parms.Amount = Amount;
	Parms.bFromFastTravel = bFromFastTravel;
	Parms.bTravelFromMapLedger = bTravelFromMapLedger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerHealthComponent.FastTravelInitiated
// (Final, Native, Public)
// Parameters:
// class UTravelDestinationData*           TravelData                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimePassed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTravelFromMapLedger                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerHealthComponent::FastTravelInitiated(const class UTravelDestinationData* TravelData, float TimePassed, bool bTravelFromMapLedger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerHealthComponent", "FastTravelInitiated");

	Params::PlayerHealthComponent_FastTravelInitiated Parms{};

	Parms.TravelData = TravelData;
	Parms.TimePassed = TimePassed;
	Parms.bTravelFromMapLedger = bTravelFromMapLedger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerHealthComponent.PlayerWaitInitiated
// (Final, Native, Public)
// Parameters:
// float                                   SecondsPassed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERestType                               RestType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerHealthComponent::PlayerWaitInitiated(float SecondsPassed, ERestType RestType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerHealthComponent", "PlayerWaitInitiated");

	Params::PlayerHealthComponent_PlayerWaitInitiated Parms{};

	Parms.SecondsPassed = SecondsPassed;
	Parms.RestType = RestType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerHealthComponent.SurvivalModeUpdated
// (Final, Native, Private)
// Parameters:
// bool                                    bSurvivalMode                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerHealthComponent::SurvivalModeUpdated(bool bSurvivalMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerHealthComponent", "SurvivalModeUpdated");

	Params::PlayerHealthComponent_SurvivalModeUpdated Parms{};

	Parms.bSurvivalMode = bSurvivalMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerHealthComponent.GetExhaustion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayerHealthComponent::GetExhaustion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerHealthComponent", "GetExhaustion");

	Params::PlayerHealthComponent_GetExhaustion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.PlayerHealthComponent.GetHunger
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayerHealthComponent::GetHunger() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerHealthComponent", "GetHunger");

	Params::PlayerHealthComponent_GetHunger Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.PlayerHealthComponent.GetLethalExhaustion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayerHealthComponent::GetLethalExhaustion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerHealthComponent", "GetLethalExhaustion");

	Params::PlayerHealthComponent_GetLethalExhaustion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.PlayerHealthComponent.GetLethalHunger
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayerHealthComponent::GetLethalHunger() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerHealthComponent", "GetLethalHunger");

	Params::PlayerHealthComponent_GetLethalHunger Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.PlayerHealthComponent.GetLethalThirst
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayerHealthComponent::GetLethalThirst() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerHealthComponent", "GetLethalThirst");

	Params::PlayerHealthComponent_GetLethalThirst Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.PlayerHealthComponent.GetMaxFastTravelExhaustion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayerHealthComponent::GetMaxFastTravelExhaustion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerHealthComponent", "GetMaxFastTravelExhaustion");

	Params::PlayerHealthComponent_GetMaxFastTravelExhaustion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.PlayerHealthComponent.GetMaxFastTravelHunger
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayerHealthComponent::GetMaxFastTravelHunger() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerHealthComponent", "GetMaxFastTravelHunger");

	Params::PlayerHealthComponent_GetMaxFastTravelHunger Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.PlayerHealthComponent.GetMaxFastTravelThirst
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayerHealthComponent::GetMaxFastTravelThirst() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerHealthComponent", "GetMaxFastTravelThirst");

	Params::PlayerHealthComponent_GetMaxFastTravelThirst Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.PlayerHealthComponent.GetThirst
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayerHealthComponent::GetThirst() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerHealthComponent", "GetThirst");

	Params::PlayerHealthComponent_GetThirst Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.PlayerInfoComponent.AddAudioLog
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAudioLogDefinition              AudioLogDefinition                                     (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UPlayerInfoComponent::AddAudioLog(struct FAudioLogDefinition* AudioLogDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "AddAudioLog");

	Params::PlayerInfoComponent_AddAudioLog Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AudioLogDefinition != nullptr)
		*AudioLogDefinition = std::move(Parms.AudioLogDefinition);
}


// Function Indiana.PlayerInfoComponent.AddXPDebug
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   XP                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoComponent::AddXPDebug(int32 XP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "AddXPDebug");

	Params::PlayerInfoComponent_AddXPDebug Parms{};

	Parms.XP = XP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInfoComponent.DisableFlawOffers
// (Final, Exec, Native, Public, BlueprintCallable)

void UPlayerInfoComponent::DisableFlawOffers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "DisableFlawOffers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInfoComponent.EnableFlawOffers
// (Final, Exec, Native, Public, BlueprintCallable)

void UPlayerInfoComponent::EnableFlawOffers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "EnableFlawOffers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInfoComponent.FlawAddDebug
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           FlawName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoComponent::FlawAddDebug(const class FString& FlawName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "FlawAddDebug");

	Params::PlayerInfoComponent_FlawAddDebug Parms{};

	Parms.FlawName = std::move(FlawName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInfoComponent.FlawClearDebug
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           FlawName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoComponent::FlawClearDebug(const class FString& FlawName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "FlawClearDebug");

	Params::PlayerInfoComponent_FlawClearDebug Parms{};

	Parms.FlawName = std::move(FlawName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInfoComponent.FlawClearOfferDebug
// (Final, Exec, Native, Public)

void UPlayerInfoComponent::FlawClearOfferDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "FlawClearOfferDebug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInfoComponent.FlawOfferAcceptDebug
// (Final, Exec, Native, Public)

void UPlayerInfoComponent::FlawOfferAcceptDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "FlawOfferAcceptDebug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInfoComponent.FlawOfferDebug
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           FlawName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoComponent::FlawOfferDebug(const class FString& FlawName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "FlawOfferDebug");

	Params::PlayerInfoComponent_FlawOfferDebug Parms{};

	Parms.FlawName = std::move(FlawName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInfoComponent.FlawOfferRejectDebug
// (Final, Exec, Native, Public)

void UPlayerInfoComponent::FlawOfferRejectDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "FlawOfferRejectDebug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInfoComponent.OnCombatStateChanged
// (Final, Native, Private)
// Parameters:
// bool                                    bInCombat                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoComponent::OnCombatStateChanged(bool bInCombat, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "OnCombatStateChanged");

	Params::PlayerInfoComponent_OnCombatStateChanged Parms{};

	Parms.bInCombat = bInCombat;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInfoComponent.PauseCurrentAudioLog
// (Final, Native, Public, BlueprintCallable)

void UPlayerInfoComponent::PauseCurrentAudioLog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "PauseCurrentAudioLog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInfoComponent.PlayAudioLog
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AudioLogIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoComponent::PlayAudioLog(int32 AudioLogIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "PlayAudioLog");

	Params::PlayerInfoComponent_PlayAudioLog Parms{};

	Parms.AudioLogIndex = AudioLogIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInfoComponent.QuestComplete
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           QuestName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoComponent::QuestComplete(const class FString& QuestName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "QuestComplete");

	Params::PlayerInfoComponent_QuestComplete Parms{};

	Parms.QuestName = std::move(QuestName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInfoComponent.QuestFail
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           QuestName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoComponent::QuestFail(const class FString& QuestName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "QuestFail");

	Params::PlayerInfoComponent_QuestFail Parms{};

	Parms.QuestName = std::move(QuestName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInfoComponent.QuestListAll
// (Final, Exec, Native, Public)

void UPlayerInfoComponent::QuestListAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "QuestListAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInfoComponent.QuestStart
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           QuestName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoComponent::QuestStart(const class FString& QuestName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "QuestStart");

	Params::PlayerInfoComponent_QuestStart Parms{};

	Parms.QuestName = std::move(QuestName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInfoComponent.QuestTriggerAddendum
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           QuestName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AddendumNode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoComponent::QuestTriggerAddendum(const class FString& QuestName, int32 AddendumNode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "QuestTriggerAddendum");

	Params::PlayerInfoComponent_QuestTriggerAddendum Parms{};

	Parms.QuestName = std::move(QuestName);
	Parms.AddendumNode = AddendumNode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInfoComponent.ResetFlawOfferTimer
// (Final, Exec, Native, Public, BlueprintCallable)

void UPlayerInfoComponent::ResetFlawOfferTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "ResetFlawOfferTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInfoComponent.ResetQuest
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           QuestName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ResetEventIDs                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UPlayerInfoComponent::ResetQuest(const class FString& QuestName, const TArray<int32>& ResetEventIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "ResetQuest");

	Params::PlayerInfoComponent_ResetQuest Parms{};

	Parms.QuestName = std::move(QuestName);
	Parms.ResetEventIDs = std::move(ResetEventIDs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInfoComponent.RespecPerks
// (Exec, Native, Public)
// Parameters:
// bool                                    bNoCost                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoComponent::RespecPerks(bool bNoCost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "RespecPerks");

	Params::PlayerInfoComponent_RespecPerks Parms{};

	Parms.bNoCost = bNoCost;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInfoComponent.RespecSkillPoints
// (Exec, Native, Public)

void UPlayerInfoComponent::RespecSkillPoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "RespecSkillPoints");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInfoComponent.ResumeCurrentAudioLog
// (Final, Native, Public, BlueprintCallable)

void UPlayerInfoComponent::ResumeCurrentAudioLog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "ResumeCurrentAudioLog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInfoComponent.SetAptitudeDebug
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           AptitudeName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoComponent::SetAptitudeDebug(const class FString& AptitudeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "SetAptitudeDebug");

	Params::PlayerInfoComponent_SetAptitudeDebug Parms{};

	Parms.AptitudeName = std::move(AptitudeName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInfoComponent.SetFlawAsOfferable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UFlaw>                Flaw                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OfferChance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreTimer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoComponent::SetFlawAsOfferable(TSubclassOf<class UFlaw> Flaw, float OfferChance, bool bIgnoreTimer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "SetFlawAsOfferable");

	Params::PlayerInfoComponent_SetFlawAsOfferable Parms{};

	Parms.Flaw = Flaw;
	Parms.OfferChance = OfferChance;
	Parms.bIgnoreTimer = bIgnoreTimer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInfoComponent.SetGenderDebug
// (Final, Exec, Native, Public)
// Parameters:
// EGender                                 GenderIn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoComponent::SetGenderDebug(EGender GenderIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "SetGenderDebug");

	Params::PlayerInfoComponent_SetGenderDebug Parms{};

	Parms.GenderIn = GenderIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInfoComponent.StopCurrentAudioLog
// (Final, Native, Public, BlueprintCallable)

void UPlayerInfoComponent::StopCurrentAudioLog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "StopCurrentAudioLog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInfoComponent.IsPlayingAudioLog
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerInfoComponent::IsPlayingAudioLog() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoComponent", "IsPlayingAudioLog");

	Params::PlayerInfoComponent_IsPlayingAudioLog Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.PlayerInteractionComponent.OnDiscrepencyAmplifierActivated
// (Final, Native, Protected)
// Parameters:
// bool                                    bActivated                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionComponent::OnDiscrepencyAmplifierActivated(bool bActivated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionComponent", "OnDiscrepencyAmplifierActivated");

	Params::PlayerInteractionComponent_OnDiscrepencyAmplifierActivated Parms{};

	Parms.bActivated = bActivated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInteractionComponent.OnHighlightModeChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionComponent::OnHighlightModeChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionComponent", "OnHighlightModeChanged");

	Params::PlayerInteractionComponent_OnHighlightModeChanged Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInteractionComponent.OnHUDVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionComponent::OnHUDVisibilityChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionComponent", "OnHUDVisibilityChanged");

	Params::PlayerInteractionComponent_OnHUDVisibilityChanged Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInventoryComponent.BreakDownItemDebug
// (Final, Exec, Native, Protected, HasOutParams)
// Parameters:
// class FName                             ItemName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFieldBreakdown                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInventoryComponent::BreakDownItemDebug(const class FName& ItemName, bool bFieldBreakdown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInventoryComponent", "BreakDownItemDebug");

	Params::PlayerInventoryComponent_BreakDownItemDebug Parms{};

	Parms.ItemName = ItemName;
	Parms.bFieldBreakdown = bFieldBreakdown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInventoryComponent.GiveTools
// (Final, Exec, Native, Protected)

void UPlayerInventoryComponent::GiveTools()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInventoryComponent", "GiveTools");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInventoryComponent.IgnoreEncumbrance
// (Final, Exec, Native, Protected)
// Parameters:
// bool                                    bIgnored                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInventoryComponent::IgnoreEncumbrance(bool bIgnored)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInventoryComponent", "IgnoreEncumbrance");

	Params::PlayerInventoryComponent_IgnoreEncumbrance Parms{};

	Parms.bIgnored = bIgnored;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInventoryComponent.OnCompanionRegistered
// (Final, Native, Protected)
// Parameters:
// class AIndianaAiCharacter*              Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAdded                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInventoryComponent::OnCompanionRegistered(class AIndianaAiCharacter* Character, bool bAdded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInventoryComponent", "OnCompanionRegistered");

	Params::PlayerInventoryComponent_OnCompanionRegistered Parms{};

	Parms.Character = Character;
	Parms.bAdded = bAdded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInventoryComponent.OnStatUpdated
// (Final, Native, Protected)
// Parameters:
// class URpgStat*                         Stat                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInventoryComponent::OnStatUpdated(const class URpgStat* Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInventoryComponent", "OnStatUpdated");

	Params::PlayerInventoryComponent_OnStatUpdated Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInventoryComponent.RepairItemDebug
// (Final, Exec, Native, Protected, HasOutParams)
// Parameters:
// class FName                             ItemName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFieldRepair                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInventoryComponent::RepairItemDebug(const class FName& ItemName, bool bFieldRepair)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInventoryComponent", "RepairItemDebug");

	Params::PlayerInventoryComponent_RepairItemDebug Parms{};

	Parms.ItemName = ItemName;
	Parms.bFieldRepair = bFieldRepair;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInventoryComponent.SetArmorHealthDebug
// (Final, Exec, Native, Protected)
// Parameters:
// float                                   Percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInventoryComponent::SetArmorHealthDebug(float Percent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInventoryComponent", "SetArmorHealthDebug");

	Params::PlayerInventoryComponent_SetArmorHealthDebug Parms{};

	Parms.Percent = Percent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInventoryComponent.SetHelmetHealthDebug
// (Final, Exec, Native, Protected)
// Parameters:
// float                                   Percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInventoryComponent::SetHelmetHealthDebug(float Percent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInventoryComponent", "SetHelmetHealthDebug");

	Params::PlayerInventoryComponent_SetHelmetHealthDebug Parms{};

	Parms.Percent = Percent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInventoryComponent.SetItemHealthDebug
// (Final, Exec, Native, Protected, HasOutParams)
// Parameters:
// class FName                             ItemName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInventoryComponent::SetItemHealthDebug(const class FName& ItemName, float Percent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInventoryComponent", "SetItemHealthDebug");

	Params::PlayerInventoryComponent_SetItemHealthDebug Parms{};

	Parms.ItemName = ItemName;
	Parms.Percent = Percent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInventoryComponent.SetWeaponHealthDebug
// (Final, Exec, Native, Protected)
// Parameters:
// float                                   Percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInventoryComponent::SetWeaponHealthDebug(float Percent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInventoryComponent", "SetWeaponHealthDebug");

	Params::PlayerInventoryComponent_SetWeaponHealthDebug Parms{};

	Parms.Percent = Percent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerInventoryComponent.VendorRepairItemDebug
// (Final, Exec, Native, Protected, HasOutParams)
// Parameters:
// class FName                             ItemName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInventoryComponent::VendorRepairItemDebug(const class FName& ItemName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInventoryComponent", "VendorRepairItemDebug");

	Params::PlayerInventoryComponent_VendorRepairItemDebug Parms{};

	Parms.ItemName = ItemName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerMovementComponent.AcrophobiaEnableDebug
// (Final, Exec, Native, Protected)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementComponent::AcrophobiaEnableDebug(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerMovementComponent", "AcrophobiaEnableDebug");

	Params::PlayerMovementComponent_AcrophobiaEnableDebug Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerMovementComponent.ControllerADSSensitivityUpdated
// (Final, Native, Private)
// Parameters:
// float                                   SensititivityIn                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementComponent::ControllerADSSensitivityUpdated(float SensititivityIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerMovementComponent", "ControllerADSSensitivityUpdated");

	Params::PlayerMovementComponent_ControllerADSSensitivityUpdated Parms{};

	Parms.SensititivityIn = SensititivityIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerMovementComponent.ControllerSensitivityUpdated
// (Final, Native, Private)
// Parameters:
// float                                   SensitivityIn                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementComponent::ControllerSensitivityUpdated(float SensitivityIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerMovementComponent", "ControllerSensitivityUpdated");

	Params::PlayerMovementComponent_ControllerSensitivityUpdated Parms{};

	Parms.SensitivityIn = SensitivityIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerMovementComponent.OnTakeFallingDamage
// (Final, Native, Protected)
// Parameters:
// float                                   FallingDamage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementComponent::OnTakeFallingDamage(float FallingDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerMovementComponent", "OnTakeFallingDamage");

	Params::PlayerMovementComponent_OnTakeFallingDamage Parms{};

	Parms.FallingDamage = FallingDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerMovementComponent.OnUnlockAbilityChanged
// (Final, Native, Protected)
// Parameters:
// EUnlockAbility                          Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementComponent::OnUnlockAbilityChanged(EUnlockAbility Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerMovementComponent", "OnUnlockAbilityChanged");

	Params::PlayerMovementComponent_OnUnlockAbilityChanged Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerShoutComponent.OnCombatStateChange
// (Final, Native, Private)
// Parameters:
// bool                                    bIsInCombat                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerShoutComponent::OnCombatStateChange(bool bIsInCombat, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerShoutComponent", "OnCombatStateChange");

	Params::PlayerShoutComponent_OnCombatStateChange Parms{};

	Parms.bIsInCombat = bIsInCombat;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerTargetingComponent.KillTarget
// (Final, Exec, Native, Public)

void UPlayerTargetingComponent::KillTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerTargetingComponent", "KillTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PlayerTargetingComponent.DrawPlayerTargetingTrace
// (Final, Exec, Native, Public, Const)
// Parameters:
// float                                   PersistTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerTargetingComponent::DrawPlayerTargetingTrace(float PersistTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerTargetingComponent", "DrawPlayerTargetingTrace");

	Params::PlayerTargetingComponent_DrawPlayerTargetingTrace Parms{};

	Parms.PersistTime = PersistTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PointOfNoReturnRollbackData.FixConversationsBP
// (Event, Public, BlueprintEvent)

void UPointOfNoReturnRollbackData::FixConversationsBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PointOfNoReturnRollbackData", "FixConversationsBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.PointOfNoReturnRollbackData.FixGlobalVarsBP
// (Event, Public, BlueprintEvent)

void UPointOfNoReturnRollbackData::FixGlobalVarsBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PointOfNoReturnRollbackData", "FixGlobalVarsBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.PointOfNoReturnRollbackData.FixItemsBP
// (Event, Public, BlueprintEvent)

void UPointOfNoReturnRollbackData::FixItemsBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PointOfNoReturnRollbackData", "FixItemsBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.PointOfNoReturnRollbackData.FixQuestsBP
// (Event, Public, BlueprintEvent)

void UPointOfNoReturnRollbackData::FixQuestsBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PointOfNoReturnRollbackData", "FixQuestsBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.PreviewCharacterAnimInstance.SetSelectionState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EUISelectionState                       InSelectionState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPreviewCharacterAnimInstance::SetSelectionState(EUISelectionState InSelectionState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreviewCharacterAnimInstance", "SetSelectionState");

	Params::PreviewCharacterAnimInstance_SetSelectionState Parms{};

	Parms.InSelectionState = InSelectionState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SliderBase.ModifySliderValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USliderBase::ModifySliderValue(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SliderBase", "ModifySliderValue");

	Params::SliderBase_ModifySliderValue Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SliderBase.SetAndCommitValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USliderBase::SetAndCommitValue(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SliderBase", "SetAndCommitValue");

	Params::SliderBase_SetAndCommitValue Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SliderBase.SetIndentHandle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USliderBase::SetIndentHandle(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SliderBase", "SetIndentHandle");

	Params::SliderBase_SetIndentHandle Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SliderBase.SetLocked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USliderBase::SetLocked(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SliderBase", "SetLocked");

	Params::SliderBase_SetLocked Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SliderBase.SetStepSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USliderBase::SetStepSize(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SliderBase", "SetStepSize");

	Params::SliderBase_SetStepSize Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SliderBase.SetValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USliderBase::SetValue(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SliderBase", "SetValue");

	Params::SliderBase_SetValue Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SliderBase.GetValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USliderBase::GetValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SliderBase", "GetValue");

	Params::SliderBase_GetValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Projectile.OnBounce
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// struct FHitResult                       ImpactResult                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ImpactVelocity                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectile::OnBounce(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile", "OnBounce");

	Params::Projectile_OnBounce Parms{};

	Parms.ImpactResult = std::move(ImpactResult);
	Parms.ImpactVelocity = std::move(ImpactVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Projectile.OnDamageBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AProjectile::OnDamageBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile", "OnDamageBeginOverlap");

	Params::Projectile_OnDamageBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Projectile.OnDamageEndOverlap
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectile::OnDamageEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile", "OnDamageEndOverlap");

	Params::Projectile_OnDamageEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Projectile.OnHit
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComp                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AProjectile::OnHit(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile", "OnHit");

	Params::Projectile_OnHit Parms{};

	Parms.HitComp = HitComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Projectile.GetChargeAmount
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AProjectile::GetChargeAmount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile", "GetChargeAmount");

	Params::Projectile_GetChargeAmount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Projectile.GetCollisionSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AProjectile::GetCollisionSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile", "GetCollisionSize");

	Params::Projectile_GetCollisionSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Projectile.GetOverlapCollisionSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AProjectile::GetOverlapCollisionSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile", "GetOverlapCollisionSize");

	Params::Projectile_GetOverlapCollisionSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.PS5ActivityManager.OnLoadComplete
// (Final, Native, Protected)
// Parameters:
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELoadGameResult                         Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPS5ActivityManager::OnLoadComplete(const class FString& Filename, ELoadGameResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5ActivityManager", "OnLoadComplete");

	Params::PS5ActivityManager_OnLoadComplete Parms{};

	Parms.Filename = std::move(Filename);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PS5ActivityManager.OnPreLoadMap
// (Final, Native, Protected)
// Parameters:
// class FString                           MapName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPS5ActivityManager::OnPreLoadMap(const class FString& MapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5ActivityManager", "OnPreLoadMap");

	Params::PS5ActivityManager_OnPreLoadMap Parms{};

	Parms.MapName = std::move(MapName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.PS5ActivityManager.OnQueryLatestSaveFinished
// (Final, Native, Protected)
// Parameters:
// class FString                           LatestSaveName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHasSaves                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPS5ActivityManager::OnQueryLatestSaveFinished(const class FString& LatestSaveName, bool bHasSaves)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5ActivityManager", "OnQueryLatestSaveFinished");

	Params::PS5ActivityManager_OnQueryLatestSaveFinished Parms{};

	Parms.LatestSaveName = std::move(LatestSaveName);
	Parms.bHasSaves = bHasSaves;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.QuestListEntryWidget.SetActiveQuest
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestListEntryWidget::SetActiveQuest(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestListEntryWidget", "SetActiveQuest");

	Params::QuestListEntryWidget_SetActiveQuest Parms{};

	Parms.bActive = bActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.QuestListEntryWidget.SetQuestCompletionStatus
// (Event, Protected, BlueprintEvent)
// Parameters:
// EQuestState                             QuestState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestListEntryWidget::SetQuestCompletionStatus(EQuestState QuestState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestListEntryWidget", "SetQuestCompletionStatus");

	Params::QuestListEntryWidget_SetQuestCompletionStatus Parms{};

	Parms.QuestState = QuestState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.QuestLogComboBoxWidget.OnSortOptionIncrement
// (Final, Native, Public)

void UQuestLogComboBoxWidget::OnSortOptionIncrement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestLogComboBoxWidget", "OnSortOptionIncrement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.QuestLogComboBoxWidget.OnValueChanged
// (Final, Native, Protected)
// Parameters:
// class FString                           SelectedItem                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESelectInfo                             SelectionType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestLogComboBoxWidget::OnValueChanged(const class FString& SelectedItem, ESelectInfo SelectionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestLogComboBoxWidget", "OnValueChanged");

	Params::QuestLogComboBoxWidget_OnValueChanged Parms{};

	Parms.SelectedItem = std::move(SelectedItem);
	Parms.SelectionType = SelectionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.QuestLogEntryWidget.FadeInQuestText
// (Event, Protected, BlueprintEvent)

void UQuestLogEntryWidget::FadeInQuestText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestLogEntryWidget", "FadeInQuestText");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.QuestLogEntryWidget.FadeOutQuestText
// (Event, Protected, BlueprintEvent)

void UQuestLogEntryWidget::FadeOutQuestText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestLogEntryWidget", "FadeOutQuestText");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.QuestLogEntryWidget.OnQuestAnimationFinishedComplete
// (Final, Native, Protected, BlueprintCallable)

void UQuestLogEntryWidget::OnQuestAnimationFinishedComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestLogEntryWidget", "OnQuestAnimationFinishedComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.QuestLogEntryWidget.OnQuestAnimationStartOrUpdateComplete
// (Final, Native, Protected, BlueprintCallable)

void UQuestLogEntryWidget::OnQuestAnimationStartOrUpdateComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestLogEntryWidget", "OnQuestAnimationStartOrUpdateComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.QuestLogEntryWidget.OnQuestCompleted
// (Event, Protected, BlueprintEvent)

void UQuestLogEntryWidget::OnQuestCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestLogEntryWidget", "OnQuestCompleted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.QuestLogEntryWidget.OnQuestFailed
// (Event, Protected, BlueprintEvent)

void UQuestLogEntryWidget::OnQuestFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestLogEntryWidget", "OnQuestFailed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.QuestLogEntryWidget.OnQuestTextFadeInComplete
// (Final, Native, Protected, BlueprintCallable)

void UQuestLogEntryWidget::OnQuestTextFadeInComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestLogEntryWidget", "OnQuestTextFadeInComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.QuestLogEntryWidget.OnQuestTextFadeOutComplete
// (Final, Native, Protected, BlueprintCallable)

void UQuestLogEntryWidget::OnQuestTextFadeOutComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestLogEntryWidget", "OnQuestTextFadeOutComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.QuestLogEntryWidget.OnQuestUpdated
// (Event, Protected, BlueprintEvent)

void UQuestLogEntryWidget::OnQuestUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestLogEntryWidget", "OnQuestUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.QuestLogWidget.FadeInContents
// (Event, Protected, BlueprintEvent)

void UQuestLogWidget::FadeInContents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestLogWidget", "FadeInContents");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.QuestLogWidget.FadeOutContents
// (Event, Protected, BlueprintEvent)

void UQuestLogWidget::FadeOutContents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestLogWidget", "FadeOutContents");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.QuestLogWidget.OnFadeInComplete
// (Final, Native, Protected, BlueprintCallable)

void UQuestLogWidget::OnFadeInComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestLogWidget", "OnFadeInComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.QuestLogWidget.OnFadeOutComplete
// (Final, Native, Protected, BlueprintCallable)

void UQuestLogWidget::OnFadeOutComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestLogWidget", "OnFadeOutComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.QuestLogWidget.OnHUDVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisibleIn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestLogWidget::OnHUDVisibilityChanged(bool bVisibleIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestLogWidget", "OnHUDVisibilityChanged");

	Params::QuestLogWidget_OnHUDVisibilityChanged Parms{};

	Parms.bVisibleIn = bVisibleIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.QuestLogWidget.OnQuestUpdateModeChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestLogWidget::OnQuestUpdateModeChanged(int32 ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestLogWidget", "OnQuestUpdateModeChanged");

	Params::QuestLogWidget_OnQuestUpdateModeChanged Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SubtitlesWidget.OnBarkSubtitleVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USubtitlesWidget::OnBarkSubtitleVisibilityChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitlesWidget", "OnBarkSubtitleVisibilityChanged");

	Params::SubtitlesWidget_OnBarkSubtitleVisibilityChanged Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SubtitlesWidget.SetSizeBoxRatio
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   HorizontalRatio                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VerticalRatio                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USubtitlesWidget::SetSizeBoxRatio(float HorizontalRatio, float VerticalRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitlesWidget", "SetSizeBoxRatio");

	Params::SubtitlesWidget_SetSizeBoxRatio Parms{};

	Parms.HorizontalRatio = HorizontalRatio;
	Parms.VerticalRatio = VerticalRatio;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.QuestObjectiveEntryWidget.OnIntroComplete
// (Final, Native, Protected, BlueprintCallable)

void UQuestObjectiveEntryWidget::OnIntroComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestObjectiveEntryWidget", "OnIntroComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.QuestObjectiveEntryWidget.OnObjectiveMadeActive
// (Event, Protected, BlueprintEvent)

void UQuestObjectiveEntryWidget::OnObjectiveMadeActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestObjectiveEntryWidget", "OnObjectiveMadeActive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.QuestObjectiveEntryWidget.OnObjectiveMadeInactive
// (Event, Protected, BlueprintEvent)

void UQuestObjectiveEntryWidget::OnObjectiveMadeInactive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestObjectiveEntryWidget", "OnObjectiveMadeInactive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.QuestObjectiveEntryWidget.OnObjectiveUpdateAnimComplete
// (Final, Native, Protected, BlueprintCallable)

void UQuestObjectiveEntryWidget::OnObjectiveUpdateAnimComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestObjectiveEntryWidget", "OnObjectiveUpdateAnimComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.QuestObjectiveEntryWidget.OnOutroComplete
// (Final, Native, Protected, BlueprintCallable)

void UQuestObjectiveEntryWidget::OnOutroComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestObjectiveEntryWidget", "OnOutroComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.QuestObjectiveEntryWidget.StartCompleteAnim
// (Event, Protected, BlueprintEvent)

void UQuestObjectiveEntryWidget::StartCompleteAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestObjectiveEntryWidget", "StartCompleteAnim");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.QuestObjectiveEntryWidget.StartFailAnim
// (Event, Protected, BlueprintEvent)

void UQuestObjectiveEntryWidget::StartFailAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestObjectiveEntryWidget", "StartFailAnim");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.QuestObjectiveTitleWidget.OnObjectiveStatusChange
// (Event, Protected, BlueprintEvent)
// Parameters:
// ECompletionStatus                       ObjectiveStatus                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestObjectiveTitleWidget::OnObjectiveStatusChange(ECompletionStatus ObjectiveStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestObjectiveTitleWidget", "OnObjectiveStatusChange");

	Params::QuestObjectiveTitleWidget_OnObjectiveStatusChange Parms{};

	Parms.ObjectiveStatus = ObjectiveStatus;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.SurvivalBarGroupWidget.OnDifficultyChanged
// (Final, Native, Protected)
// Parameters:
// EGameDifficulty                         NewDifficulty                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivalBarGroupWidget::OnDifficultyChanged(EGameDifficulty NewDifficulty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivalBarGroupWidget", "OnDifficultyChanged");

	Params::SurvivalBarGroupWidget_OnDifficultyChanged Parms{};

	Parms.NewDifficulty = NewDifficulty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SurvivalBarGroupWidget.OnSubSurvivalBarUpdated
// (Final, Native, Protected)

void USurvivalBarGroupWidget::OnSubSurvivalBarUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivalBarGroupWidget", "OnSubSurvivalBarUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Switch.CycleNextState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Initiator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASwitch::CycleNextState(class AActor* Initiator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Switch", "CycleNextState");

	Params::Switch_CycleNextState Parms{};

	Parms.Initiator = Initiator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Switch.SetCurrentState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Initiator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASwitch::SetCurrentState(int32 NewState, class AActor* Initiator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Switch", "SetCurrentState");

	Params::Switch_SetCurrentState Parms{};

	Parms.NewState = NewState;
	Parms.Initiator = Initiator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Switch.GetCurrentState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ASwitch::GetCurrentState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Switch", "GetCurrentState");

	Params::Switch_GetCurrentState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.RadialWidget.OnRadialScroll
// (Final, Native, Protected)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URadialWidget::OnRadialScroll(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadialWidget", "OnRadialScroll");

	Params::RadialWidget_OnRadialScroll Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.RadialWidget.OnSectionConfirmed
// (Final, Native, Protected)

void URadialWidget::OnSectionConfirmed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadialWidget", "OnSectionConfirmed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.RadialWidget.OnSectionConfirmedAux
// (Final, Native, Protected)

void URadialWidget::OnSectionConfirmedAux()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RadialWidget", "OnSectionConfirmedAux");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ReputationSummaryWidget.InitReputationBackgroundOnMaximize
// (Final, Native, Public)

void UReputationSummaryWidget::InitReputationBackgroundOnMaximize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReputationSummaryWidget", "InitReputationBackgroundOnMaximize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ReputationSummaryWidget.OnFactionReputationChanged
// (Final, Native, Protected)
// Parameters:
// class UFactionData*                     FactionData                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EReputationType                         ReputationType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UReputationData*                  ReputationBefore                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UReputationData*                  ReputationAfter                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UReputationSummaryWidget::OnFactionReputationChanged(const class UFactionData* FactionData, EReputationType ReputationType, int32 Amount, const class UReputationData* ReputationBefore, const class UReputationData* ReputationAfter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReputationSummaryWidget", "OnFactionReputationChanged");

	Params::ReputationSummaryWidget_OnFactionReputationChanged Parms{};

	Parms.FactionData = FactionData;
	Parms.ReputationType = ReputationType;
	Parms.Amount = Amount;
	Parms.ReputationBefore = ReputationBefore;
	Parms.ReputationAfter = ReputationAfter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ReputationSummaryWidget.RemoveReputationBackgroundOnMinimize
// (Final, Native, Public)

void UReputationSummaryWidget::RemoveReputationBackgroundOnMinimize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReputationSummaryWidget", "RemoveReputationBackgroundOnMinimize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusEffectBarWidget.OnStatusEffectAdded
// (Final, Native, Protected)
// Parameters:
// class UStatusEffectManagerComponent*    Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffect*                    StatusEffect                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffectBarWidget::OnStatusEffectAdded(class UStatusEffectManagerComponent* Sender, class UStatusEffect* StatusEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectBarWidget", "OnStatusEffectAdded");

	Params::StatusEffectBarWidget_OnStatusEffectAdded Parms{};

	Parms.Sender = Sender;
	Parms.StatusEffect = StatusEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusEffectBarWidget.OnStatusEffectRemoved
// (Final, Native, Protected)
// Parameters:
// class UStatusEffectManagerComponent*    Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffect*                    StatusEffect                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffectBarWidget::OnStatusEffectRemoved(class UStatusEffectManagerComponent* Sender, class UStatusEffect* StatusEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectBarWidget", "OnStatusEffectRemoved");

	Params::StatusEffectBarWidget_OnStatusEffectRemoved Parms{};

	Parms.Sender = Sender;
	Parms.StatusEffect = StatusEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ReticleWidget.ExpandTTDRotator
// (Event, Protected, BlueprintEvent)

void UReticleWidget::ExpandTTDRotator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReticleWidget", "ExpandTTDRotator");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.ReticleWidget.OnCombatStateChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bCombatIn                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UReticleWidget::OnCombatStateChanged(bool bCombatIn, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReticleWidget", "OnCombatStateChanged");

	Params::ReticleWidget_OnCombatStateChanged Parms{};

	Parms.bCombatIn = bCombatIn;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ReticleWidget.OnHUDVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UReticleWidget::OnHUDVisibilityChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReticleWidget", "OnHUDVisibilityChanged");

	Params::ReticleWidget_OnHUDVisibilityChanged Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ReticleWidget.OnReticleModeChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   ModeIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UReticleWidget::OnReticleModeChanged(int32 ModeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReticleWidget", "OnReticleModeChanged");

	Params::ReticleWidget_OnReticleModeChanged Parms{};

	Parms.ModeIn = ModeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ReticleWidget.OnTTDReticleMeterModeChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UReticleWidget::OnTTDReticleMeterModeChanged(int32 bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReticleWidget", "OnTTDReticleMeterModeChanged");

	Params::ReticleWidget_OnTTDReticleMeterModeChanged Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ReticleWidget.OnTTDTargetAcquired
// (Final, Native, Protected)

void UReticleWidget::OnTTDTargetAcquired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReticleWidget", "OnTTDTargetAcquired");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ReticleWidget.OnTTDTargetLost
// (Final, Native, Protected)

void UReticleWidget::OnTTDTargetLost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReticleWidget", "OnTTDTargetLost");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.ReticleWidget.SetTTDProgressRatio
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   NewTTDRatio                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UReticleWidget::SetTTDProgressRatio(float NewTTDRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReticleWidget", "SetTTDProgressRatio");

	Params::ReticleWidget_SetTTDProgressRatio Parms{};

	Parms.NewTTDRatio = NewTTDRatio;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.ReticleWidget.ShrinkTTDRotator
// (Event, Protected, BlueprintEvent)

void UReticleWidget::ShrinkTTDRotator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReticleWidget", "ShrinkTTDRotator");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.RpgStatComponent.OnCollectionStatUpdated
// (Final, Native, Protected)
// Parameters:
// class URpgStat*                         Stat                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URpgStatComponent::OnCollectionStatUpdated(const class URpgStat* Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RpgStatComponent", "OnCollectionStatUpdated");

	Params::RpgStatComponent_OnCollectionStatUpdated Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.RpgStatComponent.RemoveModifier
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          SourceObject                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SourceId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FStatModifierDescription         StatModifier                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URpgStatComponent::RemoveModifier(const class UObject* SourceObject, int32 SourceId, const struct FStatModifierDescription& StatModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RpgStatComponent", "RemoveModifier");

	Params::RpgStatComponent_RemoveModifier Parms{};

	Parms.SourceObject = SourceObject;
	Parms.SourceId = SourceId;
	Parms.StatModifier = std::move(StatModifier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.RpgStatComponent.RpgStatAddModifierDebug
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             Stat                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URpgStatComponent::RpgStatAddModifierDebug(const class FName& Stat, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RpgStatComponent", "RpgStatAddModifierDebug");

	Params::RpgStatComponent_RpgStatAddModifierDebug Parms{};

	Parms.Stat = Stat;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.RpgStatComponent.RpgStatRemoveModifierDebug
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             Stat                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URpgStatComponent::RpgStatRemoveModifierDebug(const class FName& Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RpgStatComponent", "RpgStatRemoveModifierDebug");

	Params::RpgStatComponent_RpgStatRemoveModifierDebug Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.RpgStatComponent.SetModifier
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          SourceObject                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SourceId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FStatModifierDescription         StatModifier                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void URpgStatComponent::SetModifier(const class UObject* SourceObject, int32 SourceId, const struct FStatModifierDescription& StatModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RpgStatComponent", "SetModifier");

	Params::RpgStatComponent_SetModifier Parms{};

	Parms.SourceObject = SourceObject;
	Parms.SourceId = SourceId;
	Parms.StatModifier = std::move(StatModifier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.RpgStatComponent.GetValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URpgStat*                         Stat                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERpgStatGroupMask                       StatGroupMask                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InputValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URpgStatComponent::GetValue(const class URpgStat* Stat, ERpgStatGroupMask StatGroupMask, float InputValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RpgStatComponent", "GetValue");

	Params::RpgStatComponent_GetValue Parms{};

	Parms.Stat = Stat;
	Parms.StatGroupMask = StatGroupMask;
	Parms.InputValue = InputValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.RpgStatComponent.RpgStatShowAll
// (Final, Exec, Native, Public, Const)

void URpgStatComponent::RpgStatShowAll() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RpgStatComponent", "RpgStatShowAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.RpgStatComponent.RpgStatShowStat
// (Final, Exec, Native, Public, Const)
// Parameters:
// class FString                           Stat                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URpgStatComponent::RpgStatShowStat(const class FString& Stat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RpgStatComponent", "RpgStatShowStat");

	Params::RpgStatComponent_RpgStatShowStat Parms{};

	Parms.Stat = std::move(Stat);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SaveGameManager.DisableSaves
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bDisable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveGameManager::DisableSaves(bool bDisable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SaveGameManager", "DisableSaves");

	Params::SaveGameManager_DisableSaves Parms{};

	Parms.bDisable = bDisable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SaveGameManager.RequestAutosave
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bAllowOnSuperNova                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveGameManager::RequestAutosave(bool bAllowOnSuperNova)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SaveGameManager", "RequestAutosave");

	Params::SaveGameManager_RequestAutosave Parms{};

	Parms.bAllowOnSuperNova = bAllowOnSuperNova;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SaveGameManager.RequestBeforeEVTransitionSave
// (Final, Native, Static, Public, BlueprintCallable)

void USaveGameManager::RequestBeforeEVTransitionSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SaveGameManager", "RequestBeforeEVTransitionSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SaveGameManager.RequestBeforeSkipSave
// (Final, Native, Static, Public, BlueprintCallable)

void USaveGameManager::RequestBeforeSkipSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SaveGameManager", "RequestBeforeSkipSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SaveGameManager.RequestPointOfNoReturnRollbackSave
// (Final, Native, Static, Public, BlueprintCallable)

void USaveGameManager::RequestPointOfNoReturnRollbackSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SaveGameManager", "RequestPointOfNoReturnRollbackSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SaveGameManager.RequestPointOfNoReturnSave
// (Final, Native, Static, Public, BlueprintCallable)

void USaveGameManager::RequestPointOfNoReturnSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SaveGameManager", "RequestPointOfNoReturnSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SaveGameManager.RequestPostGameSave
// (Final, Native, Static, Public, BlueprintCallable)

void USaveGameManager::RequestPostGameSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SaveGameManager", "RequestPostGameSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SaveGameManager.Autosave
// (Final, Exec, Native, Public)
// Parameters:
// EAutoSaveType                           AutoSaveType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSuperNova                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveGameManager::Autosave(EAutoSaveType AutoSaveType, bool bIgnoreSuperNova)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveGameManager", "Autosave");

	Params::SaveGameManager_Autosave Parms{};

	Parms.AutoSaveType = AutoSaveType;
	Parms.bIgnoreSuperNova = bIgnoreSuperNova;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.SaveGameManager.BeforeEVTransitionSave
// (Final, Exec, Native, Public)

void USaveGameManager::BeforeEVTransitionSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveGameManager", "BeforeEVTransitionSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SaveGameManager.CheckCanSaveGame
// (Final, Exec, Native, Public)

void USaveGameManager::CheckCanSaveGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveGameManager", "CheckCanSaveGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SaveGameManager.DeleteGame
// (Exec, Native, Public)
// Parameters:
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDeleteGameResult                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDeleteGameResult USaveGameManager::DeleteGame(const class FString& Filename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveGameManager", "DeleteGame");

	Params::SaveGameManager_DeleteGame Parms{};

	Parms.Filename = std::move(Filename);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.SaveGameManager.EnsureSignIn
// (Exec, Native, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveGameManager::EnsureSignIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveGameManager", "EnsureSignIn");

	Params::SaveGameManager_EnsureSignIn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.SaveGameManager.LoadGame
// (Exec, Native, Public)
// Parameters:
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPreValidateMetadata                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELoadGameResult                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELoadGameResult USaveGameManager::LoadGame(const class FString& Filename, bool bPreValidateMetadata)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveGameManager", "LoadGame");

	Params::SaveGameManager_LoadGame Parms{};

	Parms.Filename = std::move(Filename);
	Parms.bPreValidateMetadata = bPreValidateMetadata;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.SaveGameManager.LoadUserGameSettings
// (Final, Exec, Native, Public)

void USaveGameManager::LoadUserGameSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveGameManager", "LoadUserGameSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SaveGameManager.OnActorDestroyed
// (Final, Native, Public)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveGameManager::OnActorDestroyed(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveGameManager", "OnActorDestroyed");

	Params::SaveGameManager_OnActorDestroyed Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SaveGameManager.OnPromptedSaveSaveMenuClosed
// (Final, Native, Protected)
// Parameters:
// bool                                    bForced                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveGameManager::OnPromptedSaveSaveMenuClosed(bool bForced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveGameManager", "OnPromptedSaveSaveMenuClosed");

	Params::SaveGameManager_OnPromptedSaveSaveMenuClosed Parms{};

	Parms.bForced = bForced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SaveGameManager.PointOfNoReturnRollbackSave
// (Final, Exec, Native, Public)

void USaveGameManager::PointOfNoReturnRollbackSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveGameManager", "PointOfNoReturnRollbackSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SaveGameManager.PointOfNoReturnSave
// (Final, Exec, Native, Public)

void USaveGameManager::PointOfNoReturnSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveGameManager", "PointOfNoReturnSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SaveGameManager.Quickload
// (Exec, Native, Public)
// Parameters:
// ELoadGameResult                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELoadGameResult USaveGameManager::Quickload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveGameManager", "Quickload");

	Params::SaveGameManager_Quickload Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.SaveGameManager.Quicksave
// (Exec, Native, Public)
// Parameters:
// ESaveGameResult                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESaveGameResult USaveGameManager::Quicksave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveGameManager", "Quicksave");

	Params::SaveGameManager_Quicksave Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.SaveGameManager.SaveGame
// (Exec, Native, Public)
// Parameters:
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSuperNova                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESaveGameType                           SaveGameType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESaveGameResult                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESaveGameResult USaveGameManager::SaveGame(const class FString& Filename, bool bIgnoreSuperNova, ESaveGameType SaveGameType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveGameManager", "SaveGame");

	Params::SaveGameManager_SaveGame Parms{};

	Parms.Filename = std::move(Filename);
	Parms.bIgnoreSuperNova = bIgnoreSuperNova;
	Parms.SaveGameType = SaveGameType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.SaveGameManager.SaveUserGameSettings
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bSettingsPotentiallyChanged                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveGameManager::SaveUserGameSettings(bool bSettingsPotentiallyChanged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveGameManager", "SaveUserGameSettings");

	Params::SaveGameManager_SaveUserGameSettings Parms{};

	Parms.bSettingsPotentiallyChanged = bSettingsPotentiallyChanged;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SaveLoadMenuWidget.DeleteSave
// (Final, Native, Protected)

void USaveLoadMenuWidget::DeleteSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveLoadMenuWidget", "DeleteSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SaveLoadMenuWidget.OnActiveUserChanged
// (Final, Native, Protected)
// Parameters:
// EActiveUserChangeType                   ChangeType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveLoadMenuWidget::OnActiveUserChanged(EActiveUserChangeType ChangeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveLoadMenuWidget", "OnActiveUserChanged");

	Params::SaveLoadMenuWidget_OnActiveUserChanged Parms{};

	Parms.ChangeType = ChangeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SaveLoadMenuWidget.OnExitInterface
// (Final, Native, Protected)

void USaveLoadMenuWidget::OnExitInterface()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveLoadMenuWidget", "OnExitInterface");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SaveLoadMenuWidget.OnLoadComplete
// (Final, Native, Protected)
// Parameters:
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELoadGameResult                         Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveLoadMenuWidget::OnLoadComplete(const class FString& Filename, ELoadGameResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveLoadMenuWidget", "OnLoadComplete");

	Params::SaveLoadMenuWidget_OnLoadComplete Parms{};

	Parms.Filename = std::move(Filename);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SaveLoadMenuWidget.OnPS4LoadInturrupted
// (Final, Native, Protected)
// Parameters:
// class FString                           SaveName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveLoadMenuWidget::OnPS4LoadInturrupted(const class FString& SaveName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveLoadMenuWidget", "OnPS4LoadInturrupted");

	Params::SaveLoadMenuWidget_OnPS4LoadInturrupted Parms{};

	Parms.SaveName = std::move(SaveName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SaveLoadMenuWidget.OnSaveDataRequestFinished
// (Final, Native, Protected)

void USaveLoadMenuWidget::OnSaveDataRequestFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveLoadMenuWidget", "OnSaveDataRequestFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TrapTrigger.ArmTrapTrigger
// (Final, Native, Public, BlueprintCallable)

void ATrapTrigger::ArmTrapTrigger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrapTrigger", "ArmTrapTrigger");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TrapTrigger.ChangeState
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// ETrapTriggerState                       State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATrapTrigger::ChangeState(ETrapTriggerState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrapTrigger", "ChangeState");

	Params::TrapTrigger_ChangeState Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TrapTrigger.DisarmTrapTrigger
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAlertEffectSources                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATrapTrigger::DisarmTrapTrigger(bool bAlertEffectSources)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrapTrigger", "DisarmTrapTrigger");

	Params::TrapTrigger_DisarmTrapTrigger Parms{};

	Parms.bAlertEffectSources = bAlertEffectSources;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TrapTrigger.OnActivationShapeBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ATrapTrigger::OnActivationShapeBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrapTrigger", "OnActivationShapeBeginOverlap");

	Params::TrapTrigger_OnActivationShapeBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TrapTrigger.OnActivationShapeEndOverlap
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATrapTrigger::OnActivationShapeEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrapTrigger", "OnActivationShapeEndOverlap");

	Params::TrapTrigger_OnActivationShapeEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TrapTrigger.OnActivatorTrackingShapeBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ATrapTrigger::OnActivatorTrackingShapeBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrapTrigger", "OnActivatorTrackingShapeBeginOverlap");

	Params::TrapTrigger_OnActivatorTrackingShapeBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TrapTrigger.OnActivatorTrackingShapeEndOverlap
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATrapTrigger::OnActivatorTrackingShapeEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrapTrigger", "OnActivatorTrackingShapeEndOverlap");

	Params::TrapTrigger_OnActivatorTrackingShapeEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TrapTrigger.GetCurrentState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETrapTriggerState                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETrapTriggerState ATrapTrigger::GetCurrentState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrapTrigger", "GetCurrentState");

	Params::TrapTrigger_GetCurrentState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.TrapTrigger.IsDeploymentPending
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATrapTrigger::IsDeploymentPending() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrapTrigger", "IsDeploymentPending");

	Params::TrapTrigger_IsDeploymentPending Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.TrapTrigger.IsRearming
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATrapTrigger::IsRearming() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrapTrigger", "IsRearming");

	Params::TrapTrigger_IsRearming Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.TTDStatusEffectsWidget.OnStatusEffectAdded
// (Final, Native, Protected)
// Parameters:
// class UStatusEffectManagerComponent*    Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffect*                    StatusEffect                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTTDStatusEffectsWidget::OnStatusEffectAdded(class UStatusEffectManagerComponent* Sender, class UStatusEffect* StatusEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TTDStatusEffectsWidget", "OnStatusEffectAdded");

	Params::TTDStatusEffectsWidget_OnStatusEffectAdded Parms{};

	Parms.Sender = Sender;
	Parms.StatusEffect = StatusEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TTDStatusEffectsWidget.OnStatusEffectRemoved
// (Final, Native, Protected)
// Parameters:
// class UStatusEffectManagerComponent*    Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffect*                    StatusEffect                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTTDStatusEffectsWidget::OnStatusEffectRemoved(class UStatusEffectManagerComponent* Sender, class UStatusEffect* StatusEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TTDStatusEffectsWidget", "OnStatusEffectRemoved");

	Params::TTDStatusEffectsWidget_OnStatusEffectRemoved Parms{};

	Parms.Sender = Sender;
	Parms.StatusEffect = StatusEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.AchievementCompleted
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FName                             AchievementName                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::AchievementCompleted(const class FName& AchievementName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "AchievementCompleted");

	Params::Scripts_AchievementCompleted Parms{};

	Parms.AchievementName = AchievementName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.AchievementGameOver
// (Final, Native, Static, Public)

void UScripts::AchievementGameOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "AchievementGameOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.AchievementIncrement
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FName                             AchievementName                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::AchievementIncrement(const class FName& AchievementName, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "AchievementIncrement");

	Params::Scripts_AchievementIncrement Parms{};

	Parms.AchievementName = AchievementName;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.AddAudioLog
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           audiolog                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayOnPickup                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::AddAudioLog(const class FString& audiolog, bool bPlayOnPickup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "AddAudioLog");

	Params::Scripts_AddAudioLog Parms{};

	Parms.audiolog = std::move(audiolog);
	Parms.bPlayOnPickup = bPlayOnPickup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.AddAudioLogBP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAudioLogDataAsset*               audiolog                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayOnPickup                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::AddAudioLogBP(class UAudioLogDataAsset* audiolog, bool bPlayOnPickup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "AddAudioLogBP");

	Params::Scripts_AddAudioLogBP Parms{};

	Parms.audiolog = audiolog;
	Parms.bPlayOnPickup = bPlayOnPickup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.AddCompanionToParty
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            CompanionID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::AddCompanionToParty(const struct FGuid& CompanionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "AddCompanionToParty");

	Params::Scripts_AddCompanionToParty Parms{};

	Parms.CompanionID = std::move(CompanionID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.AdjustCompanionMoral
// (Final, Native, Static, Public)
// Parameters:
// ESpecialObsidianID                      CompanionID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPositiveMoralAdjustment                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMoraleContribution                     Contribution                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CustomAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlyActivePartyMembers                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::AdjustCompanionMoral(ESpecialObsidianID CompanionID, bool bPositiveMoralAdjustment, EMoraleContribution Contribution, float CustomAmount, bool bOnlyActivePartyMembers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "AdjustCompanionMoral");

	Params::Scripts_AdjustCompanionMoral Parms{};

	Parms.CompanionID = CompanionID;
	Parms.bPositiveMoralAdjustment = bPositiveMoralAdjustment;
	Parms.Contribution = Contribution;
	Parms.CustomAmount = CustomAmount;
	Parms.bOnlyActivePartyMembers = bOnlyActivePartyMembers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.AdjustFactionReputation
// (Final, Native, Static, Public)
// Parameters:
// class FString                           Faction                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EReputationType                         ReputationType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EReputationIncrementType                IncrementType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CustomAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::AdjustFactionReputation(const class FString& Faction, EReputationType ReputationType, EReputationIncrementType IncrementType, int32 CustomAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "AdjustFactionReputation");

	Params::Scripts_AdjustFactionReputation Parms{};

	Parms.Faction = std::move(Faction);
	Parms.ReputationType = ReputationType;
	Parms.IncrementType = IncrementType;
	Parms.CustomAmount = CustomAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.AdvanceDays
// (Final, Native, Static, Public)
// Parameters:
// float                                   Days                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::AdvanceDays(float Days)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "AdvanceDays");

	Params::Scripts_AdvanceDays Parms{};

	Parms.Days = Days;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.AdvanceHours
// (Final, Native, Static, Public)
// Parameters:
// float                                   Hours                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::AdvanceHours(float Hours)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "AdvanceHours");

	Params::Scripts_AdvanceHours Parms{};

	Parms.Hours = Hours;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.AdvanceMinutes
// (Final, Native, Static, Public)
// Parameters:
// float                                   Minutes                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::AdvanceMinutes(float Minutes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "AdvanceMinutes");

	Params::Scripts_AdvanceMinutes Parms{};

	Parms.Minutes = Minutes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.AdvanceQuest
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::AdvanceQuest(const struct FGuid& QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "AdvanceQuest");

	Params::Scripts_AdvanceQuest Parms{};

	Parms.QuestID = std::move(QuestID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.AdvanceSeconds
// (Final, Native, Static, Public)
// Parameters:
// float                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::AdvanceSeconds(float Seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "AdvanceSeconds");

	Params::Scripts_AdvanceSeconds Parms{};

	Parms.Seconds = Seconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.AdvanceTime
// (Final, Native, Static, Public)
// Parameters:
// float                                   Days                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Hours                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Minutes                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::AdvanceTime(float Days, float Hours, float Minutes, float Seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "AdvanceTime");

	Params::Scripts_AdvanceTime Parms{};

	Parms.Days = Days;
	Parms.Hours = Hours;
	Parms.Minutes = Minutes;
	Parms.Seconds = Seconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.AdvanceToHour
// (Final, Native, Static, Public)
// Parameters:
// int32                                   TargetHour                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::AdvanceToHour(int32 TargetHour)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "AdvanceToHour");

	Params::Scripts_AdvanceToHour Parms{};

	Parms.TargetHour = TargetHour;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.ArmTrap
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            TrapObjectID                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::ArmTrap(const struct FGuid& TrapObjectID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "ArmTrap");

	Params::Scripts_ArmTrap Parms{};

	Parms.TrapObjectID = std::move(TrapObjectID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.AttemptEnableHazard
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            HazardActorID                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::AttemptEnableHazard(const struct FGuid& HazardActorID, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "AttemptEnableHazard");

	Params::Scripts_AttemptEnableHazard Parms{};

	Parms.HazardActorID = std::move(HazardActorID);
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.BarOCL
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            OCLObjectID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::BarOCL(const struct FGuid& OCLObjectID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "BarOCL");

	Params::Scripts_BarOCL Parms{};

	Parms.OCLObjectID = std::move(OCLObjectID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.BeginTradeWithSpeaker
// (Final, Native, Static, Public, BlueprintCallable)

void UScripts::BeginTradeWithSpeaker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "BeginTradeWithSpeaker");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.Bribe
// (Final, Native, Static, Public)
// Parameters:
// class FString                           VariableName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::Bribe(const class FString& VariableName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "Bribe");

	Params::Scripts_Bribe Parms{};

	Parms.VariableName = std::move(VariableName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.CallGlobalScript
// (Final, Native, Static, Public, HasDefaults)
// Parameters:
// struct FGuid                            GlobalScriptID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::CallGlobalScript(const struct FGuid& GlobalScriptID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "CallGlobalScript");

	Params::Scripts_CallGlobalScript Parms{};

	Parms.GlobalScriptID = std::move(GlobalScriptID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.ClearConversationBodyTargetActor
// (Final, Native, Static, Public, HasDefaults)
// Parameters:
// struct FGuid                            Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStickyTarget                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::ClearConversationBodyTargetActor(const struct FGuid& Actor, bool bStickyTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "ClearConversationBodyTargetActor");

	Params::Scripts_ClearConversationBodyTargetActor Parms{};

	Parms.Actor = std::move(Actor);
	Parms.bStickyTarget = bStickyTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.ClearConversationEyesTargetActor
// (Final, Native, Static, Public, HasDefaults)
// Parameters:
// struct FGuid                            Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStickyTarget                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::ClearConversationEyesTargetActor(const struct FGuid& Actor, bool bStickyTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "ClearConversationEyesTargetActor");

	Params::Scripts_ClearConversationEyesTargetActor Parms{};

	Parms.Actor = std::move(Actor);
	Parms.bStickyTarget = bStickyTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.ClearConversationHeadTargetActor
// (Final, Native, Static, Public, HasDefaults)
// Parameters:
// struct FGuid                            Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStickyTarget                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::ClearConversationHeadTargetActor(const struct FGuid& Actor, bool bStickyTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "ClearConversationHeadTargetActor");

	Params::Scripts_ClearConversationHeadTargetActor Parms{};

	Parms.Actor = std::move(Actor);
	Parms.bStickyTarget = bStickyTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.ClearConversationNodeAsRead
// (Final, Native, Static, Public, HasDefaults)
// Parameters:
// struct FGuid                            ConversationID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NodeID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::ClearConversationNodeAsRead(const struct FGuid& ConversationID, int32 NodeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "ClearConversationNodeAsRead");

	Params::Scripts_ClearConversationNodeAsRead Parms{};

	Parms.ConversationID = std::move(ConversationID);
	Parms.NodeID = NodeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.ClearConversationTargetActor
// (Final, Native, Static, Public, HasDefaults)
// Parameters:
// struct FGuid                            Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStickyTarget                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::ClearConversationTargetActor(const struct FGuid& Actor, bool bStickyTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "ClearConversationTargetActor");

	Params::Scripts_ClearConversationTargetActor Parms{};

	Parms.Actor = std::move(Actor);
	Parms.bStickyTarget = bStickyTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.ClearDefaultEmotion
// (Final, Native, Static, Public, HasDefaults)
// Parameters:
// struct FGuid                            Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::ClearDefaultEmotion(const struct FGuid& Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "ClearDefaultEmotion");

	Params::Scripts_ClearDefaultEmotion Parms{};

	Parms.Actor = std::move(Actor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.ClearEmotion
// (Final, Native, Static, Public, HasDefaults)
// Parameters:
// struct FGuid                            Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::ClearEmotion(const struct FGuid& Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "ClearEmotion");

	Params::Scripts_ClearEmotion Parms{};

	Parms.Actor = std::move(Actor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.ClearFactionRecentHostilityToPlayer
// (Final, Native, Static, Public)
// Parameters:
// class FString                           Faction                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::ClearFactionRecentHostilityToPlayer(const class FString& Faction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "ClearFactionRecentHostilityToPlayer");

	Params::Scripts_ClearFactionRecentHostilityToPlayer Parms{};

	Parms.Faction = std::move(Faction);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.ClearMusicOverride
// (Final, Native, Static, Public, BlueprintCallable)

void UScripts::ClearMusicOverride()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "ClearMusicOverride");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.ClearNamedTimestamp
// (Final, Native, Static, Public)
// Parameters:
// class FString                           TimestampName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::ClearNamedTimestamp(const class FString& TimestampName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "ClearNamedTimestamp");

	Params::Scripts_ClearNamedTimestamp Parms{};

	Parms.TimestampName = std::move(TimestampName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.ClearOwnershipsOfItemsInContainer
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            ContainerID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClearPlayerOwnership                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClearNonPlayerOwnership                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::ClearOwnershipsOfItemsInContainer(const struct FGuid& ContainerID, bool bClearPlayerOwnership, bool bClearNonPlayerOwnership)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "ClearOwnershipsOfItemsInContainer");

	Params::Scripts_ClearOwnershipsOfItemsInContainer Parms{};

	Parms.ContainerID = std::move(ContainerID);
	Parms.bClearPlayerOwnership = bClearPlayerOwnership;
	Parms.bClearNonPlayerOwnership = bClearNonPlayerOwnership;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.ClearOwnershipsOfItemTypeInContainer
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            ContainerID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Item                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClearPlayerOwnership                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClearNonPlayerOwnership                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::ClearOwnershipsOfItemTypeInContainer(const struct FGuid& ContainerID, const class FString& Item, bool bClearPlayerOwnership, bool bClearNonPlayerOwnership)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "ClearOwnershipsOfItemTypeInContainer");

	Params::Scripts_ClearOwnershipsOfItemTypeInContainer Parms{};

	Parms.ContainerID = std::move(ContainerID);
	Parms.Item = std::move(Item);
	Parms.bClearPlayerOwnership = bClearPlayerOwnership;
	Parms.bClearNonPlayerOwnership = bClearNonPlayerOwnership;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.ClearPickupOwnerships
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            PickupID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClearPlayerOwnership                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClearNonPlayerOwnership                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::ClearPickupOwnerships(const struct FGuid& PickupID, bool bClearPlayerOwnership, bool bClearNonPlayerOwnership)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "ClearPickupOwnerships");

	Params::Scripts_ClearPickupOwnerships Parms{};

	Parms.PickupID = std::move(PickupID);
	Parms.bClearPlayerOwnership = bClearPlayerOwnership;
	Parms.bClearNonPlayerOwnership = bClearNonPlayerOwnership;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.ClearSpeakersDefaultEmotion
// (Final, Native, Static, Public)

void UScripts::ClearSpeakersDefaultEmotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "ClearSpeakersDefaultEmotion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.ClearSpeakersTalkIdleOverride
// (Final, Native, Static, Public)
// Parameters:
// EEmotion                                Emotion                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Persist                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::ClearSpeakersTalkIdleOverride(EEmotion Emotion, float Duration, bool Persist)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "ClearSpeakersTalkIdleOverride");

	Params::Scripts_ClearSpeakersTalkIdleOverride Parms{};

	Parms.Emotion = Emotion;
	Parms.Duration = Duration;
	Parms.Persist = Persist;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.ClearSpeakersTalkIdleOverrideOnNextEmotionChange
// (Final, Native, Static, Public)

void UScripts::ClearSpeakersTalkIdleOverrideOnNextEmotionChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "ClearSpeakersTalkIdleOverrideOnNextEmotionChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.ClearTalkIdleOverride
// (Final, Native, Static, Public, HasDefaults)
// Parameters:
// struct FGuid                            Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEmotion                                Emotion                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Persist                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::ClearTalkIdleOverride(const struct FGuid& Actor, EEmotion Emotion, float Duration, bool Persist)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "ClearTalkIdleOverride");

	Params::Scripts_ClearTalkIdleOverride Parms{};

	Parms.Actor = std::move(Actor);
	Parms.Emotion = Emotion;
	Parms.Duration = Duration;
	Parms.Persist = Persist;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.ClearTalkIdleOverrideOnNextEmotionChange
// (Final, Native, Static, Public, HasDefaults)
// Parameters:
// struct FGuid                            Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::ClearTalkIdleOverrideOnNextEmotionChange(const struct FGuid& Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "ClearTalkIdleOverrideOnNextEmotionChange");

	Params::Scripts_ClearTalkIdleOverrideOnNextEmotionChange Parms{};

	Parms.Actor = std::move(Actor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.CloseOCL
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            OCLObjectID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Block                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSeal                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::CloseOCL(const struct FGuid& OCLObjectID, bool Block, bool bSeal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "CloseOCL");

	Params::Scripts_CloseOCL Parms{};

	Parms.OCLObjectID = std::move(OCLObjectID);
	Parms.Block = Block;
	Parms.bSeal = bSeal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.DebugAdvanceQuest
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::DebugAdvanceQuest(const struct FGuid& QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "DebugAdvanceQuest");

	Params::Scripts_DebugAdvanceQuest Parms{};

	Parms.QuestID = std::move(QuestID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.DebugPrintMessage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::DebugPrintMessage(const class FString& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "DebugPrintMessage");

	Params::Scripts_DebugPrintMessage Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.DisarmTrap
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            TrapObjectID                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::DisarmTrap(const struct FGuid& TrapObjectID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "DisarmTrap");

	Params::Scripts_DisarmTrap Parms{};

	Parms.TrapObjectID = std::move(TrapObjectID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.DismissCompanion
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESpecialObsidianID                      CompanionID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::DismissCompanion(ESpecialObsidianID CompanionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "DismissCompanion");

	Params::Scripts_DismissCompanion Parms{};

	Parms.CompanionID = CompanionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.DynamicallyReplaceCompanion
// (Final, Native, Static, Public)
// Parameters:
// ESpecialObsidianID                      OldCompanionID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpecialObsidianID                      NewCompanionID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::DynamicallyReplaceCompanion(ESpecialObsidianID OldCompanionID, ESpecialObsidianID NewCompanionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "DynamicallyReplaceCompanion");

	Params::Scripts_DynamicallyReplaceCompanion Parms{};

	Parms.OldCompanionID = OldCompanionID;
	Parms.NewCompanionID = NewCompanionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.GetCompanionMoral
// (Final, Native, Static, Public)
// Parameters:
// ESpecialObsidianID                      CompanionID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UScripts::GetCompanionMoral(ESpecialObsidianID CompanionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "GetCompanionMoral");

	Params::Scripts_GetCompanionMoral Parms{};

	Parms.CompanionID = CompanionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.Scripts.GiveCurrency
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            ActorId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::GiveCurrency(const struct FGuid& ActorId, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "GiveCurrency");

	Params::Scripts_GiveCurrency Parms{};

	Parms.ActorId = std::move(ActorId);
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.GiveItem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Item                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::GiveItem(const class FString& Item, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "GiveItem");

	Params::Scripts_GiveItem Parms{};

	Parms.Item = std::move(Item);
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.GiveItemToActor
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            ActorIdID                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Item                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::GiveItemToActor(const struct FGuid& ActorIdID, const class FString& Item, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "GiveItemToActor");

	Params::Scripts_GiveItemToActor Parms{};

	Parms.ActorIdID = std::move(ActorIdID);
	Parms.Item = std::move(Item);
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.GiveLoot
// (Final, Native, Static, Public)
// Parameters:
// class FString                           LootTableData                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::GiveLoot(const class FString& LootTableData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "GiveLoot");

	Params::Scripts_GiveLoot Parms{};

	Parms.LootTableData = std::move(LootTableData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.GivePerkToActor
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            ActorId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Perk                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::GivePerkToActor(const struct FGuid& ActorId, const class FString& Perk)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "GivePerkToActor");

	Params::Scripts_GivePerkToActor Parms{};

	Parms.ActorId = std::move(ActorId);
	Parms.Perk = std::move(Perk);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.HideBeacon
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            BeaconObjectID                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::HideBeacon(const struct FGuid& BeaconObjectID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "HideBeacon");

	Params::Scripts_HideBeacon Parms{};

	Parms.BeaconObjectID = std::move(BeaconObjectID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.HidePointOfInterest
// (Final, Native, Static, Public)
// Parameters:
// class FString                           PointOfInterestData                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::HidePointOfInterest(const class FString& PointOfInterestData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "HidePointOfInterest");

	Params::Scripts_HidePointOfInterest Parms{};

	Parms.PointOfInterestData = std::move(PointOfInterestData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.IncrementGlobalValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           VariableName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   IncrementValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::IncrementGlobalValue(const class FString& VariableName, int32 IncrementValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "IncrementGlobalValue");

	Params::Scripts_IncrementGlobalValue Parms{};

	Parms.VariableName = std::move(VariableName);
	Parms.IncrementValue = IncrementValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.KillNPC
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            Character                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::KillNPC(const struct FGuid& Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "KillNPC");

	Params::Scripts_KillNPC Parms{};

	Parms.Character = std::move(Character);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.LockComputer
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            ComputerObjectID                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::LockComputer(const struct FGuid& ComputerObjectID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "LockComputer");

	Params::Scripts_LockComputer Parms{};

	Parms.ComputerObjectID = std::move(ComputerObjectID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.LockOCL
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            OCLObjectID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::LockOCL(const struct FGuid& OCLObjectID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "LockOCL");

	Params::Scripts_LockOCL Parms{};

	Parms.OCLObjectID = std::move(OCLObjectID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.MakePointOfInterestDiscoverable
// (Final, Native, Static, Public)
// Parameters:
// class FString                           PointOfInterestData                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStillHidden                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::MakePointOfInterestDiscoverable(const class FString& PointOfInterestData, bool bStillHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "MakePointOfInterestDiscoverable");

	Params::Scripts_MakePointOfInterestDiscoverable Parms{};

	Parms.PointOfInterestData = std::move(PointOfInterestData);
	Parms.bStillHidden = bStillHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.MarkConversationNodeAsRead
// (Final, Native, Static, Public, HasDefaults)
// Parameters:
// struct FGuid                            ConversationID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NodeID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::MarkConversationNodeAsRead(const struct FGuid& ConversationID, int32 NodeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "MarkConversationNodeAsRead");

	Params::Scripts_MarkConversationNodeAsRead Parms{};

	Parms.ConversationID = std::move(ConversationID);
	Parms.NodeID = NodeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.MentionPointOfInterest
// (Final, Native, Static, Public)
// Parameters:
// class FString                           PointOfInterestData                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::MentionPointOfInterest(const class FString& PointOfInterestData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "MentionPointOfInterest");

	Params::Scripts_MentionPointOfInterest Parms{};

	Parms.PointOfInterestData = std::move(PointOfInterestData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.MentionQuest
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::MentionQuest(const struct FGuid& QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "MentionQuest");

	Params::Scripts_MentionQuest Parms{};

	Parms.QuestID = std::move(QuestID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.OpenOCL
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            OCLObjectID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::OpenOCL(const struct FGuid& OCLObjectID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "OpenOCL");

	Params::Scripts_OpenOCL Parms{};

	Parms.OCLObjectID = std::move(OCLObjectID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.PauseMusic
// (Final, Native, Static, Public, BlueprintCallable)

void UScripts::PauseMusic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "PauseMusic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.PlayConversationChatterEvent
// (Final, Native, Static, Public)
// Parameters:
// EChatterEventType                       ChatterEvent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConversationNode                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::PlayConversationChatterEvent(EChatterEventType ChatterEvent, bool bConversationNode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "PlayConversationChatterEvent");

	Params::Scripts_PlayConversationChatterEvent Parms{};

	Parms.ChatterEvent = ChatterEvent;
	Parms.bConversationNode = bConversationNode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.RandomizeGlobalValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           VariableName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::RandomizeGlobalValue(const class FString& VariableName, int32 MinValue, int32 MaxValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "RandomizeGlobalValue");

	Params::Scripts_RandomizeGlobalValue Parms{};

	Parms.VariableName = std::move(VariableName);
	Parms.MinValue = MinValue;
	Parms.MaxValue = MaxValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.RandomizeGlobalValueWithGlobals
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           VariableName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MinValueGlobal                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MaxValueGlobal                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::RandomizeGlobalValueWithGlobals(const class FString& VariableName, const class FString& MinValueGlobal, const class FString& MaxValueGlobal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "RandomizeGlobalValueWithGlobals");

	Params::Scripts_RandomizeGlobalValueWithGlobals Parms{};

	Parms.VariableName = std::move(VariableName);
	Parms.MinValueGlobal = std::move(MinValueGlobal);
	Parms.MaxValueGlobal = std::move(MaxValueGlobal);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.RegisterNamedTimestamp
// (Final, Native, Static, Public)
// Parameters:
// class FString                           TimestampName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::RegisterNamedTimestamp(const class FString& TimestampName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "RegisterNamedTimestamp");

	Params::Scripts_RegisterNamedTimestamp Parms{};

	Parms.TimestampName = std::move(TimestampName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.RemoteEvent
// (Final, Native, Static, Public)
// Parameters:
// class FString                           EventName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::RemoteEvent(const class FString& EventName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "RemoteEvent");

	Params::Scripts_RemoteEvent Parms{};

	Parms.EventName = std::move(EventName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.RemoveCompanionFromParty
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            CompanionID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::RemoveCompanionFromParty(const struct FGuid& CompanionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "RemoveCompanionFromParty");

	Params::Scripts_RemoveCompanionFromParty Parms{};

	Parms.CompanionID = std::move(CompanionID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.RemoveCurrency
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            ActorId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::RemoveCurrency(const struct FGuid& ActorId, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "RemoveCurrency");

	Params::Scripts_RemoveCurrency Parms{};

	Parms.ActorId = std::move(ActorId);
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.RemoveItem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Item                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::RemoveItem(const class FString& Item, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "RemoveItem");

	Params::Scripts_RemoveItem Parms{};

	Parms.Item = std::move(Item);
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.RemoveItemFromActor
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            ActorId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Item                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::RemoveItemFromActor(const struct FGuid& ActorId, const class FString& Item, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "RemoveItemFromActor");

	Params::Scripts_RemoveItemFromActor Parms{};

	Parms.ActorId = std::move(ActorId);
	Parms.Item = std::move(Item);
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.ReplaceCompanionInSlot
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            PotientalCompanionID                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECompanionSlot                          CommpanionSlot                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::ReplaceCompanionInSlot(const struct FGuid& PotientalCompanionID, ECompanionSlot CommpanionSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "ReplaceCompanionInSlot");

	Params::Scripts_ReplaceCompanionInSlot Parms{};

	Parms.PotientalCompanionID = std::move(PotientalCompanionID);
	Parms.CommpanionSlot = CommpanionSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.ResetRPGSystems
// (Final, Native, Static, Public, BlueprintCallable)

void UScripts::ResetRPGSystems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "ResetRPGSystems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.ResumeMusic
// (Final, Native, Static, Public, BlueprintCallable)

void UScripts::ResumeMusic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "ResumeMusic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SealOCL
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            OCLObjectID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SealOCL(const struct FGuid& OCLObjectID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SealOCL");

	Params::Scripts_SealOCL Parms{};

	Parms.OCLObjectID = std::move(OCLObjectID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetCharacterTeam_AvoidUsingThis
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            CharacterID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Team                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetCharacterTeam_AvoidUsingThis(const struct FGuid& CharacterID, const class FString& Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetCharacterTeam_AvoidUsingThis");

	Params::Scripts_SetCharacterTeam_AvoidUsingThis Parms{};

	Parms.CharacterID = std::move(CharacterID);
	Parms.Team = std::move(Team);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetCompanionWantsToTalk
// (Final, Native, Static, Public)
// Parameters:
// ESpecialObsidianID                      CompanionID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWantsToTalk                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetCompanionWantsToTalk(ESpecialObsidianID CompanionID, bool bWantsToTalk)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetCompanionWantsToTalk");

	Params::Scripts_SetCompanionWantsToTalk Parms{};

	Parms.CompanionID = CompanionID;
	Parms.bWantsToTalk = bWantsToTalk;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetConversationBodyTargetActor
// (Final, Native, Static, Public, HasDefaults)
// Parameters:
// struct FGuid                            Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStickyTarget                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetConversationBodyTargetActor(const struct FGuid& Actor, const struct FGuid& Target, bool bStickyTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetConversationBodyTargetActor");

	Params::Scripts_SetConversationBodyTargetActor Parms{};

	Parms.Actor = std::move(Actor);
	Parms.Target = std::move(Target);
	Parms.bStickyTarget = bStickyTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetConversationEyesTargetActor
// (Final, Native, Static, Public, HasDefaults)
// Parameters:
// struct FGuid                            Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStickyTarget                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetConversationEyesTargetActor(const struct FGuid& Actor, const struct FGuid& Target, bool bStickyTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetConversationEyesTargetActor");

	Params::Scripts_SetConversationEyesTargetActor Parms{};

	Parms.Actor = std::move(Actor);
	Parms.Target = std::move(Target);
	Parms.bStickyTarget = bStickyTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetConversationHeadTargetActor
// (Final, Native, Static, Public, HasDefaults)
// Parameters:
// struct FGuid                            Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStickyTarget                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetConversationHeadTargetActor(const struct FGuid& Actor, const struct FGuid& Target, bool bStickyTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetConversationHeadTargetActor");

	Params::Scripts_SetConversationHeadTargetActor Parms{};

	Parms.Actor = std::move(Actor);
	Parms.Target = std::move(Target);
	Parms.bStickyTarget = bStickyTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetConversationTargetActor
// (Final, Native, Static, Public, HasDefaults)
// Parameters:
// struct FGuid                            Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRotateBody                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStickyTarget                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetConversationTargetActor(const struct FGuid& Actor, const struct FGuid& Target, bool bRotateBody, bool bStickyTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetConversationTargetActor");

	Params::Scripts_SetConversationTargetActor Parms{};

	Parms.Actor = std::move(Actor);
	Parms.Target = std::move(Target);
	Parms.bRotateBody = bRotateBody;
	Parms.bStickyTarget = bStickyTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetDefaultEmotion
// (Final, Native, Static, Public, HasDefaults)
// Parameters:
// struct FGuid                            Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEmotion                                Emotion                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetDefaultEmotion(const struct FGuid& Actor, EEmotion Emotion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetDefaultEmotion");

	Params::Scripts_SetDefaultEmotion Parms{};

	Parms.Actor = std::move(Actor);
	Parms.Emotion = Emotion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetEmotion
// (Final, Native, Static, Public, HasDefaults)
// Parameters:
// struct FGuid                            Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEmotion                                Emotion                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Persist                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetEmotion(const struct FGuid& Actor, EEmotion Emotion, float Duration, bool Persist)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetEmotion");

	Params::Scripts_SetEmotion Parms{};

	Parms.Actor = std::move(Actor);
	Parms.Emotion = Emotion;
	Parms.Duration = Duration;
	Parms.Persist = Persist;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetEmotionFull
// (Final, Native, Static, Public, HasDefaults)
// Parameters:
// struct FGuid                            Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEmotion                                Emotion                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HeadStrength                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Persist                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AffectHead                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AffectBody                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetEmotionFull(const struct FGuid& Actor, EEmotion Emotion, float Delay, float Duration, float HeadStrength, bool Persist, bool AffectHead, bool AffectBody)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetEmotionFull");

	Params::Scripts_SetEmotionFull Parms{};

	Parms.Actor = std::move(Actor);
	Parms.Emotion = Emotion;
	Parms.Delay = Delay;
	Parms.Duration = Duration;
	Parms.HeadStrength = HeadStrength;
	Parms.Persist = Persist;
	Parms.AffectHead = AffectHead;
	Parms.AffectBody = AffectBody;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetEmotionWithDelay
// (Final, Native, Static, Public, HasDefaults)
// Parameters:
// struct FGuid                            Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEmotion                                Emotion                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EmotionDelay                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Persist                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetEmotionWithDelay(const struct FGuid& Actor, EEmotion Emotion, float EmotionDelay, float Duration, bool Persist)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetEmotionWithDelay");

	Params::Scripts_SetEmotionWithDelay Parms{};

	Parms.Actor = std::move(Actor);
	Parms.Emotion = Emotion;
	Parms.EmotionDelay = EmotionDelay;
	Parms.Duration = Duration;
	Parms.Persist = Persist;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetFactionEncountered
// (Final, Native, Static, Public)
// Parameters:
// class FString                           Faction                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetFactionEncountered(const class FString& Faction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetFactionEncountered");

	Params::Scripts_SetFactionEncountered Parms{};

	Parms.Faction = std::move(Faction);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetFactionOwnershipOfItemsInContainer
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            ContainerID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Faction                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClearPlayerOwnership                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetFactionOwnershipOfItemsInContainer(const struct FGuid& ContainerID, const class FString& Faction, bool bClearPlayerOwnership)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetFactionOwnershipOfItemsInContainer");

	Params::Scripts_SetFactionOwnershipOfItemsInContainer Parms{};

	Parms.ContainerID = std::move(ContainerID);
	Parms.Faction = std::move(Faction);
	Parms.bClearPlayerOwnership = bClearPlayerOwnership;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetFactionOwnershipOfItemTypeInContainer
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            ContainerID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Item                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Faction                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClearPlayerOwnership                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetFactionOwnershipOfItemTypeInContainer(const struct FGuid& ContainerID, const class FString& Item, const class FString& Faction, bool bClearPlayerOwnership)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetFactionOwnershipOfItemTypeInContainer");

	Params::Scripts_SetFactionOwnershipOfItemTypeInContainer Parms{};

	Parms.ContainerID = std::move(ContainerID);
	Parms.Item = std::move(Item);
	Parms.Faction = std::move(Faction);
	Parms.bClearPlayerOwnership = bClearPlayerOwnership;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetGlobalIfGlobal
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ConditionVariableName                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ConditionValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           VariableName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetGlobalIfGlobal(const class FString& ConditionVariableName, int32 ConditionValue, const class FString& VariableName, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetGlobalIfGlobal");

	Params::Scripts_SetGlobalIfGlobal Parms{};

	Parms.ConditionVariableName = std::move(ConditionVariableName);
	Parms.ConditionValue = ConditionValue;
	Parms.VariableName = std::move(VariableName);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetGlobalValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           VariableName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetGlobalValue(const class FString& VariableName, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetGlobalValue");

	Params::Scripts_SetGlobalValue Parms{};

	Parms.VariableName = std::move(VariableName);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetGlobalVariableValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGlobalVariable                  Variable                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetGlobalVariableValue(const struct FGlobalVariable& Variable, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetGlobalVariableValue");

	Params::Scripts_SetGlobalVariableValue Parms{};

	Parms.Variable = std::move(Variable);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetInterrogationComplete
// (Final, Native, Static, Public)
// Parameters:
// EInterrogationResult                    Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetInterrogationComplete(EInterrogationResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetInterrogationComplete");

	Params::Scripts_SetInterrogationComplete Parms{};

	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetMusicOverride
// (Final, Native, Static, Public)
// Parameters:
// class FString                           OverrideTrack                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetMusicOverride(const class FString& OverrideTrack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetMusicOverride");

	Params::Scripts_SetMusicOverride Parms{};

	Parms.OverrideTrack = std::move(OverrideTrack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetNonPlayerOwnershipOfItemsInContainer
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            ContainerID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            Actor                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClearPlayerOwnership                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetNonPlayerOwnershipOfItemsInContainer(const struct FGuid& ContainerID, const struct FGuid& Actor, bool bClearPlayerOwnership)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetNonPlayerOwnershipOfItemsInContainer");

	Params::Scripts_SetNonPlayerOwnershipOfItemsInContainer Parms{};

	Parms.ContainerID = std::move(ContainerID);
	Parms.Actor = std::move(Actor);
	Parms.bClearPlayerOwnership = bClearPlayerOwnership;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetNonPlayerOwnershipOfItemTypeInContainer
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            ContainerID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Item                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            Actor                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClearPlayerOwnership                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetNonPlayerOwnershipOfItemTypeInContainer(const struct FGuid& ContainerID, const class FString& Item, const struct FGuid& Actor, bool bClearPlayerOwnership)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetNonPlayerOwnershipOfItemTypeInContainer");

	Params::Scripts_SetNonPlayerOwnershipOfItemTypeInContainer Parms{};

	Parms.ContainerID = std::move(ContainerID);
	Parms.Item = std::move(Item);
	Parms.Actor = std::move(Actor);
	Parms.bClearPlayerOwnership = bClearPlayerOwnership;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetObjectiveAlternateDescription
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ObjectiveID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ObjectiveDescriptionID                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetObjectiveAlternateDescription(const struct FGuid& QuestID, int32 ObjectiveID, int32 ObjectiveDescriptionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetObjectiveAlternateDescription");

	Params::Scripts_SetObjectiveAlternateDescription Parms{};

	Parms.QuestID = std::move(QuestID);
	Parms.ObjectiveID = ObjectiveID;
	Parms.ObjectiveDescriptionID = ObjectiveDescriptionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetPickupFactionOwnership
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            PickupID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Faction                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClearPlayerOwnership                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetPickupFactionOwnership(const struct FGuid& PickupID, const class FString& Faction, bool bClearPlayerOwnership)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetPickupFactionOwnership");

	Params::Scripts_SetPickupFactionOwnership Parms{};

	Parms.PickupID = std::move(PickupID);
	Parms.Faction = std::move(Faction);
	Parms.bClearPlayerOwnership = bClearPlayerOwnership;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetPickupNonPlayerOwnership
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            PickupID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            Actor                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClearPlayerOwnership                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetPickupNonPlayerOwnership(const struct FGuid& PickupID, const struct FGuid& Actor, bool bClearPlayerOwnership)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetPickupNonPlayerOwnership");

	Params::Scripts_SetPickupNonPlayerOwnership Parms{};

	Parms.PickupID = std::move(PickupID);
	Parms.Actor = std::move(Actor);
	Parms.bClearPlayerOwnership = bClearPlayerOwnership;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetPickupPlayerOwnership
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            PickupID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayerOwned                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClearNonPlayerOwnership                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetPickupPlayerOwnership(const struct FGuid& PickupID, bool bPlayerOwned, bool bClearNonPlayerOwnership)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetPickupPlayerOwnership");

	Params::Scripts_SetPickupPlayerOwnership Parms{};

	Parms.PickupID = std::move(PickupID);
	Parms.bPlayerOwned = bPlayerOwned;
	Parms.bClearNonPlayerOwnership = bClearNonPlayerOwnership;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetPlayerAwareOfRegion
// (Final, Native, Static, Public)
// Parameters:
// class FString                           TravelRegion                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetPlayerAwareOfRegion(const class FString& TravelRegion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetPlayerAwareOfRegion");

	Params::Scripts_SetPlayerAwareOfRegion Parms{};

	Parms.TravelRegion = std::move(TravelRegion);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetPlayerAwareOfTravelDestination
// (Final, Native, Static, Public)
// Parameters:
// class FString                           TravelDestination                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetPlayerAwareOfTravelDestination(const class FString& TravelDestination)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetPlayerAwareOfTravelDestination");

	Params::Scripts_SetPlayerAwareOfTravelDestination Parms{};

	Parms.TravelDestination = std::move(TravelDestination);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetPlayerOwnershipOfItemsInContainer
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            ContainerID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayerOwned                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClearNonPlayerOwnership                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetPlayerOwnershipOfItemsInContainer(const struct FGuid& ContainerID, bool bPlayerOwned, bool bClearNonPlayerOwnership)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetPlayerOwnershipOfItemsInContainer");

	Params::Scripts_SetPlayerOwnershipOfItemsInContainer Parms{};

	Parms.ContainerID = std::move(ContainerID);
	Parms.bPlayerOwned = bPlayerOwned;
	Parms.bClearNonPlayerOwnership = bClearNonPlayerOwnership;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetPlayerOwnershipOfItemTypeInContainer
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            ContainerID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Item                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayerOwned                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClearNonPlayerOwnership                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetPlayerOwnershipOfItemTypeInContainer(const struct FGuid& ContainerID, const class FString& Item, bool bPlayerOwned, bool bClearNonPlayerOwnership)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetPlayerOwnershipOfItemTypeInContainer");

	Params::Scripts_SetPlayerOwnershipOfItemTypeInContainer Parms{};

	Parms.ContainerID = std::move(ContainerID);
	Parms.Item = std::move(Item);
	Parms.bPlayerOwned = bPlayerOwned;
	Parms.bClearNonPlayerOwnership = bClearNonPlayerOwnership;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetPlayerRelationshipToHostile
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            CharacterID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetPlayerRelationshipToHostile(const struct FGuid& CharacterID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetPlayerRelationshipToHostile");

	Params::Scripts_SetPlayerRelationshipToHostile Parms{};

	Parms.CharacterID = std::move(CharacterID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetPlayerShipLocation
// (Final, Native, Static, Public)
// Parameters:
// class FString                           ShipDestination                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetPlayerShipLocation(const class FString& ShipDestination)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetPlayerShipLocation");

	Params::Scripts_SetPlayerShipLocation Parms{};

	Parms.ShipDestination = std::move(ShipDestination);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetPlayerTravelDestinationHidden
// (Final, Native, Static, Public)
// Parameters:
// class FString                           TravelDestination                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHidden                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetPlayerTravelDestinationHidden(const class FString& TravelDestination, bool bHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetPlayerTravelDestinationHidden");

	Params::Scripts_SetPlayerTravelDestinationHidden Parms{};

	Parms.TravelDestination = std::move(TravelDestination);
	Parms.bHidden = bHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetPlayerTravelDestinationLocked
// (Final, Native, Static, Public)
// Parameters:
// class FString                           TravelDestination                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLocked                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetPlayerTravelDestinationLocked(const class FString& TravelDestination, bool bLocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetPlayerTravelDestinationLocked");

	Params::Scripts_SetPlayerTravelDestinationLocked Parms{};

	Parms.TravelDestination = std::move(TravelDestination);
	Parms.bLocked = bLocked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetPlayerVisitedRegion
// (Final, Native, Static, Public)
// Parameters:
// class FString                           TravelRegion                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetPlayerVisitedRegion(const class FString& TravelRegion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetPlayerVisitedRegion");

	Params::Scripts_SetPlayerVisitedRegion Parms{};

	Parms.TravelRegion = std::move(TravelRegion);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetPlayerVisitedTravelDestination
// (Final, Native, Static, Public)
// Parameters:
// class FString                           TravelDestination                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetPlayerVisitedTravelDestination(const class FString& TravelDestination)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetPlayerVisitedTravelDestination");

	Params::Scripts_SetPlayerVisitedTravelDestination Parms{};

	Parms.TravelDestination = std::move(TravelDestination);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetPointOfInterestDiscovered
// (Final, Native, Static, Public)
// Parameters:
// class FString                           PointOfInterestData                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCanAwardXP                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetPointOfInterestDiscovered(const class FString& PointOfInterestData, bool bCanAwardXP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetPointOfInterestDiscovered");

	Params::Scripts_SetPointOfInterestDiscovered Parms{};

	Parms.PointOfInterestData = std::move(PointOfInterestData);
	Parms.bCanAwardXP = bCanAwardXP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetPosture
// (Final, Native, Static, Public)
// Parameters:
// EPosture                                Posture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Persist                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetPosture(EPosture Posture, float Delay, float Duration, bool Persist)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetPosture");

	Params::Scripts_SetPosture Parms{};

	Parms.Posture = Posture;
	Parms.Delay = Delay;
	Parms.Duration = Duration;
	Parms.Persist = Persist;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetQuestAlternateDescription
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   QuestDescriptionID                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetQuestAlternateDescription(const struct FGuid& QuestID, int32 QuestDescriptionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetQuestAlternateDescription");

	Params::Scripts_SetQuestAlternateDescription Parms{};

	Parms.QuestID = std::move(QuestID);
	Parms.QuestDescriptionID = QuestDescriptionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetSlideshowImageKey
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           ImageKey                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetSlideshowImageKey(class FString* ImageKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetSlideshowImageKey");

	Params::Scripts_SetSlideshowImageKey Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ImageKey != nullptr)
		*ImageKey = std::move(Parms.ImageKey);
}


// Function Indiana.Scripts.SetSpeakersDefaultEmotion
// (Final, Native, Static, Public)
// Parameters:
// EEmotion                                Emotion                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetSpeakersDefaultEmotion(EEmotion Emotion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetSpeakersDefaultEmotion");

	Params::Scripts_SetSpeakersDefaultEmotion Parms{};

	Parms.Emotion = Emotion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetSpeakersEmotion
// (Final, Native, Static, Public)
// Parameters:
// EEmotion                                Emotion                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Persist                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetSpeakersEmotion(EEmotion Emotion, float Duration, bool Persist)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetSpeakersEmotion");

	Params::Scripts_SetSpeakersEmotion Parms{};

	Parms.Emotion = Emotion;
	Parms.Duration = Duration;
	Parms.Persist = Persist;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetSpeakersEmotionFull
// (Final, Native, Static, Public)
// Parameters:
// EEmotion                                Emotion                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HeadStrength                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Persist                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AffectHead                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AffectBody                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetSpeakersEmotionFull(EEmotion Emotion, float Delay, float Duration, float HeadStrength, bool Persist, bool AffectHead, bool AffectBody)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetSpeakersEmotionFull");

	Params::Scripts_SetSpeakersEmotionFull Parms{};

	Parms.Emotion = Emotion;
	Parms.Delay = Delay;
	Parms.Duration = Duration;
	Parms.HeadStrength = HeadStrength;
	Parms.Persist = Persist;
	Parms.AffectHead = AffectHead;
	Parms.AffectBody = AffectBody;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetSpeakersEmotionWithDelay
// (Final, Native, Static, Public)
// Parameters:
// EEmotion                                Emotion                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EmotionDelay                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Persist                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetSpeakersEmotionWithDelay(EEmotion Emotion, float EmotionDelay, float Duration, bool Persist)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetSpeakersEmotionWithDelay");

	Params::Scripts_SetSpeakersEmotionWithDelay Parms{};

	Parms.Emotion = Emotion;
	Parms.EmotionDelay = EmotionDelay;
	Parms.Duration = Duration;
	Parms.Persist = Persist;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetSpeakersTalkIdleOverride
// (Final, Native, Static, Public)
// Parameters:
// class FName                             TalkIdleOverrideName                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEmotion                                Emotion                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Persist                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetSpeakersTalkIdleOverride(class FName TalkIdleOverrideName, EEmotion Emotion, float Delay, float Duration, bool Persist)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetSpeakersTalkIdleOverride");

	Params::Scripts_SetSpeakersTalkIdleOverride Parms{};

	Parms.TalkIdleOverrideName = TalkIdleOverrideName;
	Parms.Emotion = Emotion;
	Parms.Delay = Delay;
	Parms.Duration = Duration;
	Parms.Persist = Persist;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetTalkIdleOverride
// (Final, Native, Static, Public, HasDefaults)
// Parameters:
// struct FGuid                            Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TalkIdleOverrideName                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEmotion                                Emotion                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Persist                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetTalkIdleOverride(const struct FGuid& Actor, class FName TalkIdleOverrideName, EEmotion Emotion, float Delay, float Duration, bool Persist)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetTalkIdleOverride");

	Params::Scripts_SetTalkIdleOverride Parms{};

	Parms.Actor = std::move(Actor);
	Parms.TalkIdleOverrideName = TalkIdleOverrideName;
	Parms.Emotion = Emotion;
	Parms.Delay = Delay;
	Parms.Duration = Duration;
	Parms.Persist = Persist;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.SetTeamRelationship
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// class FString                           SourceTeam                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OtherTeam                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETeamAttitude                           Relationship                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMutual                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetTeamRelationship(const class FString& SourceTeam, class FString* OtherTeam, ETeamAttitude Relationship, bool bMutual)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetTeamRelationship");

	Params::Scripts_SetTeamRelationship Parms{};

	Parms.SourceTeam = std::move(SourceTeam);
	Parms.Relationship = Relationship;
	Parms.bMutual = bMutual;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OtherTeam != nullptr)
		*OtherTeam = std::move(Parms.OtherTeam);
}


// Function Indiana.Scripts.SetTrackedQuest
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::SetTrackedQuest(const struct FGuid& QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "SetTrackedQuest");

	Params::Scripts_SetTrackedQuest Parms{};

	Parms.QuestID = std::move(QuestID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.ShowBeacon
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            BeaconObjectID                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::ShowBeacon(const struct FGuid& BeaconObjectID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "ShowBeacon");

	Params::Scripts_ShowBeacon Parms{};

	Parms.BeaconObjectID = std::move(BeaconObjectID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.StartQuest
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::StartQuest(const struct FGuid& QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "StartQuest");

	Params::Scripts_StartQuest Parms{};

	Parms.QuestID = std::move(QuestID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.StartQuestWithAlternateDescription
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   QuestDescriptionID                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::StartQuestWithAlternateDescription(const struct FGuid& QuestID, int32 QuestDescriptionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "StartQuestWithAlternateDescription");

	Params::Scripts_StartQuestWithAlternateDescription Parms{};

	Parms.QuestID = std::move(QuestID);
	Parms.QuestDescriptionID = QuestDescriptionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.TakeItemValue
// (Final, Native, Static, Public)
// Parameters:
// class FString                           Item                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::TakeItemValue(const class FString& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "TakeItemValue");

	Params::Scripts_TakeItemValue Parms{};

	Parms.Item = std::move(Item);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.TravelToDestination
// (Final, Native, Static, Public)
// Parameters:
// class FString                           TravelDestination                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTriggerAutosave                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::TravelToDestination(const class FString& TravelDestination, bool bTriggerAutosave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "TravelToDestination");

	Params::Scripts_TravelToDestination Parms{};

	Parms.TravelDestination = std::move(TravelDestination);
	Parms.bTriggerAutosave = bTriggerAutosave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.TriggerQuestAddendum
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AddendumID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::TriggerQuestAddendum(const struct FGuid& QuestID, int32 AddendumID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "TriggerQuestAddendum");

	Params::Scripts_TriggerQuestAddendum Parms{};

	Parms.QuestID = std::move(QuestID);
	Parms.AddendumID = AddendumID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.TriggerQuestEndState
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EndStateID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::TriggerQuestEndState(const struct FGuid& QuestID, int32 EndStateID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "TriggerQuestEndState");

	Params::Scripts_TriggerQuestEndState Parms{};

	Parms.QuestID = std::move(QuestID);
	Parms.EndStateID = EndStateID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.TriggerQuestFailState
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EndStateID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::TriggerQuestFailState(const struct FGuid& QuestID, int32 EndStateID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "TriggerQuestFailState");

	Params::Scripts_TriggerQuestFailState Parms{};

	Parms.QuestID = std::move(QuestID);
	Parms.EndStateID = EndStateID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.UnbarOCL
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            OCLObjectID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::UnbarOCL(const struct FGuid& OCLObjectID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "UnbarOCL");

	Params::Scripts_UnbarOCL Parms{};

	Parms.OCLObjectID = std::move(OCLObjectID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.UnlockCompanion
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            CompanionID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::UnlockCompanion(const struct FGuid& CompanionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "UnlockCompanion");

	Params::Scripts_UnlockCompanion Parms{};

	Parms.CompanionID = std::move(CompanionID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.UnlockComputer
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            ComputerObjectID                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::UnlockComputer(const struct FGuid& ComputerObjectID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "UnlockComputer");

	Params::Scripts_UnlockComputer Parms{};

	Parms.ComputerObjectID = std::move(ComputerObjectID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.UnlockOCL
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            OCLObjectID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::UnlockOCL(const struct FGuid& OCLObjectID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "UnlockOCL");

	Params::Scripts_UnlockOCL Parms{};

	Parms.OCLObjectID = std::move(OCLObjectID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.Scripts.UnsealOCL
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            OCLObjectID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScripts::UnsealOCL(const struct FGuid& OCLObjectID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Scripts", "UnsealOCL");

	Params::Scripts_UnsealOCL Parms{};

	Parms.OCLObjectID = std::move(OCLObjectID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SelectedNotificationWidget.OnFadeOutAnimationEnd
// (Final, Native, Public, BlueprintCallable)

void USelectedNotificationWidget::OnFadeOutAnimationEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectedNotificationWidget", "OnFadeOutAnimationEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SelectedNotificationWidget.OnFadeRightAnimationEnd
// (Final, Native, Public, BlueprintCallable)

void USelectedNotificationWidget::OnFadeRightAnimationEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectedNotificationWidget", "OnFadeRightAnimationEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SelectedNotificationWidget.PlayFadeOutAnimation
// (Event, Public, BlueprintEvent)

void USelectedNotificationWidget::PlayFadeOutAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectedNotificationWidget", "PlayFadeOutAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.SelectedNotificationWidget.PlayNotificationAnimation
// (Event, Protected, BlueprintEvent)

void USelectedNotificationWidget::PlayNotificationAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectedNotificationWidget", "PlayNotificationAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.SelectedNotificationWidget.StopFadeOutAnimation
// (Event, Public, BlueprintEvent)

void USelectedNotificationWidget::StopFadeOutAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectedNotificationWidget", "StopFadeOutAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.SettingsMenuButtonSlotWidget.OnButtonClicked
// (Final, Native, Protected)

void USettingsMenuButtonSlotWidget::OnButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuButtonSlotWidget", "OnButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SystemMapSelectionEntryWidget.OnEntryHoveredFocused
// (Final, Native, Protected)

void USystemMapSelectionEntryWidget::OnEntryHoveredFocused()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SystemMapSelectionEntryWidget", "OnEntryHoveredFocused");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SystemMapSelectionEntryWidget.OnEntryUnhoveredUnfocused
// (Final, Native, Protected)

void USystemMapSelectionEntryWidget::OnEntryUnhoveredUnfocused()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SystemMapSelectionEntryWidget", "OnEntryUnhoveredUnfocused");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuCheckBoxWidget.OnValueChanged
// (Final, Native, Protected)
// Parameters:
// class UButtonBase*                      Button                                                 (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USettingsMenuCheckBoxWidget::OnValueChanged(const class UButtonBase* Button)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuCheckBoxWidget", "OnValueChanged");

	Params::SettingsMenuCheckBoxWidget_OnValueChanged Parms{};

	Parms.Button = Button;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuInputKeySelector.OnClicked
// (Final, Native, Protected)

void USettingsMenuInputKeySelector::OnClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuInputKeySelector", "OnClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuInputKeySelector.OnRightClicked
// (Final, Native, Protected)

void USettingsMenuInputKeySelector::OnRightClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuInputKeySelector", "OnRightClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StackSplittingWidget.OnInputBack
// (Final, Native, Protected)

void UStackSplittingWidget::OnInputBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StackSplittingWidget", "OnInputBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StackSplittingWidget.OnInputConfirm
// (Final, Native, Protected)

void UStackSplittingWidget::OnInputConfirm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StackSplittingWidget", "OnInputConfirm");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StackSplittingWidget.OnSliderValueChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FSliderEvent                     Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UStackSplittingWidget::OnSliderValueChanged(const struct FSliderEvent& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StackSplittingWidget", "OnSliderValueChanged");

	Params::StackSplittingWidget_OnSliderValueChanged Parms{};

	Parms.Event = std::move(Event);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StackSplittingWidget.OnStackSplitMax
// (Final, Native, Protected)

void UStackSplittingWidget::OnStackSplitMax()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StackSplittingWidget", "OnStackSplitMax");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StackSplittingWidget.OnStackSplitMin
// (Final, Native, Protected)

void UStackSplittingWidget::OnStackSplitMin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StackSplittingWidget", "OnStackSplitMin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StackSplittingWidget.SetNewBackingMaterialHeight
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   NewHeight                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStackSplittingWidget::SetNewBackingMaterialHeight(float NewHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StackSplittingWidget", "SetNewBackingMaterialHeight");

	Params::StackSplittingWidget_SetNewBackingMaterialHeight Parms{};

	Parms.NewHeight = NewHeight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.SettingsMenuKeyRebindWidget.OnBack
// (Final, Native, Protected)

void USettingsMenuKeyRebindWidget::OnBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuKeyRebindWidget", "OnBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuKeyRebindWidget.OnContainerClicked
// (Final, Native, Protected)

void USettingsMenuKeyRebindWidget::OnContainerClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuKeyRebindWidget", "OnContainerClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuKeyRebindWidget.OnKeySelected
// (Final, Native, Protected)
// Parameters:
// struct FInputChord                      InputChord                                             (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USettingsMenuKeyRebindWidget::OnKeySelected(const struct FInputChord& InputChord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuKeyRebindWidget", "OnKeySelected");

	Params::SettingsMenuKeyRebindWidget_OnKeySelected Parms{};

	Parms.InputChord = std::move(InputChord);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuKeyRebindWidget.OnPrimaryIsSelectingKeyChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bIsSelectingKey                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USettingsMenuKeyRebindWidget::OnPrimaryIsSelectingKeyChanged(bool bIsSelectingKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuKeyRebindWidget", "OnPrimaryIsSelectingKeyChanged");

	Params::SettingsMenuKeyRebindWidget_OnPrimaryIsSelectingKeyChanged Parms{};

	Parms.bIsSelectingKey = bIsSelectingKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuKeyRebindWidget.OnSecondaryIsSelectingKeyChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bIsSelectingKey                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USettingsMenuKeyRebindWidget::OnSecondaryIsSelectingKeyChanged(bool bIsSelectingKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuKeyRebindWidget", "OnSecondaryIsSelectingKeyChanged");

	Params::SettingsMenuKeyRebindWidget_OnSecondaryIsSelectingKeyChanged Parms{};

	Parms.bIsSelectingKey = bIsSelectingKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuOptionPresenterWdgt.OnValueChanged
// (Final, Native, Public)
// Parameters:
// int32                                   SelectedItem                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USettingsMenuOptionPresenterWdgt::OnValueChanged(int32 SelectedItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuOptionPresenterWdgt", "OnValueChanged");

	Params::SettingsMenuOptionPresenterWdgt_OnValueChanged Parms{};

	Parms.SelectedItem = SelectedItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SettingsMenuSliderWidget.OnValueChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FSliderEvent                     Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void USettingsMenuSliderWidget::OnValueChanged(const struct FSliderEvent& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsMenuSliderWidget", "OnValueChanged");

	Params::SettingsMenuSliderWidget_OnValueChanged Parms{};

	Parms.Event = std::move(Event);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SkillGroupDetailWidget.OnSkillSelected
// (Event, Public, BlueprintEvent)

void USkillGroupDetailWidget::OnSkillSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillGroupDetailWidget", "OnSkillSelected");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.SpreadManagerComponent.OnAttack
// (Final, Native, Private)
// Parameters:
// float                                   DurationScalar                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpreadManagerComponent::OnAttack(float DurationScalar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpreadManagerComponent", "OnAttack");

	Params::SpreadManagerComponent_OnAttack Parms{};

	Parms.DurationScalar = DurationScalar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SpreadManagerComponent.OnCombatStateChange
// (Final, Native, Private)
// Parameters:
// bool                                    bInCombat                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpreadManagerComponent::OnCombatStateChange(bool bInCombat, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpreadManagerComponent", "OnCombatStateChange");

	Params::SpreadManagerComponent_OnCombatStateChange Parms{};

	Parms.bInCombat = bInCombat;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StaminaComponent.OnCauseDamage
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FCauseDamageInfo                 CauseDamageInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UStaminaComponent::OnCauseDamage(const struct FCauseDamageInfo& CauseDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "OnCauseDamage");

	Params::StaminaComponent_OnCauseDamage Parms{};

	Parms.CauseDamageInfo = std::move(CauseDamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StaminaComponent.StaminaConsume
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaminaComponent::StaminaConsume(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "StaminaConsume");

	Params::StaminaComponent_StaminaConsume Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StaminaComponent.StaminaReplenish
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaminaComponent::StaminaReplenish(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "StaminaReplenish");

	Params::StaminaComponent_StaminaReplenish Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StaminaComponent.GetMaxValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UStaminaComponent::GetMaxValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "GetMaxValue");

	Params::StaminaComponent_GetMaxValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.StaminaComponent.GetNormalizedValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UStaminaComponent::GetNormalizedValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "GetNormalizedValue");

	Params::StaminaComponent_GetNormalizedValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.StaminaComponent.GetValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UStaminaComponent::GetValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaComponent", "GetValue");

	Params::StaminaComponent_GetValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.StatsPerksPageWidget.OnAcceptAllocations
// (Final, Native, Protected)

void UStatsPerksPageWidget::OnAcceptAllocations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsPerksPageWidget", "OnAcceptAllocations");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatsPerksPageWidget.OnAllocation
// (Final, Native, Protected)

void UStatsPerksPageWidget::OnAllocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsPerksPageWidget", "OnAllocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatsPerksPageWidget.OnDeallocation
// (Final, Native, Protected)

void UStatsPerksPageWidget::OnDeallocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsPerksPageWidget", "OnDeallocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatsPerksPageWidget.OnInputBack
// (Final, Native, Protected)

void UStatsPerksPageWidget::OnInputBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsPerksPageWidget", "OnInputBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatsPerksPageWidget.OnRevertAllocationsClicked
// (Final, Native, Protected)

void UStatsPerksPageWidget::OnRevertAllocationsClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsPerksPageWidget", "OnRevertAllocationsClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatsSkillsPageWidget.OnAllocation
// (Final, Native, Public)

void UStatsSkillsPageWidget::OnAllocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsSkillsPageWidget", "OnAllocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatsSkillsPageWidget.OnInputBack
// (Final, Native, Protected)

void UStatsSkillsPageWidget::OnInputBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsSkillsPageWidget", "OnInputBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatsSkillsPageWidget.OnLedgerToggle
// (Final, Native, Protected)

void UStatsSkillsPageWidget::OnLedgerToggle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsSkillsPageWidget", "OnLedgerToggle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatsSkillsPageWidget.OnPlayerLevelUp
// (Final, Native, Protected)
// Parameters:
// int32                                   NewLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatsSkillsPageWidget::OnPlayerLevelUp(int32 NewLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsSkillsPageWidget", "OnPlayerLevelUp");

	Params::StatsSkillsPageWidget_OnPlayerLevelUp Parms{};

	Parms.NewLevel = NewLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatsSkillsPageWidget.OnResetAllAllocations
// (Final, Native, Public)

void UStatsSkillsPageWidget::OnResetAllAllocations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsSkillsPageWidget", "OnResetAllAllocations");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatsSkillsPageWidget.OnSkillUpdated
// (Final, Native, Protected)
// Parameters:
// ESkill                                  Skill                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatsSkillsPageWidget::OnSkillUpdated(ESkill Skill, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsSkillsPageWidget", "OnSkillUpdated");

	Params::StatsSkillsPageWidget_OnSkillUpdated Parms{};

	Parms.Skill = Skill;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusEffectManagerComponent.AddStatusEffect
// (Final, Exec, Native, Protected)
// Parameters:
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffectManagerComponent::AddStatusEffect(const class FString& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectManagerComponent", "AddStatusEffect");

	Params::StatusEffectManagerComponent_AddStatusEffect Parms{};

	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusEffectManagerComponent.AddStatusEffectNPC
// (Final, Exec, Native, Protected)
// Parameters:
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffectManagerComponent::AddStatusEffectNPC(const class FString& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectManagerComponent", "AddStatusEffectNPC");

	Params::StatusEffectManagerComponent_AddStatusEffectNPC Parms{};

	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusEffectManagerComponent.AddStatusEffectToCompanions
// (Final, Exec, Native, Protected)
// Parameters:
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffectManagerComponent::AddStatusEffectToCompanions(const class FString& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectManagerComponent", "AddStatusEffectToCompanions");

	Params::StatusEffectManagerComponent_AddStatusEffectToCompanions Parms{};

	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusEffectManagerComponent.BPAddEffect
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class UStatusEffect>        Data                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TScriptInterface<class IStatusEffectOrigin>Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// struct FDynamicEffectProperties         AddProperties                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UStatusEffect*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStatusEffect* UStatusEffectManagerComponent::BPAddEffect(TSubclassOf<class UStatusEffect> Data, TScriptInterface<class IStatusEffectOrigin> Origin, const struct FDynamicEffectProperties& AddProperties)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectManagerComponent", "BPAddEffect");

	Params::StatusEffectManagerComponent_BPAddEffect Parms{};

	Parms.Data = Data;
	Parms.Origin = Origin;
	Parms.AddProperties = std::move(AddProperties);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.StatusEffectManagerComponent.ClearAllStatusEffects
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bOnlyHostile                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffectManagerComponent::ClearAllStatusEffects(bool bOnlyHostile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectManagerComponent", "ClearAllStatusEffects");

	Params::StatusEffectManagerComponent_ClearAllStatusEffects Parms{};

	Parms.bOnlyHostile = bOnlyHostile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusEffectManagerComponent.ClearAllStatusEffectsNPC
// (Final, Exec, Native, Protected)
// Parameters:
// bool                                    bOnlyHostile                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffectManagerComponent::ClearAllStatusEffectsNPC(bool bOnlyHostile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectManagerComponent", "ClearAllStatusEffectsNPC");

	Params::StatusEffectManagerComponent_ClearAllStatusEffectsNPC Parms{};

	Parms.bOnlyHostile = bOnlyHostile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusEffectManagerComponent.ClearAllStatusEffectsOnCompanions
// (Final, Exec, Native, Protected)
// Parameters:
// bool                                    bOnlyHostile                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffectManagerComponent::ClearAllStatusEffectsOnCompanions(bool bOnlyHostile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectManagerComponent", "ClearAllStatusEffectsOnCompanions");

	Params::StatusEffectManagerComponent_ClearAllStatusEffectsOnCompanions Parms{};

	Parms.bOnlyHostile = bOnlyHostile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusEffectManagerComponent.ClearStatusEffect
// (Final, Exec, Native, Protected)
// Parameters:
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffectManagerComponent::ClearStatusEffect(const class FString& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectManagerComponent", "ClearStatusEffect");

	Params::StatusEffectManagerComponent_ClearStatusEffect Parms{};

	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusEffectManagerComponent.ClearStatusEffectNPC
// (Final, Exec, Native, Protected)
// Parameters:
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffectManagerComponent::ClearStatusEffectNPC(const class FString& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectManagerComponent", "ClearStatusEffectNPC");

	Params::StatusEffectManagerComponent_ClearStatusEffectNPC Parms{};

	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusEffectManagerComponent.ClearStatusEffectOnCompanions
// (Final, Exec, Native, Protected)
// Parameters:
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffectManagerComponent::ClearStatusEffectOnCompanions(const class FString& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectManagerComponent", "ClearStatusEffectOnCompanions");

	Params::StatusEffectManagerComponent_ClearStatusEffectOnCompanions Parms{};

	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusEffectManagerComponent.OnNewStateOfBeing
// (Final, Native, Private)
// Parameters:
// EStateOfBeing                           NewStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStateOfBeing                           OldStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffectManagerComponent::OnNewStateOfBeing(EStateOfBeing NewStateOfBeing, EStateOfBeing OldStateOfBeing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectManagerComponent", "OnNewStateOfBeing");

	Params::StatusEffectManagerComponent_OnNewStateOfBeing Parms{};

	Parms.NewStateOfBeing = NewStateOfBeing;
	Parms.OldStateOfBeing = OldStateOfBeing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusEffectManagerComponent.OnRestoredStateOfBeing
// (Final, Native, Private)
// Parameters:
// EStateOfBeing                           RestoredStateOfBeing                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffectManagerComponent::OnRestoredStateOfBeing(EStateOfBeing RestoredStateOfBeing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectManagerComponent", "OnRestoredStateOfBeing");

	Params::StatusEffectManagerComponent_OnRestoredStateOfBeing Parms{};

	Parms.RestoredStateOfBeing = RestoredStateOfBeing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusEffectManagerComponent.PreventAllStatusEffects
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bPreventStatusEffectsIn                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldClear                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffectManagerComponent::PreventAllStatusEffects(bool bPreventStatusEffectsIn, bool bShouldClear)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectManagerComponent", "PreventAllStatusEffects");

	Params::StatusEffectManagerComponent_PreventAllStatusEffects Parms{};

	Parms.bPreventStatusEffectsIn = bPreventStatusEffectsIn;
	Parms.bShouldClear = bShouldClear;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusEffectManagerComponent.PreventAllStatusEffectsNPC
// (Final, Exec, Native, Protected)
// Parameters:
// bool                                    bPreventStatusEffectsIn                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldClear                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffectManagerComponent::PreventAllStatusEffectsNPC(bool bPreventStatusEffectsIn, bool bShouldClear)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectManagerComponent", "PreventAllStatusEffectsNPC");

	Params::StatusEffectManagerComponent_PreventAllStatusEffectsNPC Parms{};

	Parms.bPreventStatusEffectsIn = bPreventStatusEffectsIn;
	Parms.bShouldClear = bShouldClear;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusEffectManagerComponent.PreventAllStatusEffectsOnCompanions
// (Final, Exec, Native, Protected)
// Parameters:
// bool                                    bPreventStatusEffectsIn                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldClear                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffectManagerComponent::PreventAllStatusEffectsOnCompanions(bool bPreventStatusEffectsIn, bool bShouldClear)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectManagerComponent", "PreventAllStatusEffectsOnCompanions");

	Params::StatusEffectManagerComponent_PreventAllStatusEffectsOnCompanions Parms{};

	Parms.bPreventStatusEffectsIn = bPreventStatusEffectsIn;
	Parms.bShouldClear = bShouldClear;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusEffectManagerComponent.PreventHostileStatusEffects
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bPreventHostileStatusEffectsIn                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldClear                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffectManagerComponent::PreventHostileStatusEffects(bool bPreventHostileStatusEffectsIn, bool bShouldClear)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectManagerComponent", "PreventHostileStatusEffects");

	Params::StatusEffectManagerComponent_PreventHostileStatusEffects Parms{};

	Parms.bPreventHostileStatusEffectsIn = bPreventHostileStatusEffectsIn;
	Parms.bShouldClear = bShouldClear;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusEffectManagerComponent.PreventHostileStatusEffectsNPC
// (Final, Exec, Native, Protected)
// Parameters:
// bool                                    bPreventHostileStatusEffectsIn                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldClear                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffectManagerComponent::PreventHostileStatusEffectsNPC(bool bPreventHostileStatusEffectsIn, bool bShouldClear)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectManagerComponent", "PreventHostileStatusEffectsNPC");

	Params::StatusEffectManagerComponent_PreventHostileStatusEffectsNPC Parms{};

	Parms.bPreventHostileStatusEffectsIn = bPreventHostileStatusEffectsIn;
	Parms.bShouldClear = bShouldClear;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusEffectManagerComponent.PreventHostileStatusEffectsOnCompanions
// (Final, Exec, Native, Protected)
// Parameters:
// bool                                    bPreventHostileStatusEffectsIn                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldClear                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffectManagerComponent::PreventHostileStatusEffectsOnCompanions(bool bPreventHostileStatusEffectsIn, bool bShouldClear)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectManagerComponent", "PreventHostileStatusEffectsOnCompanions");

	Params::StatusEffectManagerComponent_PreventHostileStatusEffectsOnCompanions Parms{};

	Parms.bPreventHostileStatusEffectsIn = bPreventHostileStatusEffectsIn;
	Parms.bShouldClear = bShouldClear;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StatusEffectManagerComponent.RemoveStatusEffectsOfClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UStatusEffect>        Data                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffectManagerComponent::RemoveStatusEffectsOfClass(TSubclassOf<class UStatusEffect> Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectManagerComponent", "RemoveStatusEffectsOfClass");

	Params::StatusEffectManagerComponent_RemoveStatusEffectsOfClass Parms{};

	Parms.Data = Data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StealthComponent.OnBumped
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           SelfActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UStealthComponent::OnBumped(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StealthComponent", "OnBumped");

	Params::StealthComponent_OnBumped Parms{};

	Parms.SelfActor = SelfActor;
	Parms.OtherActor = OtherActor;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StealthComponent.OnPickpocketDetectionChange
// (Final, Native, Protected)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAlertState                             PreviousAlertState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAlertState                             TargetAlertState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStealthComponent::OnPickpocketDetectionChange(class AActor* TargetActor, EAlertState PreviousAlertState, EAlertState TargetAlertState, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StealthComponent", "OnPickpocketDetectionChange");

	Params::StealthComponent_OnPickpocketDetectionChange Parms{};

	Parms.TargetActor = TargetActor;
	Parms.PreviousAlertState = PreviousAlertState;
	Parms.TargetAlertState = TargetAlertState;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StealthComponent.OnStartStealth
// (Final, Native, Protected)

void UStealthComponent::OnStartStealth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StealthComponent", "OnStartStealth");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.StealthComponent.OnStopStealth
// (Final, Native, Protected)

void UStealthComponent::OnStopStealth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StealthComponent", "OnStopStealth");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SubtitleManagerWidget.GetCorrectName
// (Final, Native, Protected)
// Parameters:
// class FText                             currentName                                            (Parm, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USubtitleManagerWidget::GetCorrectName(const class FText& currentName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitleManagerWidget", "GetCorrectName");

	Params::SubtitleManagerWidget_GetCorrectName Parms{};

	Parms.currentName = std::move(currentName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.SubtitleManagerWidget.OnCinematicSubtitleVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USubtitleManagerWidget::OnCinematicSubtitleVisibilityChanged(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitleManagerWidget", "OnCinematicSubtitleVisibilityChanged");

	Params::SubtitleManagerWidget_OnCinematicSubtitleVisibilityChanged Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SurvivalBarWidget.OnDifficultyChanged
// (Final, Native, Protected)
// Parameters:
// EGameDifficulty                         DifficultyIn                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivalBarWidget::OnDifficultyChanged(EGameDifficulty DifficultyIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivalBarWidget", "OnDifficultyChanged");

	Params::SurvivalBarWidget_OnDifficultyChanged Parms{};

	Parms.DifficultyIn = DifficultyIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SwitchAudioComponent.Play
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESwitchEventType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USwitchAudioComponent::Play(ESwitchEventType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwitchAudioComponent", "Play");

	Params::SwitchAudioComponent_Play Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.SwitchAudioComponent.Stop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESwitchEventType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USwitchAudioComponent::Stop(ESwitchEventType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwitchAudioComponent", "Stop");

	Params::SwitchAudioComponent_Stop Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TargetableComponent.OnActionToggled
// (Final, Native, Private)
// Parameters:
// ETogglableAction                        ToggleActionType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsToggled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTargetableComponent::OnActionToggled(ETogglableAction ToggleActionType, bool bIsToggled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetableComponent", "OnActionToggled");

	Params::TargetableComponent_OnActionToggled Parms{};

	Parms.ToggleActionType = ToggleActionType;
	Parms.bIsToggled = bIsToggled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TargetableComponent.OnStateOfBeingChanged
// (Final, Native, Private)
// Parameters:
// EStateOfBeing                           NewStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStateOfBeing                           OldStateOfBeing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTargetableComponent::OnStateOfBeingChanged(EStateOfBeing NewStateOfBeing, EStateOfBeing OldStateOfBeing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetableComponent", "OnStateOfBeingChanged");

	Params::TargetableComponent_OnStateOfBeingChanged Parms{};

	Parms.NewStateOfBeing = NewStateOfBeing;
	Parms.OldStateOfBeing = OldStateOfBeing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TeamManager.BPGetRelationship
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UTeamData>            SourceTeamData                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UTeamData>            OtherTeamData                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETeamAttitude                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETeamAttitude UTeamManager::BPGetRelationship(TSubclassOf<class UTeamData> SourceTeamData, TSubclassOf<class UTeamData> OtherTeamData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TeamManager", "BPGetRelationship");

	Params::TeamManager_BPGetRelationship Parms{};

	Parms.SourceTeamData = SourceTeamData;
	Parms.OtherTeamData = OtherTeamData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.TeamManager.BPSetRelationship
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UBaseTeamData>        SourceTeamData                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UBaseTeamData>        OtherTeamData                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETeamAttitude                           Relationship                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMutual                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTeamManager::BPSetRelationship(TSubclassOf<class UBaseTeamData> SourceTeamData, TSubclassOf<class UBaseTeamData> OtherTeamData, ETeamAttitude Relationship, bool bMutual)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TeamManager", "BPSetRelationship");

	Params::TeamManager_BPSetRelationship Parms{};

	Parms.SourceTeamData = SourceTeamData;
	Parms.OtherTeamData = OtherTeamData;
	Parms.Relationship = Relationship;
	Parms.bMutual = bMutual;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TelemetryComponent.OnCharacterKilled
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FCauseDamageInfo                 CauseDamageInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UTelemetryComponent::OnCharacterKilled(const struct FCauseDamageInfo& CauseDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TelemetryComponent", "OnCharacterKilled");

	Params::TelemetryComponent_OnCharacterKilled Parms{};

	Parms.CauseDamageInfo = std::move(CauseDamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TelemetryComponent.OnCombatStateChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bInCombat                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoring                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTelemetryComponent::OnCombatStateChanged(bool bInCombat, bool bRestoring)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TelemetryComponent", "OnCombatStateChanged");

	Params::TelemetryComponent_OnCombatStateChanged Parms{};

	Parms.bInCombat = bInCombat;
	Parms.bRestoring = bRestoring;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TelemetryComponent.OnEndGameSession
// (Final, Native, Protected)
// Parameters:
// EEndPlayReason                          EndPlayReason                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTelemetryComponent::OnEndGameSession(const EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TelemetryComponent", "OnEndGameSession");

	Params::TelemetryComponent_OnEndGameSession Parms{};

	Parms.EndPlayReason = EndPlayReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TelemetryComponent.OnLevelChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTelemetryComponent::OnLevelChanged(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TelemetryComponent", "OnLevelChanged");

	Params::TelemetryComponent_OnLevelChanged Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TelemetryComponent.OnMedKitUsed
// (Final, Native, Protected)
// Parameters:
// int32                                   ConsumablesUsed                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTelemetryComponent::OnMedKitUsed(int32 ConsumablesUsed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TelemetryComponent", "OnMedKitUsed");

	Params::TelemetryComponent_OnMedKitUsed Parms{};

	Parms.ConsumablesUsed = ConsumablesUsed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TelemetryComponent.OnPlayerMove
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MapName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTelemetryComponent::OnPlayerMove(const struct FVector& Location, const class FString& MapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TelemetryComponent", "OnPlayerMove");

	Params::TelemetryComponent_OnPlayerMove Parms{};

	Parms.Location = std::move(Location);
	Parms.MapName = std::move(MapName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TelemetryComponent.OnPlayerZoneChange
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NewMapName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OldMapName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTelemetryComponent::OnPlayerZoneChange(const struct FVector& Location, const class FString& NewMapName, const class FString& OldMapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TelemetryComponent", "OnPlayerZoneChange");

	Params::TelemetryComponent_OnPlayerZoneChange Parms{};

	Parms.Location = std::move(Location);
	Parms.NewMapName = std::move(NewMapName);
	Parms.OldMapName = std::move(OldMapName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TelemetryComponent.OnStartGameSession
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// struct FGuid                            Guid                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTelemetryComponent::OnStartGameSession(const struct FGuid& Guid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TelemetryComponent", "OnStartGameSession");

	Params::TelemetryComponent_OnStartGameSession Parms{};

	Parms.Guid = std::move(Guid);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TelemetryComponent.OnTacticalTimeDialationEnded
// (Final, Native, Protected)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTelemetryComponent::OnTacticalTimeDialationEnded(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TelemetryComponent", "OnTacticalTimeDialationEnded");

	Params::TelemetryComponent_OnTacticalTimeDialationEnded Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TelemetryComponent.OnTacticalTimeDialationStarted
// (Final, Native, Protected)

void UTelemetryComponent::OnTacticalTimeDialationStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TelemetryComponent", "OnTacticalTimeDialationStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TelemetryComponent.OnTakeDamage
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FCauseDamageInfo                 CauseDamageInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UTelemetryComponent::OnTakeDamage(const struct FCauseDamageInfo& CauseDamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TelemetryComponent", "OnTakeDamage");

	Params::TelemetryComponent_OnTakeDamage Parms{};

	Parms.CauseDamageInfo = std::move(CauseDamageInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TelemetryComponent.OnVendorTransactionComplete
// (Final, Native, Protected, HasOutParams)
// Parameters:
// int32                                   BuyingBalance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SellingBalance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RepairingBalance                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FItemStackSplit                  ItemStackSplit                                         (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTelemetryComponent::OnVendorTransactionComplete(int32 BuyingBalance, int32 SellingBalance, int32 RepairingBalance, struct FItemStackSplit* ItemStackSplit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TelemetryComponent", "OnVendorTransactionComplete");

	Params::TelemetryComponent_OnVendorTransactionComplete Parms{};

	Parms.BuyingBalance = BuyingBalance;
	Parms.SellingBalance = SellingBalance;
	Parms.RepairingBalance = RepairingBalance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ItemStackSplit != nullptr)
		*ItemStackSplit = std::move(Parms.ItemStackSplit);
}


// Function Indiana.TextBlockBase.SetColorAndOpacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSlateColor                      InColorAndOpacity                                      (Parm, NativeAccessSpecifierPublic)

void UTextBlockBase::SetColorAndOpacity(const struct FSlateColor& InColorAndOpacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextBlockBase", "SetColorAndOpacity");

	Params::TextBlockBase_SetColorAndOpacity Parms{};

	Parms.InColorAndOpacity = std::move(InColorAndOpacity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TextBlockBase.SetFont
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSlateFontInfo                   InFontInfo                                             (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextBlockBase::SetFont(const struct FSlateFontInfo& InFontInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextBlockBase", "SetFont");

	Params::TextBlockBase_SetFont Parms{};

	Parms.InFontInfo = std::move(InFontInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TextBlockBase.SetOpacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InOpacity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextBlockBase::SetOpacity(float InOpacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextBlockBase", "SetOpacity");

	Params::TextBlockBase_SetOpacity Parms{};

	Parms.InOpacity = InOpacity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TextBlockBase.SetOutline
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FFontOutlineSettings             OutlineSettings                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextBlockBase::SetOutline(const struct FFontOutlineSettings& OutlineSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextBlockBase", "SetOutline");

	Params::TextBlockBase_SetOutline Parms{};

	Parms.OutlineSettings = std::move(OutlineSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TextBlockBase.SetShadowColorAndOpacity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InShadowColorAndOpacity                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextBlockBase::SetShadowColorAndOpacity(const struct FLinearColor& InShadowColorAndOpacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextBlockBase", "SetShadowColorAndOpacity");

	Params::TextBlockBase_SetShadowColorAndOpacity Parms{};

	Parms.InShadowColorAndOpacity = std::move(InShadowColorAndOpacity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TextBlockBase.SetShadowOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        InShadowOffset                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextBlockBase::SetShadowOffset(const struct FVector2D& InShadowOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextBlockBase", "SetShadowOffset");

	Params::TextBlockBase_SetShadowOffset Parms{};

	Parms.InShadowOffset = std::move(InShadowOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TextBlockBase.SetText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           inString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextBlockBase::SetText(const class FString& inString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextBlockBase", "SetText");

	Params::TextBlockBase_SetText Parms{};

	Parms.inString = std::move(inString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TextBlockBase.SetTextByLocString
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLocString                       LocString                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextBlockBase::SetTextByLocString(const struct FLocString& LocString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextBlockBase", "SetTextByLocString");

	Params::TextBlockBase_SetTextByLocString Parms{};

	Parms.LocString = std::move(LocString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TextBlockBase.UseTextStyleOutline
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldUse                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextBlockBase::UseTextStyleOutline(bool bShouldUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextBlockBase", "UseTextStyleOutline");

	Params::TextBlockBase_UseTextStyleOutline Parms{};

	Parms.bShouldUse = bShouldUse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TextBlockBase.UseTextStyleShadowOffset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldUse                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextBlockBase::UseTextStyleShadowOffset(bool bShouldUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextBlockBase", "UseTextStyleShadowOffset");

	Params::TextBlockBase_UseTextStyleShadowOffset Parms{};

	Parms.bShouldUse = bShouldUse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TextBlockBase.GetColorAndOpacity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSlateColor                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateColor UTextBlockBase::GetColorAndOpacity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextBlockBase", "GetColorAndOpacity");

	Params::TextBlockBase_GetColorAndOpacity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.TextBlockBase.GetFont
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSlateFontInfo                   ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FSlateFontInfo UTextBlockBase::GetFont() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextBlockBase", "GetFont");

	Params::TextBlockBase_GetFont Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.TextBlockBase.GetText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UTextBlockBase::GetText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextBlockBase", "GetText");

	Params::TextBlockBase_GetText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.TextBlockBase.IsEmpty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTextBlockBase::IsEmpty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextBlockBase", "IsEmpty");

	Params::TextBlockBase_IsEmpty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Indiana.TextEntryWidget.OnTextfieldChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class FText                             Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTextEntryWidget::OnTextfieldChanged(const class FText& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextEntryWidget", "OnTextfieldChanged");

	Params::TextEntryWidget_OnTextfieldChanged Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TextEntryWidget.OnTextfieldCommitted
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class FText                             Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ETextCommit                             CommitType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextEntryWidget::OnTextfieldCommitted(const class FText& Text, ETextCommit CommitType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextEntryWidget", "OnTextfieldCommitted");

	Params::TextEntryWidget_OnTextfieldCommitted Parms{};

	Parms.Text = std::move(Text);
	Parms.CommitType = CommitType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TinkeringWidget.SetNewBackingMaterialHeight
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   NewHeight                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTinkeringWidget::SetNewBackingMaterialHeight(float NewHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TinkeringWidget", "SetNewBackingMaterialHeight");

	Params::TinkeringWidget_SetNewBackingMaterialHeight Parms{};

	Parms.NewHeight = NewHeight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.TrapAudioComponent.Play
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETrapEventType                          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTrapAudioComponent::Play(ETrapEventType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrapAudioComponent", "Play");

	Params::TrapAudioComponent_Play Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TrapAudioComponent.Stop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETrapEventType                          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTrapAudioComponent::Stop(ETrapEventType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrapAudioComponent", "Stop");

	Params::TrapAudioComponent_Stop Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TrapEffectSource.GetCurrentActivators
// (Native, Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AIndianaCharacter*>        OutActivators                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ITrapEffectSource::GetCurrentActivators(TArray<class AIndianaCharacter*>* OutActivators)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrapEffectSource", "GetCurrentActivators");

	Params::TrapEffectSource_GetCurrentActivators Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActivators != nullptr)
		*OutActivators = std::move(Parms.OutActivators);
}


// Function Indiana.TrapEffectSource.ReceiveDeployOrder
// (Native, Event, Protected, BlueprintEvent)

void ITrapEffectSource::ReceiveDeployOrder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrapEffectSource", "ReceiveDeployOrder");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TrapEffectSource.ReceivePreDeploy
// (Native, Event, Protected, BlueprintEvent)

void ITrapEffectSource::ReceivePreDeploy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrapEffectSource", "ReceivePreDeploy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TrapEffectSource.ReceiveTriggerArmed
// (Native, Event, Protected, BlueprintEvent)

void ITrapEffectSource::ReceiveTriggerArmed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrapEffectSource", "ReceiveTriggerArmed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TrapEffectSource.ReceiveTriggerDisarmed
// (Native, Event, Protected, BlueprintEvent)

void ITrapEffectSource::ReceiveTriggerDisarmed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrapEffectSource", "ReceiveTriggerDisarmed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TrapEffectSource.ReceiveTriggerTripped
// (Native, Event, Protected, BlueprintEvent)

void ITrapEffectSource::ReceiveTriggerTripped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrapEffectSource", "ReceiveTriggerTripped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TrapEffectSource.ReceiveTriggerUntripped
// (Native, Event, Protected, BlueprintEvent)

void ITrapEffectSource::ReceiveTriggerUntripped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrapEffectSource", "ReceiveTriggerUntripped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.TutorialPopupStyleWidget.FadeInMascotImage
// (Event, Protected, BlueprintEvent)

void UTutorialPopupStyleWidget::FadeInMascotImage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialPopupStyleWidget", "FadeInMascotImage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Indiana.TutorialPopupStyleWidget.SetNewBackingMaterialHeight
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   NewHeight                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialPopupStyleWidget::SetNewBackingMaterialHeight(float NewHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialPopupStyleWidget", "SetNewBackingMaterialHeight");

	Params::TutorialPopupStyleWidget_SetNewBackingMaterialHeight Parms{};

	Parms.NewHeight = NewHeight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Indiana.VendorComponent.SetVendorContainer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AContainer*                       Container                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVendorComponent::SetVendorContainer(class AContainer* Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VendorComponent", "SetVendorContainer");

	Params::VendorComponent_SetVendorContainer Parms{};

	Parms.Container = Container;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.WaitTimeWidget.OnInputBack
// (Final, Native, Protected)

void UWaitTimeWidget::OnInputBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaitTimeWidget", "OnInputBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.WaitTimeWidget.OnInputConfirm
// (Final, Native, Protected)

void UWaitTimeWidget::OnInputConfirm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaitTimeWidget", "OnInputConfirm");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.WaitTimeWidget.OnSliderValueChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FSliderEvent                     Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UWaitTimeWidget::OnSliderValueChanged(const struct FSliderEvent& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaitTimeWidget", "OnSliderValueChanged");

	Params::WaitTimeWidget_OnSliderValueChanged Parms{};

	Parms.Event = std::move(Event);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Indiana.WeaponAnimInstance.WeaponCharging
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponAnimInstance::WeaponCharging() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimInstance", "WeaponCharging");

	Params::WeaponAnimInstance_WeaponCharging Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

