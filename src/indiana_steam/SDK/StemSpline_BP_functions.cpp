#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: StemSpline_BP

#include "Basic.hpp"

#include "StemSpline_BP_classes.hpp"
#include "StemSpline_BP_parameters.hpp"


namespace SDK
{

// Function StemSpline_BP.StemSpline_BP_C.UserConstructionScript
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AStemSpline_BP_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StemSpline_BP_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function StemSpline_BP.StemSpline_BP_C.FindStartPoint
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          StartLoc                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          StartNormal                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AStemSpline_BP_C::FindStartPoint(struct FVector* StartLoc, struct FVector* StartNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StemSpline_BP_C", "FindStartPoint");

	Params::StemSpline_BP_C_FindStartPoint Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (StartLoc != nullptr)
		*StartLoc = std::move(Parms.StartLoc);

	if (StartNormal != nullptr)
		*StartNormal = std::move(Parms.StartNormal);
}


// Function StemSpline_BP.StemSpline_BP_C.TraceTowardsDirection
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          StartLocation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          relativeNormal                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    forSubStem                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          HitLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          HitNormal                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          lastLocation                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          traceDirection                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    hitSomething                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AStemSpline_BP_C::TraceTowardsDirection(const struct FVector& StartLocation, const struct FVector& relativeNormal, bool forSubStem, struct FVector* HitLocation, struct FVector* HitNormal, struct FVector* lastLocation, struct FVector* traceDirection, bool* hitSomething)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StemSpline_BP_C", "TraceTowardsDirection");

	Params::StemSpline_BP_C_TraceTowardsDirection Parms{};

	Parms.StartLocation = std::move(StartLocation);
	Parms.relativeNormal = std::move(relativeNormal);
	Parms.forSubStem = forSubStem;

	UObject::ProcessEvent(Func, &Parms);

	if (HitLocation != nullptr)
		*HitLocation = std::move(Parms.HitLocation);

	if (HitNormal != nullptr)
		*HitNormal = std::move(Parms.HitNormal);

	if (lastLocation != nullptr)
		*lastLocation = std::move(Parms.lastLocation);

	if (traceDirection != nullptr)
		*traceDirection = std::move(Parms.traceDirection);

	if (hitSomething != nullptr)
		*hitSomething = Parms.hitSomething;
}


// Function StemSpline_BP.StemSpline_BP_C.TraceDown
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          StartLocation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          relativeNormal                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    forBridgeSeek                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          HitLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          HitNormal                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    hitSomething                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AStemSpline_BP_C::TraceDown(const struct FVector& StartLocation, const struct FVector& relativeNormal, bool forBridgeSeek, struct FVector* HitLocation, struct FVector* HitNormal, bool* hitSomething)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StemSpline_BP_C", "TraceDown");

	Params::StemSpline_BP_C_TraceDown Parms{};

	Parms.StartLocation = std::move(StartLocation);
	Parms.relativeNormal = std::move(relativeNormal);
	Parms.forBridgeSeek = forBridgeSeek;

	UObject::ProcessEvent(Func, &Parms);

	if (HitLocation != nullptr)
		*HitLocation = std::move(Parms.HitLocation);

	if (HitNormal != nullptr)
		*HitNormal = std::move(Parms.HitNormal);

	if (hitSomething != nullptr)
		*hitSomething = Parms.hitSomething;
}


// Function StemSpline_BP.StemSpline_BP_C.DoCheckSegment
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          StartLocation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          relativeNormal                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AStemSpline_BP_C::DoCheckSegment(const struct FVector& StartLocation, const struct FVector& relativeNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StemSpline_BP_C", "DoCheckSegment");

	Params::StemSpline_BP_C_DoCheckSegment Parms{};

	Parms.StartLocation = std::move(StartLocation);
	Parms.relativeNormal = std::move(relativeNormal);

	UObject::ProcessEvent(Func, &Parms);
}


// Function StemSpline_BP.StemSpline_BP_C.SearchForEdge
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          searchStartLocation                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          searchDirectionNormal                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    forSubStem                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    FoundAnEdge_                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          foundEdgeLocation                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          foundEdgeNormal                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AStemSpline_BP_C::SearchForEdge(const struct FVector& searchStartLocation, const struct FVector& searchDirectionNormal, bool forSubStem, bool* FoundAnEdge_, struct FVector* foundEdgeLocation, struct FVector* foundEdgeNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StemSpline_BP_C", "SearchForEdge");

	Params::StemSpline_BP_C_SearchForEdge Parms{};

	Parms.searchStartLocation = std::move(searchStartLocation);
	Parms.searchDirectionNormal = std::move(searchDirectionNormal);
	Parms.forSubStem = forSubStem;

	UObject::ProcessEvent(Func, &Parms);

	if (FoundAnEdge_ != nullptr)
		*FoundAnEdge_ = Parms.FoundAnEdge_;

	if (foundEdgeLocation != nullptr)
		*foundEdgeLocation = std::move(Parms.foundEdgeLocation);

	if (foundEdgeNormal != nullptr)
		*foundEdgeNormal = std::move(Parms.foundEdgeNormal);
}


// Function StemSpline_BP.StemSpline_BP_C.AddSplinePoints
// (Public, BlueprintCallable, BlueprintEvent)

void AStemSpline_BP_C::AddSplinePoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StemSpline_BP_C", "AddSplinePoints");

	UObject::ProcessEvent(Func, nullptr);
}


// Function StemSpline_BP.StemSpline_BP_C.AddSplineMeshes
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USplineComponent*                 SplineComponent                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AStemSpline_BP_C::AddSplineMeshes(class USplineComponent* SplineComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StemSpline_BP_C", "AddSplineMeshes");

	Params::StemSpline_BP_C_AddSplineMeshes Parms{};

	Parms.SplineComponent = SplineComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function StemSpline_BP.StemSpline_BP_C.AddSubStem
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          StartLoc                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          StartNormal                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   currentSubLevel                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AStemSpline_BP_C::AddSubStem(const struct FVector& StartLoc, const struct FVector& StartNormal, int32 currentSubLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StemSpline_BP_C", "AddSubStem");

	Params::StemSpline_BP_C_AddSubStem Parms{};

	Parms.StartLoc = std::move(StartLoc);
	Parms.StartNormal = std::move(StartNormal);
	Parms.currentSubLevel = currentSubLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function StemSpline_BP.StemSpline_BP_C.AddMeshesAlongSpline
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USplineComponent*                 SplineComp                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AStemSpline_BP_C::AddMeshesAlongSpline(class USplineComponent* SplineComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StemSpline_BP_C", "AddMeshesAlongSpline");

	Params::StemSpline_BP_C_AddMeshesAlongSpline Parms{};

	Parms.SplineComp = SplineComp;

	UObject::ProcessEvent(Func, &Parms);
}


// Function StemSpline_BP.StemSpline_BP_C.CheckIfContainsValueInRange
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<float>                           Array                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// float                                   Range__Min                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Range__Max                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Contains_                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AStemSpline_BP_C::CheckIfContainsValueInRange(TArray<float>& Array, float Range__Min, float Range__Max, bool* Contains_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StemSpline_BP_C", "CheckIfContainsValueInRange");

	Params::StemSpline_BP_C_CheckIfContainsValueInRange Parms{};

	Parms.Array = std::move(Array);
	Parms.Range__Min = Range__Min;
	Parms.Range__Max = Range__Max;

	UObject::ProcessEvent(Func, &Parms);

	Array = std::move(Parms.Array);

	if (Contains_ != nullptr)
		*Contains_ = Parms.Contains_;
}


// Function StemSpline_BP.StemSpline_BP_C.FindClosestValue
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<float>                           inArray                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// float                                   toValue                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   closestValueIndex_                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AStemSpline_BP_C::FindClosestValue(TArray<float>& inArray, float toValue, int32* closestValueIndex_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StemSpline_BP_C", "FindClosestValue");

	Params::StemSpline_BP_C_FindClosestValue Parms{};

	Parms.inArray = std::move(inArray);
	Parms.toValue = toValue;

	UObject::ProcessEvent(Func, &Parms);

	inArray = std::move(Parms.inArray);

	if (closestValueIndex_ != nullptr)
		*closestValueIndex_ = Parms.closestValueIndex_;
}


// Function StemSpline_BP.StemSpline_BP_C.CheckIfContainsVectorInDistance
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FVector>                  Array                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// float                                   inDistance                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Vector                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Contains_                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AStemSpline_BP_C::CheckIfContainsVectorInDistance(TArray<struct FVector>& Array, float inDistance, const struct FVector& Vector, bool* Contains_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StemSpline_BP_C", "CheckIfContainsVectorInDistance");

	Params::StemSpline_BP_C_CheckIfContainsVectorInDistance Parms{};

	Parms.Array = std::move(Array);
	Parms.inDistance = inDistance;
	Parms.Vector = std::move(Vector);

	UObject::ProcessEvent(Func, &Parms);

	Array = std::move(Parms.Array);

	if (Contains_ != nullptr)
		*Contains_ = Parms.Contains_;
}


// Function StemSpline_BP.StemSpline_BP_C.FindClosestVector
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FVector>                  inArray                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FVector                          toVector                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   closestValueIndex_                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AStemSpline_BP_C::FindClosestVector(TArray<struct FVector>& inArray, const struct FVector& toVector, int32* closestValueIndex_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StemSpline_BP_C", "FindClosestVector");

	Params::StemSpline_BP_C_FindClosestVector Parms{};

	Parms.inArray = std::move(inArray);
	Parms.toVector = std::move(toVector);

	UObject::ProcessEvent(Func, &Parms);

	inArray = std::move(Parms.inArray);

	if (closestValueIndex_ != nullptr)
		*closestValueIndex_ = Parms.closestValueIndex_;
}


// Function StemSpline_BP.StemSpline_BP_C.WorldLocToSplineTimeApprox
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          worldLoc                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Iterations                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   distanceTolerance_                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class USplineComponent*                 SplineComponent                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   StartTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   EndTime                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   bestTime                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AStemSpline_BP_C::WorldLocToSplineTimeApprox(const struct FVector& worldLoc, int32 Iterations, float distanceTolerance_, class USplineComponent* SplineComponent, float StartTime, float EndTime, float* bestTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StemSpline_BP_C", "WorldLocToSplineTimeApprox");

	Params::StemSpline_BP_C_WorldLocToSplineTimeApprox Parms{};

	Parms.worldLoc = std::move(worldLoc);
	Parms.Iterations = Iterations;
	Parms.distanceTolerance_ = distanceTolerance_;
	Parms.SplineComponent = SplineComponent;
	Parms.StartTime = StartTime;
	Parms.EndTime = EndTime;

	UObject::ProcessEvent(Func, &Parms);

	if (bestTime != nullptr)
		*bestTime = Parms.bestTime;
}


// Function StemSpline_BP.StemSpline_BP_C.FindBridgeEdge
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   maxSegmentChecks                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          fromWhere                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          StartNormal                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Direction                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          edgeLocation                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          edgeNormal                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AStemSpline_BP_C::FindBridgeEdge(int32 maxSegmentChecks, const struct FVector& fromWhere, const struct FVector& StartNormal, const struct FVector& Direction, bool* found, struct FVector* edgeLocation, struct FVector* edgeNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StemSpline_BP_C", "FindBridgeEdge");

	Params::StemSpline_BP_C_FindBridgeEdge Parms{};

	Parms.maxSegmentChecks = maxSegmentChecks;
	Parms.fromWhere = std::move(fromWhere);
	Parms.StartNormal = std::move(StartNormal);
	Parms.Direction = std::move(Direction);

	UObject::ProcessEvent(Func, &Parms);

	if (found != nullptr)
		*found = Parms.found;

	if (edgeLocation != nullptr)
		*edgeLocation = std::move(Parms.edgeLocation);

	if (edgeNormal != nullptr)
		*edgeNormal = std::move(Parms.edgeNormal);
}


// Function StemSpline_BP.StemSpline_BP_C.(Bridge)_TraceTowardsDirection
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          StartLocation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          relativeNormal                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Direction                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    hitSomething                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          lastLocation                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          HitLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          HitNormal                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          traceDirection                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AStemSpline_BP_C::_Bridge__TraceTowardsDirection(const struct FVector& StartLocation, const struct FVector& relativeNormal, const struct FVector& Direction, bool* hitSomething, struct FVector* lastLocation, struct FVector* HitLocation, struct FVector* HitNormal, struct FVector* traceDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StemSpline_BP_C", "(Bridge)_TraceTowardsDirection");

	Params::StemSpline_BP_C__Bridge__TraceTowardsDirection Parms{};

	Parms.StartLocation = std::move(StartLocation);
	Parms.relativeNormal = std::move(relativeNormal);
	Parms.Direction = std::move(Direction);

	UObject::ProcessEvent(Func, &Parms);

	if (hitSomething != nullptr)
		*hitSomething = Parms.hitSomething;

	if (lastLocation != nullptr)
		*lastLocation = std::move(Parms.lastLocation);

	if (HitLocation != nullptr)
		*HitLocation = std::move(Parms.HitLocation);

	if (HitNormal != nullptr)
		*HitNormal = std::move(Parms.HitNormal);

	if (traceDirection != nullptr)
		*traceDirection = std::move(Parms.traceDirection);
}


// Function StemSpline_BP.StemSpline_BP_C.SeekForBridge
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          StartLoc                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          StartNormal                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bridgeBuilt                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// TArray<struct FVector>                  bridgePoints                                           (Parm, OutParm)
// struct FVector                          newSurfaceNormal                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AStemSpline_BP_C::SeekForBridge(const struct FVector& StartLoc, const struct FVector& StartNormal, bool* bridgeBuilt, TArray<struct FVector>* bridgePoints, struct FVector* newSurfaceNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StemSpline_BP_C", "SeekForBridge");

	Params::StemSpline_BP_C_SeekForBridge Parms{};

	Parms.StartLoc = std::move(StartLoc);
	Parms.StartNormal = std::move(StartNormal);

	UObject::ProcessEvent(Func, &Parms);

	if (bridgeBuilt != nullptr)
		*bridgeBuilt = Parms.bridgeBuilt;

	if (bridgePoints != nullptr)
		*bridgePoints = std::move(Parms.bridgePoints);

	if (newSurfaceNormal != nullptr)
		*newSurfaceNormal = std::move(Parms.newSurfaceNormal);
}


// Function StemSpline_BP.StemSpline_BP_C.[SubStem]-DoCheckSegment
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          StartLocation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          relativeNormal                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   currentSubLevel                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AStemSpline_BP_C::_SubStem__DoCheckSegment(const struct FVector& StartLocation, const struct FVector& relativeNormal, int32 currentSubLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StemSpline_BP_C", "[SubStem]-DoCheckSegment");

	Params::StemSpline_BP_C__SubStem__DoCheckSegment Parms{};

	Parms.StartLocation = std::move(StartLocation);
	Parms.relativeNormal = std::move(relativeNormal);
	Parms.currentSubLevel = currentSubLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function StemSpline_BP.StemSpline_BP_C.AddSkelMeshesAlongSpline
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USplineComponent*                 SplineComp                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AStemSpline_BP_C::AddSkelMeshesAlongSpline(class USplineComponent* SplineComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StemSpline_BP_C", "AddSkelMeshesAlongSpline");

	Params::StemSpline_BP_C_AddSkelMeshesAlongSpline Parms{};

	Parms.SplineComp = SplineComp;

	UObject::ProcessEvent(Func, &Parms);
}

}

