#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Indiana

#include "Basic.hpp"

#include "SlateCore_structs.hpp"
#include "Engine_structs.hpp"
#include "InputCore_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "AIModule_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "AnimGraphRuntime_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "../UnrealContainers.hpp"


namespace SDK
{

// Enum Indiana.EDamageEventType
// NumValues: 0x0005
enum class EDamageEventType : uint8
{
	Invalid                                  = 0,
	Point                                    = 1,
	Radial                                   = 2,
	Generic                                  = 3,
	EDamageEventType_MAX                     = 4,
};

// Enum Indiana.EPhaseOfDay
// NumValues: 0x0006
enum class EPhaseOfDay : uint8
{
	Morning                                  = 0,
	Midday                                   = 1,
	Afternoon                                = 2,
	Evening                                  = 3,
	Night                                    = 4,
	EPhaseOfDay_MAX                          = 5,
};

// Enum Indiana.EDodgeDirection
// NumValues: 0x0007
enum class EDodgeDirection : uint8
{
	Invalid                                  = 0,
	Back                                     = 1,
	Left                                     = 2,
	Right                                    = 3,
	Forward                                  = 4,
	Count                                    = 5,
	EDodgeDirection_MAX                      = 6,
};

// Enum Indiana.EFootstepType
// NumValues: 0x0006
enum class EFootstepType : uint8
{
	Run                                      = 0,
	Sprint                                   = 1,
	Crouched                                 = 2,
	Climb                                    = 3,
	Count                                    = 4,
	EFootstepType_MAX                        = 5,
};

// Enum Indiana.EFootID
// NumValues: 0x0013
enum class EFootID : uint8
{
	None                                     = 0,
	LeftFoot                                 = 1,
	RightFoot                                = 2,
	Foot3                                    = 3,
	Foot4                                    = 4,
	Foot5                                    = 5,
	Foot6                                    = 6,
	Foot7                                    = 7,
	Foot8                                    = 8,
	Foot9                                    = 9,
	Foot10                                   = 10,
	Foot11                                   = 11,
	Foot12                                   = 12,
	Foot13                                   = 13,
	Foot14                                   = 14,
	Foot15                                   = 15,
	Foot16                                   = 16,
	NumFeetID                                = 17,
	EFootID_MAX                              = 18,
};

// Enum Indiana.ESpecialMovementEvent
// NumValues: 0x0007
enum class ESpecialMovementEvent : uint8
{
	None                                     = 0,
	Crouch                                   = 1,
	Uncrouch                                 = 2,
	Jump                                     = 3,
	Land                                     = 4,
	Dodge                                    = 5,
	ESpecialMovementEvent_MAX                = 6,
};

// Enum Indiana.EStateOfBeing
// NumValues: 0x0004
enum class EStateOfBeing : uint8
{
	Healthy                                  = 0,
	Dying                                    = 1,
	Dead                                     = 2,
	EStateOfBeing_MAX                        = 3,
};

// Enum Indiana.EAnimNotify
// NumValues: 0x0015
enum class EAnimNotify : uint8
{
	CalledShotCameraStart                    = 0,
	WeaponFire                               = 1,
	MeleeAllowInput                          = 2,
	MeleeDisallowInput                       = 3,
	MeleeCanStartQueuedAction                = 4,
	MeleeActionFinished                      = 5,
	MeleeRecoilFrame                         = 6,
	MeleeCheckInput                          = 7,
	MeleeDamageTypePending                   = 8,
	MeleeDamageTypeNext                      = 9,
	AnimationFinished                        = 10,
	RefillAmmo                               = 11,
	AttachWeapon                             = 12,
	DetachWeapon                             = 13,
	UseMedKit                                = 14,
	MedKitEnd                                = 15,
	Finished                                 = 16,
	MeleeEnableBlock                         = 17,
	UpdateCanisterVisual                     = 18,
	Invalid                                  = 19,
	EAnimNotify_MAX                          = 20,
};

// Enum Indiana.EGameDifficulty
// NumValues: 0x0007
enum class EGameDifficulty : uint8
{
	Story                                    = 0,
	Normal                                   = 1,
	Hard                                     = 2,
	SuperNova                                = 3,
	Count                                    = 4,
	Invalid                                  = 5,
	EGameDifficulty_MAX                      = 6,
};

// Enum Indiana.EInterrogationResult
// NumValues: 0x0005
enum class EInterrogationResult : uint8
{
	Invalid                                  = 0,
	Bribe                                    = 1,
	Talk                                     = 2,
	Fight                                    = 3,
	EInterrogationResult_MAX                 = 4,
};

// Enum Indiana.ECrimeType
// NumValues: 0x0008
enum class ECrimeType : uint8
{
	None                                     = 0,
	RestrictedArea                           = 1,
	Pickpocket                               = 2,
	Lockpick                                 = 3,
	Hack                                     = 4,
	Disguised                                = 5,
	Theft                                    = 6,
	ECrimeType_MAX                           = 7,
};

// Enum Indiana.ECalledShotCameraStep
// NumValues: 0x0005
enum class ECalledShotCameraStep : uint8
{
	Attacker                                 = 0,
	Target                                   = 1,
	TargetReaction                           = 2,
	Complete                                 = 3,
	ECalledShotCameraStep_MAX                = 4,
};

// Enum Indiana.EAttribute
// NumValues: 0x000C
enum class EAttribute : uint8
{
	Strength                                 = 0,
	Dexterity                                = 1,
	Endurance                                = 2,
	Intelligence                             = 3,
	Perception                               = 4,
	Willpower                                = 5,
	Charm                                    = 6,
	Wits                                     = 7,
	Temperament                              = 8,
	Count                                    = 9,
	Invalid                                  = 10,
	EAttribute_MAX                           = 11,
};

// Enum Indiana.ESkill
// NumValues: 0x0015
enum class ESkill : uint8
{
	HandGuns                                 = 0,
	LongGuns                                 = 1,
	HeavyWeapons                             = 2,
	Sneak                                    = 3,
	Lockpick                                 = 4,
	Engineering                              = 5,
	Hack                                     = 6,
	Medical                                  = 7,
	LightMelee                               = 8,
	HeavyMelee                               = 9,
	Science                                  = 10,
	Persuade                                 = 11,
	Lie                                      = 12,
	Intimidate                               = 13,
	Dodge                                    = 14,
	Block                                    = 15,
	Inspiration                              = 16,
	Determination                            = 17,
	Count                                    = 18,
	Invalid                                  = 19,
	ESkill_MAX                               = 20,
};

// Enum Indiana.EOCLState
// NumValues: 0x000C
enum class EOCLState : uint8
{
	Closed                                   = 0,
	Open                                     = 1,
	Locked                                   = 2,
	SealedClosed                             = 3,
	SealedOpen                               = 4,
	Barred                                   = 5,
	Opening                                  = 6,
	OpeningToSealed                          = 7,
	Closing                                  = 8,
	ClosingToSealed                          = 9,
	ClosingToLocked                          = 10,
	EOCLState_MAX                            = 11,
};

// Enum Indiana.ESaveGameType
// NumValues: 0x0009
enum class ESaveGameType : uint8
{
	Standard                                 = 0,
	Quicksave                                = 1,
	Autosave                                 = 2,
	PostGame                                 = 3,
	PointOfNoReturn                          = 4,
	BeforeSkip                               = 5,
	BeforeEVTransition                       = 6,
	Invalid                                  = 255,
	ESaveGameType_MAX                        = 256,
};

// Enum Indiana.ESaveGameResult
// NumValues: 0x0014
enum class ESaveGameResult : uint8
{
	Success                                  = 0,
	Restricted                               = 1,
	FileWritingFailure                       = 2,
	UnableToSaveCompanionStates              = 3,
	PlayerNotAvailable                       = 4,
	AsyncSaveTask_Begun                      = 5,
	AsyncSaveTask_Failed_DeviceFull          = 6,
	AsyncSaveTask_FailedDeletingStaleTargetDir = 7,
	AsyncSaveTask_FailedCreatingTargetDir    = 8,
	AsyncSaveTask_StorageUninitialized       = 9,
	AsyncSaveTask_FailedStorageContainer     = 10,
	AsyncSaveTask_Suspended                  = 11,
	AsyncSaveTask_NoMetadata                 = 12,
	AsyncSaveTask_BufferAccessFailed         = 13,
	AsyncSaveTask_BufferMaximumReached       = 14,
	AsyncSaveTask_FailedPopulatingSaveFileMap = 15,
	AsyncSaveTask_Delayed                    = 16,
	AsyncSaveTask_FailedScreenshotWaitTimeout = 17,
	AsyncSaveTask_FailedSaveStateCompression = 18,
	ESaveGameResult_MAX                      = 19,
};

// Enum Indiana.EActiveUserChangeType
// NumValues: 0x0006
enum class EActiveUserChangeType : uint8
{
	Login                                    = 0,
	LoggingOut                               = 1,
	Logout                                   = 2,
	SwitchingUser                            = 3,
	ControllerChange                         = 4,
	EActiveUserChangeType_MAX                = 5,
};

// Enum Indiana.ELoadGameResult
// NumValues: 0x0017
enum class ELoadGameResult : uint8
{
	Success                                  = 0,
	Restricted                               = 1,
	MissingFile                              = 2,
	FileReadingFailure                       = 3,
	CorruptionDetected                       = 4,
	UnableToRestorePlayerState               = 5,
	UnableToRestoreCompanionState            = 6,
	NoCompanionManager                       = 7,
	ClassDependencyLoadFailure               = 8,
	SpawnFailure                             = 9,
	InvalidQuicksaveIndex                    = 10,
	InvalidAutosaveIndex                     = 11,
	SaveOfGivenNameNotFound                  = 12,
	PlatformLoadUnsuccessful                 = 13,
	StorageUninitialized                     = 14,
	SaveVersionUnsupported                   = 15,
	SaveFromNewerBuild                       = 16,
	MapLoadFailure                           = 17,
	ChunkInstallation                        = 18,
	CompressedGameStateUnpackFailure         = 19,
	LoadCanceledByUser                       = 20,
	LoadInturruptedForPONR                   = 21,
	ELoadGameResult_MAX                      = 22,
};

// Enum Indiana.EBehaviorStateEventType
// NumValues: 0x0005
enum class EBehaviorStateEventType : uint8
{
	Added                                    = 0,
	Entered                                  = 1,
	Exited                                   = 2,
	Removed                                  = 3,
	EBehaviorStateEventType_MAX              = 4,
};

// Enum Indiana.EBehaviorState
// NumValues: 0x0031
enum class EBehaviorState : uint8
{
	None                                     = 0,
	Cover                                    = 1,
	Range                                    = 2,
	MeleeSlot                                = 3,
	Search                                   = 4,
	RepositionSearch                         = 5,
	MeleeBlock                               = 6,
	Dodge                                    = 7,
	Idle                                     = 8,
	Tether                                   = 9,
	SwitchWeapon                             = 10,
	SwitchTarget                             = 11,
	Dead                                     = 12,
	Disabled                                 = 13,
	SwitchContext                            = 14,
	Suspicious                               = 15,
	Investigate                              = 16,
	Patrol                                   = 17,
	Wander                                   = 18,
	CompanionFollow                          = 19,
	Conversation                             = 20,
	Flee                                     = 21,
	Furniture                                = 22,
	Jump                                     = 23,
	CompanionCommandMoveTo                   = 24,
	CompanionCommandSuppress                 = 25,
	CompanionCommandHunkerDown               = 26,
	Deactivated                              = 27,
	Activated                                = 28,
	CompanionCommandFlank                    = 29,
	Approach                                 = 30,
	CalledShot                               = 31,
	Persuade                                 = 32,
	Teleport                                 = 33,
	SpawnActor                               = 34,
	Cower                                    = 35,
	Follow                                   = 36,
	SpellTarget                              = 37,
	Retreat                                  = 38,
	Animation                                = 39,
	MoveTo                                   = 40,
	Crouch                                   = 41,
	QuickCover                               = 42,
	OnRails                                  = 43,
	HopeBot                                  = 44,
	Walk                                     = 45,
	HealGun                                  = 46,
	Count                                    = 47,
	EBehaviorState_MAX                       = 48,
};

// Enum Indiana.EUnlockAbility
// NumValues: 0x002D
enum class EUnlockAbility : uint8
{
	Invalid                                  = 0,
	PerfectDodge                             = 1,
	PerfectDodgeCounter                      = 2,
	PerfectDodgeCounterCrit                  = 3,
	PerfectBlock                             = 4,
	PerfectBlockCounter                      = 5,
	PerfectBlockCounterCrit                  = 6,
	PickPocket                               = 7,
	HackRobots                               = 8,
	MedKitOneDrug                            = 9,
	MedKitTwoDrugs                           = 10,
	MedKitThreeDrugs                         = 11,
	Acrophobia                               = 12,
	PowerAttacksLightMelee                   = 13,
	PowerAttacksHeavyMelee                   = 14,
	WeakSpotLightMelee                       = 15,
	WeakSpotHeavyMelee                       = 16,
	WeakSpotHandGuns                         = 17,
	WeakSpotLongGuns                         = 18,
	WeakSpotHeavyWeapons                     = 19,
	TTDSpellsLightMelee                      = 20,
	TTDSpellsHeavyMelee                      = 21,
	TTDSpellsHandGuns                        = 22,
	TTDSpellsLongGuns                        = 23,
	TTDSpellsHeavyWeapons                    = 24,
	MeleeFartherReach                        = 25,
	MeleeCannotBeBlocked                     = 26,
	SneakAttack                              = 27,
	FieldRepair                              = 28,
	SellToAnyVendingMachine                  = 29,
	CompanionCommands                        = 30,
	DodgeForward                             = 31,
	FastTravelWhileEncumbered                = 32,
	Tinkering                                = 33,
	LockPickPreview                          = 34,
	MedKitHealsCompanions                    = 35,
	TinkerScienceCostCap                     = 36,
	DoubleHackRobots                         = 37,
	UndetectableLockpicking                  = 38,
	UseScienceAsWeaponSkill                  = 39,
	InstantReloadHeavyOnEmpty                = 40,
	StealthInstantKillUndetectable           = 41,
	NoDamageOnPerfectBlock                   = 42,
	Count                                    = 43,
	EUnlockAbility_MAX                       = 44,
};

// Enum Indiana.EStringTableType
// NumValues: 0x0015
enum class EStringTableType : uint8
{
	Unassigned                               = 0,
	Gui                                      = 1,
	Items                                    = 2,
	Abilities                                = 3,
	Tutorial                                 = 4,
	Achievements                             = 5,
	Credits                                  = 6,
	Debug                                    = 7,
	LoadingTips                              = 8,
	Characters                               = 9,
	Areas                                    = 10,
	Waypoints                                = 11,
	Random                                   = 12,
	Factions                                 = 13,
	Vendors                                  = 14,
	Codex                                    = 15,
	BrandSlogans                             = 16,
	CutsceneSubtitles                        = 17,
	Legal                                    = 18,
	Count                                    = 19,
	EStringTableType_MAX                     = 20,
};

// Enum Indiana.ERestType
// NumValues: 0x0003
enum class ERestType : uint8
{
	Sleep                                    = 0,
	Wait                                     = 1,
	ERestType_MAX                            = 2,
};

// Enum Indiana.ETraverseType
// NumValues: 0x0006
enum class ETraverseType : uint8
{
	None                                     = 0,
	Jump                                     = 1,
	Crouch                                   = 2,
	Climb                                    = 3,
	Walk                                     = 4,
	ETraverseType_MAX                        = 5,
};

// Enum Indiana.EAlarmState
// NumValues: 0x0004
enum class EAlarmState : uint8
{
	Off                                      = 0,
	On                                       = 1,
	Disabled                                 = 2,
	EAlarmState_MAX                          = 3,
};

// Enum Indiana.EAlertState
// NumValues: 0x0006
enum class EAlertState : uint8
{
	Unaware                                  = 0,
	Suspicious                               = 1,
	Investigating                            = 2,
	Alerted                                  = 3,
	Count                                    = 4,
	EAlertState_MAX                          = 5,
};

// Enum Indiana.EItemDegradationState
// NumValues: 0x0005
enum class EItemDegradationState : uint8
{
	None                                     = 0,
	Damaged                                  = 1,
	SeverelyDamaged                          = 2,
	Destroyed                                = 3,
	EItemDegradationState_MAX                = 4,
};

// Enum Indiana.EWeaponPreference
// NumValues: 0x0009
enum class EWeaponPreference : uint8
{
	UsePrimary                               = 0,
	PreferRanged                             = 1,
	PreferMelee                              = 2,
	StronglyPreferMelee                      = 3,
	AlwaysRanged                             = 4,
	AlwaysMelee                              = 5,
	PreferLimitedRanged                      = 6,
	AlwaysUnlimitedRanged                    = 7,
	EWeaponPreference_MAX                    = 8,
};

// Enum Indiana.EInteractionType
// NumValues: 0x001F
enum class EInteractionType : uint8
{
	None                                     = 0,
	Door                                     = 1,
	DoorBar                                  = 2,
	Ladder                                   = 3,
	Elevator                                 = 4,
	Switch                                   = 5,
	Pickup                                   = 6,
	Container                                = 7,
	Computer                                 = 8,
	Trap                                     = 9,
	Loot                                     = 10,
	Conversation                             = 11,
	PickPocket                               = 12,
	Workbench                                = 13,
	Vendor                                   = 14,
	Generic                                  = 15,
	OCL                                      = 16,
	Travel                                   = 17,
	NoConversationChatter                    = 18,
	Bed                                      = 19,
	NotAllowedInCombat                       = 20,
	Chair                                    = 21,
	Hack                                     = 22,
	ShipTerminal                             = 23,
	Respec                                   = 24,
	GenericDelayed                           = 25,
	ContainerKeyUnlock                       = 26,
	Pet                                      = 27,
	Evidence                                 = 28,
	AudioLog                                 = 29,
	EInteractionType_MAX                     = 30,
};

// Enum Indiana.EDetectionType
// NumValues: 0x000A
enum class EDetectionType : uint8
{
	None                                     = 0,
	Suspicious                               = 1,
	Investigate                              = 2,
	Pacifist                                 = 3,
	MindControlled                           = 4,
	PacifistCombat                           = 5,
	Crime                                    = 6,
	Combat                                   = 7,
	Count                                    = 8,
	EDetectionType_MAX                       = 9,
};

// Enum Indiana.EReputationType
// NumValues: 0x0003
enum class EReputationType : uint8
{
	Positive                                 = 0,
	Negative                                 = 1,
	EReputationType_MAX                      = 2,
};

// Enum Indiana.EComputerLockState
// NumValues: 0x0003
enum class EComputerLockState : uint8
{
	Unlocked                                 = 0,
	Locked                                   = 1,
	EComputerLockState_MAX                   = 2,
};

// Enum Indiana.ETrapState
// NumValues: 0x0004
enum class ETrapState : uint8
{
	Armed                                    = 0,
	Disarmed                                 = 1,
	Deactivated                              = 2,
	ETrapState_MAX                           = 3,
};

// Enum Indiana.ECompanionCommand
// NumValues: 0x000B
enum class ECompanionCommand : uint8
{
	Invalid                                  = 0,
	MoveTo                                   = 1,
	Return                                   = 2,
	ForceReturn                              = 3,
	Attack                                   = 4,
	Flank                                    = 5,
	Suppress                                 = 6,
	HunkerDown                               = 7,
	CalledShot                               = 8,
	Count                                    = 9,
	ECompanionCommand_MAX                    = 10,
};

// Enum Indiana.ETrapTriggerState
// NumValues: 0x0004
enum class ETrapTriggerState : uint8
{
	Armed                                    = 0,
	Disarmed                                 = 1,
	Deployed                                 = 2,
	ETrapTriggerState_MAX                    = 3,
};

// Enum Indiana.EAudioLogPlayState
// NumValues: 0x0005
enum class EAudioLogPlayState : uint8
{
	Stopped                                  = 0,
	Playing                                  = 1,
	PausedByGame                             = 2,
	PausedByPlayer                           = 3,
	EAudioLogPlayState_MAX                   = 4,
};

// Enum Indiana.EIndianaUIColorType
// NumValues: 0x0037
enum class EIndianaUIColorType : uint8
{
	Invalid                                  = 0,
	Stamina                                  = 1,
	Health                                   = 2,
	TacticalTimeDilation                     = 3,
	Ammo                                     = 4,
	CalledShot                               = 5,
	Intimidate                               = 6,
	Hostile                                  = 7,
	Neutral                                  = 8,
	ConversationVisitedNode                  = 9,
	ConversationUnvisitedNode                = 10,
	UIPiping                                 = 11,
	InteractionPlayerResources               = 12,
	InteractionPossible                      = 13,
	InteractionImpossible                    = 14,
	InteractIcon                             = 15,
	InWorldQuestBeacon                       = 16,
	StandardFontGlow                         = 17,
	QuestBeaconFontGlow                      = 18,
	CompanionCommandMoveTo                   = 19,
	NotificationQuestMessage                 = 20,
	NotificationComputerInteractionMessage   = 21,
	NotificationGenericMessage               = 22,
	OutOfAmmo                                = 23,
	IndianaYellow                            = 24,
	IndianaNotQuiteYellow                    = 25,
	IndianaGrey                              = 26,
	IndianaBrown                             = 27,
	IndianaDarkBrown                         = 28,
	IndianaRed                               = 29,
	IndianaGreen                             = 30,
	NRayDamageText                           = 31,
	NRayDamageTextShadow                     = 32,
	EnergyDamageText                         = 33,
	EnergyDamageTextShadow                   = 34,
	ThermalDamageText                        = 35,
	ThermalDamageTextShadow                  = 36,
	CorrosiveDamageText                      = 37,
	CorrosiveDamageTextShadow                = 38,
	ShockDamageText                          = 39,
	ShockDamageTextShadow                    = 40,
	BallisticDamageText                      = 41,
	BallisticDamageTextShadow                = 42,
	TTDTextColor                             = 43,
	Pacifist                                 = 44,
	SkillTextColor                           = 45,
	IndianaBlack                             = 46,
	HealingText                              = 47,
	HealingTextShadow                        = 48,
	INX1Color                                = 49,
	INX2Color                                = 50,
	ColdDamageText                           = 51,
	ColdDamageTextShadow                     = 52,
	Count                                    = 53,
	EIndianaUIColorType_MAX                  = 54,
};

// Enum Indiana.ECharacterAttributeRange
// NumValues: 0x000A
enum class ECharacterAttributeRange : uint8
{
	Minimum                                  = 0,
	BelowAverage                             = 1,
	Average                                  = 2,
	Good                                     = 3,
	High                                     = 4,
	VeryHigh                                 = 5,
	Maximum                                  = 6,
	Count                                    = 7,
	Invalid                                  = 8,
	ECharacterAttributeRange_MAX             = 9,
};

// Enum Indiana.ECharacterCreationPageType
// NumValues: 0x0008
enum class ECharacterCreationPageType : uint8
{
	Attributes                               = 0,
	Skills                                   = 1,
	Aptitude                                 = 2,
	Physical                                 = 3,
	Naming                                   = 4,
	Summary                                  = 5,
	Count                                    = 6,
	ECharacterCreationPageType_MAX           = 7,
};

// Enum Indiana.ESkillCategory
// NumValues: 0x000A
enum class ESkillCategory : uint8
{
	Melee                                    = 0,
	Ranged                                   = 1,
	Defense                                  = 2,
	Dialog                                   = 3,
	Stealth                                  = 4,
	Tech                                     = 5,
	Leadership                               = 6,
	Count                                    = 7,
	Invalid                                  = 8,
	ESkillCategory_MAX                       = 9,
};

// Enum Indiana.EAptitudeType
// NumValues: 0x0011
enum class EAptitudeType : uint8
{
	NoAptitude                               = 0,
	BeverageTech                             = 1,
	Bureaucrat                               = 2,
	Cashier                                  = 3,
	Construction                             = 4,
	Elevator                                 = 5,
	Factory                                  = 6,
	Farmer                                   = 7,
	FoodTester                               = 8,
	Janitor                                  = 9,
	Mascot                                   = 10,
	MedicalTech                              = 11,
	SafetyInspector                          = 12,
	Scientist                                = 13,
	Chef                                     = 14,
	Invalid                                  = 15,
	EAptitudeType_MAX                        = 16,
};

// Enum Indiana.EAbilityPosition
// NumValues: 0x0005
enum class EAbilityPosition : uint8
{
	Bottom                                   = 0,
	Left                                     = 1,
	Top                                      = 2,
	Right                                    = 3,
	EAbilityPosition_MAX                     = 4,
};

// Enum Indiana.EAchievementOnlineUpdateType
// NumValues: 0x0004
enum class EAchievementOnlineUpdateType : uint8
{
	None                                     = 0,
	ProgressChangeOnly                       = 1,
	Force                                    = 2,
	EAchievementOnlineUpdateType_MAX         = 3,
};

// Enum Indiana.EActorPoolingMethod
// NumValues: 0x0004
enum class EActorPoolingMethod : uint32
{
	Unregister                               = 0,
	Hide                                     = 1,
	Nothing                                  = 2,
	EActorPoolingMethod_MAX                  = 3,
};

// Enum Indiana.ESoundAcceptanceType
// NumValues: 0x0007
enum class ESoundAcceptanceType : uint8
{
	None                                     = 0,
	Hostile                                  = 1,
	NonHostile                               = 2,
	ChangeHostile                            = 3,
	AutoDetectPlayer                         = 4,
	ChangeHostileAutoDetectPlayer            = 5,
	ESoundAcceptanceType_MAX                 = 6,
};

// Enum Indiana.ESoundDetectionType
// NumValues: 0x0013
enum class ESoundDetectionType : uint8
{
	None                                     = 0,
	Projectile                               = 1,
	Gun                                      = 2,
	Shout                                    = 3,
	ShoutLoS                                 = 4,
	ShoutDeath                               = 5,
	LockPick                                 = 6,
	Hack                                     = 7,
	ArmTrap                                  = 8,
	DisarmTrap                               = 9,
	Footstep                                 = 10,
	PickPocket                               = 11,
	ProjectileWizz                           = 12,
	Bumped                                   = 13,
	ShoutSight                               = 14,
	ShoutProxy                               = 15,
	ShoutDeathProxy                          = 16,
	NumSoundDetectionType                    = 17,
	ESoundDetectionType_MAX                  = 18,
};

// Enum Indiana.EDetectionDataType
// NumValues: 0x0005
enum class EDetectionDataType : uint8
{
	Unknown                                  = 0,
	SoundData                                = 1,
	DamageData                               = 2,
	Count                                    = 3,
	EDetectionDataType_MAX                   = 4,
};

// Enum Indiana.ETeamAttitudeFlag
// NumValues: 0x0006
enum class ETeamAttitudeFlag : uint32
{
	None                                     = 0,
	Friendly                                 = 2,
	Neutral                                  = 4,
	Hostile                                  = 8,
	All                                      = 4294967295,
	ETeamAttitudeFlag_MAX                    = 4294967296,
};

// Enum Indiana.EAsyncQueryResult
// NumValues: 0x0005
enum class EAsyncQueryResult : uint8
{
	Invalid                                  = 0,
	Pending                                  = 1,
	Success                                  = 2,
	Failure                                  = 3,
	EAsyncQueryResult_MAX                    = 4,
};

// Enum Indiana.EBehaviorRestoreType
// NumValues: 0x0004
enum class EBehaviorRestoreType : uint8
{
	Restore                                  = 0,
	None                                     = 1,
	Discard                                  = 2,
	EBehaviorRestoreType_MAX                 = 3,
};

// Enum Indiana.ECompanionState
// NumValues: 0x0005
enum class ECompanionState : uint8
{
	CompanionNotRecruited                    = 0,
	CompanionRecruited                       = 1,
	CompanionInActiveParty                   = 2,
	CompanionDismissed                       = 3,
	ECompanionState_MAX                      = 4,
};

// Enum Indiana.ECompanionCombatMode
// NumValues: 0x0004
enum class ECompanionCombatMode : uint8
{
	Passive                                  = 0,
	Defensive                                = 1,
	Aggressive                               = 2,
	ECompanionCombatMode_MAX                 = 3,
};

// Enum Indiana.ERagdollFreezeState
// NumValues: 0x0004
enum class ERagdollFreezeState : uint8
{
	None                                     = 0,
	PrePhysicsFreeze                         = 1,
	Frozen                                   = 2,
	ERagdollFreezeState_MAX                  = 3,
};

// Enum Indiana.ERagdollSettleState
// NumValues: 0x0004
enum class ERagdollSettleState : uint8
{
	None                                     = 0,
	Alive                                    = 1,
	Dead                                     = 2,
	ERagdollSettleState_MAX                  = 3,
};

// Enum Indiana.EFurnitureAnimationInterrupt
// NumValues: 0x0004
enum class EFurnitureAnimationInterrupt : uint8
{
	BlendToBaseIdle                          = 0,
	BlendToEnd                               = 1,
	BlendEndToBaseIdleInConversation         = 2,
	EFurnitureAnimationInterrupt_MAX         = 3,
};

// Enum Indiana.EFurnitureBehaviorState
// NumValues: 0x0009
enum class EFurnitureBehaviorState : uint8
{
	InitialMove                              = 0,
	MovingToEnter                            = 1,
	MovingToExit                             = 2,
	Furniture                                = 3,
	Conversation                             = 4,
	ReEnterFurniture                         = 5,
	Complete                                 = 6,
	WaitingToReserve                         = 7,
	EFurnitureBehaviorState_MAX              = 8,
};

// Enum Indiana.EPseudoGodMode
// NumValues: 0x0005
enum class EPseudoGodMode : uint8
{
	Off                                      = 0,
	NonPlayer_LowMinHealth                   = 1,
	NonPlayer_MediumMinHealth                = 2,
	NonPlayer_HighMinHealth                  = 3,
	EPseudoGodMode_MAX                       = 4,
};

// Enum Indiana.ETetherExpansionEvent
// NumValues: 0x0009
enum class ETetherExpansionEvent : uint8
{
	None                                     = 0,
	PlayerDamage                             = 1,
	CompanionDamage                          = 2,
	NPCDamage                                = 3,
	CompanionCommand                         = 4,
	SwitchTargetFromPlayer                   = 5,
	SwitchTargetToPlayer                     = 6,
	EnterCombat                              = 7,
	ETetherExpansionEvent_MAX                = 8,
};

// Enum Indiana.EBribeDifficulty
// NumValues: 0x0006
enum class EBribeDifficulty : uint8
{
	CrimeInterrogation                       = 0,
	Easy                                     = 1,
	Medium                                   = 2,
	Hard                                     = 3,
	Extreme                                  = 4,
	EBribeDifficulty_MAX                     = 5,
};

// Enum Indiana.ECombatReaction
// NumValues: 0x0006
enum class ECombatReaction : uint8
{
	Attack                                   = 0,
	Cower                                    = 1,
	Flee                                     = 2,
	CowerOrFlee                              = 3,
	None                                     = 4,
	ECombatReaction_MAX                      = 5,
};

// Enum Indiana.EDetectionMode
// NumValues: 0x0004
enum class EDetectionMode : uint8
{
	Perception                               = 0,
	PlayerProximity                          = 1,
	None                                     = 2,
	EDetectionMode_MAX                       = 3,
};

// Enum Indiana.EThirdPersonSocket
// NumValues: 0x0009
enum class EThirdPersonSocket : uint8
{
	None                                     = 0,
	Chest                                    = 1,
	Head                                     = 2,
	RightArm                                 = 3,
	LeftArm                                  = 4,
	RightLeg                                 = 5,
	LeftLeg                                  = 6,
	Groin                                    = 7,
	EThirdPersonSocket_MAX                   = 8,
};

// Enum Indiana.EStationaryRotateTarget
// NumValues: 0x0004
enum class EStationaryRotateTarget : uint8
{
	None                                     = 0,
	NextPathCorner                           = 1,
	CurrentTarget                            = 2,
	EStationaryRotateTarget_MAX              = 3,
};

// Enum Indiana.EStationaryRotationType
// NumValues: 0x0005
enum class EStationaryRotationType : uint8
{
	None                                     = 0,
	OutOfCombatOnly                          = 1,
	AlwaysDuringTurns                        = 2,
	Always                                   = 3,
	EStationaryRotationType_MAX              = 4,
};

// Enum Indiana.EChangeRelationshipSource
// NumValues: 0x0005
enum class EChangeRelationshipSource : uint8
{
	CompanionCommand                         = 0,
	CrimeActive                              = 1,
	CrimeDetected                            = 2,
	Default                                  = 3,
	EChangeRelationshipSource_MAX            = 4,
};

// Enum Indiana.EReputationRankType
// NumValues: 0x0005
enum class EReputationRankType : uint8
{
	Bad                                      = 0,
	Mixed                                    = 1,
	Default                                  = 2,
	Good                                     = 3,
	EReputationRankType_MAX                  = 4,
};

// Enum Indiana.EReputationIncrementType
// NumValues: 0x0006
enum class EReputationIncrementType : uint8
{
	None                                     = 0,
	Low                                      = 1,
	Medium                                   = 2,
	High                                     = 3,
	Custom                                   = 4,
	EReputationIncrementType_MAX             = 5,
};

// Enum Indiana.EMoraleContribution
// NumValues: 0x0005
enum class EMoraleContribution : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Custom                                   = 3,
	EMoraleContribution_MAX                  = 4,
};

// Enum Indiana.EReputationActionType
// NumValues: 0x000C
enum class EReputationActionType : uint8
{
	Invalid                                  = 0,
	Damage                                   = 1,
	Kill                                     = 2,
	Trespass                                 = 3,
	CrimeRestrictedAreaDisguise              = 4,
	CrimeRestrictedAreaNoDisguise            = 5,
	CrimePickpocket                          = 6,
	CrimeLockpick                            = 7,
	CrimeHack                                = 8,
	CrimeDisguised                           = 9,
	CrimeTheft                               = 10,
	EReputationActionType_MAX                = 11,
};

// Enum Indiana.ETrackingMode
// NumValues: 0x0006
enum class ETrackingMode : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Bark                                     = 2,
	Conversation                             = 4,
	Elevator                                 = 8,
	ETrackingMode_MAX                        = 9,
};

// Enum Indiana.ETrackingRegion
// NumValues: 0x0006
enum class ETrackingRegion : uint8
{
	TR_Head                                  = 0,
	TR_Body                                  = 1,
	TR_Eyes                                  = 2,
	TR_WeaponAim                             = 3,
	TR_Count                                 = 4,
	TR_MAX                                   = 5,
};

// Enum Indiana.ETrackingPriority
// NumValues: 0x000A
enum class ETrackingPriority : uint8
{
	TP_Default                               = 0,
	TP_PersonalSpace                         = 1,
	TP_Moving                                = 2,
	TP_Conversation                          = 3,
	TP_Scripted                              = 4,
	TP_Behavior                              = 5,
	TP_Reaction                              = 6,
	TP_Debug                                 = 7,
	TP_Count                                 = 8,
	TP_MAX                                   = 9,
};

// Enum Indiana.EBehaviorStateCompletionType
// NumValues: 0x0005
enum class EBehaviorStateCompletionType : uint8
{
	None                                     = 0,
	Success                                  = 1,
	Complete                                 = 2,
	ExternalComplete                         = 3,
	EBehaviorStateCompletionType_MAX         = 4,
};

// Enum Indiana.EAIEventType
// NumValues: 0x0006
enum class EAIEventType : uint8
{
	Invalid                                  = 0,
	BehaviorDiscrete                         = 1,
	BehaviorContinuous                       = 2,
	ExternalDiscrete                         = 3,
	ExternalContinuous                       = 4,
	EAIEventType_MAX                         = 5,
};

// Enum Indiana.EStimulusType
// NumValues: 0x0014
enum class EStimulusType : uint8
{
	None                                     = 0,
	Distraction                              = 1,
	SightInactive                            = 2,
	Projectile                               = 3,
	GenericSound                             = 4,
	DeadBodyKiller                           = 5,
	Shout                                    = 6,
	ForceDetect                              = 7,
	SightActive                              = 8,
	Damage                                   = 9,
	FriendInCombat                           = 10,
	EncounterAggro                           = 11,
	EnteredRestrictedArea                    = 12,
	Crime                                    = 13,
	SawFriendKilledByPlayer                  = 14,
	AutoDetect                               = 15,
	PickpocketSound                          = 16,
	LockpickSound                            = 17,
	HackSound                                = 18,
	EStimulusType_MAX                        = 19,
};

// Enum Indiana.ETargetOverrideType
// NumValues: 0x0005
enum class ETargetOverrideType : uint8
{
	None                                     = 0,
	Taunt                                    = 1,
	CommandAttack                            = 2,
	CommandCalledShot                        = 3,
	ETargetOverrideType_MAX                  = 4,
};

// Enum Indiana.ETargetRequestType
// NumValues: 0x000B
enum class ETargetRequestType : uint8
{
	Clear                                    = 0,
	Fresh                                    = 1,
	FirstTarget                              = 2,
	Override                                 = 3,
	ClearOverride                            = 4,
	Lost                                     = 5,
	Untargetable                             = 6,
	Threat                                   = 7,
	Unreachable                              = 8,
	Restore                                  = 9,
	ETargetRequestType_MAX                   = 10,
};

// Enum Indiana.ECoverTypes
// NumValues: 0x0004
enum class ECoverTypes : uint8
{
	FullHeight                               = 0,
	HalfHeight                               = 1,
	None                                     = 2,
	ECoverTypes_MAX                          = 3,
};

// Enum Indiana.ERangedRepositionCondition
// NumValues: 0x0005
enum class ERangedRepositionCondition : uint8
{
	None                                     = 0,
	TooNear                                  = 1,
	PreferredRange                           = 2,
	TooFar                                   = 3,
	ERangedRepositionCondition_MAX           = 4,
};

// Enum Indiana.ERangedRepositionType
// NumValues: 0x0006
enum class ERangedRepositionType : uint8
{
	Default                                  = 0,
	Stationary                               = 1,
	Forward                                  = 2,
	Backward                                 = 3,
	Strafe                                   = 4,
	ERangedRepositionType_MAX                = 5,
};

// Enum Indiana.EAnimTreeState
// NumValues: 0x0007
enum class EAnimTreeState : uint8
{
	None                                     = 0,
	Neutral                                  = 1,
	Precombat                                = 2,
	CombatNotReady                           = 3,
	Combat                                   = 4,
	Count                                    = 5,
	EAnimTreeState_MAX                       = 6,
};

// Enum Indiana.EDecisionTreeContextType
// NumValues: 0x0006
enum class EDecisionTreeContextType : uint32
{
	None                                     = 0,
	All                                      = 1,
	OutOfCombat                              = 2,
	InCombat                                 = 3,
	Count                                    = 4,
	EDecisionTreeContextType_MAX             = 5,
};

// Enum Indiana.EDisablePriority
// NumValues: 0x000B
enum class EDisablePriority : uint8
{
	Invalid                                  = 0,
	IdleDisable                              = 1,
	ShockFace                                = 2,
	DelayableCombatEffect                    = 3,
	LightHitReact                            = 4,
	HeavyHitReact                            = 5,
	ImmediateCombatEffect                    = 6,
	CalledShotCombatEffect                   = 7,
	PushEffect                               = 8,
	RagdollDisable                           = 9,
	EDisablePriority_MAX                     = 10,
};

// Enum Indiana.EParentDefaultBehaviorType
// NumValues: 0x0003
enum class EParentDefaultBehaviorType : uint8
{
	Idle                                     = 0,
	Wander                                   = 1,
	EParentDefaultBehaviorType_MAX           = 2,
};

// Enum Indiana.EDefaultBehaviorType
// NumValues: 0x0007
enum class EDefaultBehaviorType : uint8
{
	None                                     = 0,
	Idle                                     = 1,
	Patrol                                   = 2,
	Follow                                   = 3,
	FollowPlayer                             = 4,
	Wander                                   = 5,
	EDefaultBehaviorType_MAX                 = 6,
};

// Enum Indiana.EBehaviorStatePriority
// NumValues: 0x0014
enum class EBehaviorStatePriority : uint8
{
	None                                     = 0,
	Default                                  = 1,
	SwitchContext                            = 2,
	SwitchWeapon                             = 3,
	Approach                                 = 4,
	IdleDisable                              = 5,
	Conversation                             = 6,
	ShockFace                                = 7,
	Blackout                                 = 8,
	DelayableCombatEffect                    = 9,
	LightHitReact                            = 10,
	HeavyHitReact                            = 11,
	ImmediateCombatEffect                    = 12,
	CalledShotCombatEffect                   = 13,
	PushEffect                               = 14,
	RagdollDisable                           = 15,
	CalledShot                               = 16,
	ForceTeleport                            = 17,
	Dead                                     = 18,
	EBehaviorStatePriority_MAX               = 19,
};

// Enum Indiana.EDecisionTreeRequestPriority
// NumValues: 0x0007
enum class EDecisionTreeRequestPriority : uint8
{
	None                                     = 0,
	OutOfCombat                              = 1,
	Default                                  = 2,
	ForcedQueued                             = 3,
	HardScript                               = 4,
	ForcedImmediate                          = 5,
	EDecisionTreeRequestPriority_MAX         = 6,
};

// Enum Indiana.ESlotPriority
// NumValues: 0x0006
enum class ESlotPriority : uint8
{
	Lowest                                   = 0,
	Low                                      = 1,
	Normal                                   = 2,
	High                                     = 3,
	Highest                                  = 4,
	ESlotPriority_MAX                        = 5,
};

// Enum Indiana.EWeaponSwitchType
// NumValues: 0x0006
enum class EWeaponSwitchType : uint8
{
	Type                                     = 0,
	Slot                                     = 1,
	LimitedRanged                            = 2,
	UnlimitedRanged                          = 3,
	CalledShot                               = 4,
	EWeaponSwitchType_MAX                    = 5,
};

// Enum Indiana.EAvoidanceGroupType
// NumValues: 0x0003
enum class EAvoidanceGroupType : uint8
{
	Default                                  = 0,
	FleeingCritter                           = 1,
	EAvoidanceGroupType_MAX                  = 2,
};

// Enum Indiana.EJumpGravityState
// NumValues: 0x0004
enum class EJumpGravityState : uint8
{
	Off                                      = 0,
	On                                       = 1,
	ForcedOn                                 = 2,
	EJumpGravityState_MAX                    = 3,
};

// Enum Indiana.EStationaryRotateState
// NumValues: 0x0003
enum class EStationaryRotateState : uint8
{
	None                                     = 0,
	Rotating                                 = 1,
	EStationaryRotateState_MAX               = 2,
};

// Enum Indiana.ETraverseState
// NumValues: 0x0004
enum class ETraverseState : uint8
{
	None                                     = 0,
	Waiting                                  = 1,
	Traversing                               = 2,
	ETraverseState_MAX                       = 3,
};

// Enum Indiana.EAIMovementState
// NumValues: 0x0005
enum class EAIMovementState : uint8
{
	Walk                                     = 0,
	Run                                      = 1,
	Sprint                                   = 2,
	Dynamic                                  = 3,
	EAIMovementState_MAX                     = 4,
};

// Enum Indiana.EUsableCoverTypes
// NumValues: 0x0004
enum class EUsableCoverTypes : uint8
{
	All                                      = 0,
	FullOnly                                 = 1,
	HalfOnly                                 = 2,
	EUsableCoverTypes_MAX                    = 3,
};

// Enum Indiana.EDefensiveActionType
// NumValues: 0x0006
enum class EDefensiveActionType : uint8
{
	Unknown                                  = 0,
	MeleeBlock                               = 1,
	Dodge                                    = 2,
	ReactiveRange                            = 3,
	Count                                    = 4,
	EDefensiveActionType_MAX                 = 5,
};

// Enum Indiana.ELostTargetSearchMode
// NumValues: 0x0003
enum class ELostTargetSearchMode : uint8
{
	DirectSearch                             = 0,
	RepositionSearch                         = 1,
	ELostTargetSearchMode_MAX                = 2,
};

// Enum Indiana.ELostTargetWaitTime
// NumValues: 0x0006
enum class ELostTargetWaitTime : uint8
{
	Invalid                                  = 0,
	VeryShort                                = 1,
	Short                                    = 2,
	Medium                                   = 3,
	Long                                     = 4,
	ELostTargetWaitTime_MAX                  = 5,
};

// Enum Indiana.EMeleeRecoveryType
// NumValues: 0x0004
enum class EMeleeRecoveryType : uint8
{
	None                                     = 0,
	Move                                     = 1,
	Dodge                                    = 2,
	EMeleeRecoveryType_MAX                   = 3,
};

// Enum Indiana.EMeleeActionUseCase
// NumValues: 0x0006
enum class EMeleeActionUseCase : uint8
{
	Default                                  = 0,
	WithinRange                              = 1,
	OutsideRange                             = 2,
	AbilityOnly                              = 3,
	ForceIfOutsideRange                      = 4,
	EMeleeActionUseCase_MAX                  = 5,
};

// Enum Indiana.EPatrolType
// NumValues: 0x0004
enum class EPatrolType : uint8
{
	OneShot                                  = 0,
	Loop                                     = 1,
	PingPong                                 = 2,
	EPatrolType_MAX                          = 3,
};

// Enum Indiana.EAggresionType
// NumValues: 0x0004
enum class EAggresionType : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	EAggresionType_MAX                       = 3,
};

// Enum Indiana.ERangeBehaviorType
// NumValues: 0x0005
enum class ERangeBehaviorType : uint8
{
	Cover                                    = 0,
	Range                                    = 1,
	PreferredRange                           = 2,
	None                                     = 3,
	ERangeBehaviorType_MAX                   = 4,
};

// Enum Indiana.EOnEnterCombatBehavior
// NumValues: 0x0004
enum class EOnEnterCombatBehavior : uint8
{
	None                                     = 0,
	StationaryFire                           = 1,
	StationaryFireIfOutsidePreferredRange    = 2,
	EOnEnterCombatBehavior_MAX               = 3,
};

// Enum Indiana.ESuppressingFireDuration
// NumValues: 0x0006
enum class ESuppressingFireDuration : uint8
{
	Invalid                                  = 0,
	Disabled                                 = 1,
	Short                                    = 2,
	Medium                                   = 3,
	Long                                     = 4,
	ESuppressingFireDuration_MAX             = 5,
};

// Enum Indiana.EWeaponFireType
// NumValues: 0x0003
enum class EWeaponFireType : uint8
{
	Ranged                                   = 0,
	Melee                                    = 1,
	EWeaponFireType_MAX                      = 2,
};

// Enum Indiana.EAmmoType
// NumValues: 0x0009
enum class EAmmoType : uint8
{
	Invalid                                  = 0,
	Handgun                                  = 1,
	Rifle                                    = 2,
	Shotgun                                  = 3,
	Battery                                  = 4,
	EnergyCell                               = 5,
	RPG                                      = 6,
	Needler                                  = 7,
	EAmmoType_MAX                            = 8,
};

// Enum Indiana.ENotifyChatterEventType
// NumValues: 0x000E
enum class ENotifyChatterEventType : uint8
{
	Invalid                                  = 0,
	Event01                                  = 1,
	Event02                                  = 2,
	Event03                                  = 3,
	Event04                                  = 4,
	Event05                                  = 5,
	Event06                                  = 6,
	Event07                                  = 7,
	Event08                                  = 8,
	Event09                                  = 9,
	Event10                                  = 10,
	Event11                                  = 11,
	Event12                                  = 12,
	ENotifyChatterEventType_MAX              = 13,
};

// Enum Indiana.EDespawnRules
// NumValues: 0x0004
enum class EDespawnRules : uint8
{
	Idle                                     = 0,
	Combat                                   = 1,
	Never                                    = 2,
	EDespawnRules_MAX                        = 3,
};

// Enum Indiana.EHeadStyle
// NumValues: 0x0009
enum class EHeadStyle : uint8
{
	Normal                                   = 0,
	NormalWithoutBeard                       = 1,
	CappedHair                               = 2,
	CappedHairWithoutBeard                   = 3,
	HiddenHair                               = 4,
	HiddenHairWithoutBeard                   = 5,
	CompletelyHidden                         = 6,
	None                                     = 7,
	EHeadStyle_MAX                           = 8,
};

// Enum Indiana.EArmorModSlot
// NumValues: 0x0007
enum class EArmorModSlot : uint8
{
	Armoring                                 = 0,
	Resistance                               = 1,
	Dampening                                = 2,
	Utility                                  = 3,
	Count                                    = 4,
	Invalid                                  = 5,
	EArmorModSlot_MAX                        = 6,
};

// Enum Indiana.EArmorSlot
// NumValues: 0x0005
enum class EArmorSlot : uint8
{
	ArmorSet                                 = 0,
	Helmet                                   = 1,
	Count                                    = 2,
	Invalid                                  = 3,
	EArmorSlot_MAX                           = 4,
};

// Enum Indiana.EAudioLogPackageType
// NumValues: 0x0004
enum class EAudioLogPackageType : uint8
{
	BaseGame                                 = 0,
	INX01                                    = 1,
	INX02                                    = 2,
	EAudioLogPackageType_MAX                 = 3,
};

// Enum Indiana.EUIMarkerType
// NumValues: 0x000B
enum class EUIMarkerType : uint8
{
	None                                     = 0,
	Quest                                    = 1,
	POI_Undiscovered                         = 2,
	AreaBeacon                               = 3,
	Enemy                                    = 4,
	Hostile                                  = 5,
	POI_Discovered                           = 6,
	NonHostile                               = 7,
	HostilePacifist                          = 8,
	Error                                    = 9,
	EUIMarkerType_MAX                        = 10,
};

// Enum Indiana.EBeaconType
// NumValues: 0x0004
enum class EBeaconType : uint8
{
	None                                     = 0,
	Type1                                    = 1,
	POI                                      = 2,
	Max                                      = 3,
};

// Enum Indiana.ESpecialBeaconType
// NumValues: 0x0005
enum class ESpecialBeaconType : uint8
{
	None                                     = 0,
	Ship                                     = 1,
	ShipDoor                                 = 2,
	ShipTerminal                             = 3,
	ESpecialBeaconType_MAX                   = 4,
};

// Enum Indiana.EFlowAbortCondition
// NumValues: 0x0003
enum class EFlowAbortCondition : uint8
{
	Conditional                              = 0,
	Custom                                   = 1,
	EFlowAbortCondition_MAX                  = 2,
};

// Enum Indiana.EFlowAbortMode
// NumValues: 0x0003
enum class EFlowAbortMode : uint8
{
	None                                     = 0,
	Self                                     = 1,
	EFlowAbortMode_MAX                       = 2,
};

// Enum Indiana.EAIScriptExecutionType
// NumValues: 0x0004
enum class EAIScriptExecutionType : uint8
{
	OnEnter                                  = 0,
	OnUpdate                                 = 1,
	OnExit                                   = 2,
	EAIScriptExecutionType_MAX               = 3,
};

// Enum Indiana.EToggleScriptType
// NumValues: 0x0003
enum class EToggleScriptType : uint8
{
	OnEnter                                  = 0,
	OnExit                                   = 1,
	EToggleScriptType_MAX                    = 2,
};

// Enum Indiana.EAIAnimationParameter
// NumValues: 0x0003
enum class EAIAnimationParameter : uint8
{
	InCover                                  = 0,
	InvestigatingDeadBody                    = 1,
	EAIAnimationParameter_MAX                = 2,
};

// Enum Indiana.EAnimationState
// NumValues: 0x0005
enum class EAnimationState : uint8
{
	Combat                                   = 0,
	PreCombat                                = 1,
	Neutral                                  = 2,
	None                                     = 100,
	EAnimationState_MAX                      = 101,
};

// Enum Indiana.ETargetLostResponse
// NumValues: 0x0004
enum class ETargetLostResponse : uint8
{
	None                                     = 0,
	AIEvent                                  = 1,
	RequestNewTarget                         = 2,
	ETargetLostResponse_MAX                  = 3,
};

// Enum Indiana.EFiringPatternState
// NumValues: 0x0008
enum class EFiringPatternState : uint8
{
	PrePause                                 = 0,
	StartPause                               = 1,
	Burst                                    = 2,
	BurstAnimation                           = 3,
	BurstPause                               = 4,
	EndPause                                 = 5,
	Invalid                                  = 6,
	EFiringPatternState_MAX                  = 7,
};

// Enum Indiana.EFiringPatternCompleteType
// NumValues: 0x0004
enum class EFiringPatternCompleteType : uint8
{
	FinishBehavior                           = 0,
	FinishTask                               = 1,
	Repeat                                   = 2,
	EFiringPatternCompleteType_MAX           = 3,
};

// Enum Indiana.EMoveToResultResponse
// NumValues: 0x0004
enum class EMoveToResultResponse : uint8
{
	ContinueTask                             = 0,
	ExitTask                                 = 1,
	ExitBehavior                             = 2,
	EMoveToResultResponse_MAX                = 3,
};

// Enum Indiana.EMoveToState
// NumValues: 0x0008
enum class EMoveToState : uint8
{
	None                                     = 0,
	MoveToTarget                             = 1,
	MoveToNavMesh                            = 2,
	PartialSuccess                           = 3,
	WaitForUnblock                           = 4,
	Failed                                   = 5,
	Succeeded                                = 6,
	EMoveToState_MAX                         = 7,
};

// Enum Indiana.EMoveToResult
// NumValues: 0x0008
enum class EMoveToResult : uint8
{
	Pending                                  = 0,
	Success                                  = 1,
	Blocked                                  = 2,
	UnexpectedFailure                        = 3,
	OffNavMesh                               = 4,
	Repath                                   = 5,
	TotalFailure                             = 6,
	EMoveToResult_MAX                        = 7,
};

// Enum Indiana.EAnimMovementModifierState
// NumValues: 0x0004
enum class EAnimMovementModifierState : uint8
{
	None                                     = 0,
	Lamed                                    = 1,
	Hobbled                                  = 2,
	EAnimMovementModifierState_MAX           = 3,
};

// Enum Indiana.EAnimMovementState
// NumValues: 0x0005
enum class EAnimMovementState : uint8
{
	OnGround                                 = 0,
	InAir                                    = 1,
	Sprinting                                = 2,
	Climbing                                 = 3,
	EAnimMovementState_MAX                   = 4,
};

// Enum Indiana.EDeathType
// NumValues: 0x000A
enum class EDeathType : uint8
{
	Corrosive                                = 0,
	Dismember                                = 1,
	Energy                                   = 2,
	Gib                                      = 3,
	NRay                                     = 4,
	Ragdoll                                  = 5,
	Shock                                    = 6,
	Thermal                                  = 7,
	Count                                    = 8,
	EDeathType_MAX                           = 9,
};

// Enum Indiana.ECharacterDeathTriBool
// NumValues: 0x0005
enum class ECharacterDeathTriBool : uint8
{
	BFalse                                   = 0,
	BTrue                                    = 1,
	Any                                      = 2,
	Count                                    = 3,
	ECharacterDeathTriBool_MAX               = 4,
};

// Enum Indiana.ECharacterGrouping
// NumValues: 0x0017
enum class ECharacterGrouping : uint8
{
	None                                     = 0,
	Complex                                  = 1,
	GuardGardener                            = 2,
	GuardIconoclasts                         = 3,
	GuardLlama                               = 4,
	GuardMardets                             = 5,
	GuardOtherCorporate                      = 6,
	GuardOutlaws                             = 7,
	GuardSublight                            = 8,
	GuardUDL                                 = 9,
	Infected                                 = 10,
	Marauder                                 = 11,
	RobotBipedCombatant                      = 12,
	RobotBipedNonCombatant                   = 13,
	RobotHoverCombatant                      = 14,
	RobotHoverNonCombatant                   = 15,
	RobotTripedCombatant                     = 16,
	RobotTripedNonCombatant                  = 17,
	TownieByzantium                          = 18,
	TownieHoodlum                            = 19,
	TownieLight                              = 20,
	TownieNonByzantium                       = 21,
	ECharacterGrouping_MAX                   = 22,
};

// Enum Indiana.ECreatureXPType
// NumValues: 0x0007
enum class ECreatureXPType : uint8
{
	Invalid                                  = 0,
	Trivial                                  = 1,
	Fodder                                   = 2,
	Normal                                   = 3,
	Leader                                   = 4,
	Boss                                     = 5,
	ECreatureXPType_MAX                      = 6,
};

// Enum Indiana.ECharacterSkillRange
// NumValues: 0x0008
enum class ECharacterSkillRange : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Extreme                                  = 3,
	Cosmetic                                 = 4,
	Count                                    = 5,
	Invalid                                  = 6,
	ECharacterSkillRange_MAX                 = 7,
};

// Enum Indiana.EAttributeGroup
// NumValues: 0x0006
enum class EAttributeGroup : uint8
{
	Body                                     = 0,
	Mind                                     = 1,
	Personality                              = 2,
	Count                                    = 3,
	Invalid                                  = 4,
	EAttributeGroup_MAX                      = 5,
};

// Enum Indiana.EChatterEventType
// NumValues: 0x00A7
enum class EChatterEventType : uint8
{
	ALL_BlockHit                             = 0,
	ALL_Death                                = 1,
	ALL_DeathCorrosive                       = 2,
	ALL_DeathEnergy                          = 3,
	ALL_DeathGibbed                          = 4,
	ALL_DeathNray                            = 5,
	ALL_DeathShock                           = 6,
	ALL_DeathThermal                         = 7,
	ALL_FallDamage                           = 8,
	ALL_Hit                                  = 9,
	ALL_HitCrit                              = 10,
	ALL_HitGraze                             = 11,
	ALL_HitHeavy                             = 12,
	ALL_HitNoDamage                          = 13,
	ALL_LowHealth                            = 14,
	ALL_Melee                                = 15,
	ALL_MeleeHeavy                           = 16,
	ALL_MeleeSweep                           = 17,
	ALL_MovementDodge                        = 18,
	ALL_MovementFalling                      = 19,
	ALL_MovementJump                         = 20,
	ALL_MovementLand                         = 21,
	ALL_StateAcid                            = 22,
	ALL_StateBleed                           = 23,
	ALL_StateBlind                           = 24,
	ALL_StateBurning                         = 25,
	ALL_StateConcuss                         = 26,
	ALL_StateCripple                         = 27,
	ALL_StateKnockback                       = 28,
	ALL_StateMaim                            = 29,
	ALL_StatePoison                          = 30,
	ALL_StateStaggered                       = 31,
	COM_CommandAttack                        = 32,
	COM_CommandCalledshot1                   = 33,
	COM_CommandCalledshot2                   = 34,
	COM_CommandCalledshot3                   = 35,
	COM_CommandMoveInvalidLocation           = 36,
	COM_CommandMove                          = 37,
	COM_CommandReturn                        = 38,
	COM_HackSuccessEasy                      = 39,
	COM_HackSuccessHard                      = 40,
	COM_Idle                                 = 41,
	COM_LockpickSuccessEasy                  = 42,
	COM_LockpickSuccessHard                  = 43,
	COM_PartyCombatEnd                       = 44,
	COM_PartyCombatEndNoDamageTaken          = 45,
	COM_PartyCombatStartAttacked             = 46,
	COM_PartyCombatStartAttacking            = 47,
	COM_PartyCombatStartEasy                 = 48,
	COM_PartyCombatStartHard                 = 49,
	COM_PlayerDeath                          = 50,
	COM_PlayerHitCrit                        = 51,
	COM_PlayerHitGraze                       = 52,
	COM_PlayerHitGrazeCorrosive              = 53,
	COM_PlayerHitGrazeEnergy                 = 54,
	COM_PlayerHitGrazeNray                   = 55,
	COM_PlayerHitGrazeShock                  = 56,
	COM_PlayerHitGrazeThermal                = 57,
	COM_PlayerKill                           = 58,
	COM_PlayerKillStealth                    = 59,
	COM_PlayerLowHealth                      = 60,
	COM_PlayerUseDrug                        = 61,
	COM_ResumeBanter                         = 62,
	COM_StealthEnter                         = 63,
	COM_StealthExit                          = 64,
	COM_StealthWarning                       = 65,
	COM_WantsToTalk                          = 66,
	NPC_AlertAllyDeath                       = 67,
	NPC_AlertCorpse                          = 68,
	NPC_AlertInvestigate                     = 69,
	NPC_AlertSuspicious                      = 70,
	NPC_CombatEndLostTarget                  = 71,
	NPC_CombatEndTether                      = 72,
	NPC_CombatEndVictory                     = 73,
	NPC_CombatSearchIdle                     = 74,
	NPC_CombatStartAttacked                  = 75,
	NPC_CombatStartAttacking                 = 76,
	NPC_CombatStartCrime                     = 77,
	NPC_CombatStartScared                    = 78,
	NPC_CombatTargetLost                     = 79,
	NPC_CombatTargetReacquired               = 80,
	NPC_CrimeDetected                        = 81,
	NPC_CrimeDetectedDisguise                = 82,
	NPC_CrimeDetectedHack                    = 83,
	NPC_CrimeDetectedLockpick                = 84,
	NPC_CrimeDetectedPickpocket              = 85,
	NPC_CrimeDetectedRestrictedArea          = 86,
	NPC_CrimeDetectedTheft                   = 87,
	NPC_CrimeFleeing                         = 88,
	NPC_DialogIntimidated                    = 89,
	NPC_DialogLiedTo                         = 90,
	NPC_DialogPersuaded                      = 91,
	NPC_FriendlyFire                         = 92,
	NPC_InterrogationBegin                   = 93,
	NPC_InterrogationBeginRestrictedArea     = 94,
	NPC_InterrogationBribed                  = 95,
	NPC_InterrogationConvinced               = 96,
	NPC_InterrogationFight                   = 97,
	NPC_InvestigateGiveUp                    = 98,
	NPC_Kill                                 = 99,
	NPC_MeleeWaiting                         = 100,
	NPC_NoConversation                       = 101,
	NPC_HeardCombat                          = 102,
	NPC_ObserveCombat                        = 103,
	NPC_PerfectDisguise                      = 104,
	NPC_PersonalSpaceEnter                   = 105,
	NPC_PersonalSpaceExit                    = 106,
	NPC_SelfAdvance                          = 107,
	NPC_SelfCover                            = 108,
	NPC_SelfReload                           = 109,
	NPC_SelfSuppress                         = 110,
	NPC_SelfSwitchTarget                     = 111,
	NPC_SquadAdvance                         = 112,
	NPC_SquadCover                           = 113,
	NPC_SquadSuppress                        = 114,
	NPC_SquadSwitchTarget                    = 115,
	NPC_StateDisarmed                        = 116,
	NPC_StateKnockdown                       = 117,
	NPC_StateKnockout                        = 118,
	NPC_StateStunned                         = 119,
	NPC_Threatened                           = 120,
	PL_Medkit                                = 121,
	PL_SkillIntimidate                       = 122,
	PL_SkillLie                              = 123,
	PL_SkillPersuade                         = 124,
	ROBO_HackPowerDown                       = 125,
	ROBO_HackPowerUp                         = 126,
	ROBO_HackWarning                         = 127,
	COM_NPCTargetedPlayerBack                = 128,
	COM_NPCTargetedPlayerFront               = 129,
	COM_NPCTargetedPlayerLeft                = 130,
	COM_NPCTargetedPlayerRight               = 131,
	AnimNotify01                             = 132,
	AnimNotify02                             = 133,
	AnimNotify03                             = 134,
	AnimNotify04                             = 135,
	AnimNotify05                             = 136,
	AnimNotify06                             = 137,
	AnimNotify07                             = 138,
	AnimNotify08                             = 139,
	AnimNotify09                             = 140,
	AnimNotify10                             = 141,
	AnimNotify11                             = 142,
	AnimNotify12                             = 143,
	Cutscene_Line01                          = 144,
	Cutscene_Line02                          = 145,
	Cutscene_Line03                          = 146,
	Cutscene_Line04                          = 147,
	Cutscene_Line05                          = 148,
	Cutscene_Line06                          = 149,
	Cutscene_Line07                          = 150,
	Cutscene_Line08                          = 151,
	Cutscene_Line09                          = 152,
	Cutscene_Line10                          = 153,
	Cutscene_Line11                          = 154,
	Cutscene_Line12                          = 155,
	Cutscene_Line13                          = 156,
	Cutscene_Line14                          = 157,
	Cutscene_Line15                          = 158,
	Cutscene_Line16                          = 159,
	Stub1                                    = 160,
	Stub2                                    = 161,
	Stub3                                    = 162,
	Stub4                                    = 163,
	Stub5                                    = 164,
	Count                                    = 165,
	EChatterEventType_MAX                    = 166,
};

// Enum Indiana.EChatterLevel
// NumValues: 0x0005
enum class EChatterLevel : uint8
{
	All                                      = 0,
	EventType                                = 1,
	Group                                    = 2,
	Character                                = 3,
	EChatterLevel_MAX                        = 4,
};

// Enum Indiana.EClearThreatTarget
// NumValues: 0x0004
enum class EClearThreatTarget : uint32
{
	Applier                                  = 0,
	Companions                               = 1,
	Player                                   = 2,
	EClearThreatTarget_MAX                   = 3,
};

// Enum Indiana.ECameraParamsScore
// NumValues: 0x0008
enum class ECameraParamsScore : uint8
{
	Invalid                                  = 0,
	Fail                                     = 1,
	InitialEnvSweepFail                      = 2,
	InitialEnvCharSweepFail                  = 3,
	EnvClear                                 = 4,
	InitialEnvCharSweepEnv                   = 5,
	EnvCharClear                             = 6,
	ECameraParamsScore_MAX                   = 7,
};

// Enum Indiana.ECompanionSlot
// NumValues: 0x0003
enum class ECompanionSlot : uint8
{
	Slot1                                    = 0,
	Slot2                                    = 1,
	ECompanionSlot_MAX                       = 2,
};

// Enum Indiana.ECompanionFollowDistance
// NumValues: 0x0005
enum class ECompanionFollowDistance : uint8
{
	Close                                    = 0,
	Medium                                   = 1,
	Far                                      = 2,
	Invalid                                  = 3,
	ECompanionFollowDistance_MAX             = 4,
};

// Enum Indiana.ECompanionPosition
// NumValues: 0x0005
enum class ECompanionPosition : uint8
{
	CompanionLeft                            = 0,
	CompanionRight                           = 1,
	NumCompanionPositions                    = 2,
	Follower                                 = 3,
	ECompanionPosition_MAX                   = 4,
};

// Enum Indiana.EEaseType
// NumValues: 0x000F
enum class EEaseType : uint32
{
	CircularIn                               = 0,
	CircularOut                              = 1,
	CircularInOut                            = 2,
	EaseIn                                   = 3,
	EaseOut                                  = 4,
	EaseInOut                                = 5,
	ExpoIn                                   = 6,
	ExpoOut                                  = 7,
	ExpoInOut                                = 8,
	SinIn                                    = 9,
	SinOut                                   = 10,
	SinInOut                                 = 11,
	Step                                     = 12,
	Lerp                                     = 13,
	EEaseType_MAX                            = 14,
};

// Enum Indiana.EComputerTerminalResult
// NumValues: 0x000A
enum class EComputerTerminalResult : uint8
{
	Success                                  = 0,
	Failed_Locked                            = 1,
	Failed_Locked_Permanent                  = 2,
	Failed_Locked_Key_NoHack                 = 3,
	Failed_Locked_ComputerNoKey_HackResource = 4,
	Failed_Locked_Key_HackResource           = 5,
	Failed_Locked_Hack_SkillInsufficient     = 6,
	Failed_Locked_Error                      = 7,
	Pending_Hacking                          = 8,
	EComputerTerminalResult_MAX              = 9,
};

// Enum Indiana.EComputerTerminalEventType
// NumValues: 0x000B
enum class EComputerTerminalEventType : uint8
{
	Invalid                                  = 0,
	Use                                      = 1,
	Unlocked                                 = 2,
	UnlockAttemptedLocked                    = 3,
	Locked                                   = 4,
	InsufficientSkill                        = 5,
	HackSuccess                              = 6,
	HackStart                                = 7,
	HackInterrupted                          = 8,
	InteractLoopFinished                     = 9,
	EComputerTerminalEventType_MAX           = 10,
};

// Enum Indiana.EComputerType
// NumValues: 0x000F
enum class EComputerType : uint8
{
	Invalid                                  = 0,
	None                                     = 1,
	SpacersChoice                            = 2,
	AuntieCleos                              = 3,
	UniversalDefenseLogistics                = 4,
	CandP                                    = 5,
	Rizzo                                    = 6,
	MonarchStellarIndustries                 = 7,
	TandL                                    = 8,
	Error                                    = 9,
	TheGroundbreaker                         = 10,
	TheHope                                  = 11,
	Iconoclast                               = 12,
	JobBoard                                 = 13,
	EComputerType_MAX                        = 14,
};

// Enum Indiana.EConversationRestrictions
// NumValues: 0x0005
enum class EConversationRestrictions : uint32
{
	None                                     = 0,
	Combat                                   = 1,
	HostileSE                                = 2,
	All                                      = 4294967295,
	EConversationRestrictions_MAX            = 4294967296,
};

// Enum Indiana.EPayloadID
// NumValues: 0x0020
enum class EPayloadID : uint8
{
	None                                     = 0,
	Payload1                                 = 1,
	Payload2                                 = 2,
	Payload3                                 = 3,
	Payload4                                 = 4,
	Payload5                                 = 5,
	Payload6                                 = 6,
	Payload7                                 = 7,
	Payload8                                 = 8,
	Payload9                                 = 9,
	Payload10                                = 10,
	Payload11                                = 11,
	Payload12                                = 12,
	Payload13                                = 13,
	Payload14                                = 14,
	Payload15                                = 15,
	Payload16                                = 16,
	Payload17                                = 17,
	Payload18                                = 18,
	Payload19                                = 19,
	Payload20                                = 20,
	Payload21                                = 21,
	Payload22                                = 22,
	Payload23                                = 23,
	Payload24                                = 24,
	Payload25                                = 25,
	Payload26                                = 26,
	Payload27                                = 27,
	Payload28                                = 28,
	Payload29                                = 29,
	Payload30                                = 30,
	EPayloadID_MAX                           = 31,
};

// Enum Indiana.ECameraFramingOffset
// NumValues: 0x0005
enum class ECameraFramingOffset : uint8
{
	Auto                                     = 0,
	Center                                   = 1,
	Left                                     = 2,
	Right                                    = 3,
	ECameraFramingOffset_MAX                 = 4,
};

// Enum Indiana.ECreateItemCountRule
// NumValues: 0x0005
enum class ECreateItemCountRule : uint8
{
	UseItemDefinitionCount                   = 0,
	UseFormulaTier1Count                     = 1,
	UseFormulaTier2Count                     = 2,
	UseFormulaTier3Count                     = 3,
	ECreateItemCountRule_MAX                 = 4,
};

// Enum Indiana.FCreditsSpacingType
// NumValues: 0x0007
enum class EFCreditsSpacingType : uint8
{
	None                                     = 0,
	VerySmall                                = 1,
	Small                                    = 2,
	Average                                  = 3,
	Large                                    = 4,
	VeryLarge                                = 5,
	FCreditsSpacingType_MAX                  = 6,
};

// Enum Indiana.FCreditsTextType
// NumValues: 0x0007
enum class EFCreditsTextType : uint8
{
	None                                     = 0,
	Header                                   = 1,
	Subheader                                = 2,
	Title                                    = 3,
	Subtitle                                 = 4,
	Normal                                   = 5,
	FCreditsTextType_MAX                     = 6,
};

// Enum Indiana.FCreditsDisplayType
// NumValues: 0x0005
enum class EFCreditsDisplayType : uint8
{
	None                                     = 0,
	Text                                     = 1,
	Image                                    = 2,
	Spacing                                  = 3,
	FCreditsDisplayType_MAX                  = 4,
};

// Enum Indiana.EMeleeAttackType
// NumValues: 0x0005
enum class EMeleeAttackType : uint8
{
	None                                     = 0,
	Light                                    = 1,
	Heavy                                    = 2,
	WindUp                                   = 3,
	EMeleeAttackType_MAX                     = 4,
};

// Enum Indiana.EHitReactType
// NumValues: 0x0004
enum class EHitReactType : uint8
{
	None                                     = 0,
	Light                                    = 1,
	Heavy                                    = 2,
	EHitReactType_MAX                        = 3,
};

// Enum Indiana.EDamageFlags
// NumValues: 0x001B
enum class EDamageFlags : uint32
{
	None                                     = 0,
	Critical                                 = 1,
	Graze                                    = 2,
	Melee                                    = 4,
	CalledShot                               = 8,
	Stealth                                  = 16,
	NoDamage                                 = 32,
	Blocked                                  = 64,
	Range                                    = 128,
	IgnoreNonSealedArmor                     = 256,
	WeakSpot                                 = 512,
	KillingBlow                              = 1024,
	CanDamageFriends                         = 2048,
	AllDamageTypes                           = 4096,
	PowerAttack                              = 8192,
	IgnorePostArmorMult                      = 16384,
	SweepAttack                              = 32768,
	FriendlyFire                             = 65536,
	TacticalTimeDilation                     = 131072,
	ScienceWeapon                            = 262144,
	IgnoreDTDR                               = 524288,
	Suicide                                  = 1048576,
	HeadShot                                 = 2097152,
	ApplyOnTick                              = 4194304,
	Spell                                    = 8388608,
	IsLastTarget                             = 16777216,
	EDamageFlags_MAX                         = 16777217,
};

// Enum Indiana.EDamageScalars
// NumValues: 0x0008
enum class EDamageScalars : uint8
{
	WeaponLevel                              = 0,
	CharLevel                                = 1,
	TargetLevel                              = 2,
	WeaponDurability                         = 3,
	SneakAttack                              = 4,
	WeaponCritMult                           = 5,
	SimulateCrit                             = 6,
	EDamageScalars_MAX                       = 7,
};

// Enum Indiana.EDamageValueType
// NumValues: 0x0003
enum class EDamageValueType : uint8
{
	Value                                    = 0,
	Percent                                  = 1,
	EDamageValueType_MAX                     = 2,
};

// Enum Indiana.EDamageBaseAmount
// NumValues: 0x0003
enum class EDamageBaseAmount : uint8
{
	Default                                  = 0,
	WeaponDPS                                = 1,
	EDamageBaseAmount_MAX                    = 2,
};

// Enum Indiana.EDecisionTreeProcessType
// NumValues: 0x0004
enum class EDecisionTreeProcessType : uint8
{
	None                                     = 0,
	FirstSuccess                             = 1,
	Sequential                               = 2,
	EDecisionTreeProcessType_MAX             = 3,
};

// Enum Indiana.EStateInfoResultType
// NumValues: 0x0004
enum class EStateInfoResultType : uint8
{
	Failure                                  = 0,
	Success                                  = 1,
	RunScript                                = 2,
	EStateInfoResultType_MAX                 = 3,
};

// Enum Indiana.EDestructibleState
// NumValues: 0x0004
enum class EDestructibleState : uint8
{
	Pristine                                 = 0,
	Damaged                                  = 1,
	Destroyed                                = 2,
	EDestructibleState_MAX                   = 3,
};

// Enum Indiana.EDestructibleEventType
// NumValues: 0x0005
enum class EDestructibleEventType : uint8
{
	Invalid                                  = 0,
	Pristine                                 = 1,
	Damaged                                  = 2,
	Destroyed                                = 3,
	EDestructibleEventType_MAX               = 4,
};

// Enum Indiana.EDialogPromptMode
// NumValues: 0x0006
enum class EDialogPromptMode : uint8
{
	AcceptCancel                             = 0,
	ContinueCancel                           = 1,
	YesNo                                    = 2,
	ConfirmBack                              = 3,
	KeepRevert                               = 4,
	EDialogPromptMode_MAX                    = 5,
};

// Enum Indiana.EVOPositioning
// NumValues: 0x0004
enum class EVOPositioning : uint8
{
	Default                                  = 0,
	NonPositional                            = 1,
	Positional                               = 2,
	EVOPositioning_MAX                       = 3,
};

// Enum Indiana.EDisableTrackingType
// NumValues: 0x0004
enum class EDisableTrackingType : uint8
{
	Locked                                   = 0,
	TrackCaster                              = 1,
	None                                     = 2,
	EDisableTrackingType_MAX                 = 3,
};

// Enum Indiana.EDisguiseKeyResult
// NumValues: 0x0004
enum class EDisguiseKeyResult : uint8
{
	MissingShroud                            = 0,
	MissingKey                               = 1,
	Passed                                   = 2,
	EDisguiseKeyResult_MAX                   = 3,
};

// Enum Indiana.EWeatherType
// NumValues: 0x0005
enum class EWeatherType : uint8
{
	None                                     = 0,
	Rain                                     = 1,
	Dust                                     = 2,
	Snow                                     = 3,
	EWeatherType_MAX                         = 4,
};

// Enum Indiana.EElevatorEventType
// NumValues: 0x0004
enum class EElevatorEventType : uint8
{
	Invalid                                  = 0,
	MoveStart                                = 1,
	MoveEnd                                  = 2,
	EElevatorEventType_MAX                   = 3,
};

// Enum Indiana.ECoreFaceEmotion
// NumValues: 0x0019
enum class ECoreFaceEmotion : uint8
{
	DoNotChange                              = 0,
	Fear                                     = 27,
	Angry                                    = 1,
	Disgust                                  = 28,
	Flirtatious                              = 17,
	Happy                                    = 8,
	Sad                                      = 11,
	Shock                                    = 12,
	Neutral                                  = 9,
	Annoyed                                  = 2,
	Anxious                                  = 3,
	Awkward                                  = 4,
	Despair                                  = 6,
	Proud                                    = 10,
	Skeptical                                = 13,
	SlightlyAngry                            = 14,
	SlightlyHappy                            = 15,
	Livid                                    = 20,
	SlightlyAnnoyed                          = 21,
	Smolder                                  = 30,
	Confused                                 = 31,
	Smug                                     = 32,
	Grimace                                  = 33,
	Smirk                                    = 16,
	ECoreFaceEmotion_MAX                     = 34,
};

// Enum Indiana.EPosture
// NumValues: 0x000A
enum class EPosture : uint8
{
	DoNotUse                                 = 0,
	Conspiratorial                           = 5,
	Drunk                                    = 7,
	DrunkBar                                 = 26,
	Thinking                                 = 18,
	Neutral                                  = 9,
	Angry                                    = 36,
	Relaxed                                  = 37,
	ReadDocument                             = 38,
	EPosture_MAX                             = 39,
};

// Enum Indiana.EEmotion
// NumValues: 0x0029
enum class EEmotion : uint8
{
	DoNotUse                                 = 0,
	Angry                                    = 1,
	Annoyed                                  = 2,
	Anxious                                  = 3,
	Awkward                                  = 4,
	Conspiratorial                           = 5,
	Despair                                  = 6,
	Drunk                                    = 7,
	Happy                                    = 8,
	Neutral                                  = 9,
	Proud                                    = 10,
	Sad                                      = 11,
	Shock                                    = 12,
	Skeptical                                = 13,
	SlightlyAngry                            = 14,
	SlightlyHappy                            = 15,
	Smirk                                    = 16,
	Smolder                                  = 17,
	Thinking                                 = 18,
	WorkBench                                = 19,
	Livid                                    = 20,
	SlightlyAnnoyed                          = 21,
	LookDown                                 = 22,
	LookLeft                                 = 23,
	LookRight                                = 24,
	LookUp                                   = 25,
	DrunkBar                                 = 26,
	Fear                                     = 27,
	Disgust                                  = 28,
	Injured                                  = 29,
	SmolderNew                               = 30,
	Confused                                 = 31,
	Smug                                     = 32,
	Grimace                                  = 33,
	Yes                                      = 34,
	No                                       = 35,
	AngryPosture                             = 36,
	RelaxedPosture                           = 37,
	ReadDocumentPosture                      = 38,
	NumEmotionStates                         = 39,
	EEmotion_MAX                             = 40,
};

// Enum Indiana.EEncounterAggroType
// NumValues: 0x0004
enum class EEncounterAggroType : uint8
{
	Default                                  = 0,
	On                                       = 1,
	Off                                      = 2,
	EEncounterAggroType_MAX                  = 3,
};

// Enum Indiana.EEndGameImageType
// NumValues: 0x0005
enum class EEndGameImageType : uint8
{
	Invalid                                  = 0,
	SkipHopeToSun                            = 1,
	BoardPath                                = 2,
	ScientistPath                            = 3,
	EEndGameImageType_MAX                    = 4,
};

// Enum Indiana.EHolsterRequestSource
// NumValues: 0x0006
enum class EHolsterRequestSource : uint8
{
	None                                     = 0,
	Player                                   = 1,
	Ladder                                   = 2,
	Medkit                                   = 4,
	Scripted                                 = 8,
	EHolsterRequestSource_MAX                = 9,
};

// Enum Indiana.EEventEffectFloatParams
// NumValues: 0x0009
enum class EEventEffectFloatParams : uint8
{
	Duration                                 = 0,
	Size                                     = 1,
	Scalar                                   = 2,
	NormalizedStartTime                      = 3,
	SkipAnimations                           = 4,
	RateOfFire                               = 5,
	Count                                    = 6,
	Invalid                                  = 7,
	EEventEffectFloatParams_MAX              = 8,
};

// Enum Indiana.ETTDState
// NumValues: 0x0004
enum class ETTDState : uint8
{
	Invalid                                  = 0,
	TTDOnly                                  = 1,
	NotInTTDOnly                             = 2,
	ETTDState_MAX                            = 3,
};

// Enum Indiana.EFactionHardEnum
// NumValues: 0x0018
enum class EFactionHardEnum : uint8
{
	Anarchists                               = 0,
	Byzantium                                = 1,
	CnPFactory                               = 2,
	Deserters                                = 3,
	EmeraldVale                              = 4,
	Fairfield                                = 5,
	Groundbreaker                            = 6,
	InformationBroker                        = 7,
	Keystone                                 = 8,
	Marauders                                = 9,
	MatherFamily                             = 10,
	Midway                                   = 11,
	MSI                                      = 12,
	Roseway                                  = 13,
	SpacersChoice                            = 14,
	StellarBayResidents                      = 15,
	Syndicate                                = 16,
	TartarusMilitary                         = 17,
	TartarusPrisoners                        = 18,
	TartarusWorkers                          = 19,
	TheBoard                                 = 20,
	TheHope                                  = 21,
	Count                                    = 22,
	EFactionHardEnum_MAX                     = 23,
};

// Enum Indiana.EFactionVisibility
// NumValues: 0x0004
enum class EFactionVisibility : uint8
{
	Never                                    = 0,
	Always                                   = 1,
	Encounter                                = 2,
	EFactionVisibility_MAX                   = 3,
};

// Enum Indiana.ERapidFireMode
// NumValues: 0x0004
enum class ERapidFireMode : uint8
{
	None                                     = 0,
	RapidFire                                = 1,
	FineRapidFire                            = 2,
	ERapidFireMode_MAX                       = 3,
};

// Enum Indiana.EFireMode
// NumValues: 0x0007
enum class EFireMode : uint8
{
	Automatic                                = 0,
	Burst                                    = 1,
	Charge                                   = 2,
	SemiAutomatic                            = 3,
	SpinUp                                   = 4,
	ProjectileCharge                         = 5,
	EFireMode_MAX                            = 6,
};

// Enum Indiana.EFlawTrigger
// NumValues: 0x001A
enum class EFlawTrigger : uint8
{
	SpendMoney                               = 0,
	EyeInjury                                = 1,
	HeadInjury                               = 2,
	DialogFastSelection                      = 3,
	DialogAttack                             = 4,
	SetOffAlarm                              = 5,
	MaimedArm                                = 6,
	CrippledLeg                              = 7,
	Blinded                                  = 8,
	Concussed                                = 9,
	DamageThermal                            = 10,
	DamageCorrosion                          = 11,
	DamageNRay                               = 12,
	DamageShock                              = 13,
	DamagePoison                             = 14,
	DamageSwarm                              = 15,
	DamageFalling                            = 16,
	DamageRaptidon                           = 17,
	DamageRobot                              = 18,
	DamagePhysical                           = 19,
	AddictionDrug                            = 20,
	AddictionFood                            = 21,
	AddictionAlcohol                         = 22,
	AddictionSmoke                           = 23,
	Count                                    = 24,
	EFlawTrigger_MAX                         = 25,
};

// Enum Indiana.EFlawType
// NumValues: 0x0003
enum class EFlawType : uint8
{
	Systemic                                 = 0,
	Specific                                 = 1,
	EFlawType_MAX                            = 2,
};

// Enum Indiana.ETalkNodeVOAttenuationType
// NumValues: 0x0010
enum class ETalkNodeVOAttenuationType : uint8
{
	Default                                  = 0,
	None                                     = 1,
	SmallDistance                            = 2,
	MediumDistance                           = 3,
	LargeDistance                            = 4,
	Custom01                                 = 5,
	Custom02                                 = 6,
	Custom03                                 = 7,
	Custom04                                 = 8,
	Custom05                                 = 9,
	Custom06                                 = 10,
	Custom07                                 = 11,
	Custom08                                 = 12,
	Custom09                                 = 13,
	Custom10                                 = 14,
	ETalkNodeVOAttenuationType_MAX           = 15,
};

// Enum Indiana.EQuestDifficulty
// NumValues: 0x0006
enum class EQuestDifficulty : uint8
{
	Easy                                     = 0,
	Normal                                   = 1,
	Hard                                     = 2,
	Deadly                                   = 3,
	Count                                    = 4,
	EQuestDifficulty_MAX                     = 5,
};

// Enum Indiana.EQuestLocation
// NumValues: 0x0018
enum class EQuestLocation : uint8
{
	EmeraldVale                              = 0,
	Groundbreaker                            = 1,
	Terra2                                   = 2,
	Monarch                                  = 3,
	Tartarus                                 = 4,
	Roseway                                  = 5,
	Scylla                                   = 6,
	Hephaestus                               = 7,
	Space                                    = 8,
	Hope                                     = 9,
	Gorgon                                   = 10,
	Eridanos                                 = 11,
	PhaethonPilothouse                       = 12,
	RizzosDistillationStation                = 13,
	EridanosSpaceport                        = 14,
	TheGrandColonialHotel                    = 15,
	WildernessExploitationReserve            = 16,
	RizzosPurpleberryOrchards                = 17,
	RizzosResearchDevelopmentDistrictLabs    = 18,
	HappyDaleFarms                           = 19,
	StormtailShelter                         = 20,
	None                                     = 21,
	Count                                    = 22,
	EQuestLocation_MAX                       = 23,
};

// Enum Indiana.EResponseType
// NumValues: 0x0007
enum class EResponseType : uint8
{
	None                                     = 0,
	Lie                                      = 1,
	Intimidate                               = 2,
	Persuade                                 = 3,
	Dumb                                     = 4,
	Science                                  = 5,
	EResponseType_MAX                        = 6,
};

// Enum Indiana.EOEIQuestType
// NumValues: 0x0019
enum class EOEIQuestType : uint8
{
	MajorStoryQuest                          = 0,
	MajorSideQuest                           = 1,
	Task                                     = 2,
	MinorStoryQuest                          = 3,
	MinorSideQuest                           = 4,
	MajorFaction                             = 5,
	MinorFaction                             = 6,
	Companion                                = 7,
	INX1MajorStoryQuest                      = 8,
	INX1MajorSideQuest                       = 9,
	INX1Task                                 = 10,
	INX1MinorStoryQuest                      = 11,
	INX1MinorSideQuest                       = 12,
	INX1MajorFaction                         = 13,
	INX1MinorFaction                         = 14,
	INX1Companion                            = 15,
	INX2MajorStoryQuest                      = 16,
	INX2MajorSideQuest                       = 17,
	INX2Task                                 = 18,
	INX2MinorStoryQuest                      = 19,
	INX2MinorSideQuest                       = 20,
	INX2MajorFaction                         = 21,
	INX2MinorFaction                         = 22,
	INX2Companion                            = 23,
	EOEIQuestType_MAX                        = 24,
};

// Enum Indiana.EQuestType
// NumValues: 0x001A
enum class EQuestType : uint8
{
	MajorStoryQuest                          = 0,
	MinorStoryQuest                          = 1,
	INX1MajorStoryQuest                      = 2,
	INX1MinorStoryQuest                      = 3,
	INX2MajorStoryQuest                      = 4,
	INX2MinorStoryQuest                      = 5,
	MajorSideQuest                           = 6,
	MinorSideQuest                           = 7,
	INX1MajorSideQuest                       = 8,
	INX1MinorSideQuest                       = 9,
	INX2MajorSideQuest                       = 10,
	INX2MinorSideQuest                       = 11,
	MajorFaction                             = 12,
	MinorFaction                             = 13,
	INX1MajorFaction                         = 14,
	INX1MinorFaction                         = 15,
	INX2MajorFaction                         = 16,
	INX2MinorFaction                         = 17,
	Companion                                = 18,
	INX1Companion                            = 19,
	INX2Companion                            = 20,
	Task                                     = 21,
	INX1Task                                 = 22,
	INX2Task                                 = 23,
	Count                                    = 24,
	EQuestType_MAX                           = 25,
};

// Enum Indiana.QuestionNodeDisplayType
// NumValues: 0x0004
enum class EQuestionNodeDisplayType : uint8
{
	ShowOnce                                 = 0,
	ShowAlways                               = 1,
	ShowNever                                = 2,
	QuestionNodeDisplayType_MAX              = 3,
};

// Enum Indiana.FlowChartNodeType
// NumValues: 0x000F
enum class EFlowChartNodeType : uint8
{
	Talk                                     = 0,
	PlayerResponse                           = 1,
	Script                                   = 2,
	TriggerConversation                      = 3,
	Chatter                                  = 4,
	Bank                                     = 5,
	Quest                                    = 6,
	Objective                                = 7,
	EndState                                 = 8,
	GlobalQuest                              = 9,
	BranchComplete                           = 10,
	ChatterEvent                             = 11,
	ChatterBranch                            = 12,
	SoundEffect                              = 13,
	FlowChartNodeType_MAX                    = 14,
};

// Enum Indiana.NodeDisplayType
// NumValues: 0x0005
enum class ENodeDisplayType : uint8
{
	Hidden                                   = 0,
	Conversation                             = 1,
	Bark                                     = 2,
	Overlay                                  = 3,
	NodeDisplayType_MAX                      = 4,
};

// Enum Indiana.NodePlayType
// NumValues: 0x0006
enum class ENodePlayType : uint8
{
	Normal                                   = 0,
	Random                                   = 1,
	CycleLoop                                = 2,
	CycleStop                                = 3,
	CycleRandom                              = 4,
	NodePlayType_MAX                         = 5,
};

// Enum Indiana.ConversationType
// NumValues: 0x0005
enum class EConversationType : uint8
{
	Conversation                             = 0,
	Chatter                                  = 1,
	Count                                    = 2,
	Invalid                                  = 3,
	ConversationType_MAX                     = 4,
};

// Enum Indiana.PersistenceType
// NumValues: 0x0005
enum class EPersistenceType : uint8
{
	None                                     = 0,
	OnceEver                                 = 1,
	OncePerConversation                      = 2,
	MarkAsRead                               = 3,
	PersistenceType_MAX                      = 4,
};

// Enum Indiana.EParticleSpawnType
// NumValues: 0x0004
enum class EParticleSpawnType : uint8
{
	AtStepLocation                           = 0,
	AtSocketLocation                         = 1,
	AttachedToSocket                         = 2,
	EParticleSpawnType_MAX                   = 3,
};

// Enum Indiana.EClimbValidityStatus
// NumValues: 0x0005
enum class EClimbValidityStatus : uint8
{
	Valid                                    = 0,
	InvalidStart                             = 1,
	InvalidExit                              = 2,
	InvalidStartExit                         = 3,
	EClimbValidityStatus_MAX                 = 4,
};

// Enum Indiana.EFurniturePreviewType
// NumValues: 0x0004
enum class EFurniturePreviewType : uint8
{
	Start                                    = 0,
	Loop                                     = 1,
	Exit                                     = 2,
	EFurniturePreviewType_MAX                = 3,
};

// Enum Indiana.EEntryLocationStatus
// NumValues: 0x0008
enum class EEntryLocationStatus : uint32
{
	Clear                                    = 0,
	InvalidLocation                          = 1,
	Ignored                                  = 2,
	InvalidNav                               = 3,
	InvalidExitLocation                      = 4,
	SpaceBlocked                             = 5,
	MissingFloor                             = 6,
	EEntryLocationStatus_MAX                 = 7,
};

// Enum Indiana.EGender
// NumValues: 0x0005
enum class EGender : uint8
{
	Male                                     = 0,
	Female                                   = 1,
	Neuter                                   = 2,
	Count                                    = 3,
	EGender_MAX                              = 4,
};

// Enum Indiana.ENotificationState
// NumValues: 0x000D
enum class ENotificationState : uint8
{
	NotificationHidden                       = 0,
	NotificationFadingIn                     = 1,
	NotificationFadingInComplete             = 2,
	NotificationSetText                      = 3,
	NotificationAnimateIn                    = 4,
	NotificationAnimateInComplete            = 5,
	NotificationVisible                      = 6,
	NotificationShowText                     = 7,
	NotificationAnimateOut                   = 8,
	NotificationAnimateOutComplete           = 9,
	NotificationFadingOut                    = 10,
	NotificationFadingOutComplete            = 11,
	ENotificationState_MAX                   = 12,
};

// Enum Indiana.EInputBindingType
// NumValues: 0x0013
enum class EInputBindingType : uint8
{
	Press                                    = 0,
	PressAndRelease                          = 1,
	ReleaseNotHeld                           = 2,
	ReleaseNoConsume                         = 3,
	Release                                  = 4,
	HoldPoint25                              = 5,
	HoldPoint35                              = 6,
	HoldPoint5                               = 7,
	Hold1                                    = 8,
	Hold1Point5                              = 9,
	Axis                                     = 10,
	Linked                                   = 11,
	ReleaseOnHeldPoint25                     = 12,
	ReleaseOnHeldPoint35                     = 13,
	ReleaseOnHeldPoint5                      = 14,
	ReleaseOnHeld1                           = 15,
	ReleaseOnHeld1Point5                     = 16,
	Invalid                                  = 17,
	EInputBindingType_MAX                    = 18,
};

// Enum Indiana.EStickLayoutType
// NumValues: 0x0003
enum class EStickLayoutType : uint8
{
	Righty                                   = 0,
	Lefty                                    = 1,
	EStickLayoutType_MAX                     = 2,
};

// Enum Indiana.EGamepadLayoutType
// NumValues: 0x0005
enum class EGamepadLayoutType : uint8
{
	Standard                                 = 0,
	Modern                                   = 1,
	Legacy                                   = 2,
	Flipped                                  = 3,
	EGamepadLayoutType_MAX                   = 4,
};

// Enum Indiana.EButtonPress
// NumValues: 0x0006
enum class EButtonPress : uint8
{
	Invalid                                  = 0,
	OnPress                                  = 1,
	OnTap                                    = 2,
	OnHold                                   = 3,
	OnRelease                                = 4,
	EButtonPress_MAX                         = 5,
};

// Enum Indiana.EMeleeAction
// NumValues: 0x0015
enum class EMeleeAction : uint8
{
	Invalid                                  = 0,
	Idle                                     = 1,
	WindUpRight                              = 2,
	WindUpLeft                               = 3,
	AttackRightToLeft                        = 4,
	AttackLeftToRight                        = 5,
	WindUpPower                              = 6,
	PowerAttack                              = 7,
	WindUpSweep                              = 8,
	SweepAttack                              = 9,
	CounterAttack                            = 10,
	Recoil                                   = 11,
	WindUpNoStamina                          = 12,
	NoStaminaAttack                          = 13,
	CalledShotAttack                         = 14,
	SpecialAttack1                           = 15,
	SpecialAttack2                           = 16,
	SpecialAttack3                           = 17,
	SpecialAttack4                           = 18,
	CalledShot                               = 19,
	EMeleeAction_MAX                         = 20,
};

// Enum Indiana.EHazardEventType
// NumValues: 0x0005
enum class EHazardEventType : uint8
{
	Enabling                                 = 0,
	Enabled                                  = 1,
	Disabling                                = 2,
	Disabled                                 = 3,
	EHazardEventType_MAX                     = 4,
};

// Enum Indiana.EHealValueType
// NumValues: 0x0003
enum class EHealValueType : uint8
{
	Value                                    = 0,
	Percent                                  = 1,
	EHealValueType_MAX                       = 2,
};

// Enum Indiana.EHighlightMode
// NumValues: 0x0002
enum class EHighlightMode : uint8
{
	InteractableItems                        = 0,
	EHighlightMode_MAX                       = 1,
};

// Enum Indiana.EIdleCamFailReason
// NumValues: 0x000D
enum class EIdleCamFailReason : uint8
{
	Invalid                                  = 0,
	PlayerInputDetected                      = 1,
	PlayerInCombat                           = 2,
	PlayerInConversation                     = 3,
	PlayerIsReloading                        = 4,
	PlayerIsAiming                           = 5,
	PlayerIsMoving                           = 6,
	PlayerIsCrouching                        = 7,
	PlayerIsTakingSurvivalDamage             = 8,
	PlayerHasHostileStatusEffects            = 9,
	PlayerIsNotHealthy                       = 10,
	Success                                  = 11,
	EIdleCamFailReason_MAX                   = 12,
};

// Enum Indiana.EAnimationAudioLoopType
// NumValues: 0x0006
enum class EAnimationAudioLoopType : uint8
{
	None                                     = 0,
	Furniture                                = 1,
	Jump                                     = 2,
	AnimNotifyState                          = 3,
	Count                                    = 4,
	EAnimationAudioLoopType_MAX              = 5,
};

// Enum Indiana.EAudioMovementState
// NumValues: 0x0005
enum class EAudioMovementState : uint8
{
	Idle                                     = 0,
	Walking                                  = 1,
	Sprinting                                = 2,
	Count                                    = 3,
	EAudioMovementState_MAX                  = 4,
};

// Enum Indiana.ECharacterMovementAudioEvents
// NumValues: 0x000F
enum class ECharacterMovementAudioEvents : uint8
{
	None                                     = 0,
	Crouch                                   = 1,
	CrouchStanding                           = 2,
	Uncrouch                                 = 3,
	UncrouchStanding                         = 4,
	Jump                                     = 5,
	DodgeLeft                                = 6,
	DodgeBack                                = 7,
	DodgeRight                               = 8,
	DodgeForward                             = 9,
	Land                                     = 10,
	StartClimbing                            = 11,
	StopClimbing                             = 12,
	Count                                    = 13,
	ECharacterMovementAudioEvents_MAX        = 14,
};

// Enum Indiana.ECharacterAudioEvent
// NumValues: 0x0003
enum class ECharacterAudioEvent : uint8
{
	None                                     = 0,
	Passive                                  = 1,
	ECharacterAudioEvent_MAX                 = 2,
};

// Enum Indiana.ECrouchState
// NumValues: 0x0004
enum class ECrouchState : uint8
{
	Current                                  = 0,
	Crouched                                 = 1,
	UnCrouched                               = 2,
	ECrouchState_MAX                         = 3,
};

// Enum Indiana.EUISelectionState
// NumValues: 0x0005
enum class EUISelectionState : uint8
{
	None                                     = 0,
	Select                                   = 1,
	SelectLoop                               = 2,
	Deselect                                 = 3,
	EUISelectionState_MAX                    = 4,
};

// Enum Indiana.EPhaseMode
// NumValues: 0x0004
enum class EPhaseMode : uint8
{
	None                                     = 0,
	Partial                                  = 1,
	Full                                     = 2,
	EPhaseMode_MAX                           = 3,
};

// Enum Indiana.EIndianaCustomMovementType
// NumValues: 0x0002
enum class EIndianaCustomMovementType : uint8
{
	Climbing                                 = 0,
	EIndianaCustomMovementType_MAX           = 1,
};

// Enum Indiana.EIndianaDamageType
// NumValues: 0x000A
enum class EIndianaDamageType : uint8
{
	Physical                                 = 0,
	Thermal                                  = 1,
	Energy                                   = 2,
	Shock                                    = 3,
	Corrosion                                = 4,
	NRay                                     = 5,
	Swarm                                    = 6,
	Cold                                     = 7,
	Count                                    = 8,
	EIndianaDamageType_MAX                   = 9,
};

// Enum Indiana.EDLCType
// NumValues: 0x0003
enum class EDLCType : uint8
{
	INX1                                     = 0,
	INX2                                     = 1,
	EDLCType_MAX                             = 2,
};

// Enum Indiana.EDLCFlags
// NumValues: 0x0004
enum class EDLCFlags : uint8
{
	None                                     = 0,
	INX1                                     = 1,
	INX2                                     = 2,
	EDLCFlags_MAX                            = 3,
};

// Enum Indiana.EBoolResult
// NumValues: 0x0003
enum class EBoolResult : uint8
{
	OnTrue                                   = 0,
	OnFalse                                  = 1,
	EBoolResult_MAX                          = 2,
};

// Enum Indiana.EDownLoadableContent
// NumValues: 0x0003
enum class EDownLoadableContent : uint8
{
	INX1                                     = 0,
	INX2                                     = 1,
	EDownLoadableContent_MAX                 = 2,
};

// Enum Indiana.ETogglableAction
// NumValues: 0x000E
enum class ETogglableAction : uint8
{
	Dodge                                    = 0,
	Lunge                                    = 1,
	Disarmed                                 = 2,
	CanFlinch                                = 3,
	MindControlled                           = 4,
	IgnoreMeleeDamage                        = 5,
	IgnorePawnCollision                      = 6,
	Untargetable                             = 7,
	Undamageable                             = 8,
	Blind                                    = 9,
	Sprint                                   = 10,
	StatusEffectImmune                       = 11,
	WeaponCrit                               = 12,
	ETogglableAction_MAX                     = 13,
};

// Enum Indiana.EMeshTarget
// NumValues: 0x0004
enum class EMeshTarget : uint8
{
	FirstMesh                                = 0,
	CurrentCharacterMesh                     = 1,
	WeaponMesh                               = 2,
	EMeshTarget_MAX                          = 3,
};

// Enum Indiana.ESimplifiedLockpickHackingMode
// NumValues: 0x0003
enum class ESimplifiedLockpickHackingMode : uint8
{
	Normal                                   = 0,
	Simplified                               = 1,
	ESimplifiedLockpickHackingMode_MAX       = 2,
};

// Enum Indiana.EWeaponSelectAxisMode
// NumValues: 0x0003
enum class EWeaponSelectAxisMode : uint8
{
	Vertical                                 = 0,
	Horizontal                               = 1,
	EWeaponSelectAxisMode_MAX                = 2,
};

// Enum Indiana.EWeaponSelectMode
// NumValues: 0x0004
enum class EWeaponSelectMode : uint8
{
	Off                                      = 0,
	TimedFade                                = 1,
	On                                       = 2,
	EWeaponSelectMode_MAX                    = 3,
};

// Enum Indiana.ETTDReticleMeterMode
// NumValues: 0x0004
enum class ETTDReticleMeterMode : uint8
{
	Off                                      = 0,
	CombatOnly                               = 1,
	On                                       = 2,
	ETTDReticleMeterMode_MAX                 = 3,
};

// Enum Indiana.ECompanionAbilityPassiveNotificationMode
// NumValues: 0x0005
enum class ECompanionAbilityPassiveNotificationMode : uint8
{
	Off                                      = 0,
	CombatOnly                               = 1,
	TimedFade                                = 2,
	On                                       = 3,
	ECompanionAbilityPassiveNotificationMode_MAX = 4,
};

// Enum Indiana.ECompanionAbilityPassiveCDMode
// NumValues: 0x0005
enum class ECompanionAbilityPassiveCDMode : uint8
{
	Off                                      = 0,
	CombatOnly                               = 1,
	TimedFade                                = 2,
	On                                       = 3,
	ECompanionAbilityPassiveCDMode_MAX       = 4,
};

// Enum Indiana.ECompanionStatusMode
// NumValues: 0x0005
enum class ECompanionStatusMode : uint8
{
	Off                                      = 0,
	CombatOnly                               = 1,
	TimedFade                                = 2,
	On                                       = 3,
	ECompanionStatusMode_MAX                 = 4,
};

// Enum Indiana.EDodgeDisplayMode
// NumValues: 0x0004
enum class EDodgeDisplayMode : uint8
{
	Off                                      = 0,
	CombatOnly                               = 1,
	On                                       = 2,
	EDodgeDisplayMode_MAX                    = 3,
};

// Enum Indiana.ETTDDisplayMode
// NumValues: 0x0004
enum class ETTDDisplayMode : uint8
{
	Off                                      = 0,
	CombatOnly                               = 1,
	On                                       = 2,
	ETTDDisplayMode_MAX                      = 3,
};

// Enum Indiana.EAbilityControlMode
// NumValues: 0x0005
enum class EAbilityControlMode : uint8
{
	Off                                      = 0,
	CombatOnly                               = 1,
	TimedFade                                = 2,
	On                                       = 3,
	EAbilityControlMode_MAX                  = 4,
};

// Enum Indiana.EMedicalInhalerMode
// NumValues: 0x0004
enum class EMedicalInhalerMode : uint8
{
	Off                                      = 0,
	CombatOnly                               = 1,
	On                                       = 2,
	EMedicalInhalerMode_MAX                  = 3,
};

// Enum Indiana.ESurvivalMode
// NumValues: 0x0004
enum class ESurvivalMode : uint8
{
	Off                                      = 0,
	TimedFade                                = 1,
	On                                       = 2,
	ESurvivalMode_MAX                        = 3,
};

// Enum Indiana.EFPSIndicatorMode
// NumValues: 0x0006
enum class EFPSIndicatorMode : uint8
{
	Off                                      = 0,
	TopLeft                                  = 1,
	TopRight                                 = 2,
	BottomRight                              = 3,
	BottomLeft                               = 4,
	EFPSIndicatorMode_MAX                    = 5,
};

// Enum Indiana.EDirectionalDamageIndicatorMode
// NumValues: 0x0004
enum class EDirectionalDamageIndicatorMode : uint8
{
	Off                                      = 0,
	CombatOnly                               = 1,
	On                                       = 2,
	EDirectionalDamageIndicatorMode_MAX      = 3,
};

// Enum Indiana.EEnemyAwarenessMeterMode
// NumValues: 0x0004
enum class EEnemyAwarenessMeterMode : uint8
{
	Off                                      = 0,
	CombatOnly                               = 1,
	On                                       = 2,
	EEnemyAwarenessMeterMode_MAX             = 3,
};

// Enum Indiana.EEnemyHealthBarMode
// NumValues: 0x0004
enum class EEnemyHealthBarMode : uint8
{
	Off                                      = 0,
	CombatOnly                               = 1,
	On                                       = 2,
	EEnemyHealthBarMode_MAX                  = 3,
};

// Enum Indiana.ECompassVisibilityMode
// NumValues: 0x0004
enum class ECompassVisibilityMode : uint8
{
	Off                                      = 0,
	CombatOnly                               = 1,
	On                                       = 2,
	ECompassVisibilityMode_MAX               = 3,
};

// Enum Indiana.EHUDMode
// NumValues: 0x0005
enum class EHUDMode : uint8
{
	Minimal                                  = 0,
	Default                                  = 1,
	Maximum                                  = 2,
	Custom                                   = 3,
	EHUDMode_MAX                             = 4,
};

// Enum Indiana.EAreaNameMode
// NumValues: 0x0004
enum class EAreaNameMode : uint8
{
	Off                                      = 0,
	TimedFade                                = 1,
	On                                       = 2,
	EAreaNameMode_MAX                        = 3,
};

// Enum Indiana.EHeldWeaponDisplayText
// NumValues: 0x0005
enum class EHeldWeaponDisplayText : uint8
{
	Off                                      = 0,
	CombatOnly                               = 1,
	TimedFade                                = 2,
	On                                       = 3,
	EHeldWeaponDisplayText_MAX               = 4,
};

// Enum Indiana.EHeldWeaponDisplayMode
// NumValues: 0x0005
enum class EHeldWeaponDisplayMode : uint8
{
	Off                                      = 0,
	CombatOnly                               = 1,
	TimedFade                                = 2,
	On                                       = 3,
	EHeldWeaponDisplayMode_MAX               = 4,
};

// Enum Indiana.ECompanionAbilityBindingMode
// NumValues: 0x0005
enum class ECompanionAbilityBindingMode : uint8
{
	Off                                      = 0,
	CombatOnly                               = 1,
	TimedFade                                = 2,
	On                                       = 3,
	ECompanionAbilityBindingMode_MAX         = 4,
};

// Enum Indiana.ECompanionAbilityUIMode
// NumValues: 0x0005
enum class ECompanionAbilityUIMode : uint8
{
	Off                                      = 0,
	CombatOnly                               = 1,
	TimedFade                                = 2,
	On                                       = 3,
	ECompanionAbilityUIMode_MAX              = 4,
};

// Enum Indiana.EPlayerStatusEffectTextMode
// NumValues: 0x0004
enum class EPlayerStatusEffectTextMode : uint8
{
	Off                                      = 0,
	TimedFade                                = 1,
	AlwaysOn                                 = 2,
	EPlayerStatusEffectTextMode_MAX          = 3,
};

// Enum Indiana.EPlayerStatusBarMode
// NumValues: 0x0004
enum class EPlayerStatusBarMode : uint8
{
	Off                                      = 0,
	TimedFade                                = 1,
	On                                       = 2,
	EPlayerStatusBarMode_MAX                 = 3,
};

// Enum Indiana.EQuestUpdateMode
// NumValues: 0x0004
enum class EQuestUpdateMode : uint8
{
	Off                                      = 0,
	TimedFade                                = 1,
	On                                       = 2,
	EQuestUpdateMode_MAX                     = 3,
};

// Enum Indiana.EReticleMode
// NumValues: 0x0005
enum class EReticleMode : uint8
{
	Off                                      = 0,
	ADSOnly                                  = 1,
	CombatOnly                               = 2,
	On                                       = 3,
	EReticleMode_MAX                         = 4,
};

// Enum Indiana.EAimingReticleMode
// NumValues: 0x0004
enum class EAimingReticleMode : uint8
{
	Off                                      = 0,
	CombatOnly                               = 1,
	On                                       = 2,
	EAimingReticleMode_MAX                   = 3,
};

// Enum Indiana.EDialogSkillMode
// NumValues: 0x0004
enum class EDialogSkillMode : uint8
{
	Never                                    = 0,
	OnlyWhenClose                            = 1,
	Always                                   = 2,
	EDialogSkillMode_MAX                     = 3,
};

// Enum Indiana.ESSGIMode
// NumValues: 0x0003
enum class ESSGIMode : uint8
{
	Halfres                                  = 1,
	Fullres                                  = 2,
	ESSGIMode_MAX                            = 3,
};

// Enum Indiana.EFSR2Mode
// NumValues: 0x0005
enum class EFSR2Mode : uint8
{
	Quality                                  = 1,
	Balanced                                 = 2,
	Performance                              = 3,
	UltraPerf                                = 4,
	EFSR2Mode_MAX                            = 5,
};

// Enum Indiana.EPerformanceMode
// NumValues: 0x0003
enum class EPerformanceMode : uint8
{
	Performance                              = 0,
	Cinematic                                = 1,
	EPerformanceMode_MAX                     = 2,
};

// Enum Indiana.ELanguageMode
// NumValues: 0x000E
enum class ELanguageMode : uint8
{
	English                                  = 0,
	French                                   = 1,
	Italian                                  = 2,
	German                                   = 3,
	SpanishCastilian                         = 4,
	PortugueseBrazilian                      = 5,
	Russian                                  = 6,
	Korean                                   = 7,
	Japanese                                 = 8,
	ChineseSimplified                        = 9,
	Polish                                   = 10,
	Count                                    = 11,
	Invalid                                  = 12,
	ELanguageMode_MAX                        = 13,
};

// Enum Indiana.EWeaponTooltipStatMode
// NumValues: 0x0003
enum class EWeaponTooltipStatMode : uint8
{
	DPS                                      = 0,
	Damage                                   = 1,
	EWeaponTooltipStatMode_MAX               = 2,
};

// Enum Indiana.ECompanionOutlineMode
// NumValues: 0x0004
enum class ECompanionOutlineMode : uint8
{
	On                                       = 0,
	CombatOnly                               = 1,
	Off                                      = 2,
	ECompanionOutlineMode_MAX                = 3,
};

// Enum Indiana.EConversationSubtitleMode
// NumValues: 0x0004
enum class EConversationSubtitleMode : uint8
{
	On                                       = 0,
	Delayed                                  = 1,
	Off                                      = 2,
	EConversationSubtitleMode_MAX            = 3,
};

// Enum Indiana.EFPSLimit
// NumValues: 0x000B
enum class EFPSLimit : uint8
{
	Thirty                                   = 0,
	Sixty                                    = 1,
	HundredTwenty                            = 2,
	HundredFourtyFour                        = 3,
	HundredSixty                             = 4,
	HundredSixtyFive                         = 5,
	HundredEighty                            = 6,
	TwoHundred                               = 7,
	TwoHundredFourty                         = 8,
	Unlimited                                = 9,
	EFPSLimit_MAX                            = 10,
};

// Enum Indiana.EItemInteraction
// NumValues: 0x0005
enum class EItemInteraction : uint8
{
	EDragDropStart                           = 0,
	EDragDropEnd                             = 1,
	EItemPickup                              = 2,
	EItemConsumed                            = 3,
	EItemInteraction_MAX                     = 4,
};

// Enum Indiana.ECheckBranches
// NumValues: 0x0003
enum class ECheckBranches : uint8
{
	Valid                                    = 0,
	Invalid                                  = 1,
	ECheckBranches_MAX                       = 2,
};

// Enum Indiana.EOccupationChannel
// NumValues: 0x0004
enum class EOccupationChannel : uint8
{
	Firing                                   = 0,
	CharacterArea                            = 1,
	Count                                    = 2,
	EOccupationChannel_MAX                   = 3,
};

// Enum Indiana.EPathBlockedType
// NumValues: 0x0005
enum class EPathBlockedType : uint8
{
	None                                     = 0,
	Stuck                                    = 1,
	Lost                                     = 2,
	Destination                              = 3,
	EPathBlockedType_MAX                     = 4,
};

// Enum Indiana.EPlayerAudioEvent
// NumValues: 0x002D
enum class EPlayerAudioEvent : uint8
{
	None                                     = 0,
	TacticalTimeDilation                     = 1,
	EndTacticalTimeDilation                  = 2,
	CalledShot                               = 3,
	CalledShotImpactClose                    = 4,
	CalledShotImpactFar                      = 5,
	CalledShotCameraCutToTarget              = 6,
	CalledShotEnd                            = 7,
	CalledShotOffCooldown                    = 8,
	KillCamera                               = 9,
	QuestStarted                             = 10,
	QuestCompleted                           = 11,
	QuestFailed                              = 12,
	ObjectiveCompleted                       = 13,
	ObjectiveFailed                          = 14,
	AddendumAdded                            = 15,
	ObjectiveUpdated                         = 16,
	CombatStart                              = 17,
	BlockRangedAttack                        = 18,
	BlockMeleeAttack                         = 19,
	Bribe                                    = 20,
	DisguiseMeter                            = 21,
	DisguiseMeterDrain                       = 22,
	DisguiseMeterDepleted                    = 23,
	DisguiseMeterRefilled                    = 24,
	PickPocketStart                          = 25,
	PickPocketSuccess                        = 26,
	PickPocketFail                           = 27,
	PickPocketStop                           = 28,
	HackStart                                = 29,
	HackSuccess                              = 30,
	HackFail                                 = 31,
	WeaponDamaged                            = 32,
	WeaponSeverelyDamaged                    = 33,
	WeaponDestroyed                          = 34,
	HelmetDamaged                            = 35,
	HelmetSeverelyDamaged                    = 36,
	HelmetDestroyed                          = 37,
	ArmorDamaged                             = 38,
	ArmorSeverelyDamaged                     = 39,
	ArmorDestroyed                           = 40,
	StealthEntered                           = 41,
	StealthExited                            = 42,
	ReloadFail                               = 43,
	EPlayerAudioEvent_MAX                    = 44,
};

// Enum Indiana.EPlayerAudioDetectionState
// NumValues: 0x0004
enum class EPlayerAudioDetectionState : uint8
{
	Undetected                               = 0,
	Danger                                   = 1,
	Combat                                   = 2,
	EPlayerAudioDetectionState_MAX           = 3,
};

// Enum Indiana.EMapFlags
// NumValues: 0x0004
enum class EMapFlags : uint8
{
	None                                     = 0,
	Known                                    = 1,
	Visited                                  = 2,
	EMapFlags_MAX                            = 3,
};

// Enum Indiana.EIndianaTextAnimationType
// NumValues: 0x0006
enum class EIndianaTextAnimationType : uint8
{
	Invalid                                  = 0,
	DefaultComputerTerminalHeader            = 1,
	DefaultComputerTerminalSubheader         = 2,
	ComputerTerminalBody                     = 3,
	Count                                    = 4,
	EIndianaTextAnimationType_MAX            = 5,
};

// Enum Indiana.EIndianaAudioEvent
// NumValues: 0x0095
enum class EIndianaAudioEvent : uint8
{
	Invalid                                  = 0,
	CCAptitudeSelect                         = 1,
	CCRandomizeAppearance                    = 2,
	CCFinalize                               = 3,
	CompanionGained                          = 4,
	CompanionLost                            = 5,
	ToggleAdvanceStats                       = 6,
	CollapseExpandList                       = 7,
	SliderValueChange                        = 8,
	PageNext                                 = 9,
	PagePrev                                 = 10,
	SubPageChange                            = 11,
	Back                                     = 12,
	Sort                                     = 13,
	FlipSort                                 = 14,
	Hold                                     = 15,
	HoldCancel                               = 16,
	HoldFinished                             = 17,
	OpenToMap                                = 18,
	OpenToQuests                             = 19,
	OpenToInventory                          = 20,
	TabOpenLedger                            = 21,
	LootBody                                 = 22,
	PickpocketAction                         = 23,
	ItemViewerPageChange                     = 24,
	InventoryChangeTab                       = 25,
	CantDo                                   = 26,
	CharacterCreationRespecConfirm           = 27,
	ExaminablePopUp                          = 28,
	GlobalSelect                             = 29,
	TutorialAccept                           = 30,
	ItemAdded                                = 31,
	ItemRemoved                              = 32,
	ItemRepair                               = 33,
	ItemRepairAll                            = 34,
	ItemBreakdown                            = 35,
	ItemJunkUnjunk                           = 36,
	ItemDrop                                 = 37,
	ItemInspect                              = 38,
	ItemCompare                              = 39,
	ItemInspectZoom                          = 40,
	TutorialPopUpFullScreen                  = 41,
	TutorialPopUpMinor                       = 42,
	RepIncreased                             = 43,
	RepDecreased                             = 44,
	SkillCheckPass                           = 45,
	POIDiscovered                            = 46,
	XPGained                                 = 47,
	LevelUpNotificationStart                 = 48,
	LevelUpNotificationEnd                   = 49,
	FastTravelImpossible_Encumbered          = 50,
	FastTravelImpossible_Combat              = 51,
	ManualSave                               = 52,
	FastTravelAdded                          = 53,
	TextEntryTyping                          = 54,
	WarningDialog                            = 55,
	NewGame                                  = 56,
	ContinueGame                             = 57,
	Zoom                                     = 58,
	Pan                                      = 59,
	FastTravelConfirm                        = 60,
	MapTabChange                             = 61,
	SystemMapOpen                            = 62,
	SystemMapOpenAmbient                     = 63,
	SystemMapClose                           = 64,
	SystemMapCloseAmbient                    = 65,
	SystemMapShipStart                       = 66,
	SystemMapShipStop                        = 67,
	SystemMapShipLandingPad                  = 68,
	SystemMapFastTravelConfirm               = 69,
	SystemMapPanStart                        = 70,
	SystemMapPanStop                         = 71,
	SystemMapDestinationUnlocked             = 72,
	QuestSelect                              = 73,
	QuestFilterChange                        = 74,
	SkillSelectUnselect                      = 75,
	SkillUnavailable                         = 76,
	SkillApply                               = 77,
	PerkAddRemove                            = 78,
	PerkApply                                = 79,
	PerkFinalConfirm                         = 80,
	VendorOpenClose                          = 81,
	VendorOpenClose_AC                       = 82,
	VendorOpenClose_CP                       = 83,
	VendorOpenClose_Groundbreaker            = 84,
	VendorOpenClose_MSI                      = 85,
	VendorOpenClose_SC                       = 86,
	VendorOpenClose_Sublight                 = 87,
	VendorOpenClose_TL                       = 88,
	VendorChangeTab                          = 89,
	VendorBuy                                = 90,
	VendorCantBuy                            = 91,
	VendorSell                               = 92,
	VendorChangeCategory                     = 93,
	VendorSellJunk                           = 94,
	VendorRepair                             = 95,
	Vendor_Machine_Open_Factionless          = 96,
	Vendor_Machine_Open_AC                   = 97,
	Vendor_Machine_Open_CP                   = 98,
	Vendor_Machine_Open_Groundbreaker        = 99,
	Vendor_Machine_Open_MSI                  = 100,
	Vendor_Machine_Open_SC                   = 101,
	Vendor_Machine_Open_Sublight             = 102,
	Vendor_Machine_Open_TL                   = 103,
	Vendor_Human_Open_Factionless            = 104,
	Vendor_Human_Open_AC                     = 105,
	Vendor_Human_Open_CP                     = 106,
	Vendor_Human_Open_Groundbreaker          = 107,
	Vendor_Human_Open_MSI                    = 108,
	Vendor_Human_Open_SC                     = 109,
	Vendor_Human_Open_Sublight               = 110,
	Vendor_Human_Open_TL                     = 111,
	Vendor_Machine_Close_Factionless         = 112,
	Vendor_Machine_Close_AC                  = 113,
	Vendor_Machine_Close_CP                  = 114,
	Vendor_Machine_Close_Groundbreaker       = 115,
	Vendor_Machine_Close_MSI                 = 116,
	Vendor_Machine_Close_SC                  = 117,
	Vendor_Machine_Close_Sublight            = 118,
	Vendor_Machine_Close_TL                  = 119,
	Vendor_Human_Close_Factionless           = 120,
	Vendor_Human_Close_AC                    = 121,
	Vendor_Human_Close_CP                    = 122,
	Vendor_Human_Close_Groundbreaker         = 123,
	Vendor_Human_Close_MSI                   = 124,
	Vendor_Human_Close_SC                    = 125,
	Vendor_Human_Close_Sublight              = 126,
	Vendor_Human_Close_TL                    = 127,
	WBOpenClose                              = 128,
	WBInstallMod                             = 129,
	WBRepair                                 = 130,
	WBTinker                                 = 131,
	TextReadOut                              = 132,
	TerminalEnter                            = 133,
	TerminalExit                             = 134,
	RespecEnter                              = 135,
	SleepBed                                 = 136,
	WaitChair                                = 137,
	PauseMenuOpen                            = 138,
	PauseMenuClose                           = 139,
	PerkSuppressionNotification              = 140,
	AudioLogAcquiredNew                      = 141,
	AudioLogAcquiredRepeat                   = 142,
	AudioLogStarted                          = 143,
	AudioLogResumed                          = 144,
	AudioLogPaused                           = 145,
	AudioLogStopped                          = 146,
	Count                                    = 147,
	EIndianaAudioEvent_MAX                   = 148,
};

// Enum Indiana.EIndianaUIOpacityType
// NumValues: 0x0005
enum class EIndianaUIOpacityType : uint8
{
	Invalid                                  = 0,
	PipingOpacity                            = 1,
	BackgroundOpacity                        = 2,
	Count                                    = 3,
	EIndianaUIOpacityType_MAX                = 4,
};

// Enum Indiana.EWidgetOpenState
// NumValues: 0x0005
enum class EWidgetOpenState : uint8
{
	Maximized                                = 0,
	TransitioningToMinimized                 = 1,
	Minimized                                = 2,
	TransitioningToMaximized                 = 3,
	EWidgetOpenState_MAX                     = 4,
};

// Enum Indiana.EPlayerHomeBaseType
// NumValues: 0x0004
enum class EPlayerHomeBaseType : uint8
{
	None                                     = 0,
	Fake                                     = 1,
	Real                                     = 2,
	EPlayerHomeBaseType_MAX                  = 3,
};

// Enum Indiana.EObjectInteractionUIType
// NumValues: 0x0005
enum class EObjectInteractionUIType : uint8
{
	Lockpick                                 = 0,
	Hack                                     = 1,
	Trap                                     = 2,
	Pickpocket                               = 3,
	EObjectInteractionUIType_MAX             = 4,
};

// Enum Indiana.EPropagationMode
// NumValues: 0x0004
enum class EPropagationMode : uint8
{
	None                                     = 0,
	Parent                                   = 1,
	Indirect                                 = 2,
	EPropagationMode_MAX                     = 3,
};

// Enum Indiana.EInteractPayloadType
// NumValues: 0x0004
enum class EInteractPayloadType : uint8
{
	Int32_1                                  = 0,
	Float_1                                  = 1,
	String_1                                 = 2,
	EInteractPayloadType_MAX                 = 3,
};

// Enum Indiana.EInterruptType
// NumValues: 0x0003
enum class EInterruptType : uint8
{
	Interrupt                                = 0,
	PlaySimultaneously                       = 1,
	EInterruptType_MAX                       = 2,
};

// Enum Indiana.EItemType
// NumValues: 0x0011
enum class EItemType : uint8
{
	Weapon                                   = 0,
	ArmorSet                                 = 1,
	Ammo                                     = 2,
	Currency                                 = 3,
	Resource                                 = 4,
	Quest                                    = 5,
	WeaponMod                                = 6,
	Helmet                                   = 7,
	ArmorModArmoring                         = 8,
	ArmorModUtility                          = 9,
	ArmorModResistance                       = 10,
	ArmorModDampening                        = 11,
	MedKit                                   = 12,
	Gadget                                   = 13,
	Count                                    = 14,
	Invalid                                  = 15,
	EItemType_MAX                            = 16,
};

// Enum Indiana.EItemStat
// NumValues: 0x0031
enum class EItemStat : uint8
{
	WeaponType                               = 0,
	FireMode                                 = 1,
	AmmoType                                 = 2,
	SkillType                                = 3,
	DamageType                               = 4,
	DamageTypeEnumValue                      = 5,
	Damage                                   = 6,
	DPM                                      = 7,
	DPS                                      = 8,
	RPM                                      = 9,
	RoF                                      = 10,
	SwingAttackRate                          = 11,
	EquipTime                                = 12,
	ReloadTime                               = 13,
	CriticalChance                           = 14,
	CriticalMultiplier                       = 15,
	PostArmorMultiplier                      = 16,
	MagazineSize                             = 17,
	EffectiveRange                           = 18,
	MaxRange                                 = 19,
	Recoil                                   = 20,
	AimSpreadReduction                       = 21,
	SwayAngle                                = 22,
	SpreadAngle                              = 23,
	NoiseRange                               = 24,
	AoEOuterRadius                           = 25,
	MaxChargeTime                            = 26,
	AmmoPerShot                              = 27,
	AmmoTypeEmbedded                         = 28,
	DamageSpecialEffect                      = 29,
	ArmorThresholdPhysical                   = 30,
	ArmorResistancePhysical                  = 31,
	ArmorThresholdThermal                    = 32,
	ArmorResistanceThermal                   = 33,
	ArmorThresholdEnergy                     = 34,
	ArmorResistanceEnergy                    = 35,
	ArmorThresholdCorruption                 = 36,
	ArmorResistanceCorruption                = 37,
	ArmorThresholdShock                      = 38,
	ArmorResistanceShock                     = 39,
	ArmorThresholdNRay                       = 40,
	ArmorResistanceNRay                      = 41,
	ArmorThresholdCold                       = 42,
	ArmorResistanceCold                      = 43,
	ArmorSkillBonus                          = 44,
	ArmorType                                = 45,
	Durability                               = 46,
	Count                                    = 47,
	EItemStat_MAX                            = 48,
};

// Enum Indiana.EItemSorting
// NumValues: 0x000B
enum class EItemSorting : uint8
{
	CustomSort                               = 0,
	Alphabetical                             = 1,
	Value                                    = 2,
	Weight                                   = 3,
	ValueToWeight                            = 4,
	DamageRating                             = 5,
	WeaponType                               = 6,
	ArmorRating                              = 7,
	ArmorType                                = 8,
	RangedMeleeArmorMod                      = 9,
	EItemSorting_MAX                         = 10,
};

// Enum Indiana.ELedgerPages
// NumValues: 0x000E
enum class ELedgerPages : uint8
{
	CharacterStats                           = 0,
	Inventory                                = 1,
	Journal                                  = 2,
	Map                                      = 3,
	Companion1                               = 4,
	Companion2                               = 5,
	Companion3                               = 6,
	Companion4                               = 7,
	Companion5                               = 8,
	Companion6                               = 9,
	Null                                     = 10,
	Count                                    = 11,
	Invalid                                  = 12,
	ELedgerPages_MAX                         = 13,
};

// Enum Indiana.ELoadingScreenRegion
// NumValues: 0x000F
enum class ELoadingScreenRegion : uint8
{
	NoRegion                                 = 0,
	Byzantium                                = 1,
	EmeraldVale                              = 2,
	Groundbreaker                            = 3,
	Monarch                                  = 4,
	PlayerShip                               = 5,
	Roseway                                  = 6,
	ScientistLab                             = 7,
	Scylla                                   = 8,
	Tartarus                                 = 9,
	TheHope                                  = 10,
	Gorgon                                   = 11,
	Eridanos                                 = 12,
	Count                                    = 13,
	ELoadingScreenRegion_MAX                 = 14,
};

// Enum Indiana.ELocomotionCategory
// NumValues: 0x000E
enum class ELocomotionCategory : uint8
{
	LC_WalkStart                             = 0,
	LC_WalkStop                              = 1,
	LC_WalkTurn                              = 2,
	LC_RunStart                              = 3,
	LC_RunStop                               = 4,
	LC_RunTurn                               = 5,
	LC_WalkToRun                             = 6,
	LC_RunToWalk                             = 7,
	LC_TurnInPlace                           = 8,
	LC_Walk                                  = 9,
	LC_Idle                                  = 10,
	LC_Run                                   = 11,
	LC_Invalid                               = 12,
	LC_MAXIMUM                               = 13,
};

// Enum Indiana.EEqualityComparison
// NumValues: 0x0003
enum class EEqualityComparison : uint8
{
	Equal                                    = 0,
	NotEqual                                 = 1,
	EEqualityComparison_MAX                  = 2,
};

// Enum Indiana.EGlobalVariableComparison
// NumValues: 0x0007
enum class EGlobalVariableComparison : uint8
{
	Equal                                    = 0,
	NotEqual                                 = 1,
	GreaterThan                              = 2,
	LessThan                                 = 3,
	GreaterThanEqual                         = 4,
	LessThanEqual                            = 5,
	EGlobalVariableComparison_MAX            = 6,
};

// Enum Indiana.EConditionalType
// NumValues: 0x0006
enum class EConditionalType : uint8
{
	GlobalVar                                = 0,
	QuestState                               = 1,
	CompanionState                           = 2,
	PCGender                                 = 3,
	DLCInstalled                             = 4,
	EConditionalType_MAX                     = 5,
};

// Enum Indiana.ELogicalOperator
// NumValues: 0x0003
enum class ELogicalOperator : uint8
{
	And                                      = 0,
	Or                                       = 1,
	ELogicalOperator_MAX                     = 2,
};

// Enum Indiana.EDebugPCPlatformID
// NumValues: 0x0006
enum class EDebugPCPlatformID : uint8
{
	Normal                                   = 0,
	PC_EpicGamesStore                        = 1,
	PC_Steam                                 = 2,
	PC_WindowsStore                          = 3,
	PC_Gamepass                              = 4,
	EDebugPCPlatformID_MAX                   = 5,
};

// Enum Indiana.EWaitingForInputState
// NumValues: 0x0005
enum class EWaitingForInputState : uint8
{
	AutosaveSplash                           = 0,
	WaitingForInput                          = 1,
	HidingText                               = 2,
	Complete                                 = 3,
	EWaitingForInputState_MAX                = 4,
};

// Enum Indiana.EMaterialParamType
// NumValues: 0x0004
enum class EMaterialParamType : uint8
{
	Scalar                                   = 0,
	Vector                                   = 1,
	Texture                                  = 2,
	EMaterialParamType_MAX                   = 3,
};

// Enum Indiana.EAttackerSlottingState
// NumValues: 0x0005
enum class EAttackerSlottingState : uint8
{
	Unslotted_NoMove                         = 0,
	Unslotted                                = 1,
	Waiting                                  = 2,
	Slotted                                  = 3,
	EAttackerSlottingState_MAX               = 4,
};

// Enum Indiana.EMusicChangeReason
// NumValues: 0x000C
enum class EMusicChangeReason : uint8
{
	NoMusicAvailable                         = 0,
	LoadingDefault                           = 1,
	LoadingConditional                       = 2,
	GameOver                                 = 3,
	ScriptedOverride                         = 4,
	ConditionalOverride                      = 5,
	PlayerInDanger                           = 6,
	PlayerInCombat                           = 7,
	Default                                  = 8,
	PlayerInPostCombat                       = 9,
	UserSkip                                 = 10,
	EMusicChangeReason_MAX                   = 11,
};

// Enum Indiana.ESpecialObsidianID
// NumValues: 0x000A
enum class ESpecialObsidianID : uint8
{
	None                                     = 0,
	Companion1                               = 1,
	Companion2                               = 2,
	Companion3                               = 3,
	Companion4                               = 4,
	Companion5                               = 5,
	Companion6                               = 6,
	Companion7                               = 7,
	Count                                    = 8,
	ESpecialObsidianID_MAX                   = 9,
};

// Enum Indiana.EOCLEventType
// NumValues: 0x0011
enum class EOCLEventType : uint8
{
	Invalid                                  = 0,
	Open                                     = 1,
	Opening                                  = 2,
	Closed                                   = 3,
	Closing                                  = 4,
	Unlocked                                 = 5,
	Barred                                   = 6,
	Locked                                   = 7,
	LockpickSuccess                          = 8,
	LockpickInterrupted                      = 9,
	Lockpick                                 = 10,
	TravelStart                              = 11,
	Ambient                                  = 12,
	Unbarred                                 = 13,
	Unsealed                                 = 14,
	InteractLoopFinished                     = 15,
	EOCLEventType_MAX                        = 16,
};

// Enum Indiana.EOCLResult
// NumValues: 0x0009
enum class EOCLResult : uint8
{
	Success                                  = 0,
	Failed_Locked                            = 1,
	Failed_LockedPermanent                   = 2,
	Failed_Sealed                            = 3,
	Failed_IsOpening                         = 4,
	Failed_IsClosing                         = 5,
	Failed_Barred                            = 6,
	Pending_Lockpicking                      = 7,
	EOCLResult_MAX                           = 8,
};

// Enum Indiana.EOCLDifficulty
// NumValues: 0x0005
enum class EOCLDifficulty : uint8
{
	Easy                                     = 0,
	Medium                                   = 1,
	Difficult                                = 2,
	Extreme                                  = 3,
	EOCLDifficulty_MAX                       = 4,
};

// Enum Indiana.EPatrolMovementType
// NumValues: 0x0003
enum class EPatrolMovementType : uint32
{
	Run                                      = 0,
	Walk                                     = 1,
	EPatrolMovementType_MAX                  = 2,
};

// Enum Indiana.EPerkCategory
// NumValues: 0x0006
enum class EPerkCategory : uint8
{
	Military                                 = 0,
	Adventurer                               = 1,
	SilverTongue                             = 2,
	Companion                                = 3,
	Count                                    = 4,
	EPerkCategory_MAX                        = 5,
};

// Enum Indiana.EPersonalSpaceZone
// NumValues: 0x0005
enum class EPersonalSpaceZone : uint8
{
	None                                     = 0,
	Acknowledgement                          = 1,
	Interaction                              = 2,
	Violation                                = 3,
	EPersonalSpaceZone_MAX                   = 4,
};

// Enum Indiana.EPlanetType
// NumValues: 0x0005
enum class EPlanetType : uint8
{
	Hephaestus                               = 0,
	Monarch                                  = 1,
	Tartarus                                 = 2,
	Terra2                                   = 3,
	EPlanetType_MAX                          = 4,
};

// Enum Indiana.EDesiredEvent
// NumValues: 0x0004
enum class EDesiredEvent : uint8
{
	None                                     = 0,
	Single                                   = 1,
	Loop                                     = 2,
	EDesiredEvent_MAX                        = 3,
};

// Enum Indiana.EXPGainReason
// NumValues: 0x000B
enum class EXPGainReason : uint8
{
	EnemyKilled                              = 0,
	QuestCompleted                           = 1,
	QuestObjectiveCompleted                  = 2,
	DiscoveredPointOfInterest                = 3,
	HackTerminal                             = 4,
	LockPick                                 = 5,
	Conversation                             = 6,
	FoundCollectible                         = 7,
	Debug                                    = 8,
	DiscoveredTravelDestination              = 9,
	EXPGainReason_MAX                        = 10,
};

// Enum Indiana.EPointOfInterestXPType
// NumValues: 0x0007
enum class EPointOfInterestXPType : uint8
{
	None                                     = 0,
	LargePointOfInterest                     = 1,
	MediumPointOfInterest                    = 2,
	SmallPointOfInterest                     = 3,
	MicroPointOfInterest                     = 4,
	Services                                 = 5,
	EPointOfInterestXPType_MAX               = 6,
};

// Enum Indiana.EPointOfInterestLocationType
// NumValues: 0x0009
enum class EPointOfInterestLocationType : uint8
{
	FastTravel                               = 0,
	Town                                     = 1,
	Cave                                     = 2,
	Dungeon                                  = 3,
	Landmark                                 = 4,
	Vendor                                   = 5,
	VendingMachine                           = 6,
	Workbench                                = 7,
	EPointOfInterestLocationType_MAX         = 8,
};

// Enum Indiana.EPointOfInterestState
// NumValues: 0x0006
enum class EPointOfInterestState : uint8
{
	Hidden                                   = 0,
	HiddenUndiscoverable                     = 1,
	Unknown                                  = 2,
	Mentioned                                = 3,
	Discovered                               = 4,
	EPointOfInterestState_MAX                = 5,
};

// Enum Indiana.EQuestState
// NumValues: 0x0006
enum class EQuestState : uint8
{
	Invalid                                  = 0,
	InProgress                               = 1,
	Completed                                = 2,
	Failed                                   = 3,
	Mentioned                                = 4,
	EQuestState_MAX                          = 5,
};

// Enum Indiana.ECompletionStatus
// NumValues: 0x0006
enum class ECompletionStatus : uint8
{
	Invalid                                  = 0,
	Unstarted                                = 1,
	InProgress                               = 2,
	Completed                                = 3,
	Botched                                  = 4,
	ECompletionStatus_MAX                    = 5,
};

// Enum Indiana.EQueueType
// NumValues: 0x0003
enum class EQueueType : uint8
{
	Queue                                    = 0,
	Discard                                  = 1,
	EQueueType_MAX                           = 2,
};

// Enum Indiana.ERandomBankType
// NumValues: 0x0003
enum class ERandomBankType : uint8
{
	RandomGoodbye                            = 0,
	Count                                    = 1,
	ERandomBankType_MAX                      = 2,
};

// Enum Indiana.ERecoilState
// NumValues: 0x0004
enum class ERecoilState : uint8
{
	Active                                   = 0,
	ReturnToZero                             = 1,
	Inactive                                 = 2,
	ERecoilState_MAX                         = 3,
};

// Enum Indiana.ERegionType
// NumValues: 0x0019
enum class ERegionType : uint8
{
	None                                     = 0,
	Player_Ship_0301                         = 1,
	EmeraldVale_0001_Exterior                = 2,
	EmeraldVale_0002_Town                    = 3,
	EmeraldVale_0004_Geothermal_Plant        = 4,
	EmeraldVale_0005_Outcast_Camp            = 5,
	Groundbreaker_0101_Docking_Bays          = 6,
	Groundbreaker_0102_Promenade             = 7,
	Groundbreaker_0103_Operations            = 8,
	Monarch_0401_Exterior                    = 9,
	Monarch_0402_Stellar_Bay                 = 10,
	Monarch_0410_Stellar_Bay_Secret_Entrance = 11,
	Monarch_0403_Info_Broker_Compound        = 12,
	Monarch_0406_Devils_Peak_Station         = 13,
	Monarch_0408_Devils_Peak_Caverns         = 14,
	Monarch_0409_Nyoka_Secret_Passage        = 15,
	Roseway_0801_Forest                      = 16,
	Roseway_0802_Town                        = 17,
	Roseway_0804_Cleo_Lab                    = 18,
	Roseway_0803_Covert_Lab                  = 19,
	Roseway_0805_Storage_Facility            = 20,
	Terra2_0201_Exterior                     = 21,
	Terra2_0202_Byzantium                    = 22,
	Terra2_0203_HHCBuilding                  = 23,
	ERegionType_MAX                          = 24,
};

// Enum Indiana.ERelevancyType
// NumValues: 0x0004
enum class ERelevancyType : uint8
{
	None                                     = 0,
	Standard                                 = 1,
	Complete                                 = 2,
	ERelevancyType_MAX                       = 3,
};

// Enum Indiana.ECrosshairState
// NumValues: 0x0005
enum class ECrosshairState : uint8
{
	Invalid                                  = 0,
	Default                                  = 1,
	Hostile                                  = 2,
	Neutral                                  = 3,
	ECrosshairState_MAX                      = 4,
};

// Enum Indiana.EReticleType
// NumValues: 0x0004
enum class EReticleType : uint8
{
	Invalid                                  = 0,
	GenericMelee                             = 1,
	GenericRanged                            = 2,
	EReticleType_MAX                         = 3,
};

// Enum Indiana.EStatClampingMethod
// NumValues: 0x0006
enum class EStatClampingMethod : uint8
{
	None                                     = 0,
	ClampTo0                                 = 1,
	Custom                                   = 2,
	Attribute                                = 3,
	Skill                                    = 4,
	EStatClampingMethod_MAX                  = 5,
};

// Enum Indiana.EIndianaChunkIndex
// NumValues: 0x0005
enum class EIndianaChunkIndex : uint32
{
	EarlyInteractive                         = 0,
	BaseGame                                 = 1,
	INX1                                     = 15,
	INX2                                     = 16,
	EIndianaChunkIndex_MAX                   = 17,
};

// Enum Indiana.EAutoSaveType
// NumValues: 0x0004
enum class EAutoSaveType : uint8
{
	Default                                  = 0,
	Travel                                   = 1,
	Scripted                                 = 2,
	EAutoSaveType_MAX                        = 3,
};

// Enum Indiana.EDeleteGameResult
// NumValues: 0x0006
enum class EDeleteGameResult : uint8
{
	Success                                  = 0,
	Restricted                               = 1,
	Failed                                   = 2,
	SaveOfGivenNameNotFound                  = 3,
	FailedDeletingStaleTargetDir             = 4,
	EDeleteGameResult_MAX                    = 5,
};

// Enum Indiana.ESaveLoadRestriction
// NumValues: 0x001B
enum class ESaveLoadRestriction : uint8
{
	NoCurrentRestriction                     = 0,
	RunningPlayInEditor                      = 1,
	NoPlayerPresent                          = 2,
	CinematicInProgress                      = 3,
	PlayerInConversation                     = 4,
	PlayerInCombat                           = 5,
	PlayerCrimeDetected                      = 6,
	LevelTraveling                           = 7,
	ModalInterface                           = 8,
	PlayerIsIncapacitated                    = 9,
	SaveInProgress                           = 10,
	LoadInProgress                           = 11,
	TimeDilation                             = 12,
	ManualRestriction                        = 13,
	Unsupported                              = 14,
	DeviceFull                               = 15,
	PlatformSaveSystemNull                   = 16,
	PlatformStorageInaccessible              = 17,
	PlayerFalling                            = 18,
	PlayerInActiveHazard                     = 19,
	PlayerInterpolatingToSpline              = 20,
	PlayerDeadOrDying                        = 21,
	SuperNovaOnlySaveOnShip                  = 22,
	UserLoggingOut                           = 23,
	UIWindowActive                           = 24,
	UICharacterCreationActive                = 25,
	ESaveLoadRestriction_MAX                 = 26,
};

// Enum Indiana.EButtonType
// NumValues: 0x0003
enum class EButtonType : uint8
{
	Normal                                   = 0,
	Selectable                               = 1,
	EButtonType_MAX                          = 2,
};

// Enum Indiana.EScalarType
// NumValues: 0x0005
enum class EScalarType : uint8
{
	Invalid                                  = 0,
	Health                                   = 1,
	Damage                                   = 2,
	Armor                                    = 3,
	EScalarType_MAX                          = 4,
};

// Enum Indiana.ComparisonOperator
// NumValues: 0x0009
enum class EComparisonOperator : uint8
{
	Equals                                   = 0,
	GreaterThan                              = 1,
	LessThan                                 = 2,
	NotEqual                                 = 3,
	GreaterThanOrEquals                      = 4,
	LessThanOrEquals                         = 5,
	Count                                    = 6,
	Invalid                                  = 7,
	ComparisonOperator_MAX                   = 8,
};

// Enum Indiana.ExpressionComponentType
// NumValues: 0x0003
enum class ExpressionComponentType : uint8
{
	ScriptCall                               = 0,
	Expression                               = 1,
	ExpressionComponentType_MAX              = 2,
};

// Enum Indiana.LogicalOperator
// NumValues: 0x0003
//enum class Indiana::ELogicalOperator : uint8
//{
//	And                                      = 0,
//	Or                                       = 1,
//	LogicalOperator_MAX                      = 2,
//};

// Enum Indiana.EPlatformFamily
// NumValues: 0x0005
enum class EPlatformFamily : uint8
{
	PC                                       = 0,
	Xbox                                     = 1,
	PS4                                      = 2,
	Switch                                   = 3,
	EPlatformFamily_MAX                      = 4,
};

// Enum Indiana.ESettingSubcategory
// NumValues: 0x0012
enum class ESettingSubcategory : uint8
{
	Invalid                                  = 0,
	GraphicsDisplay                          = 1,
	GraphicsQuality                          = 2,
	AudioVolume                              = 3,
	ControlsController                       = 4,
	Subtitles                                = 5,
	General                                  = 6,
	Quests                                   = 7,
	Movement                                 = 8,
	Gameplay                                 = 9,
	Menus                                    = 10,
	ControlsMouseKeyboard                    = 11,
	UI                                       = 12,
	GameplayDisplay                          = 13,
	HUD                                      = 14,
	UIGeneral                                = 15,
	GraphicsEffects                          = 16,
	ESettingSubcategory_MAX                  = 17,
};

// Enum Indiana.ESetting
// NumValues: 0x00AA
enum class ESetting : uint8
{
	Invalid                                  = 0,
	Resolution                               = 1,
	WindowMode                               = 2,
	VerticalSync                             = 3,
	ViewDistanceQuality                      = 4,
	ShadowQuality                            = 5,
	AAQuality                                = 6,
	TextureQuality                           = 7,
	VisualEffectQuality                      = 8,
	PostProcessingQuality                    = 9,
	FolliageQuality                          = 10,
	MasterVolume                             = 11,
	EffectsVolume                            = 12,
	MusicVolume                              = 13,
	UIVolume                                 = 14,
	InvertControllerY                        = 15,
	ConversationSubtitleMode                 = 16,
	ConversationContinueOnVOEnd              = 17,
	ConversationResponsesVisibleDuringVO     = 18,
	QuestLogVisibleAllTimes                  = 19,
	MotionBlur                               = 20,
	AAMethod                                 = 21,
	MouseSensitivity                         = 22,
	VoiceVolume                              = 23,
	ItemStatsRaw                             = 24,
	GameDifficulty                           = 25,
	RadialSensitivity                        = 26,
	ControllerSensitivity                    = 27,
	ShowTutorials                            = 28,
	ShowFloatingDamageText                   = 29,
	ShowPlayerHelmet                         = 30,
	ShowCompanionHelmets                     = 31,
	GeneralQuality                           = 32,
	Gamma                                    = 33,
	BarkSubtitleVisibility                   = 34,
	CinematicSubtitleVisibility              = 35,
	CompanionOutlineVisibility               = 36,
	KeyBinds                                 = 37,
	GamePadLayout                            = 38,
	StickLayout                              = 39,
	MoveForward                              = 40,
	MoveBackward                             = 41,
	StrafeLeft                               = 42,
	StrafeRight                              = 43,
	LookUp                                   = 44,
	LookDown                                 = 45,
	TurnLeft                                 = 46,
	TurnRight                                = 47,
	Sprint                                   = 48,
	Jump                                     = 49,
	CrouchSneak                              = 50,
	QuickSave                                = 51,
	QuickLoad                                = 52,
	UseInteract                              = 53,
	WeaponOne                                = 54,
	WeaponTwo                                = 55,
	WeaponThree                              = 56,
	WeaponFour                               = 57,
	Inhaler                                  = 58,
	NextWeapon                               = 59,
	PreviousWeapon                           = 60,
	LastWeapon                               = 61,
	PrimaryFire                              = 62,
	AlernateFire                             = 63,
	Overcharge                               = 64,
	QuickMelee                               = 65,
	Reload                                   = 66,
	WeaponWheel                              = 67,
	TimeDilation                             = 68,
	CompanionMove                            = 69,
	CompanionAttack                          = 70,
	CompanionFollow                          = 71,
	CompanionOneSpecialAbility               = 72,
	CompanionTwoSpecialAbility               = 73,
	Pause                                    = 74,
	ViewInventory                            = 75,
	ViewLedger                               = 76,
	ViewCharacterMenu                        = 77,
	ViewJournal                              = 78,
	ViewMap                                  = 79,
	ViewRegionMap                            = 80,
	ViewCompanionMenu                        = 81,
	ViewPerks                                = 82,
	ViewSkills                               = 83,
	ViewCodex                                = 84,
	ViewSummary                              = 85,
	ViewDetails                              = 86,
	ViewReputation                           = 87,
	InvertMouseY                             = 88,
	ControllerRumble                         = 89,
	AutoCollapseInventory                    = 90,
	GameplayGamma                            = 91,
	Language                                 = 92,
	WeaponTooltipStatMode                    = 93,
	HUDVisibility                            = 94,
	HUDMode                                  = 95,
	CompassVisibility                        = 96,
	ShowDialogSkill                          = 97,
	TooltipDelay                             = 98,
	NotificationDuration                     = 99,
	InteractionOutlines                      = 100,
	InteractionControls                      = 101,
	WaypointMarkers                          = 102,
	EnemyHealthBars                          = 103,
	EnemyAwarenessMeters                     = 104,
	AimingReticle                            = 105,
	ReticleFeedback                          = 106,
	QuestUpdates                             = 107,
	PlayerStatusBars                         = 108,
	PlayerStatusEffects                      = 109,
	PlayerStatusEffectNames                  = 110,
	CompanionAbilityUI                       = 111,
	CompanionAbilityBindings                 = 112,
	HeldWeaponDisplay                        = 113,
	HeldWeaponDisplayText                    = 114,
	AreaNames                                = 115,
	DirectionalDamageIndicators              = 116,
	FPSIndicator                             = 117,
	SurvivalMeters                           = 118,
	MedicalInhaler                           = 119,
	AbilityControls                          = 120,
	CompanionStatus                          = 121,
	CompanionPassiveCooldowns                = 122,
	CompanionPassiveCooldownNotification     = 123,
	LevelUpNotifications                     = 124,
	LevelUpReminders                         = 125,
	CombatIndicator                          = 126,
	TTDScanner                               = 127,
	TTDReticleMeter                          = 128,
	TTDStatusEffectPreview                   = 129,
	DisguiseMeter                            = 130,
	EquipmentRepairWarning                   = 131,
	SimplifiedEquipmentRepairWarning         = 132,
	WeaponSelect                             = 133,
	WeaponSelectAxis                         = 134,
	SimplifiedLockpickHacking                = 135,
	LootTooltips                             = 136,
	LootControls                             = 137,
	ShowTutorialNotifications                = 138,
	FPSLimit                                 = 139,
	Resolution3D                             = 140,
	DetectGraphics                           = 141,
	FieldOfView                              = 142,
	TTDDisplayMode                           = 143,
	DodgeDisplayMode                         = 144,
	ControllerDeadZoneLeftInner              = 145,
	ControllerDeadZoneLeftOuter              = 146,
	ControllerDeadZoneRightInner             = 147,
	ControllerDeadZoneRightOuter             = 148,
	EnlargedFontSize                         = 149,
	ColorblindMode                           = 150,
	OffsetReticle                            = 151,
	CinematicKillCam                         = 152,
	ChromaticAberration                      = 153,
	Headbobbing                              = 154,
	MouseADSSensitivity                      = 155,
	ControllerADSSensitivity                 = 156,
	FontSizeModifier                         = 157,
	ControllerEnableAutoSprint               = 158,
	AutoSprint                               = 159,
	InvertMouseX                             = 160,
	InvertControllerX                        = 161,
	InterruptAudioLog                        = 162,
	PerformanceMode                          = 163,
	ControllerEnableImpulseTriggers          = 164,
	ImpulseTriggerIntensity                  = 165,
	DynamicResolution                        = 166,
	SSGI                                     = 167,
	FSR2                                     = 168,
	ESetting_MAX                             = 169,
};

// Enum Indiana.ECategory
// NumValues: 0x0009
enum class ECategory : uint8
{
	None                                     = 0,
	Graphics                                 = 1,
	Audio                                    = 2,
	Control                                  = 3,
	Gameplay                                 = 4,
	UI                                       = 5,
	Debug                                    = 6,
	Count                                    = 7,
	ECategory_MAX                            = 8,
};

// Enum Indiana.EShapeType
// NumValues: 0x0005
enum class EShapeType : uint8
{
	Unknown                                  = 0,
	Box                                      = 1,
	Sphere                                   = 2,
	Capsule                                  = 3,
	EShapeType_MAX                           = 4,
};

// Enum Indiana.ESpawnActorEventLocationSetting
// NumValues: 0x0003
enum class ESpawnActorEventLocationSetting : uint8
{
	MatchTargetActor                         = 0,
	ProjectToGround                          = 1,
	ESpawnActorEventLocationSetting_MAX      = 2,
};

// Enum Indiana.ESpawnActorEventRotationSetting
// NumValues: 0x0003
enum class ESpawnActorEventRotationSetting : uint8
{
	DoNotRotate                              = 0,
	MatchTargetActor                         = 1,
	ESpawnActorEventRotationSetting_MAX      = 2,
};

// Enum Indiana.ESpellApplicationResult
// NumValues: 0x0004
enum class ESpellApplicationResult : uint8
{
	NotApplied                               = 0,
	OneShot                                  = 1,
	Persistent                               = 2,
	ESpellApplicationResult_MAX              = 3,
};

// Enum Indiana.EConeAxis
// NumValues: 0x0005
enum class EConeAxis : uint8
{
	None                                     = 0,
	X                                        = 1,
	Y                                        = 2,
	Z                                        = 3,
	EConeAxis_MAX                            = 4,
};

// Enum Indiana.ESpellEffectDirectionType
// NumValues: 0x0005
enum class ESpellEffectDirectionType : uint8
{
	Default                                  = 0,
	CasterToTarget                           = 1,
	CasterForward                            = 2,
	TargetForward                            = 3,
	ESpellEffectDirectionType_MAX            = 4,
};

// Enum Indiana.ESpellEffectTarget
// NumValues: 0x000F
enum class ESpellEffectTarget : uint8
{
	Self                                     = 0,
	Player                                   = 1,
	Companions                               = 2,
	Target                                   = 3,
	Party                                    = 4,
	AOE                                      = 5,
	Cone                                     = 6,
	RandomCompanion                          = 7,
	RandomCompanionOnCooldown                = 8,
	OtherCompanion                           = 9,
	CharactersDetectingPlayer                = 10,
	AOESingleChoice                          = 11,
	Count                                    = 12,
	Invalid                                  = 13,
	ESpellEffectTarget_MAX                   = 14,
};

// Enum Indiana.ESpellCastResult
// NumValues: 0x0008
enum class ESpellCastResult : uint8
{
	Success                                  = 0,
	AlreadyActive                            = 1,
	InvalidTarget                            = 2,
	OnCooldown                               = 3,
	NotEnoughResources                       = 4,
	Count                                    = 5,
	Invalid                                  = 6,
	ESpellCastResult_MAX                     = 7,
};

// Enum Indiana.EStackSplitStyle
// NumValues: 0x000C
enum class EStackSplitStyle : uint8
{
	Default                                  = 0,
	CenterBG                                 = 1,
	Center                                   = 2,
	LeftBG                                   = 3,
	Left                                     = 4,
	TopBG                                    = 5,
	Top                                      = 6,
	RightBG                                  = 7,
	Right                                    = 8,
	BottomBG                                 = 9,
	Bottom                                   = 10,
	EStackSplitStyle_MAX                     = 11,
};

// Enum Indiana.TestEnum
// NumValues: 0x0004
enum class ETestEnum : uint8
{
	EnumValue0                               = 0,
	EnumValue1                               = 1,
	EnumValue2                               = 2,
	TestEnum_MAX                             = 3,
};

// Enum Indiana.EAdjustmentDirection
// NumValues: 0x0004
enum class EAdjustmentDirection : uint8
{
	Neutral                                  = 0,
	Positive                                 = 1,
	Negative                                 = 2,
	EAdjustmentDirection_MAX                 = 3,
};

// Enum Indiana.ERpgStatGroupMask
// NumValues: 0x0005
enum class ERpgStatGroupMask : uint8
{
	None                                     = 0,
	CharacterOnly                            = 1,
	WeaponOnly                               = 2,
	CharacterAndWeapon                       = 3,
	ERpgStatGroupMask_MAX                    = 4,
};

// Enum Indiana.ERpgStatGroup
// NumValues: 0x0005
enum class ERpgStatGroup : uint8
{
	Character                                = 0,
	Weapon                                   = 1,
	Count                                    = 2,
	Invalid                                  = 255,
	ERpgStatGroup_MAX                        = 256,
};

// Enum Indiana.EStatModifierType
// NumValues: 0x0004
enum class EStatModifierType : uint8
{
	PreAdd                                   = 0,
	Multiplier                               = 1,
	PostAdd                                  = 2,
	EStatModifierType_MAX                    = 3,
};

// Enum Indiana.EStatusEffectApplicationType
// NumValues: 0x0005
enum class EStatusEffectApplicationType : uint8
{
	ApplyOnStart                             = 0,
	ApplyOnTick                              = 1,
	ApplyOverTime                            = 2,
	ApplyAtEnd                               = 3,
	EStatusEffectApplicationType_MAX         = 4,
};

// Enum Indiana.EStatusEffectDurationType
// NumValues: 0x0007
enum class EStatusEffectDurationType : uint8
{
	UseDurationTime                          = 0,
	Instant                                  = 1,
	Infinite                                 = 2,
	Parent                                   = 3,
	Formula                                  = 4,
	PassThroughValue                         = 5,
	EStatusEffectDurationType_MAX            = 6,
};

// Enum Indiana.EStatusEffectInitialApplicationType
// NumValues: 0x0007
enum class EStatusEffectInitialApplicationType : uint8
{
	StackIfAlreadyApplied                    = 0,
	RemoveExistingIfAlreadyApplied           = 1,
	UseLongerDurationIfAlreadyApplied        = 2,
	AddDurationIfAlreadyApplied              = 3,
	DontApplyIfAlreadyApplied                = 4,
	StackSingleInstance                      = 5,
	EStatusEffectInitialApplicationType_MAX  = 6,
};

// Enum Indiana.EStatusEffectKeywordType
// NumValues: 0x0008
enum class EStatusEffectKeywordType : uint8
{
	None                                     = 0,
	Acid                                     = 1,
	Bleed                                    = 2,
	Disease                                  = 3,
	Fire                                     = 4,
	Ice                                      = 5,
	Poison                                   = 6,
	EStatusEffectKeywordType_MAX             = 7,
};

// Enum Indiana.EGuiText
// NumValues: 0x0492
enum class EGuiText : uint16
{
	__Invalid__                              = 0,
	No                                       = 1,
	Accept                                   = 2,
	Cancel                                   = 3,
	Continue                                 = 4,
	EndDialogue                              = 6,
	Back                                     = 7,
	Quit                                     = 9,
	NewSaveFile                              = 17,
	LedgerNavigation_Inventory               = 18,
	Ledger_Tab_Journal                       = 19,
	LedgerNavigation_Map                     = 20,
	Male                                     = 22,
	Female                                   = 23,
	StatusEffect_Injure                      = 24,
	StatusEffect_Stagger                     = 25,
	StatusEffect_Knockback                   = 26,
	StatusEffect_Wind                        = 27,
	StatusEffect_Lame                        = 28,
	StatusEffect_Maim                        = 29,
	StatusEffect_Stun                        = 30,
	StatusEffect_Concuss                     = 31,
	StatusEffect_Knockdown                   = 32,
	StatusEffect_Blur                        = 33,
	StatusEffect_Disarm                      = 34,
	StatusEffect_Knockout                    = 35,
	On                                       = 36,
	Off                                      = 37,
	Revert                                   = 38,
	Yes                                      = 39,
	SoundMaster                              = 40,
	SoundEffects                             = 41,
	SoundMusic                               = 42,
	SoundUI                                  = 43,
	SettingCategorySound                     = 44,
	SettingCategoryGeneral                   = 45,
	YAxisInverted                            = 46,
	Default                                  = 47,
	Fullscreen                               = 48,
	ResponseLie                              = 49,
	ResponseIntimidate                       = 50,
	ResponsePersuade                         = 51,
	QuestAdded                               = 52,
	QuestUpdated                             = 53,
	QuestCompleted                           = 54,
	QuestFailed                              = 55,
	Door_BarredShut                          = 56,
	Door_InformLocked                        = 57,
	Door_InformPermanentlyLocked             = 58,
	Door_Unlocked                            = 61,
	KeyItem_Removed                          = 63,
	Menu_Resume                              = 64,
	Menu_Restart                             = 65,
	Menu_MainMenu                            = 66,
	Menu_Settings                            = 67,
	Settings_Debug                           = 68,
	Menu_Dead                                = 69,
	Menu_Levels                              = 70,
	Level_BeautifulCorner                    = 71,
	Level_Prototype                          = 72,
	Level_Dialog                             = 73,
	Level_Stealth                            = 74,
	Level_Combat                             = 75,
	Level_Movement                           = 76,
	Level_Back                               = 77,
	Settings_VSync                           = 78,
	Settings_General                         = 79,
	Container_BarredShut                     = 81,
	Level_Area                               = 82,
	Level_QuestTest                          = 83,
	Level_GameObjectsTest                    = 84,
	Button_Claim                             = 85,
	Button_Close                             = 86,
	Button_Unlock                            = 88,
	Button_Transfer                          = 89,
	Button_Claim_All                         = 90,
	Door_Guide_Open                          = 92,
	Door_Guide_Locked                        = 93,
	Door_Guide_Barred                        = 94,
	Guide_Unlock_With_Requirement            = 95,
	Switch_Guide_Use                         = 96,
	Ladder_Guide_Use                         = 97,
	Pickup_Guide_Use                         = 98,
	Elevator_Guide_Use                       = 99,
	Switch_Guide_Use_Travel                  = 106,
	Build_Version                            = 107,
	Computer_Guide_Use                       = 108,
	Computer_Guide_Locked                    = 109,
	Computer_KeyItem_Removed                 = 111,
	Computer_Unlocked_Key                    = 113,
	Computer_Locked                          = 114,
	Computer_InformLocked_Error              = 117,
	Computer_Difficulty_Easy                 = 118,
	Computer_Difficulty_Medium               = 119,
	Computer_Difficulty_Difficult            = 120,
	Computer_Difficulty_Extreme              = 121,
	Button_Clear                             = 122,
	Talk                                     = 123,
	Available                                = 132,
	StatusEffect_Intimidate                  = 133,
	StatusEffect_ReducedRange                = 134,
	StatusEffect_ReducedSight                = 135,
	StatusEffect_Disabled                    = 136,
	StatusEffect_ReducedDamage               = 137,
	StatusEffect_Slow                        = 138,
	Settings_Apply                           = 139,
	Settings_Back                            = 140,
	Settings_Graphics                        = 141,
	Settings_Audio                           = 142,
	Settings_Controls                        = 143,
	Settings_Game                            = 144,
	Settings_UI                              = 145,
	Settings_Subcat_Volume                   = 146,
	Settings_Fullscreen                      = 147,
	Settings_WindowedFullscreen              = 148,
	Settings_Windowed                        = 149,
	Settings_WindowMode                      = 150,
	Settings_Low                             = 151,
	Settings_Medium                          = 152,
	Settings_High                            = 153,
	Settings_VeryHigh                        = 154,
	Settings_ViewDistanceQuality             = 155,
	Settings_ShadowQuality                   = 156,
	Settings_AAQuality                       = 157,
	Settings_TextureQuality                  = 158,
	Settings_PostProcessingQuality           = 159,
	Settings_FoliageQuality                  = 160,
	Settings_HDR                             = 161,
	Settings_VisualEffectQuality             = 162,
	Settings_Subcat_Quality                  = 163,
	Settings_Subcat_General                  = 164,
	Settings_Resolution                      = 165,
	Settings_Subcat_Camera                   = 166,
	Settings_Reserved                        = 167,
	Settings_Subcat_Display                  = 168,
	InputLabel_MoveSelection                 = 169,
	InputLabel_Select                        = 170,
	InputLabel_Back                          = 171,
	InputLabel_PageLeft                      = 172,
	InputLabel_PageRight                     = 173,
	Settings_Defaults_Confirmation           = 176,
	Trap_Difficulty_Easy                     = 177,
	Trap_Difficulty_Medium                   = 178,
	Trap_Difficulty_Difficult                = 179,
	Trap_Difficulty_Extreme                  = 180,
	Trap_Guide_Armed                         = 181,
	Trap_Guide_Disarmed                      = 182,
	Trap_Guide_Deactivated                   = 183,
	Conversation_PlayerName                  = 185,
	Settings_On                              = 193,
	Settings_Off                             = 194,
	Conversation_Exit_Conversation           = 201,
	ContextMenu_Repair                       = 205,
	ContextMenu_Drop                         = 206,
	ContextMenu_Deconstruct                  = 207,
	ContextMenu_Inspect                      = 208,
	ContextMenu_Unequip                      = 209,
	Input_Zero                               = 210,
	Input_One                                = 211,
	Input_Two                                = 212,
	Input_Three                              = 213,
	Input_Four                               = 214,
	Input_Five                               = 215,
	Input_Six                                = 216,
	Input_Seven                              = 217,
	Input_Eight                              = 218,
	Input_Nine                               = 219,
	StatusEffect_Burn                        = 220,
	StatusEffect_Bleed                       = 221,
	ContextMenu_MarkAsJunk                   = 222,
	ContextMenu_UnmarkAsJunk                 = 223,
	LedgerNavigation_Quests                  = 224,
	Ledger_Tab_Companion                     = 225,
	Inventory_ToggleComparison               = 226,
	Inventory_AddToJunk                      = 227,
	Inventory_Keep                           = 228,
	Inventory_Inspect                        = 229,
	CharacterTitleFighting                   = 232,
	CharacterTitleDialog                     = 233,
	CharacterTitleStealth                    = 234,
	CharacterTitleLeadership                 = 235,
	CharacterNameFighting                    = 236,
	CharacterNameDialog                      = 237,
	CharacterNameStealth                     = 238,
	CharacterNameLeadership                  = 239,
	CharacterBioFighting                     = 240,
	CharacterBioDialog                       = 241,
	CharacterBioStealth                      = 242,
	CharacterBioLeadership                   = 243,
	Item_Inspector                           = 244,
	WeaponStats_UnoccupiedMod                = 245,
	WeaponStat_Damage                        = 247,
	WeaponStat_Rof                           = 248,
	WeaponStat_MagSize                       = 249,
	WeaponStat_DPS                           = 250,
	WeaponStat_Accuracy                      = 251,
	WeaponStat_ReloadTime                    = 252,
	WeaponStat_Range                         = 253,
	WeaponStat_EquipTime                     = 254,
	WeaponStat_CritChanceBonus               = 255,
	WeaponStat_CritDamageBonus               = 256,
	WeaponStat_NoiseRange                    = 257,
	WeaponStat_Recoil                        = 258,
	WeaponStat_AimAccuracyBonus              = 259,
	WeaponStat_AimStaminaCost                = 260,
	WeaponStat_AmmoPerShot                   = 261,
	WeaponStat_PostArmorMultiplier           = 262,
	WeaponStat_OverchargeDurationBonus       = 263,
	WeaponStat_OverchargeTime                = 264,
	WeaponStat_AOESpreadRadius               = 265,
	Settings_ConversationSubtitle_Delayed    = 266,
	DT_Physical                              = 268,
	DT_Thermal                               = 269,
	DT_Energy                                = 270,
	DT_Shock                                 = 271,
	DT_Corrosion                             = 272,
	DT_NRay                                  = 273,
	WeaponStat_DamageType                    = 274,
	Unit_RoundsOverSeconds                   = 275,
	WeaponStat_MinMaxEffectiveRange          = 276,
	WeaponStat_EffectiveRange                = 277,
	Unit_Meters                              = 278,
	Unit_Percent                             = 279,
	Unit_Meters_Range                        = 280,
	Unit_Range                               = 281,
	WeaponStat_Ranged                        = 282,
	WeaponStat_Melee                         = 283,
	WeaponStat_Type                          = 284,
	WeaponStat_Class                         = 285,
	WeaponStat_SwayAngle                     = 291,
	WeaponStat_SpreadAngle                   = 292,
	Unit_PerSecond                           = 293,
	Unit_PercentPerSecond                    = 294,
	Unit_Degrees                             = 295,
	WeaponStat_AimSpreadReduction            = 296,
	WeaponStat_DPM                           = 297,
	ContextMenu_Use                          = 298,
	Unit_Seconds                             = 299,
	Health_Kit                               = 300,
	Quest_InProgress                         = 301,
	Quest_Completed                          = 302,
	Quest_Botched                            = 303,
	ContextMenu_Equip                        = 304,
	Quest_SetAsActive                        = 305,
	Quest_SortQuestType                      = 307,
	Quest_SortNewest                         = 308,
	Quest_SortOldest                         = 309,
	ResponseDumb                             = 314,
	ResponseScience                          = 315,
	Computer_Guide_Hack_Requirements         = 316,
	Door_Guide_Lockpick_Requirements         = 317,
	InteractionGuide_Lockpick_Hold           = 318,
	InteractionGuide_Hack_Hold               = 319,
	InteractionGuide_Disarm_Hold             = 320,
	Container_GenericName                    = 321,
	Door_Guide_Close                         = 328,
	InventoryCategory_Weapons                = 329,
	InventoryCategory_Armor                  = 330,
	InventoryCategory_Consumables            = 331,
	InventoryCategory_Modifications          = 332,
	InventoryCategory_General                = 333,
	InventoryCategory_Quests                 = 334,
	Settings_Ultra                           = 338,
	Guide_Unlock_With_Key                    = 342,
	Guide_Requires_Key                       = 343,
	Settings_MotionBlur                      = 344,
	Settings_None                            = 345,
	Settings_FXAA                            = 346,
	Settings_Temporal                        = 347,
	Settings_MSAA                            = 348,
	Settings_AAMethod                        = 349,
	Settings_MouseSensitivity                = 350,
	CharacterStats_Attributes                = 351,
	CharacterStats_Skills                    = 352,
	CharacterStats_Abilities                 = 353,
	Skill_Desc_Block                         = 368,
	Skill_Desc_Determination                 = 369,
	Skill_Desc_Dodge                         = 370,
	Skill_Desc_Hack                          = 371,
	Skill_Desc_HandGuns                      = 372,
	Skill_Desc_HeavyMelee                    = 373,
	Skill_Desc_HeavyWeapons                  = 374,
	Skill_Desc_Inspiration                   = 375,
	Skill_Desc_Intimidate                    = 376,
	Skill_Desc_Lie                           = 377,
	Skill_Desc_LightMelee                    = 378,
	Skill_Desc_Lockpick                      = 379,
	Skill_Desc_LongGuns                      = 380,
	Skill_Desc_Medical                       = 381,
	Skill_Desc_Persuade                      = 382,
	Skill_Desc_Engineering                   = 383,
	Skill_Desc_Science                       = 384,
	Skill_Desc_Sneak                         = 385,
	LedgerNavigation_Character               = 386,
	GenericNotification_Quest                = 388,
	InteractionGuide_Lockpick_Impossible     = 389,
	InteractionGuide_Hack_Impossible         = 390,
	InteractionGuide_Trap_Impossible         = 391,
	InteractionGuide_Arm_Hold                = 392,
	PauseMenu_Dialog_ConfirmExit             = 393,
	PauseMenu_Dialog_ConfirmMainMenu         = 394,
	Location_EmeraldVale                     = 404,
	Door_Guide_Unbar                         = 405,
	CompanionCommand_Temp_Ability_One        = 406,
	CompanionCommand_Temp_Ability_Two        = 407,
	CompanionCommand_Temp_Ability_Three      = 408,
	CompanionCommand_Temp_Ability_Desc       = 409,
	CompanionCommand_MissingCompanion        = 410,
	CompanionCommand_Flank                   = 411,
	CompanionCommand_Attack                  = 412,
	CompanionCommand_Suppress                = 413,
	Location_Monarch                         = 414,
	Location_Groundbreaker                   = 415,
	SaveLoad_ConfirmLoad                     = 418,
	SaveLoad_ConfirmSaveOverwrite            = 419,
	SaveLoad_LoadHeader                      = 420,
	SaveLoad_SaveHeader                      = 421,
	UseVendingMachine                        = 429,
	SaveLoad_ConfirmSaveDelete               = 432,
	SaveLoad_StandardSave                    = 433,
	SaveLoad_Quicksave                       = 434,
	SaveLoad_Autosave                        = 435,
	SaveLoad_PostgameSave                    = 436,
	Saveload_Playtime                        = 437,
	SaveLoad_SaveDate                        = 438,
	SaveLoad_SaveSubHeader                   = 439,
	SaveLoad__PlayerLevel                    = 442,
	SaveLoad_SaveTypeAndRegion               = 443,
	Computer_Guide_Unlock_Requirement        = 444,
	CharacterTab_Perks                       = 447,
	GenericNotification_SaveComplete         = 449,
	GenericNotification_SaveFailed           = 450,
	Skill_HandGuns                           = 451,
	Skill_LightMelee                         = 452,
	Skill_HeavyMelee                         = 453,
	Skill_LongGuns                           = 454,
	Skill_HeavyWeapons                       = 455,
	Skill_Dodge                              = 456,
	Skill_Block                              = 457,
	Skill_Persuade                           = 458,
	Skill_Lie                                = 459,
	Skill_Intimidate                         = 460,
	Skill_Sneak                              = 461,
	Skill_Hack                               = 462,
	Skill_Lockpick                           = 463,
	Skill_Medical                            = 464,
	Skill_Engineering                        = 465,
	Skill_Science                            = 466,
	Skill_Inspiration                        = 467,
	Skill_Determination                      = 468,
	Category_Melee                           = 469,
	Category_Ranged                          = 470,
	Category_Defense                         = 471,
	Category_Dialog                          = 472,
	Category_Stealth                         = 473,
	Category_Tech                            = 474,
	Category_Leadership                      = 475,
	CharacterStats_Attribute_Strength        = 526,
	CharacterStats_Attribute_Desc_Strength   = 527,
	CharacterStats_Attribute_Dexterity       = 528,
	CharacterStats_Attribute_Desc_Dexterity  = 529,
	CharacterStats_Attribute_Endurance       = 530,
	CharacterStats_Attribute_Desc_Endurance  = 531,
	CharacterStats_Attribute_Intelligence    = 532,
	CharacterStats_Attribute_Desc_Intelligence = 533,
	CharacterStats_Attribute_Perception      = 534,
	CharacterStats_Attribute_Desc_Perception = 535,
	CharacterStats_Attribute_Willpower       = 536,
	CharacterStats_Attribute_Charm           = 538,
	CharacterStats_Attribute_Desc_Charm      = 539,
	CharacterStats_Attribute_Wits            = 540,
	CharacterStats_Attribute_Temperament     = 542,
	CharacterStats_Attribute_Desc_Temperament = 543,
	Attribute_Category_Mind                  = 544,
	Attribute_Category_Body                  = 545,
	Attribute_Category_Personality           = 546,
	Attribute_Range_Minimum                  = 547,
	Attribute_Range_BelowAverage             = 548,
	Attribute_Range_Average                  = 549,
	Attribute_Range_Good                     = 550,
	Attribute_Range_High                     = 551,
	Attribute_Range_VeryHigh                 = 552,
	Maximum                                  = 553,
	WeaponStat_ProjectilesPerShot            = 557,
	WeaponStat_MaxChargeTime                 = 558,
	CharacterStats_CategoryRefund_Warning    = 559,
	CharacterStats_SkillsPage_Leave_Warning  = 560,
	InventoryCategory_Gadgets                = 562,
	WeaponStat_RoundsPerMin                  = 563,
	ContextMenu_Compare                      = 566,
	ContextMenu_StopCompare                  = 567,
	Unit_RoundsOverMinutes                   = 568,
	WeaponStat_Skill                         = 569,
	AmmoType_Handgun                         = 570,
	AmmoType_Rifle                           = 571,
	AmmoType_EnergyCell                      = 572,
	WeaponStat_AmmoType                      = 573,
	WeaponStat_SwingAttackRate               = 574,
	WeaponStat_PowerAttackRate               = 575,
	WeaponStat_SweepAttackRate               = 576,
	WeaponStat_FireMode                      = 577,
	FireMode_SemiAutomatic                   = 578,
	FireMode_Automatic                       = 579,
	FireMode_Burst                           = 580,
	FireMode_Charge                          = 581,
	WeaponStat_AOE                           = 582,
	ArmorStat_DT                             = 583,
	ArmorStat_DTP                            = 584,
	ArmorStat_DR                             = 585,
	ArmorStat_DRP                            = 586,
	ModSlot_MeleeGrip                        = 587,
	ModSlot_MeleeAttack                      = 588,
	ModSlot_Barrel                           = 589,
	ModSlot_Sight                            = 590,
	ModSlot_Magazine                         = 591,
	ModSlot_UnderBarrel                      = 592,
	Mod_DamageType                           = 593,
	Stat_Delta                               = 594,
	WeaponStat_SecondaryDamageType           = 595,
	ModAffix_Add                             = 598,
	Unit_AttacksOverSeconds                  = 599,
	Location_Terra2                          = 600,
	CharacterStats_FinalAllocation_Confirmation = 601,
	WeaponStat_OnHitEffectChance             = 602,
	WeaponStat_OnHitEffect                   = 603,
	AmmoType_Needler                         = 604,
	WeaponStat_SkillRequirement              = 629,
	WeaponStat_DamageMultiProjectile         = 630,
	Unit_Count                               = 644,
	ItemStack_Count                          = 645,
	Body                                     = 646,
	Mind                                     = 647,
	Personality                              = 648,
	CharacterCreation_AtttributeGroupDesc_Body = 649,
	CharacterCreation_AtttributeGroupDesc_Mind = 650,
	CharacterCreation_AtttributeGroupDesc_Personality = 651,
	CharacterCreation_SkillsRemaining        = 652,
	RawItemStats                             = 654,
	Background01                             = 661,
	Background02                             = 662,
	Background03                             = 663,
	Background04                             = 664,
	Background05                             = 665,
	Background_Desc_Background01             = 666,
	Background_Desc_Background02             = 667,
	Background_Desc_Background03             = 668,
	Background_Desc_Background04             = 669,
	Background_Desc_Background05             = 670,
	UseWorkbench                             = 671,
	NoBackground                             = 672,
	CharacterCreation_FinalizationConfirmation = 673,
	Background_Desc_NoBackground             = 674,
	ContextMenu_Mod                          = 677,
	ContextMenu_InstallMod                   = 681,
	AttributeBonus_Strength_Maximum          = 686,
	AttributeBonus_Strength_VeryHigh         = 687,
	AttributeBonus_Strength_High             = 688,
	AttributeBonus_Strength_Good             = 689,
	AttributeBonus_Strength_Average          = 690,
	AttributeBonus_Strength_BelowAverage     = 691,
	AttributeBonus_Strength_Minimum          = 692,
	AttributeBonus_Dexterity_Maximum         = 693,
	AttributeBonus_Dexterity_VeryHigh        = 694,
	AttributeBonus_Dexterity_High            = 695,
	AttributeBonus_Dexterity_Good            = 696,
	AttributeBonus_Dexterity_Average         = 697,
	AttributeBonus_Dexterity_BelowAverage    = 698,
	AttributeBonus_Dexterity_Minimum         = 699,
	AttributeBonus_Endurance_Maximum         = 700,
	AttributeBonus_Endurance_VeryHigh        = 701,
	AttributeBonus_Endurance_High            = 702,
	AttributeBonus_Endurance_Good            = 703,
	AttributeBonus_Endurance_Average         = 704,
	AttributeBonus_Endurance_BelowAverage    = 705,
	AttributeBonus_Endurance_Minimum         = 706,
	AttributeBonus_Intelligence_Maximum      = 707,
	AttributeBonus_Intelligence_VeryHigh     = 708,
	AttributeBonus_Intelligence_High         = 709,
	AttributeBonus_Intelligence_Good         = 710,
	AttributeBonus_Intelligence_Average      = 711,
	AttributeBonus_Intelligence_BelowAverage = 712,
	AttributeBonus_Intelligence_Minimum      = 713,
	AttributeBonus_Perception_Maximum        = 714,
	AttributeBonus_Perception_VeryHigh       = 715,
	AttributeBonus_Perception_High           = 716,
	AttributeBonus_Perception_Good           = 717,
	AttributeBonus_Perception_Average        = 718,
	AttributeBonus_Perception_BelowAverage   = 719,
	AttributeBonus_Perception_Minimum        = 720,
	AttributeBonus_Willpower_Maximum         = 721,
	AttributeBonus_Charm_Maximum             = 728,
	AttributeBonus_Charm_VeryHigh            = 729,
	AttributeBonus_Charm_High                = 730,
	AttributeBonus_Charm_Good                = 731,
	AttributeBonus_Charm_Average             = 732,
	AttributeBonus_Charm_BelowAverage        = 733,
	AttributeBonus_Charm_Minimum             = 734,
	AttributeBonus_Wits_Maximum              = 735,
	AttributeBonus_Temperament_Maximum       = 742,
	AttributeBonus_Temperament_VeryHigh      = 743,
	AttributeBonus_Temperament_High          = 744,
	AttributeBonus_Temperament_Good          = 745,
	AttributeBonus_Temperament_Average       = 746,
	AttributeBonus_Temperament_BelowAverage  = 747,
	AttributeBonus_Temperament_Minimum       = 748,
	Modifications_InstallConfirmation        = 750,
	Breakdown_Confirmation                   = 751,
	Repair_Confirm                           = 753,
	CharacterCreation_ReturnToMenu           = 785,
	AttributeBonus_Strength_Advanced         = 787,
	AttributeBonus_Dexterity_Advanced        = 788,
	AttributeBonus_Endurance_Advanced        = 789,
	AttributeBonus_Intelligence_Advanced     = 790,
	AttributeBonus_Perception_Advanced       = 791,
	AttributeBonus_Willpower_Advanced        = 792,
	AttributeBonus_Charm_Advanced            = 793,
	AttributeBonus_Wits_Advanced             = 794,
	AttributeBonus_Temperament_Advanced      = 795,
	X_Of_Y                                   = 819,
	Perks_PerksRemaining                     = 823,
	ArmorStat_DamageThreshold                = 824,
	ArmorStat_DamageThresholdPercentage      = 825,
	ArmorModSlot_Armoring                    = 827,
	ArmorModSlot_Dampening                   = 828,
	ArmorModSlot_Resistance                  = 829,
	ArmorModSlot_Utility                     = 830,
	Dialog_Dumb                              = 889,
	Dialog_Prefix                            = 890,
	Requirements_Header                      = 891,
	Perk_Purchase_Requirements               = 892,
	Perk_Requirement_Skill                   = 893,
	CharacterStats_PerkUpgrade               = 899,
	Category_Desc_Ranged                     = 955,
	Category_Desc_Defense                    = 956,
	Category_Desc_Dialog                     = 957,
	Category_Desc_Stealth                    = 958,
	Category_Desc_Tech                       = 959,
	Category_Desc_Leadership                 = 960,
	AttributeBonus_Strength_BAEffect         = 961,
	AttributeBonus_Dexterity_BAEffect        = 962,
	AttributeBonus_Endurance_BAEffect        = 963,
	AttributeBonus_Intelligence_BAEffect     = 964,
	AttributeBonus_Perception_BAEffect       = 965,
	AttributeBonus_Willpower_BAEffect        = 966,
	AttributeBonus_Charm_BAEffect            = 967,
	AttributeBonus_Wits_BAEffect             = 968,
	AttributeBonus_Temperament_BAEffect      = 969,
	FactionResponse_KOS                      = 1001,
	FactionResponse_Friendly                 = 1002,
	FactionResponse_Neutral                  = 1003,
	FactionResponse_VendorPriceIncrease      = 1004,
	FactionResponse_VendorPriceDecrease      = 1005,
	AmmoType_Light                           = 1028,
	AmmoType_Heavy                           = 1029,
	AmmoType_Energy                          = 1030,
	UseVendor                                = 1032,
	ContextMenu_Buy                          = 1038,
	ContextMenu_Pawn                         = 1039,
	ContextMenu_ClearBuy                     = 1041,
	ContextMenu_ClearPawn                    = 1042,
	Trade                                    = 1043,
	Vendor_TotalToPay                        = 1044,
	Vendor_TotalToEarn                       = 1045,
	Vendor_TotalEven                         = 1046,
	Vendor_VendorLacksCurrency               = 1047,
	Vendor_BuyerLacksCurrency                = 1048,
	Vendor_BuyerHasCurrency                  = 1049,
	LedgerMap_AcceptFastTravel               = 1056,
	LedgerMap_FastTravel                     = 1062,
	WalkSpeed                                = 1072,
	CrouchSpeed                              = 1073,
	SprintSpeed                              = 1074,
	Unit_MetersOverSeconds                   = 1076,
	Unit_Ratio                               = 1077,
	Unit_HealthOverSeconds                   = 1079,
	Generic_Guide_Locked                     = 1090,
	Generic_Guide_Travel                     = 1091,
	OCL_Guide_Sealed                         = 1097,
	ContextMenu_Unload                       = 1139,
	GameDifficulty                           = 1143,
	GameDifficulty_Story                     = 1144,
	GameDifficulty_Normal                    = 1145,
	GameDifficulty_Hard                      = 1146,
	GameDifficulty_SuperNova                 = 1147,
	Difficulty_Desc_Story                    = 1162,
	Difficulty_Desc_Normal                   = 1163,
	Difficulty_Desc_Hard                     = 1164,
	Difficulty_Desc_SuperNova                = 1165,
	ArmorPartsRequired                       = 1329,
	WeaponPartsRequired                      = 1330,
	ItemBreakdown_ArmorParts                 = 1331,
	ItemBreakdown_WeaponParts                = 1332,
	Heal_Percent_Over_Time                   = 1441,
	RestrictedStock                          = 1442,
	RestrictedStockLocked                    = 1443,
	Skill_Category_Weapon_Melee              = 1449,
	Skill_Category_Weapon_Ranged             = 1450,
	Skill_Category_Defense                   = 1451,
	Skill_Category_Dialog                    = 1452,
	Skill_Category_Stealth                   = 1453,
	Skill_Category_Tech                      = 1454,
	Skill_Category_Leadership                = 1455,
	Skill_Unlock_Header                      = 1456,
	Stat_WalkSpeed                           = 1457,
	Skill_Tier1_Format                       = 1458,
	Skill_Tier2_Format                       = 1459,
	Skill_Tier3_Format                       = 1460,
	Weapon_OnCritHit                         = 1469,
	QuestLog_NoActiveQuest                   = 1470,
	ContextMenu_Swap                         = 1472,
	Location_Hephaestus                      = 1475,
	Location_Scylla                          = 1476,
	AbilityUnlock_WeakSpotHandguns           = 1511,
	AbilityUnlock_TTDSpellsHandguns          = 1514,
	AbilityUnlock_PowerAttackHeavyMelee      = 1531,
	AbilityUnlock_WeakSpotHeavyMelee         = 1533,
	AbilityUnlock_MeleeUnblockable           = 1535,
	AbilityUnlock_WeakSpotHeavyWeapons       = 1540,
	AbilityUnlock_TTDSpellsHeavyWeapons      = 1542,
	AbilityUnlock_CompanionAbilities         = 1548,
	AbilityUnlock_WeakSpotLongGuns           = 1573,
	AbilityUnlock_TTDSpellsLongGuns          = 1575,
	AbilityUnlock_PowerAttackLightMelee      = 1582,
	AbilityUnlock_WeakSpotLightMelee         = 1584,
	AbilityUnlock_MeleeReach                 = 1586,
	WeaponStat_AmmoPerSecond                 = 1605,
	Dialog_Bribe                             = 1606,
	UseBed                                   = 1611,
	Positive_Reputation_Gained               = 1616,
	Positive_Reputation_Lost                 = 1617,
	Negative_Reputation_Gained               = 1620,
	Negative_Reputation_Lost                 = 1621,
	Faction_Reputation_Changed               = 1623,
	Companion_Gained_Morale                  = 1624,
	Companion_Lost_Morale                    = 1625,
	Companion_Joined                         = 1627,
	Companion_Left                           = 1628,
	XP_Enemy_Killed                          = 1631,
	XP_Point_of_Interest                     = 1632,
	XP_Skill_Used                            = 1633,
	XP_Collectible_Found                     = 1634,
	XP_Generic                               = 1635,
	Item_Gained                              = 1647,
	Item_Lost                                = 1648,
	PerkSurcharges_Percent                   = 1765,
	PerkBuyingPrice_Percent                  = 1766,
	Duration_S                               = 1801,
	Duration_M_S                             = 1802,
	Duration_M                               = 1803,
	Duration_H                               = 1804,
	Duration_H_M                             = 1805,
	DT_All                                   = 1811,
	AbilityUnlock_Dodge                      = 1813,
	AbilityUnlock_Block                      = 1816,
	AbilityUnlock_Pickpocket                 = 1819,
	AbilityUnlock_HackRobots                 = 1820,
	AbilityUnlock_Medkit1                    = 1821,
	AbilityUnlock_Medkit2                    = 1822,
	AbilityUnlock_Medkit3                    = 1823,
	DT_Abbreviation                          = 1829,
	Rank_X_Colon                             = 1834,
	Heal_Over_Duration                       = 1837,
	Distance_Meters                          = 1843,
	UI_Cooldown                              = 1844,
	UI_Create_Item_Format                    = 1854,
	Location_Roseway                         = 1903,
	UI_Passive_Bonuses                       = 1907,
	RestrictedArea                           = 1966,
	FastTravel_InCombat                      = 1972,
	FastTravel_InConversation                = 1973,
	FastTravel_Hazard                        = 1974,
	FastTravel_Encumbered                    = 1975,
	FastTravel_Interior                      = 1976,
	FastTravel_Crime                         = 1977,
	FastTravel_General                       = 1978,
	FastTravel_NearHostiles                  = 1979,
	NotAllowedInCombat                       = 1988,
	FastTravelLocationDiscovered             = 1989,
	Bribe_Prefix                             = 1993,
	Companion_Unlocked                       = 1994,
	Skills_Level_X                           = 2012,
	UseChair                                 = 2031,
	SystemMap_SelectDestination              = 2073,
	SystemMap_TravelTo_X                     = 2074,
	CharacterCreation_NameEntry              = 2075,
	Location_Tartarus                        = 2085,
	Companion_Follow_Close                   = 2093,
	Companion_Follow_Medium                  = 2094,
	Companion_Follow_Far                     = 2095,
	Companion_WeaponPref_Melee               = 2096,
	Companion_WeaponPref_Mixed               = 2097,
	Companion_WeaponPref_Ranged              = 2098,
	Companion_Combat_Defensive               = 2099,
	Companion_Combat_Offensive               = 2100,
	CharacterCreation_NamePrompt             = 2101,
	SurvivalMode_Desc                        = 2110,
	Input_X_Hold                             = 2145,
	Hold                                     = 2146,
	AbilityUnlock_Acrophobia                 = 2148,
	ShipTerminal                             = 2151,
	Companion_Combat_Passive                 = 2152,
	Companion_PerksPage_Revert_Warning       = 2153,
	FastTravel_Exhausted                     = 2157,
	FastTravel_Starving                      = 2158,
	FastTravel_Dehydrated                    = 2159,
	FastTravel_ShipRestrict                  = 2160,
	ItemCondition                            = 2173,
	ItemStats_AmmoTypeEmbedded               = 2174,
	ArmorType_Heavy                          = 2176,
	ArmorType_Medium                         = 2177,
	ArmorType_Light                          = 2178,
	ArmorType_Header                         = 2179,
	StatBonus_SkillBonus                     = 2180,
	SpacersChoice_Flaw                       = 2181,
	Reward_Perk_Point                        = 2182,
	Name_Exclamation                         = 2183,
	CharacterTab_Skills                      = 2190,
	Ledger_Level_Up_Offer                    = 2192,
	Flaw_Effects                             = 2193,
	Skill_Tier4_Format                       = 2200,
	Skill_Tier5_Format                       = 2201,
	AbilityUnlock_SneakAttack                = 2215,
	AbilityUnlock_LockpickPreview            = 2217,
	Item_Salvaged_With_Count                 = 2220,
	Item_Salvaged                            = 2221,
	AbilityUnlock_SellToMachine              = 2225,
	AbilityUnlock_FieldRepair                = 2237,
	Optional_Item_Name_X                     = 2244,
	Value_X_Seconds                          = 2245,
	AbilityUnlock_Leap                       = 2249,
	SaveLoad_SaveUnavailable                 = 2254,
	AbilityUnlock_TTDSpellsLightMelee        = 2262,
	AbilityUnlock_TTDSpellsHeavyMelee        = 2263,
	AbilityUnlock_FastTravelWhileEncumbered  = 2266,
	PerkAdditionalAmmoStock_Percent          = 2280,
	PerkAdditionalConsumableStock_Percent    = 2281,
	Perk_Tier_Header                         = 2283,
	Prompt_Steal_Item                        = 2284,
	Category_Desc_Melee                      = 2314,
	SaveLoad_XboxActiveUserSignedOutInGame   = 2348,
	SaveLoad_XboxActiveUserSignedOutTitle    = 2349,
	SaveLoad_XboxActiveUserSignedOutMainMenu = 2353,
	AbilityUnlock_Tinkering                  = 2354,
	FlavorAptitude                           = 2356,
	FlavorCharacterGeneric                   = 2360,
	FlavorCharacterLevelUp                   = 2361,
	FlavorSkills                             = 2362,
	FlavorPerks                              = 2363,
	FlavorCharacterDetails                   = 2364,
	FlavorCharacterReputation                = 2365,
	FlavorInventoryGeneric                   = 2366,
	FlavorInventoryBucket                    = 2367,
	FlavorQuestsGeneric                      = 2368,
	FlavorMapGeneric                         = 2369,
	FlavorCompanionsGeneric                  = 2370,
	FlavorCompanionsInventoryHover           = 2371,
	FlavorCompanionsStatsHover               = 2372,
	FlavorCompanionsBehaviorHover            = 2373,
	FlavorCompanionPerksHover                = 2374,
	FlavorWorkbenchGeneric                   = 2375,
	FlavorWorkbenchRepairHover               = 2376,
	FlavorWorkbenchBreakdownHover            = 2377,
	FlavorWorkbenchJunkHover                 = 2378,
	FlavorWorkbenchModGeneric                = 2379,
	FlavorWorkbenchBreakdownHover_0          = 2380,
	FlavorCCAttributes                       = 2381,
	FlavorCCAppearance                       = 2382,
	FlavorCCName                             = 2383,
	FlavorCCReview                           = 2384,
	FlavorPartySelection                     = 2385,
	FlavorCCAtrributesMajor                  = 2386,
	FlavorCCAttributesMinor                  = 2387,
	FlavorCCSkills                           = 2388,
	FlavorInventoryCategoryWeapons           = 2396,
	FlavorInventoryCategoryArmor             = 2397,
	FlavorInventoryCategoryConsumables       = 2398,
	FlavorInventoryCategoryModifications     = 2399,
	FlavorInventoryCategoryGeneral           = 2400,
	FlavorInventoryCategoryQuests            = 2401,
	FlavorCompanionsPerksGeneric             = 2404,
	FlavorCompanionsPerksAvailable           = 2405,
	FlavorCompanionsInventoryRanged          = 2406,
	FlavorCompanionsInventoryMelee           = 2407,
	FlavorCompanionsInventoryHelmet          = 2408,
	FlavorCompanionsInventoryArmor           = 2409,
	FlavorWorkbenchBreakDownGeneric          = 2419,
	FlavorWorkbenchRepairGeneric             = 2420,
	Archive                                  = 2434,
	CharacterStats_Respec                    = 2455,
	CharacterStats_Respec_Dialog1            = 2456,
	CharacterStats_Respec_Dialog2            = 2457,
	QualityLevel                             = 2460,
	Settings_Custom                          = 2461,
	SavingWidget_Saving                      = 2483,
	X_Number_Uses                            = 2485,
	Disguise_RequiresKey                     = 2489,
	Disguise_Failed                          = 2490,
	Disguise_DialogueDifficulty              = 2491,
	X_Number                                 = 2492,
	Companion_WeaponPref_LongRange           = 2493,
	Companion_WeaponPref_CloseRange          = 2494,
	Scanner_EnemyLevel                       = 2501,
	X_Percent_Discount                       = 2506,
	X_Percent_Surcharge                      = 2508,
	Workbench_TinkerItem                     = 2509,
	Workbench_TinkerWeaponBase               = 2510,
	Workbench_TinkerArmorBase                = 2511,
	ItemModding_ItemNameDesc                 = 2522,
	RepairAllEquipped_X_Bits                 = 2523,
	RepairAllEquipped_X_WeaponParts          = 2524,
	RepairAllEquipped_X_ArmorParts           = 2525,
	Quest_SortLocation                       = 2530,
	Quest_SortDifficulty                     = 2531,
	Quest_SortAlphabetical                   = 2533,
	Inventory_StackSplitDrop                 = 2534,
	Inventory_StackSplitJunk                 = 2535,
	Inventory_StackSplitUnjunk               = 2536,
	QuestType_Main                           = 2537,
	QuestType_Side                           = 2538,
	QuestType_Faction                        = 2539,
	QuestType_Companion                      = 2540,
	QuestType_Task                           = 2541,
	Location_Space                           = 2542,
	QuestDifficulty_Easy                     = 2543,
	QuestDifficulty_Normal                   = 2544,
	QuestDifficulty_Hard                     = 2545,
	QuestDifficulty_Deadly                   = 2546,
	Sell_X                                   = 2547,
	Buy_X                                    = 2548,
	Clear_Cart                               = 2550,
	SaveLoad_LoadSubHeader                   = 2551,
	SaveLoad_SaveFlavorText                  = 2552,
	SaveLoad_LoadFlavorText                  = 2553,
	VendorStackSplitBuy                      = 2566,
	VendorStackSplitUnbuy                    = 2567,
	VendorStackSplitSell                     = 2568,
	VendorStackSplitUnsell                   = 2569,
	LevelUp_NewLevel                         = 2577,
	PointsAvailable_Skills                   = 2578,
	PointOfInterestDiscovered                = 2592,
	XP_Fast_Travel                           = 2593,
	Weapon_Parts_Required_Value              = 2595,
	Armor_Parts_Required_Value               = 2596,
	FlavorInventoryCategoryJunk              = 2600,
	SaveLoad_PointOfNoReturnDelete           = 2601,
	UI_Empty                                 = 2603,
	Unicode_Infinity                         = 2605,
	Warning_PointOfNoReturn_Phineas          = 2608,
	SettingName_PseudoGod                    = 2609,
	SettingCategory_Cheat                    = 2610,
	SettingName_God                          = 2611,
	SettingName_InfiniteAmmo                 = 2612,
	SettingCategory_Movement                 = 2613,
	SettingCategory_Attributes               = 2614,
	SettingCategory_Skills                   = 2615,
	SaveLoad_PointOfNoReturn                 = 2616,
	Unknown                                  = 2629,
	CC_ChangeAttributeValue                  = 2645,
	CharacterCreation_AttributePoints_Remaining = 2647,
	AbilityUnlock_PowerAttackScience         = 2648,
	EyeHorizontal                            = 2665,
	MouthVertical                            = 2675,
	Missing                                  = 2683,
	Skills_AdjustedValue                     = 2690,
	Value_Hyphen_Locked                      = 2699,
	MainMenu_Keyboard_Prompt                 = 2715,
	Perk_Purchased                           = 2719,
	Perk_Unlocked                            = 2720,
	Perk_Marked                              = 2721,
	CharacterCustomization_PlayerAge         = 2722,
	SaveLoad_XboxActiveUserSignedOut         = 2876,
	SaveLoad_XboxActiveUserDisconnected      = 2877,
	Item_on_Display                          = 2969,
	LedgerMap_LocalMapName                   = 2982,
	Lasts_Duration                           = 3002,
	OneYear                                  = 3003,
	XYears                                   = 3004,
	OneMonth                                 = 3005,
	XMonths                                  = 3006,
	OneWeek                                  = 3007,
	XWeeks                                   = 3008,
	OneDay                                   = 3009,
	XDays                                    = 3010,
	OneHour                                  = 3011,
	XHours                                   = 3012,
	OneMinute                                = 3013,
	XMinutes                                 = 3014,
	OneSecond                                = 3015,
	XSeconds                                 = 3016,
	ValueCommaSpace                          = 3017,
	Vendor_Confirm                           = 3018,
	NameColonText                            = 3033,
	Journal_Codex                            = 3102,
	RespecificationMachine                   = 3108,
	MainMenu_Gamepad_Prompt                  = 3142,
	Inventory_InCombat                       = 3146,
	SelectTravelDestinationOn_X              = 3164,
	Disguise_RequiresID                      = 3170,
	SavedLoadRestriction_LoggingOut          = 3172,
	SavedLoadRestriction_PlatformStorageInacessible = 3173,
	SavedLoadRestriction_PlatformSaveSystemNull = 3174,
	SavedLoadRestriction_DeviceFull          = 3175,
	SavedLoadRestriction_Unsupported         = 3176,
	SavedLoadRestriction_GenericFail         = 3177,
	Supernova_DifficultyChange               = 3179,
	DownloadComplete_Percent_X               = 3181,
	Disguise_RequiresShroud                  = 3183,
	Key_CannotBeRebound                      = 3189,
	Key_CannotBeAssignedTo_Action            = 3190,
	Key_AssignedTo_Action_NewAction          = 3191,
	MissingKeybinds_Actions                  = 3192,
	AutosaveSplash_PS4                       = 3197,
	AutosaveSplash_Xbox                      = 3198,
	AutosaveSplash_PC                        = 3199,
	AutosaveSplash_PS5                       = 3200,
	Keybinds_Rebind                          = 3239,
	Keybindings_Attack                       = 3279,
	Keybindings_Reload                       = 3284,
	Keybindings_CompanionMove                = 3287,
	Righty                                   = 3317,
	Lefty                                    = 3318,
	Normal                                   = 3319,
	Inverted                                 = 3320,
	Hold_X                                   = 3329,
	Click_X                                  = 3330,
	Move                                     = 3332,
	Look                                     = 3337,
	CodexCategory_Symbols                    = 3339,
	CombatOnly                               = 3348,
	SystemMapLocationUnlocked                = 3355,
	Items_Gained                             = 3358,
	Items_Lost                               = 3359,
	Repair_X                                 = 3378,
	ArmorType_Flesh                          = 3379,
	GamepadNotAllowedWarning                 = 3381,
	RestrictedStockUnlocked                  = 3382,
	NowAvailable                             = 3384,
	Breakdown_EngineeringLevel               = 3387,
	Breakdown_BasicModChance                 = 3388,
	Breakdown_RareModChance                  = 3389,
	Breakdown_PopupTitle                     = 3390,
	ModifyNoRecovery                         = 3393,
	ModifyItemWithMod                        = 3394,
	CurrentMod_MeleeGrip                     = 3396,
	NewMod_MeleeGrip                         = 3397,
	CurrentMod_MeleeAttack                   = 3398,
	NewMod_MeleeAttack                       = 3399,
	CurrentMod_Barrel                        = 3400,
	NewMod_Barrel                            = 3401,
	CurrentMod_Magazine                      = 3402,
	NewMod_Magazine                          = 3403,
	CurrentMod_Sight                         = 3404,
	NewMod_Sight                             = 3405,
	CurrentMod_Armoring                      = 3406,
	NewMod_Armoring                          = 3407,
	CurrentMod_Resistance                    = 3408,
	NewMod_Resistance                        = 3409,
	CurrentMod_Dampening                     = 3410,
	NewMod_Dampening                         = 3411,
	CurrentMod_Utility                       = 3412,
	NewMod_Utility                           = 3413,
	YourBits                                 = 3423,
	SaveLoad_BeforeSkippingHope              = 3424,
	YourWeaponParts                          = 3433,
	YourArmorParts                           = 3434,
	ItemSorting_Alphabetical                 = 3436,
	ItemSorting_Value                        = 3437,
	ItemSorting_Weight                       = 3438,
	ItemSorting_ValueToWeight                = 3439,
	ItemSorting_DamageRating                 = 3440,
	ItemSorting_ArmorRating                  = 3441,
	ItemSorting_WeaponType                   = 3442,
	ItemSorting_ArmorType                    = 3443,
	ItemSorting_RangedMeleeArmorMod          = 3445,
	Breakdown_ItemCount                      = 3449,
	EquipmentMods_ModCount                   = 3496,
	AlreadyInstalledMod                      = 3497,
	TinkerMaxLevelReachedPostDLC             = 3498,
	TinkerSkillLocked                        = 3499,
	SaveLoad_PS4ActiveUserDisconnected       = 3503,
	MainMenu_Gamepad_PS4_Prompt              = 3531,
	PointsAvailable_Perks                    = 3536,
	Perk_Cost                                = 3537,
	PointsAvailable_SkillPerks               = 3538,
	Language_English                         = 3570,
	Language_French                          = 3571,
	Language_Italian                         = 3572,
	Language_German                          = 3573,
	Language_Spanish                         = 3574,
	Language_Portuguese                      = 3575,
	Language_Russian                         = 3576,
	Language_Korean                          = 3577,
	Language_Japanese                        = 3578,
	Language_Chinese                         = 3579,
	Language_Polish                          = 3580,
	Minimal                                  = 3622,
	Always                                   = 3627,
	OnlyWhenClose                            = 3628,
	Never                                    = 3629,
	TimedFade                                = 3646,
	FPSIndicator                             = 3668,
	FPSIndicatorDescription                  = 3669,
	TopLeft                                  = 3670,
	TopRight                                 = 3671,
	BottomLeft                               = 3672,
	BottomRight                              = 3673,
	AbilityUnlock_TinkerScienceCostCap       = 3789,
	Vertical                                 = 3804,
	Horizontal                               = 3805,
	Simplified                               = 3809,
	SellToVendingMachines_Locked             = 3810,
	Conversation_Trade                       = 3814,
	Attribute_Range_Maximum                  = 3822,
	Setting_LanguageDisabled                 = 3839,
	Keybinds_UnbindKey                       = 3840,
	Keybinds_ResetDefault                    = 3841,
	Keybinds_CurrentlyBound                  = 3842,
	Keybinds_CurrentBinding                  = 3843,
	Keybinds_CurrentlyUnbound                = 3844,
	DetectGraphicsSettings                   = 3845,
	Thirty                                   = 3846,
	Sixty                                    = 3847,
	OneHundredTwenty                         = 3848,
	OneHundredFourtyFour                     = 3849,
	OneHundredSixty                          = 3850,
	OneHundredSixtyFive                      = 3851,
	OneHundredEighty                         = 3852,
	TwoHundred                               = 3853,
	TwoHundredFourty                         = 3854,
	Unlimited                                = 3855,
	CompanionCommand_Ability_One             = 3864,
	CompanionCommand_Ability_Two             = 3865,
	ModifyReplaceWarning                     = 3873,
	RepairAllEquipped_X_Parts                = 3875,
	Inventory_SamWarning                     = 3876,
	InventorySlot_BodyArmor                  = 3877,
	InventorySlot_Helmet                     = 3878,
	Companion_Disguise                       = 3879,
	Perk_Purchase_Requirements_1             = 3880,
	Flavor_CompanionsInventory_Hover_2       = 3881,
	SaveLoad_Maximum_Saves                   = 3882,
	Keybindings_Unbind                       = 3884,
	Keybindings_Bind                         = 3887,
	Keybindings_Rebind                       = 3888,
	CompanionPerkUnlocked                    = 3890,
	SaveLoad_LeavingEV                       = 3891,
	SaveLoad_LeavingEVDescription            = 3892,
	SaveLoad_Sorting_Date                    = 3899,
	SaveLoad_Sorting_PlayTime                = 3900,
	SaveLoad_Sorting_Location                = 3901,
	SaveLoad_Sorting_Level                   = 3902,
	SaveLoad_SaveConfirm                     = 3903,
	SaveLoad_SaveDoubleConfirm               = 3904,
	Cannot_Rebind                            = 3905,
	Menus_Cannot_Rebind                      = 3906,
	PartySelect_Encumbered                   = 3907,
	PartySelect_WeightAllowance              = 3908,
	Settings_ApplyNow                        = 3912,
	Settings_RevertWarn                      = 3913,
	NameBlacklisted                          = 3914,
	Appearance_Warn                          = 3920,
	NotSignedIn_Xbox                         = 3921,
	Settings_LanguageSelect                  = 3922,
	Perk_Confirmation                        = 3923,
	Map_Active                               = 3994,
	Map_Inactive                             = 3995,
	Map_Toggle_Inactive                      = 3996,
	Pristine                                 = 3997,
	Settings_AimingOnly                      = 4001,
	AndMore_Ellipsis                         = 4038,
	InactiveQuests                           = 4039,
	ShowInactiveQuests                       = 4040,
	HideInactiveQuests                       = 4041,
	MultipleQuests                           = 4042,
	Format_DotSpaceEntry                     = 4043,
	DoubleClick_x                            = 4048,
	IdleCameraAvailable                      = 4064,
	IdleCameraUnavailable                    = 4067,
	AdjustedSkillValue                       = 4093,
	Location_Gorgon                          = 4094,
	UsePet                                   = 4105,
	Play                                     = 4181,
	Stop                                     = 4182,
	AudioLog                                 = 4183,
	AudioLogs                                = 4184,
	AudioLogs_BaseGame                       = 4185,
	AudioLogs_INX01                          = 4186,
	AudioLogs_INX02                          = 4187,
	INX01_Name                               = 4216,
	INX02_Name                               = 4217,
	NowAvailableExclamation                  = 4218,
	ComingSoon                               = 4219,
	OwnedUninstalled                         = 4220,
	Installed                                = 4221,
	Skill_Tier6_Format                       = 4228,
	AbilityUnlock_InstantReloadHeavyOnEmpty  = 4232,
	DT_Cold                                  = 4273,
	PerkSuppressed                           = 4309,
	PerkUnsuppressed                         = 4310,
	PerkSuppressedEffect                     = 4312,
	AbilityUnlock__StealthInstantKillUndetectable = 4315,
	AbilityUnlock__DoubleHackRobots          = 4316,
	AbilityUnlock__UndetectableLockpicking   = 4317,
	AbilityUnlock__UseScienceAsWeaponSkill   = 4325,
	FlawDecidophobia                         = 4327,
	PerkSuppressedByNameDuration             = 4328,
	CurSuppressingNameDuration               = 4329,
	CurrentBitsValue                         = 4332,
	CurrentWeaponPartsValue                  = 4333,
	CurrentArmorPartsValue                   = 4334,
	CurVersionValue                          = 4335,
	VersionMismatchValue                     = 4336,
	SaveVersionValue                         = 4337,
	QuoteValueMissing                        = 4338,
	QuoteValueInstalled                      = 4339,
	PurchaseDLC                              = 4340,
	Workbench_PlayerLacksWeaponParts         = 4341,
	Workbench_PlayerLacksArmorParts          = 4342,
	Analyze                                  = 4373,
	TinkerMaxLevelReachedPreDLC              = 4374,
	TinkerMaxLevelReached                    = 4375,
	Location_PhaethonPilothouse              = 4438,
	Location_RizzosDistillationStation       = 4439,
	Location_EridanosSpaceport               = 4440,
	Location_TheGrandColonialHotel           = 4441,
	Location_WildernessExploitationReserve   = 4442,
	Location_RizzosPurpleberryOrchards       = 4443,
	Location_RizzosResearchDevelopmentDistrictLabs = 4444,
	Location_HappyDaleFarms                  = 4445,
	Location_StormtailShelter                = 4446,
	SkillName_Virtuoso_Value                 = 4455,
	ModRecoveryEngineeringVirtuoso           = 4456,
	PreviousModRecovered                     = 4457,
	ModInstallWarningEngineeringVirtuoso     = 4458,
	GameName                                 = 4461,
	Quest_SortContent                        = 4462,
	Stop_Audio_Log                           = 4487,
	Warning_PointOfNoReturn_Overwrite        = 4493,
	DLCpopup_Gorgon_Title                    = 4506,
	DLCpopup_Gorgon                          = 4507,
	FastTravel_EridanosQuest                 = 4511,
	MoreInfo                                 = 4512,
	DLCpopup_Eridanos_Title                  = 4513,
	DLCpopup_Eridanos                        = 4514,
	DLC_PONR_Prompt                          = 4574,
	DLC_PONR_Prompt_Dual                     = 4575,
	DLCpopup_Dual                            = 4576,
	DLCpopup_Dual_Title                      = 4577,
	EvidenceNearbyNotification               = 4583,
	Settings_ControllerEnableImpulseTriggers = 4585,
	Settings_ImpulseTriggerIntensity         = 4586,
	Settings_ControllerEnableImpulseTriggersDescription = 4587,
	Settings_ImpulseTriggerIntensityDescription = 4588,
	Settings_PerformanceMode                 = 4589,
	Settings_PerformanceModeDescription      = 4590,
	Mode_PerformanceMode                     = 4591,
	Mode_CinematicMode                       = 4592,
	Settings_SSGI                            = 4593,
	Settings_SSGIDescription                 = 4594,
	Mode_SSGIOff                             = 4595,
	Mode_SSGIFullres                         = 4596,
	Mode_SSGIHalfres                         = 4597,
	Settings_DynRes                          = 4598,
	Settings_DynResDescription               = 4599,
	Settings_FSR2                            = 4600,
	Settings_FSR2Description                 = 4601,
	Settings_FSR2Quality                     = 4602,
	Settings_FSR2Balanced                    = 4603,
	Settings_FSR2Performance                 = 4604,
	EGuiText_MAX                             = 4605,
};

// Enum Indiana.ESurvivalBar
// NumValues: 0x0005
enum class ESurvivalBar : uint8
{
	Hunger                                   = 0,
	Thirst                                   = 1,
	Sleep                                    = 2,
	Invalid                                  = 3,
	ESurvivalBar_MAX                         = 4,
};

// Enum Indiana.CycleBehavior
// NumValues: 0x0004
enum class ECycleBehavior : uint8
{
	LinearRepeat                             = 0,
	LinearOnceOnly                           = 1,
	PingPong                                 = 2,
	CycleBehavior_MAX                        = 3,
};

// Enum Indiana.ESwitchEventType
// NumValues: 0x0004
enum class ESwitchEventType : uint8
{
	Invalid                                  = 0,
	Changed                                  = 1,
	AnimateSwitch                            = 2,
	ESwitchEventType_MAX                     = 3,
};

// Enum Indiana.ESymbolType
// NumValues: 0x0007
enum class ESymbolType : uint8
{
	DamageType                               = 0,
	Buff                                     = 1,
	Debuff                                   = 2,
	MapCompass                               = 3,
	Count                                    = 4,
	Invalid                                  = 5,
	ESymbolType_MAX                          = 6,
};

// Enum Indiana.EDesiredBrushType
// NumValues: 0x0005
enum class EDesiredBrushType : uint8
{
	Normal                                   = 0,
	Hovered                                  = 1,
	Pressed                                  = 2,
	Focused                                  = 3,
	EDesiredBrushType_MAX                    = 4,
};

// Enum Indiana.ETargetRelationship
// NumValues: 0x0005
enum class ETargetRelationship : uint8
{
	Friendly                                 = 0,
	Neutral                                  = 1,
	Hostile                                  = 2,
	PacifistHostile                          = 3,
	ETargetRelationship_MAX                  = 4,
};

// Enum Indiana.EScriptedTeamType
// NumValues: 0x0003
enum class EScriptedTeamType : uint8
{
	Script                                   = 0,
	MindControl                              = 1,
	EScriptedTeamType_MAX                    = 2,
};

// Enum Indiana.ETimeDilationType
// NumValues: 0x0003
enum class ETimeDilationType : uint8
{
	Static                                   = 0,
	Curve                                    = 1,
	ETimeDilationType_MAX                    = 2,
};

// Enum Indiana.ETimeDilationPriority
// NumValues: 0x0005
enum class ETimeDilationPriority : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Critical                                 = 3,
	ETimeDilationPriority_MAX                = 4,
};

// Enum Indiana.ERagdollGetupState
// NumValues: 0x0006
enum class ERagdollGetupState : uint8
{
	Inactive                                 = 0,
	AnimationDelayed                         = 1,
	AnimationQueued                          = 2,
	AnimationBegan                           = 3,
	AnimationActive                          = 4,
	ERagdollGetupState_MAX                   = 5,
};

// Enum Indiana.ETrapResult
// NumValues: 0x0007
enum class ETrapResult : uint8
{
	Success                                  = 0,
	Failed                                   = 1,
	Failed_Skill                             = 2,
	Failed_Error                             = 3,
	Pending_Arming                           = 4,
	Pending_Disarming                        = 5,
	ETrapResult_MAX                          = 6,
};

// Enum Indiana.ETrapDifficulty
// NumValues: 0x0005
enum class ETrapDifficulty : uint8
{
	Easy                                     = 0,
	Medium                                   = 1,
	Difficult                                = 2,
	Extreme                                  = 3,
	ETrapDifficulty_MAX                      = 4,
};

// Enum Indiana.ETrapEventType
// NumValues: 0x0006
enum class ETrapEventType : uint8
{
	Invalid                                  = 0,
	Armed                                    = 1,
	Disarmed                                 = 2,
	PreDetonate                              = 3,
	Detonate                                 = 4,
	ETrapEventType_MAX                       = 5,
};

// Enum Indiana.EDiscoveryStatusFlags
// NumValues: 0x0005
enum class EDiscoveryStatusFlags : uint8
{
	Aware                                    = 0,
	Visited                                  = 1,
	Locked                                   = 2,
	Hidden                                   = 3,
	EDiscoveryStatusFlags_MAX                = 4,
};

// Enum Indiana.ETutorialCategory
// NumValues: 0x000C
enum class ETutorialCategory : uint8
{
	Basics                                   = 0,
	Exploration                              = 1,
	Loot                                     = 2,
	WeaponsAndArmor                          = 3,
	SkillsAndReputation                      = 4,
	Combat                                   = 5,
	Stealth                                  = 6,
	Companions                               = 7,
	Supernova                                = 8,
	Count                                    = 9,
	Invalid                                  = 10,
	ETutorialCategory_MAX                    = 11,
};

// Enum Indiana.ETutorialEvent
// NumValues: 0x007C
enum class ETutorialEvent : uint8
{
	Invalid                                  = 0,
	DisguiseActivated                        = 1,
	DisguiseDurationEnded                    = 2,
	DisguiseImperfectThresholdReached        = 3,
	DisguiseInterrogationBegun               = 4,
	DisguiseInterrogationFailed              = 5,
	DisguiseInterrogationSuccess             = 6,
	DisguiseIntro_1                          = 7,
	DisguiseIntro_2                          = 8,
	DisguiseIntro_3                          = 9,
	DisguiseIntro_4                          = 10,
	FastTravelPointLearned                   = 11,
	FlawOffered                              = 12,
	InterrogationBegun                       = 13,
	InterrogationFailed                      = 14,
	InterrogationSuccess                     = 15,
	PlayerArmor                              = 16,
	PlayerArmorGamepad                       = 17,
	PlayerBasicMovement                      = 18,
	PlayerBlocking                           = 19,
	PlayerCombatAttack                       = 20,
	PlayerCombatDialogAbilities              = 21,
	PlayerCompanionAbilities                 = 22,
	PlayerCompanionBonuses                   = 23,
	PlayerCompanionCommands                  = 24,
	PlayerCompanionGain                      = 25,
	PlayerCompanionGear                      = 26,
	PlayerCompanionPerks                     = 27,
	PlayerCompanionPerksAssigned             = 28,
	PlayerConsumables                        = 29,
	PlayerConsumablesController              = 30,
	PlayerCover                              = 31,
	PlayerCriminalActivities                 = 32,
	PlayerCrouch                             = 33,
	PlayerDamageTypes                        = 34,
	PlayerDestructibles                      = 35,
	PlayerDodging                            = 36,
	PlayerDodgeLeap                          = 37,
	PlayerEncumbrance                        = 38,
	PlayerEnemyAwareness                     = 39,
	PlayerFalling                            = 40,
	PlayerFlaws                              = 41,
	PlayerFlawOffered                        = 42,
	PlayerGrazes                             = 43,
	PlayerFastTravel                         = 44,
	PlayerHealthMedkitMax                    = 45,
	PlayerItemBroke                          = 46,
	PlayerItemDegradation                    = 47,
	PlayerItemGain                           = 48,
	PlayerItemPristine                       = 49,
	PlayerItemRepair                         = 50,
	PlayerJump                               = 51,
	PlayerLevelInstructions                  = 52,
	PlayerLevelSkills                        = 53,
	PlayerLevelUp                            = 54,
	PlayerLoot                               = 55,
	PlayerLootController                     = 56,
	PlayerMedKit                             = 57,
	PlayerMeleePowerAttack                   = 58,
	PlayerMeleeWithRanged                    = 59,
	PlayerModIntro                           = 60,
	PlayerModUse                             = 61,
	PlayerNRayDamage                         = 62,
	PlayerObjectiveMarkers                   = 63,
	PlayerPerfectBlocks                      = 64,
	PlayerPerks                              = 65,
	PlayerPerksUnlocked                      = 66,
	PlayerLockpicks                          = 67,
	PlayerQuestDependencies                  = 68,
	PlayerQuestScreen                        = 69,
	PlayerQuestSwitching                     = 70,
	PlayerReinforcement                      = 71,
	PlayerReinforcement2                     = 72,
	PlayerReinforcement3                     = 73,
	PlayerReinforcement4                     = 74,
	PlayerReinforcement5                     = 75,
	PlayerReinforcement6                     = 76,
	PlayerReinforcement7                     = 77,
	PlayerReinforcement8                     = 78,
	PlayerReinforcement9                     = 79,
	PlayerReinforcement10                    = 80,
	PlayerReinforcement11                    = 81,
	PlayerReinforcement12                    = 82,
	PlayerReinforcement13                    = 83,
	PlayerReinforcement14                    = 84,
	PlayerReinforcement15                    = 85,
	PlayerReputations                        = 86,
	PlayerRespec                             = 87,
	PlayerResting                            = 88,
	PlayerScienceWeapons                     = 89,
	PlayerSneak                              = 90,
	PlayerSneakAttack                        = 91,
	PlayerSprint                             = 92,
	PlayerStarmap                            = 93,
	PlayerStealthAttack                      = 94,
	PlayerSwitchingWeapons                   = 95,
	PlayerTacticalTimeDilation               = 96,
	PlayerTTDLocationHits                    = 97,
	PlayerTallGrass                          = 98,
	PlayerVendingMachine                     = 99,
	PlayerVendorScreen                       = 100,
	PlayerWeakspots                          = 101,
	PlayerWeapons                            = 102,
	PlayerWeaponsController                  = 103,
	PlayerWorkbench                          = 104,
	PlayerHunger                             = 105,
	PlayerSleepDeprivation                   = 106,
	PlayerThirst                             = 107,
	PlayerSpecialEffects                     = 108,
	PlayerDamageTypeCodex                    = 109,
	PlayerReinforcement16                    = 110,
	PlayerReinforcement17                    = 111,
	PlayerReinforcement18                    = 112,
	PlayerReinforcement19                    = 113,
	PlayerReinforcement20                    = 114,
	SpinUpWeapons                            = 115,
	ChargedBurstWeapons                      = 116,
	LowGravity                               = 117,
	DiscrepancyAmplifierAcquired             = 118,
	DiscrepancyAmplifierEquipped             = 119,
	DiscrepancyAmplifierUnacquired           = 120,
	PlayerItemImprovised                     = 121,
	Count                                    = 122,
	ETutorialEvent_MAX                       = 123,
};

// Enum Indiana.EControlDevice
// NumValues: 0x0004
enum class EControlDevice : uint8
{
	None                                     = 0,
	Keyboard                                 = 1,
	Gamepad                                  = 2,
	EControlDevice_MAX                       = 3,
};

// Enum Indiana.ETutorialDisplayType
// NumValues: 0x0005
enum class ETutorialDisplayType : uint8
{
	Invalid                                  = 0,
	Simple                                   = 1,
	CorporateLarge                           = 2,
	Count                                    = 3,
	ETutorialDisplayType_MAX                 = 4,
};

// Enum Indiana.EInputGroup
// NumValues: 0x0005
enum class EInputGroup : uint8
{
	None                                     = 0,
	LeftStick                                = 1,
	RightStick                               = 2,
	DPad                                     = 4,
	EInputGroup_MAX                          = 5,
};

// Enum Indiana.ETransactionValidationResult
// NumValues: 0x000D
enum class ETransactionValidationResult : uint8
{
	Valid                                    = 0,
	PlayerLacksCurrency                      = 1,
	VendorLacksCurrency                      = 2,
	NullPlayerInventory                      = 3,
	VendorLacksInventory                     = 4,
	VendorInventoryMismatch                  = 5,
	PlayerInventoryMismatch                  = 6,
	VendorDoesntBuy                          = 7,
	CantBuyRestrictedStock                   = 8,
	CantPawnNoDropItems                      = 9,
	NoItems                                  = 10,
	CantRepairHealthyItems                   = 11,
	ETransactionValidationResult_MAX         = 12,
};

// Enum Indiana.EVendorPages
// NumValues: 0x0005
enum class EVendorPages : uint8
{
	Buy                                      = 0,
	Sell                                     = 1,
	Repair                                   = 2,
	Count                                    = 3,
	EVendorPages_MAX                         = 4,
};

// Enum Indiana.EHolsterState
// NumValues: 0x0005
enum class EHolsterState : uint8
{
	Holstered                                = 0,
	Holstering                               = 1,
	Unholstering                             = 2,
	Unholstered                              = 3,
	EHolsterState_MAX                        = 4,
};

// Enum Indiana.EWeaponEquipMode
// NumValues: 0x0004
enum class EWeaponEquipMode : uint8
{
	FirstPerson                              = 0,
	ThirdPerson                              = 1,
	UIPreview                                = 2,
	EWeaponEquipMode_MAX                     = 3,
};

// Enum Indiana.EModSlot
// NumValues: 0x0009
enum class EModSlot : uint8
{
	None                                     = 0,
	Barrel                                   = 1,
	UnderBarrel                              = 2,
	Magazine                                 = 3,
	Sight                                    = 4,
	MeleeGrip                                = 5,
	MeleeAttack                              = 6,
	SlotCount                                = 7,
	EModSlot_MAX                             = 8,
};

// Enum Indiana.EAttackRestrictions
// NumValues: 0x000B
enum class EAttackRestrictions : uint16
{
	None                                     = 0,
	PendingReload                            = 1,
	Sprinting                                = 2,
	Blocking                                 = 4,
	AttackSuspended                          = 8,
	InputSuppressed                          = 16,
	Reloading                                = 32,
	NoAmmo                                   = 64,
	QuickMeleeCooldown                       = 128,
	FireCooldown                             = 256,
	EAttackRestrictions_MAX                  = 257,
};

// Enum Indiana.EWeaponState
// NumValues: 0x0010
enum class EWeaponState : uint8
{
	Invalid                                  = 0,
	Equipped                                 = 1,
	Reloading                                = 2,
	Firing                                   = 3,
	Active                                   = 4,
	Charging                                 = 5,
	ChargeUp                                 = 6,
	ChargeFull                               = 7,
	Scoped                                   = 8,
	FineAiming                               = 9,
	BeamLocked                               = 10,
	FiringFineAiming                         = 11,
	FiringScoped                             = 12,
	FiringNotAiming                          = 13,
	CalledShot                               = 14,
	EWeaponState_MAX                         = 15,
};

// Enum Indiana.EWeaponEvent
// NumValues: 0x0031
enum class EWeaponEvent : uint8
{
	Invalid                                  = 0,
	Equip                                    = 1,
	Unequip                                  = 2,
	Holster                                  = 3,
	Unholster                                = 4,
	InstantEquip                             = 5,
	InstantUnequip                           = 6,
	Fire                                     = 7,
	FireFineAim                              = 8,
	FireScoped                               = 9,
	DryFire                                  = 10,
	DamageTicked                             = 11,
	CalledShot                               = 12,
	FireCalledShot                           = 13,
	FakeFireCalledShot                       = 14,
	Reload                                   = 15,
	ChargeMax                                = 16,
	MeleeWindUpLeft                          = 17,
	MeleeWindUpRight                         = 18,
	MeleeAttackRight                         = 19,
	MeleeAttackLeft                          = 20,
	PowerAttackWindUp                        = 21,
	PowerAttackSwing                         = 22,
	SweepAttackWindUp                        = 23,
	SweepAttackSwing                         = 24,
	CounterAttack                            = 25,
	Recoil                                   = 26,
	WindUpNoStamina                          = 27,
	NoStaminaAttack                          = 28,
	MeleeImpact                              = 29,
	Block                                    = 30,
	QuickMelee                               = 31,
	Stagger                                  = 32,
	CustomFire                               = 33,
	SpecialAttack1                           = 34,
	SpecialAttack2                           = 35,
	SpecialAttack3                           = 36,
	SpecialAttack4                           = 37,
	FineAimStart                             = 38,
	FineAimLeave                             = 39,
	ScopeStart                               = 40,
	ScopeLeave                               = 41,
	ScopeEnter                               = 42,
	ScopeExit                                = 43,
	InstantHolster                           = 44,
	InstantUnholster                         = 45,
	StealthMelee                             = 46,
	PerfectBlock                             = 47,
	EWeaponEvent_MAX                         = 48,
};

// Enum Indiana.EWorkbenchPages
// NumValues: 0x0006
enum class EWorkbenchPages : uint8
{
	Modification                             = 0,
	Upgrade                                  = 1,
	Repair                                   = 2,
	Breakdown                                = 3,
	Count                                    = 4,
	EWorkbenchPages_MAX                      = 5,
};

// Enum Indiana.ETextDirectionType
// NumValues: 0x0004
enum class ETextDirectionType : uint8
{
	NoDirectionalBias                        = 0,
	Up                                       = 1,
	Down                                     = 2,
	ETextDirectionType_MAX                   = 3,
};

// ScriptStruct Indiana.AddictionTimer
// 0x0040 (0x0040 - 0x0000)
struct FAddictionTimer final
{
public:
	struct FGameplayTag                           AddictionTag;                                    // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimerMax;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncreasePerSecond;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFlaw>                      FlawClass;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAddictionTimerEntersMaxed;                       // 0x0018(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAddictionTimerLeavesMaxed;                       // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         CurrentTimer;                                      // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAddictionTimer) == 0x000008, "Wrong alignment on FAddictionTimer");
static_assert(sizeof(FAddictionTimer) == 0x000040, "Wrong size on FAddictionTimer");
static_assert(offsetof(FAddictionTimer, AddictionTag) == 0x000000, "Member 'FAddictionTimer::AddictionTag' has a wrong offset!");
static_assert(offsetof(FAddictionTimer, TimerMax) == 0x000008, "Member 'FAddictionTimer::TimerMax' has a wrong offset!");
static_assert(offsetof(FAddictionTimer, IncreasePerSecond) == 0x00000C, "Member 'FAddictionTimer::IncreasePerSecond' has a wrong offset!");
static_assert(offsetof(FAddictionTimer, FlawClass) == 0x000010, "Member 'FAddictionTimer::FlawClass' has a wrong offset!");
static_assert(offsetof(FAddictionTimer, OnAddictionTimerEntersMaxed) == 0x000018, "Member 'FAddictionTimer::OnAddictionTimerEntersMaxed' has a wrong offset!");
static_assert(offsetof(FAddictionTimer, OnAddictionTimerLeavesMaxed) == 0x000028, "Member 'FAddictionTimer::OnAddictionTimerLeavesMaxed' has a wrong offset!");
static_assert(offsetof(FAddictionTimer, CurrentTimer) == 0x000038, "Member 'FAddictionTimer::CurrentTimer' has a wrong offset!");

// ScriptStruct Indiana.GlobalVariable
// 0x0010 (0x0010 - 0x0000)
struct FGlobalVariable final
{
public:
	class FString                                 DisplayName;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGlobalVariable) == 0x000008, "Wrong alignment on FGlobalVariable");
static_assert(sizeof(FGlobalVariable) == 0x000010, "Wrong size on FGlobalVariable");
static_assert(offsetof(FGlobalVariable, DisplayName) == 0x000000, "Member 'FGlobalVariable::DisplayName' has a wrong offset!");

// ScriptStruct Indiana.LocString
// 0x0008 (0x0008 - 0x0000)
struct FLocString final
{
public:
	int32                                         StringID;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStringTableType                              TableType;                                         // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLocString) == 0x000004, "Wrong alignment on FLocString");
static_assert(sizeof(FLocString) == 0x000008, "Wrong size on FLocString");
static_assert(offsetof(FLocString, StringID) == 0x000000, "Member 'FLocString::StringID' has a wrong offset!");
static_assert(offsetof(FLocString, TableType) == 0x000004, "Member 'FLocString::TableType' has a wrong offset!");

// ScriptStruct Indiana.GlobalVariableConditional
// 0x0030 (0x0030 - 0x0000)
struct FGlobalVariableConditional final
{
public:
	struct FGlobalVariable                        GlobalVariable;                                    // 0x0000(0x0010)(Edit, NativeAccessSpecifierPublic)
	EGlobalVariableComparison                     Operator;                                          // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGlobalVariable                        OtherGlobalVariable;                               // 0x0018(0x0010)(Edit, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefault;                                          // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGlobalVariableConditional) == 0x000008, "Wrong alignment on FGlobalVariableConditional");
static_assert(sizeof(FGlobalVariableConditional) == 0x000030, "Wrong size on FGlobalVariableConditional");
static_assert(offsetof(FGlobalVariableConditional, GlobalVariable) == 0x000000, "Member 'FGlobalVariableConditional::GlobalVariable' has a wrong offset!");
static_assert(offsetof(FGlobalVariableConditional, Operator) == 0x000010, "Member 'FGlobalVariableConditional::Operator' has a wrong offset!");
static_assert(offsetof(FGlobalVariableConditional, OtherGlobalVariable) == 0x000018, "Member 'FGlobalVariableConditional::OtherGlobalVariable' has a wrong offset!");
static_assert(offsetof(FGlobalVariableConditional, Value) == 0x000028, "Member 'FGlobalVariableConditional::Value' has a wrong offset!");
static_assert(offsetof(FGlobalVariableConditional, bDefault) == 0x00002C, "Member 'FGlobalVariableConditional::bDefault' has a wrong offset!");

// ScriptStruct Indiana.QuestReference
// 0x0010 (0x0010 - 0x0000)
struct FQuestReference final
{
public:
	struct FGuid                                  ID;                                                // 0x0000(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestReference) == 0x000004, "Wrong alignment on FQuestReference");
static_assert(sizeof(FQuestReference) == 0x000010, "Wrong size on FQuestReference");
static_assert(offsetof(FQuestReference, ID) == 0x000000, "Member 'FQuestReference::ID' has a wrong offset!");

// ScriptStruct Indiana.QuestStateConditional
// 0x0014 (0x0014 - 0x0000)
struct FQuestStateConditional final
{
public:
	struct FQuestReference                        QuestReference;                                    // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EEqualityComparison                           Operator;                                          // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQuestState                                   ComparisonState;                                   // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefault;                                          // 0x0012(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestStateConditional) == 0x000004, "Wrong alignment on FQuestStateConditional");
static_assert(sizeof(FQuestStateConditional) == 0x000014, "Wrong size on FQuestStateConditional");
static_assert(offsetof(FQuestStateConditional, QuestReference) == 0x000000, "Member 'FQuestStateConditional::QuestReference' has a wrong offset!");
static_assert(offsetof(FQuestStateConditional, Operator) == 0x000010, "Member 'FQuestStateConditional::Operator' has a wrong offset!");
static_assert(offsetof(FQuestStateConditional, ComparisonState) == 0x000011, "Member 'FQuestStateConditional::ComparisonState' has a wrong offset!");
static_assert(offsetof(FQuestStateConditional, bDefault) == 0x000012, "Member 'FQuestStateConditional::bDefault' has a wrong offset!");

// ScriptStruct Indiana.CompanionStateConditional
// 0x0004 (0x0004 - 0x0000)
struct FCompanionStateConditional final
{
public:
	ESpecialObsidianID                            CompanionToCheck;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEqualityComparison                           Operator;                                          // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECompanionState                               ComparisonState;                                   // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefault;                                          // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCompanionStateConditional) == 0x000001, "Wrong alignment on FCompanionStateConditional");
static_assert(sizeof(FCompanionStateConditional) == 0x000004, "Wrong size on FCompanionStateConditional");
static_assert(offsetof(FCompanionStateConditional, CompanionToCheck) == 0x000000, "Member 'FCompanionStateConditional::CompanionToCheck' has a wrong offset!");
static_assert(offsetof(FCompanionStateConditional, Operator) == 0x000001, "Member 'FCompanionStateConditional::Operator' has a wrong offset!");
static_assert(offsetof(FCompanionStateConditional, ComparisonState) == 0x000002, "Member 'FCompanionStateConditional::ComparisonState' has a wrong offset!");
static_assert(offsetof(FCompanionStateConditional, bDefault) == 0x000003, "Member 'FCompanionStateConditional::bDefault' has a wrong offset!");

// ScriptStruct Indiana.PCGenderConditional
// 0x0003 (0x0003 - 0x0000)
struct FPCGenderConditional final
{
public:
	EEqualityComparison                           Operator;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGender                                       ComparisonGender;                                  // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefault;                                          // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPCGenderConditional) == 0x000001, "Wrong alignment on FPCGenderConditional");
static_assert(sizeof(FPCGenderConditional) == 0x000003, "Wrong size on FPCGenderConditional");
static_assert(offsetof(FPCGenderConditional, Operator) == 0x000000, "Member 'FPCGenderConditional::Operator' has a wrong offset!");
static_assert(offsetof(FPCGenderConditional, ComparisonGender) == 0x000001, "Member 'FPCGenderConditional::ComparisonGender' has a wrong offset!");
static_assert(offsetof(FPCGenderConditional, bDefault) == 0x000002, "Member 'FPCGenderConditional::bDefault' has a wrong offset!");

// ScriptStruct Indiana.DLCInstalledConditional
// 0x0002 (0x0002 - 0x0000)
struct FDLCInstalledConditional final
{
public:
	EDLCType                                      DLCToCheck;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefault;                                          // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDLCInstalledConditional) == 0x000001, "Wrong alignment on FDLCInstalledConditional");
static_assert(sizeof(FDLCInstalledConditional) == 0x000002, "Wrong size on FDLCInstalledConditional");
static_assert(offsetof(FDLCInstalledConditional, DLCToCheck) == 0x000000, "Member 'FDLCInstalledConditional::DLCToCheck' has a wrong offset!");
static_assert(offsetof(FDLCInstalledConditional, bDefault) == 0x000001, "Member 'FDLCInstalledConditional::bDefault' has a wrong offset!");

// ScriptStruct Indiana.LogicalStatement
// 0x0058 (0x0058 - 0x0000)
struct FLogicalStatement final
{
public:
	Indiana::ELogicalOperator                     Operator;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConditionalType                              ConditionalType;                                   // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGlobalVariableConditional             Condition;                                         // 0x0008(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FQuestStateConditional                 QuestStateCondition;                               // 0x0038(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCompanionStateConditional             CompanionStateCondition;                           // 0x004C(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FPCGenderConditional                   PCGenderCondition;                                 // 0x0050(0x0003)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FDLCInstalledConditional               DLCInstalledCondition;                             // 0x0053(0x0002)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLogicalStatement) == 0x000008, "Wrong alignment on FLogicalStatement");
static_assert(sizeof(FLogicalStatement) == 0x000058, "Wrong size on FLogicalStatement");
static_assert(offsetof(FLogicalStatement, Operator) == 0x000000, "Member 'FLogicalStatement::Operator' has a wrong offset!");
static_assert(offsetof(FLogicalStatement, ConditionalType) == 0x000001, "Member 'FLogicalStatement::ConditionalType' has a wrong offset!");
static_assert(offsetof(FLogicalStatement, Condition) == 0x000008, "Member 'FLogicalStatement::Condition' has a wrong offset!");
static_assert(offsetof(FLogicalStatement, QuestStateCondition) == 0x000038, "Member 'FLogicalStatement::QuestStateCondition' has a wrong offset!");
static_assert(offsetof(FLogicalStatement, CompanionStateCondition) == 0x00004C, "Member 'FLogicalStatement::CompanionStateCondition' has a wrong offset!");
static_assert(offsetof(FLogicalStatement, PCGenderCondition) == 0x000050, "Member 'FLogicalStatement::PCGenderCondition' has a wrong offset!");
static_assert(offsetof(FLogicalStatement, DLCInstalledCondition) == 0x000053, "Member 'FLogicalStatement::DLCInstalledCondition' has a wrong offset!");

// ScriptStruct Indiana.LogicalExpression
// 0x0068 (0x0068 - 0x0000)
struct FLogicalExpression final
{
public:
	EConditionalType                              ConditionalType;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGlobalVariableConditional             BaseCondition;                                     // 0x0008(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FQuestStateConditional                 BaseQuestStateCondition;                           // 0x0038(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCompanionStateConditional             BaseCompanionStateCondition;                       // 0x004C(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FPCGenderConditional                   BasePCGenderCondition;                             // 0x0050(0x0003)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FDLCInstalledConditional               BaseDLCInstalledCondition;                         // 0x0053(0x0002)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLogicalStatement>              AdditionalConditions;                              // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLogicalExpression) == 0x000008, "Wrong alignment on FLogicalExpression");
static_assert(sizeof(FLogicalExpression) == 0x000068, "Wrong size on FLogicalExpression");
static_assert(offsetof(FLogicalExpression, ConditionalType) == 0x000000, "Member 'FLogicalExpression::ConditionalType' has a wrong offset!");
static_assert(offsetof(FLogicalExpression, BaseCondition) == 0x000008, "Member 'FLogicalExpression::BaseCondition' has a wrong offset!");
static_assert(offsetof(FLogicalExpression, BaseQuestStateCondition) == 0x000038, "Member 'FLogicalExpression::BaseQuestStateCondition' has a wrong offset!");
static_assert(offsetof(FLogicalExpression, BaseCompanionStateCondition) == 0x00004C, "Member 'FLogicalExpression::BaseCompanionStateCondition' has a wrong offset!");
static_assert(offsetof(FLogicalExpression, BasePCGenderCondition) == 0x000050, "Member 'FLogicalExpression::BasePCGenderCondition' has a wrong offset!");
static_assert(offsetof(FLogicalExpression, BaseDLCInstalledCondition) == 0x000053, "Member 'FLogicalExpression::BaseDLCInstalledCondition' has a wrong offset!");
static_assert(offsetof(FLogicalExpression, AdditionalConditions) == 0x000058, "Member 'FLogicalExpression::AdditionalConditions' has a wrong offset!");

// ScriptStruct Indiana.ConditionalizedLoadingTips
// 0x0070 (0x0070 - 0x0000)
struct FConditionalizedLoadingTips final
{
public:
	struct FLocString                             Tip;                                               // 0x0000(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLogicalExpression                     Conditional;                                       // 0x0008(0x0068)(Edit, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FConditionalizedLoadingTips) == 0x000008, "Wrong alignment on FConditionalizedLoadingTips");
static_assert(sizeof(FConditionalizedLoadingTips) == 0x000070, "Wrong size on FConditionalizedLoadingTips");
static_assert(offsetof(FConditionalizedLoadingTips, Tip) == 0x000000, "Member 'FConditionalizedLoadingTips::Tip' has a wrong offset!");
static_assert(offsetof(FConditionalizedLoadingTips, Conditional) == 0x000008, "Member 'FConditionalizedLoadingTips::Conditional' has a wrong offset!");

// ScriptStruct Indiana.ComponentEvent
// 0x0030 (0x0030 - 0x0000)
struct FComponentEvent
{
public:
	class UWidget*                                Dispatcher;                                        // 0x0000(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8[0x28];                                       // 0x0008(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FComponentEvent) == 0x000008, "Wrong alignment on FComponentEvent");
static_assert(sizeof(FComponentEvent) == 0x000030, "Wrong size on FComponentEvent");
static_assert(offsetof(FComponentEvent, Dispatcher) == 0x000000, "Member 'FComponentEvent::Dispatcher' has a wrong offset!");

// ScriptStruct Indiana.SliderEvent
// 0x0008 (0x0038 - 0x0030)
struct FSliderEvent final : public FComponentEvent
{
public:
	float                                         Value;                                             // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSliderEvent) == 0x000008, "Wrong alignment on FSliderEvent");
static_assert(sizeof(FSliderEvent) == 0x000038, "Wrong size on FSliderEvent");
static_assert(offsetof(FSliderEvent, Value) == 0x000030, "Member 'FSliderEvent::Value' has a wrong offset!");

// ScriptStruct Indiana.ImpactParticle
// 0x0060 (0x0060 - 0x0000)
struct FImpactParticle final
{
public:
	class UParticleSystem*                        Fx;                                                // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FxScale;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRotation;                                      // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      ChargeEmitterEnableThresholds;                     // 0x0010(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FImpactParticle) == 0x000008, "Wrong alignment on FImpactParticle");
static_assert(sizeof(FImpactParticle) == 0x000060, "Wrong size on FImpactParticle");
static_assert(offsetof(FImpactParticle, Fx) == 0x000000, "Member 'FImpactParticle::Fx' has a wrong offset!");
static_assert(offsetof(FImpactParticle, FxScale) == 0x000008, "Member 'FImpactParticle::FxScale' has a wrong offset!");
static_assert(offsetof(FImpactParticle, bUseRotation) == 0x00000C, "Member 'FImpactParticle::bUseRotation' has a wrong offset!");
static_assert(offsetof(FImpactParticle, ChargeEmitterEnableThresholds) == 0x000010, "Member 'FImpactParticle::ChargeEmitterEnableThresholds' has a wrong offset!");

// ScriptStruct Indiana.CauseDamageInfo
// 0x0110 (0x0110 - 0x0000)
struct FCauseDamageInfo final
{
public:
	TWeakObjectPtr<class AController>             InstigatorController;                              // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  SourceActor;                                       // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Target;                                            // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageEventType                              DamageEventType;                                   // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DesiredDamage;                                     // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActualDamage;                                      // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    ImpactLocation;                                    // 0x0028(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    ImpactDirection;                                   // 0x0034(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HitBone;                                           // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UPhysicalMaterial>       HitPhysMaterial;                                   // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BodyPartHit;                                       // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UIndianaDamageType>         DamageType;                                        // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WeaponCategory;                                    // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0xA8];                                      // 0x0068(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCauseDamageInfo) == 0x000008, "Wrong alignment on FCauseDamageInfo");
static_assert(sizeof(FCauseDamageInfo) == 0x000110, "Wrong size on FCauseDamageInfo");
static_assert(offsetof(FCauseDamageInfo, InstigatorController) == 0x000000, "Member 'FCauseDamageInfo::InstigatorController' has a wrong offset!");
static_assert(offsetof(FCauseDamageInfo, SourceActor) == 0x000008, "Member 'FCauseDamageInfo::SourceActor' has a wrong offset!");
static_assert(offsetof(FCauseDamageInfo, Target) == 0x000010, "Member 'FCauseDamageInfo::Target' has a wrong offset!");
static_assert(offsetof(FCauseDamageInfo, DamageEventType) == 0x000018, "Member 'FCauseDamageInfo::DamageEventType' has a wrong offset!");
static_assert(offsetof(FCauseDamageInfo, DesiredDamage) == 0x00001C, "Member 'FCauseDamageInfo::DesiredDamage' has a wrong offset!");
static_assert(offsetof(FCauseDamageInfo, ActualDamage) == 0x000020, "Member 'FCauseDamageInfo::ActualDamage' has a wrong offset!");
static_assert(offsetof(FCauseDamageInfo, ImpactLocation) == 0x000028, "Member 'FCauseDamageInfo::ImpactLocation' has a wrong offset!");
static_assert(offsetof(FCauseDamageInfo, ImpactDirection) == 0x000034, "Member 'FCauseDamageInfo::ImpactDirection' has a wrong offset!");
static_assert(offsetof(FCauseDamageInfo, HitBone) == 0x000040, "Member 'FCauseDamageInfo::HitBone' has a wrong offset!");
static_assert(offsetof(FCauseDamageInfo, HitPhysMaterial) == 0x000048, "Member 'FCauseDamageInfo::HitPhysMaterial' has a wrong offset!");
static_assert(offsetof(FCauseDamageInfo, BodyPartHit) == 0x000050, "Member 'FCauseDamageInfo::BodyPartHit' has a wrong offset!");
static_assert(offsetof(FCauseDamageInfo, DamageType) == 0x000058, "Member 'FCauseDamageInfo::DamageType' has a wrong offset!");
static_assert(offsetof(FCauseDamageInfo, WeaponCategory) == 0x000060, "Member 'FCauseDamageInfo::WeaponCategory' has a wrong offset!");

// ScriptStruct Indiana.AISelector_FValue
// 0x0008 (0x0008 - 0x0000)
struct FAISelector_FValue final
{
public:
	TSubclassOf<class UAIFValue>                  AIFValue;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISelector_FValue) == 0x000008, "Wrong alignment on FAISelector_FValue");
static_assert(sizeof(FAISelector_FValue) == 0x000008, "Wrong size on FAISelector_FValue");
static_assert(offsetof(FAISelector_FValue, AIFValue) == 0x000000, "Member 'FAISelector_FValue::AIFValue' has a wrong offset!");

// ScriptStruct Indiana.SaveGameDataDetection
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FSaveGameDataDetection final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSaveGameDataDetection) == 0x000008, "Wrong alignment on FSaveGameDataDetection");
static_assert(sizeof(FSaveGameDataDetection) == 0x000030, "Wrong size on FSaveGameDataDetection");

// ScriptStruct Indiana.InteractionDescription
// 0x0028 (0x0028 - 0x0000)
struct FInteractionDescription final
{
public:
	class AActor*                                 Interactee;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AIndianaCharacter*                      Initiator;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionType                              Interaction;                                       // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UInteractableComponent>  Interactable;                                      // 0x0014(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C[0xC];                                       // 0x001C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractionDescription) == 0x000008, "Wrong alignment on FInteractionDescription");
static_assert(sizeof(FInteractionDescription) == 0x000028, "Wrong size on FInteractionDescription");
static_assert(offsetof(FInteractionDescription, Interactee) == 0x000000, "Member 'FInteractionDescription::Interactee' has a wrong offset!");
static_assert(offsetof(FInteractionDescription, Initiator) == 0x000008, "Member 'FInteractionDescription::Initiator' has a wrong offset!");
static_assert(offsetof(FInteractionDescription, Interaction) == 0x000010, "Member 'FInteractionDescription::Interaction' has a wrong offset!");
static_assert(offsetof(FInteractionDescription, Interactable) == 0x000014, "Member 'FInteractionDescription::Interactable' has a wrong offset!");

// ScriptStruct Indiana.AchievementProgress
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FAchievementProgress final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAchievementProgress) == 0x000004, "Wrong alignment on FAchievementProgress");
static_assert(sizeof(FAchievementProgress) == 0x000004, "Wrong size on FAchievementProgress");

// ScriptStruct Indiana.WeaponInputBuffer
// 0x000C (0x000C - 0x0000)
struct FWeaponInputBuffer final
{
public:
	float                                         WindowTime;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputTimeStamp;                                    // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x4];                                        // 0x0008(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponInputBuffer) == 0x000004, "Wrong alignment on FWeaponInputBuffer");
static_assert(sizeof(FWeaponInputBuffer) == 0x00000C, "Wrong size on FWeaponInputBuffer");
static_assert(offsetof(FWeaponInputBuffer, WindowTime) == 0x000000, "Member 'FWeaponInputBuffer::WindowTime' has a wrong offset!");
static_assert(offsetof(FWeaponInputBuffer, InputTimeStamp) == 0x000004, "Member 'FWeaponInputBuffer::InputTimeStamp' has a wrong offset!");

// ScriptStruct Indiana.AISettings_RecoveryBackupBehavior
// 0x0020 (0x0020 - 0x0000)
struct FAISettings_RecoveryBackupBehavior final
{
public:
	EMeleeRecoveryType                            RecoveryType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BackupChance;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBackupDistance;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinBackupDistance;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DodgeChance;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDodgeDirection                               DodgeDirection;                                    // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDodgeRequiresClearPath;                           // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxValidTargetDistance;                            // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldLookAtTarget;                               // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAISettings_RecoveryBackupBehavior) == 0x000004, "Wrong alignment on FAISettings_RecoveryBackupBehavior");
static_assert(sizeof(FAISettings_RecoveryBackupBehavior) == 0x000020, "Wrong size on FAISettings_RecoveryBackupBehavior");
static_assert(offsetof(FAISettings_RecoveryBackupBehavior, RecoveryType) == 0x000000, "Member 'FAISettings_RecoveryBackupBehavior::RecoveryType' has a wrong offset!");
static_assert(offsetof(FAISettings_RecoveryBackupBehavior, BackupChance) == 0x000004, "Member 'FAISettings_RecoveryBackupBehavior::BackupChance' has a wrong offset!");
static_assert(offsetof(FAISettings_RecoveryBackupBehavior, MaxBackupDistance) == 0x000008, "Member 'FAISettings_RecoveryBackupBehavior::MaxBackupDistance' has a wrong offset!");
static_assert(offsetof(FAISettings_RecoveryBackupBehavior, MinBackupDistance) == 0x00000C, "Member 'FAISettings_RecoveryBackupBehavior::MinBackupDistance' has a wrong offset!");
static_assert(offsetof(FAISettings_RecoveryBackupBehavior, DodgeChance) == 0x000010, "Member 'FAISettings_RecoveryBackupBehavior::DodgeChance' has a wrong offset!");
static_assert(offsetof(FAISettings_RecoveryBackupBehavior, DodgeDirection) == 0x000014, "Member 'FAISettings_RecoveryBackupBehavior::DodgeDirection' has a wrong offset!");
static_assert(offsetof(FAISettings_RecoveryBackupBehavior, bDodgeRequiresClearPath) == 0x000015, "Member 'FAISettings_RecoveryBackupBehavior::bDodgeRequiresClearPath' has a wrong offset!");
static_assert(offsetof(FAISettings_RecoveryBackupBehavior, MaxValidTargetDistance) == 0x000018, "Member 'FAISettings_RecoveryBackupBehavior::MaxValidTargetDistance' has a wrong offset!");
static_assert(offsetof(FAISettings_RecoveryBackupBehavior, bShouldLookAtTarget) == 0x00001C, "Member 'FAISettings_RecoveryBackupBehavior::bShouldLookAtTarget' has a wrong offset!");

// ScriptStruct Indiana.AISettings_MeleeActionBase
// 0x003C (0x003C - 0x0000)
struct FAISettings_MeleeActionBase
{
public:
	float                                         RecoveryDelay;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAdaptiveRootMotion;                            // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdaptiveRootMotionStopDistance;                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideBackupBehavior;                           // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAISettings_RecoveryBackupBehavior     BackupBehavior;                                    // 0x0010(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AttackingRotationThreshold;                        // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreferredAttackDistance;                           // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x4];                                       // 0x0038(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAISettings_MeleeActionBase) == 0x000004, "Wrong alignment on FAISettings_MeleeActionBase");
static_assert(sizeof(FAISettings_MeleeActionBase) == 0x00003C, "Wrong size on FAISettings_MeleeActionBase");
static_assert(offsetof(FAISettings_MeleeActionBase, RecoveryDelay) == 0x000000, "Member 'FAISettings_MeleeActionBase::RecoveryDelay' has a wrong offset!");
static_assert(offsetof(FAISettings_MeleeActionBase, bUseAdaptiveRootMotion) == 0x000004, "Member 'FAISettings_MeleeActionBase::bUseAdaptiveRootMotion' has a wrong offset!");
static_assert(offsetof(FAISettings_MeleeActionBase, AdaptiveRootMotionStopDistance) == 0x000008, "Member 'FAISettings_MeleeActionBase::AdaptiveRootMotionStopDistance' has a wrong offset!");
static_assert(offsetof(FAISettings_MeleeActionBase, bOverrideBackupBehavior) == 0x00000C, "Member 'FAISettings_MeleeActionBase::bOverrideBackupBehavior' has a wrong offset!");
static_assert(offsetof(FAISettings_MeleeActionBase, BackupBehavior) == 0x000010, "Member 'FAISettings_MeleeActionBase::BackupBehavior' has a wrong offset!");
static_assert(offsetof(FAISettings_MeleeActionBase, AttackingRotationThreshold) == 0x000030, "Member 'FAISettings_MeleeActionBase::AttackingRotationThreshold' has a wrong offset!");
static_assert(offsetof(FAISettings_MeleeActionBase, PreferredAttackDistance) == 0x000034, "Member 'FAISettings_MeleeActionBase::PreferredAttackDistance' has a wrong offset!");

// ScriptStruct Indiana.AISettings_MeleePatternEntry
// 0x0048 (0x0048 - 0x0000)
struct FAISettings_MeleePatternEntry final
{
public:
	class UMeleeSlotRequestData*                  MeleeAction;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAISettings_MeleeActionBase            Settings;                                          // 0x0008(0x003C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAISettings_MeleePatternEntry) == 0x000008, "Wrong alignment on FAISettings_MeleePatternEntry");
static_assert(sizeof(FAISettings_MeleePatternEntry) == 0x000048, "Wrong size on FAISettings_MeleePatternEntry");
static_assert(offsetof(FAISettings_MeleePatternEntry, MeleeAction) == 0x000000, "Member 'FAISettings_MeleePatternEntry::MeleeAction' has a wrong offset!");
static_assert(offsetof(FAISettings_MeleePatternEntry, Settings) == 0x000008, "Member 'FAISettings_MeleePatternEntry::Settings' has a wrong offset!");

// ScriptStruct Indiana.AISettings_MeleePattern
// 0x0020 (0x0020 - 0x0000)
struct FAISettings_MeleePattern final
{
public:
	float                                         MaxValidTargetDistance;                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cooldown;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAISettings_MeleePatternEntry>  AttackPattern;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISettings_MeleePattern) == 0x000008, "Wrong alignment on FAISettings_MeleePattern");
static_assert(sizeof(FAISettings_MeleePattern) == 0x000020, "Wrong size on FAISettings_MeleePattern");
static_assert(offsetof(FAISettings_MeleePattern, MaxValidTargetDistance) == 0x000000, "Member 'FAISettings_MeleePattern::MaxValidTargetDistance' has a wrong offset!");
static_assert(offsetof(FAISettings_MeleePattern, Weight) == 0x000004, "Member 'FAISettings_MeleePattern::Weight' has a wrong offset!");
static_assert(offsetof(FAISettings_MeleePattern, Cooldown) == 0x000008, "Member 'FAISettings_MeleePattern::Cooldown' has a wrong offset!");
static_assert(offsetof(FAISettings_MeleePattern, AttackPattern) == 0x000010, "Member 'FAISettings_MeleePattern::AttackPattern' has a wrong offset!");

// ScriptStruct Indiana.ItemStack
// 0x0010 (0x0010 - 0x0000)
struct FItemStack final
{
public:
	class UItem*                                  Item;                                              // 0x0000(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLootable;                                         // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemStack) == 0x000008, "Wrong alignment on FItemStack");
static_assert(sizeof(FItemStack) == 0x000010, "Wrong size on FItemStack");
static_assert(offsetof(FItemStack, Item) == 0x000000, "Member 'FItemStack::Item' has a wrong offset!");
static_assert(offsetof(FItemStack, Count) == 0x000008, "Member 'FItemStack::Count' has a wrong offset!");
static_assert(offsetof(FItemStack, bLootable) == 0x00000C, "Member 'FItemStack::bLootable' has a wrong offset!");

// ScriptStruct Indiana.SettingPlatformStringContainer
// 0x0010 (0x0010 - 0x0000)
struct FSettingPlatformStringContainer final
{
public:
	struct FLocString                             Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLocString                             Description;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSettingPlatformStringContainer) == 0x000004, "Wrong alignment on FSettingPlatformStringContainer");
static_assert(sizeof(FSettingPlatformStringContainer) == 0x000010, "Wrong size on FSettingPlatformStringContainer");
static_assert(offsetof(FSettingPlatformStringContainer, Name) == 0x000000, "Member 'FSettingPlatformStringContainer::Name' has a wrong offset!");
static_assert(offsetof(FSettingPlatformStringContainer, Description) == 0x000008, "Member 'FSettingPlatformStringContainer::Description' has a wrong offset!");

// ScriptStruct Indiana.SubcategoryDescription
// 0x0060 (0x0060 - 0x0000)
struct FSubcategoryDescription final
{
public:
	struct FLocString                             Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLocString                             Description;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EPlatformFamily, struct FSettingPlatformStringContainer> PlatformOverrides;                                 // 0x0010(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSubcategoryDescription) == 0x000008, "Wrong alignment on FSubcategoryDescription");
static_assert(sizeof(FSubcategoryDescription) == 0x000060, "Wrong size on FSubcategoryDescription");
static_assert(offsetof(FSubcategoryDescription, Name) == 0x000000, "Member 'FSubcategoryDescription::Name' has a wrong offset!");
static_assert(offsetof(FSubcategoryDescription, Description) == 0x000008, "Member 'FSubcategoryDescription::Description' has a wrong offset!");
static_assert(offsetof(FSubcategoryDescription, PlatformOverrides) == 0x000010, "Member 'FSubcategoryDescription::PlatformOverrides' has a wrong offset!");

// ScriptStruct Indiana.ReactiveToRangeElement
// 0x0014 (0x0014 - 0x0000)
struct FReactiveToRangeElement final
{
public:
	float                                         MinSustainFireDuration;                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSustainFireDuration;                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SustainFirePauseDuration;                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DodgeProbability;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlockProbability;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReactiveToRangeElement) == 0x000004, "Wrong alignment on FReactiveToRangeElement");
static_assert(sizeof(FReactiveToRangeElement) == 0x000014, "Wrong size on FReactiveToRangeElement");
static_assert(offsetof(FReactiveToRangeElement, MinSustainFireDuration) == 0x000000, "Member 'FReactiveToRangeElement::MinSustainFireDuration' has a wrong offset!");
static_assert(offsetof(FReactiveToRangeElement, MaxSustainFireDuration) == 0x000004, "Member 'FReactiveToRangeElement::MaxSustainFireDuration' has a wrong offset!");
static_assert(offsetof(FReactiveToRangeElement, SustainFirePauseDuration) == 0x000008, "Member 'FReactiveToRangeElement::SustainFirePauseDuration' has a wrong offset!");
static_assert(offsetof(FReactiveToRangeElement, DodgeProbability) == 0x00000C, "Member 'FReactiveToRangeElement::DodgeProbability' has a wrong offset!");
static_assert(offsetof(FReactiveToRangeElement, BlockProbability) == 0x000010, "Member 'FReactiveToRangeElement::BlockProbability' has a wrong offset!");

// ScriptStruct Indiana.CrosshairVisuals
// 0x0030 (0x0030 - 0x0000)
struct FCrosshairVisuals final
{
public:
	class UTexture2D*                             Left;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Top;                                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Center;                                            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Minimal;                                           // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             StaticImage;                                       // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StaticImagePositionOffset;                         // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrosshairVisuals) == 0x000008, "Wrong alignment on FCrosshairVisuals");
static_assert(sizeof(FCrosshairVisuals) == 0x000030, "Wrong size on FCrosshairVisuals");
static_assert(offsetof(FCrosshairVisuals, Left) == 0x000000, "Member 'FCrosshairVisuals::Left' has a wrong offset!");
static_assert(offsetof(FCrosshairVisuals, Top) == 0x000008, "Member 'FCrosshairVisuals::Top' has a wrong offset!");
static_assert(offsetof(FCrosshairVisuals, Center) == 0x000010, "Member 'FCrosshairVisuals::Center' has a wrong offset!");
static_assert(offsetof(FCrosshairVisuals, Minimal) == 0x000018, "Member 'FCrosshairVisuals::Minimal' has a wrong offset!");
static_assert(offsetof(FCrosshairVisuals, StaticImage) == 0x000020, "Member 'FCrosshairVisuals::StaticImage' has a wrong offset!");
static_assert(offsetof(FCrosshairVisuals, StaticImagePositionOffset) == 0x000028, "Member 'FCrosshairVisuals::StaticImagePositionOffset' has a wrong offset!");

// ScriptStruct Indiana.AISoundDetectionSettings
// 0x0028 (0x0028 - 0x0000)
struct FAISoundDetectionSettings final
{
public:
	EAlertState                                   DetectedAlertState;                                // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DetectedAwarenessChange;                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bContinuousAwareness;                              // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URpgStat*                               AwarenessChangeStat;                               // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMatchFriendAwareness;                             // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathDistanceCheckScalar;                           // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EStimulusType                                 StimulusType;                                      // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAISoundDetectionSettings) == 0x000008, "Wrong alignment on FAISoundDetectionSettings");
static_assert(sizeof(FAISoundDetectionSettings) == 0x000028, "Wrong size on FAISoundDetectionSettings");
static_assert(offsetof(FAISoundDetectionSettings, DetectedAlertState) == 0x000000, "Member 'FAISoundDetectionSettings::DetectedAlertState' has a wrong offset!");
static_assert(offsetof(FAISoundDetectionSettings, DetectedAwarenessChange) == 0x000004, "Member 'FAISoundDetectionSettings::DetectedAwarenessChange' has a wrong offset!");
static_assert(offsetof(FAISoundDetectionSettings, bContinuousAwareness) == 0x000008, "Member 'FAISoundDetectionSettings::bContinuousAwareness' has a wrong offset!");
static_assert(offsetof(FAISoundDetectionSettings, AwarenessChangeStat) == 0x000010, "Member 'FAISoundDetectionSettings::AwarenessChangeStat' has a wrong offset!");
static_assert(offsetof(FAISoundDetectionSettings, bMatchFriendAwareness) == 0x000018, "Member 'FAISoundDetectionSettings::bMatchFriendAwareness' has a wrong offset!");
static_assert(offsetof(FAISoundDetectionSettings, PathDistanceCheckScalar) == 0x00001C, "Member 'FAISoundDetectionSettings::PathDistanceCheckScalar' has a wrong offset!");
static_assert(offsetof(FAISoundDetectionSettings, StimulusType) == 0x000020, "Member 'FAISoundDetectionSettings::StimulusType' has a wrong offset!");

// ScriptStruct Indiana.ItemStackSplit
// 0x0018 (0x0018 - 0x0000)
struct FItemStackSplit final
{
public:
	struct FItemStack                             ItemStack;                                         // 0x0000(0x0010)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         SplitCount;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemStackSplit) == 0x000008, "Wrong alignment on FItemStackSplit");
static_assert(sizeof(FItemStackSplit) == 0x000018, "Wrong size on FItemStackSplit");
static_assert(offsetof(FItemStackSplit, ItemStack) == 0x000000, "Member 'FItemStackSplit::ItemStack' has a wrong offset!");
static_assert(offsetof(FItemStackSplit, SplitCount) == 0x000010, "Member 'FItemStackSplit::SplitCount' has a wrong offset!");

// ScriptStruct Indiana.ConversationReference
// 0x0010 (0x0010 - 0x0000)
struct FConversationReference final
{
public:
	struct FGuid                                  ID;                                                // 0x0000(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConversationReference) == 0x000004, "Wrong alignment on FConversationReference");
static_assert(sizeof(FConversationReference) == 0x000010, "Wrong size on FConversationReference");
static_assert(offsetof(FConversationReference, ID) == 0x000000, "Member 'FConversationReference::ID' has a wrong offset!");

// ScriptStruct Indiana.ButtonEvent
// 0x0000 (0x0030 - 0x0030)
struct FButtonEvent final : public FComponentEvent
{
};
static_assert(alignof(FButtonEvent) == 0x000008, "Wrong alignment on FButtonEvent");
static_assert(sizeof(FButtonEvent) == 0x000030, "Wrong size on FButtonEvent");

// ScriptStruct Indiana.AISelector_EQSParameter
// 0x0008 (0x0008 - 0x0000)
struct FAISelector_EQSParameter final
{
public:
	TSubclassOf<class UAIEQSParameter>            EQSParameter;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISelector_EQSParameter) == 0x000008, "Wrong alignment on FAISelector_EQSParameter");
static_assert(sizeof(FAISelector_EQSParameter) == 0x000008, "Wrong size on FAISelector_EQSParameter");
static_assert(offsetof(FAISelector_EQSParameter, EQSParameter) == 0x000000, "Member 'FAISelector_EQSParameter::EQSParameter' has a wrong offset!");

// ScriptStruct Indiana.SlateBrushContainer
// 0x0090 (0x0090 - 0x0000)
struct FSlateBrushContainer final
{
public:
	class USlateBrushAsset*                       BrushAsset;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            Brush;                                             // 0x0008(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSlateBrushContainer) == 0x000008, "Wrong alignment on FSlateBrushContainer");
static_assert(sizeof(FSlateBrushContainer) == 0x000090, "Wrong size on FSlateBrushContainer");
static_assert(offsetof(FSlateBrushContainer, BrushAsset) == 0x000000, "Member 'FSlateBrushContainer::BrushAsset' has a wrong offset!");
static_assert(offsetof(FSlateBrushContainer, Brush) == 0x000008, "Member 'FSlateBrushContainer::Brush' has a wrong offset!");

// ScriptStruct Indiana.SizeConstraint
// 0x0014 (0x0014 - 0x0000)
struct FSizeConstraint final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseBrushAsMinSize;                                // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSnap;                                          // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Minimum;                                           // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Snap;                                              // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSizeConstraint) == 0x000004, "Wrong alignment on FSizeConstraint");
static_assert(sizeof(FSizeConstraint) == 0x000014, "Wrong size on FSizeConstraint");
static_assert(offsetof(FSizeConstraint, bEnabled) == 0x000000, "Member 'FSizeConstraint::bEnabled' has a wrong offset!");
static_assert(offsetof(FSizeConstraint, bUseBrushAsMinSize) == 0x000001, "Member 'FSizeConstraint::bUseBrushAsMinSize' has a wrong offset!");
static_assert(offsetof(FSizeConstraint, bUseSnap) == 0x000002, "Member 'FSizeConstraint::bUseSnap' has a wrong offset!");
static_assert(offsetof(FSizeConstraint, Minimum) == 0x000004, "Member 'FSizeConstraint::Minimum' has a wrong offset!");
static_assert(offsetof(FSizeConstraint, Snap) == 0x00000C, "Member 'FSizeConstraint::Snap' has a wrong offset!");

// ScriptStruct Indiana.IndianaTextBlockStyle
// 0x0010 (0x0288 - 0x0278)
struct FIndianaTextBlockStyle final : public FTextBlockStyle
{
public:
	class USlateWidgetStyleAsset*                 ImportAsset;                                       // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EIndianaUIColorType                           ColorOverride;                                     // 0x0280(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_281[0x7];                                      // 0x0281(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIndianaTextBlockStyle) == 0x000008, "Wrong alignment on FIndianaTextBlockStyle");
static_assert(sizeof(FIndianaTextBlockStyle) == 0x000288, "Wrong size on FIndianaTextBlockStyle");
static_assert(offsetof(FIndianaTextBlockStyle, ImportAsset) == 0x000278, "Member 'FIndianaTextBlockStyle::ImportAsset' has a wrong offset!");
static_assert(offsetof(FIndianaTextBlockStyle, ColorOverride) == 0x000280, "Member 'FIndianaTextBlockStyle::ColorOverride' has a wrong offset!");

// ScriptStruct Indiana.IndianaButtonStyle
// 0x0820 (0x0828 - 0x0008)
struct FIndianaButtonStyle final : public FSlateWidgetStyle
{
public:
	struct FSlateBrushContainer                   NormalBrush;                                       // 0x0008(0x0090)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrushContainer                   HoveredBrush;                                      // 0x0098(0x0090)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrushContainer                   PressedBrush;                                      // 0x0128(0x0090)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrushContainer                   FocusedBrush;                                      // 0x01B8(0x0090)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrushContainer                   SelectedNormalBrush;                               // 0x0248(0x0090)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrushContainer                   SelectedHoveredBrush;                              // 0x02D8(0x0090)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrushContainer                   SelectedPressedBrush;                              // 0x0368(0x0090)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrushContainer                   SelectedFocusedBrush;                              // 0x03F8(0x0090)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrushContainer                   DisabledBrush;                                     // 0x0488(0x0090)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FLinearColor                           ContentColor;                                      // 0x0518(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ButtonColor;                                       // 0x0528(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                NormalPadding;                                     // 0x0538(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FMargin                                PressedPadding;                                    // 0x0548(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FSizeConstraint                        SizeConstraints;                                   // 0x0558(0x0014)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_56C[0x4];                                      // 0x056C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIndianaTextBlockStyle                 TextBlockStyle;                                    // 0x0570(0x0288)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          PressedSoundOverride;                              // 0x07F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          HoveredSoundOverride;                              // 0x0800(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          FocusedSoundOverride;                              // 0x0808(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          SelectedPressedSoundOverride;                      // 0x0810(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          SelectedHoveredSoundOverride;                      // 0x0818(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          SelectedFocusedSoundOverride;                      // 0x0820(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIndianaButtonStyle) == 0x000008, "Wrong alignment on FIndianaButtonStyle");
static_assert(sizeof(FIndianaButtonStyle) == 0x000828, "Wrong size on FIndianaButtonStyle");
static_assert(offsetof(FIndianaButtonStyle, NormalBrush) == 0x000008, "Member 'FIndianaButtonStyle::NormalBrush' has a wrong offset!");
static_assert(offsetof(FIndianaButtonStyle, HoveredBrush) == 0x000098, "Member 'FIndianaButtonStyle::HoveredBrush' has a wrong offset!");
static_assert(offsetof(FIndianaButtonStyle, PressedBrush) == 0x000128, "Member 'FIndianaButtonStyle::PressedBrush' has a wrong offset!");
static_assert(offsetof(FIndianaButtonStyle, FocusedBrush) == 0x0001B8, "Member 'FIndianaButtonStyle::FocusedBrush' has a wrong offset!");
static_assert(offsetof(FIndianaButtonStyle, SelectedNormalBrush) == 0x000248, "Member 'FIndianaButtonStyle::SelectedNormalBrush' has a wrong offset!");
static_assert(offsetof(FIndianaButtonStyle, SelectedHoveredBrush) == 0x0002D8, "Member 'FIndianaButtonStyle::SelectedHoveredBrush' has a wrong offset!");
static_assert(offsetof(FIndianaButtonStyle, SelectedPressedBrush) == 0x000368, "Member 'FIndianaButtonStyle::SelectedPressedBrush' has a wrong offset!");
static_assert(offsetof(FIndianaButtonStyle, SelectedFocusedBrush) == 0x0003F8, "Member 'FIndianaButtonStyle::SelectedFocusedBrush' has a wrong offset!");
static_assert(offsetof(FIndianaButtonStyle, DisabledBrush) == 0x000488, "Member 'FIndianaButtonStyle::DisabledBrush' has a wrong offset!");
static_assert(offsetof(FIndianaButtonStyle, ContentColor) == 0x000518, "Member 'FIndianaButtonStyle::ContentColor' has a wrong offset!");
static_assert(offsetof(FIndianaButtonStyle, ButtonColor) == 0x000528, "Member 'FIndianaButtonStyle::ButtonColor' has a wrong offset!");
static_assert(offsetof(FIndianaButtonStyle, NormalPadding) == 0x000538, "Member 'FIndianaButtonStyle::NormalPadding' has a wrong offset!");
static_assert(offsetof(FIndianaButtonStyle, PressedPadding) == 0x000548, "Member 'FIndianaButtonStyle::PressedPadding' has a wrong offset!");
static_assert(offsetof(FIndianaButtonStyle, SizeConstraints) == 0x000558, "Member 'FIndianaButtonStyle::SizeConstraints' has a wrong offset!");
static_assert(offsetof(FIndianaButtonStyle, TextBlockStyle) == 0x000570, "Member 'FIndianaButtonStyle::TextBlockStyle' has a wrong offset!");
static_assert(offsetof(FIndianaButtonStyle, PressedSoundOverride) == 0x0007F8, "Member 'FIndianaButtonStyle::PressedSoundOverride' has a wrong offset!");
static_assert(offsetof(FIndianaButtonStyle, HoveredSoundOverride) == 0x000800, "Member 'FIndianaButtonStyle::HoveredSoundOverride' has a wrong offset!");
static_assert(offsetof(FIndianaButtonStyle, FocusedSoundOverride) == 0x000808, "Member 'FIndianaButtonStyle::FocusedSoundOverride' has a wrong offset!");
static_assert(offsetof(FIndianaButtonStyle, SelectedPressedSoundOverride) == 0x000810, "Member 'FIndianaButtonStyle::SelectedPressedSoundOverride' has a wrong offset!");
static_assert(offsetof(FIndianaButtonStyle, SelectedHoveredSoundOverride) == 0x000818, "Member 'FIndianaButtonStyle::SelectedHoveredSoundOverride' has a wrong offset!");
static_assert(offsetof(FIndianaButtonStyle, SelectedFocusedSoundOverride) == 0x000820, "Member 'FIndianaButtonStyle::SelectedFocusedSoundOverride' has a wrong offset!");

// ScriptStruct Indiana.IndianaComboButtonStyle
// 0x0958 (0x0960 - 0x0008)
struct FIndianaComboButtonStyle final : public FSlateWidgetStyle
{
public:
	struct FIndianaButtonStyle                    ButtonStyle;                                       // 0x0008(0x0828)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrushContainer                   DownArrowImage;                                    // 0x0830(0x0090)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrushContainer                   MenuBorderBrush;                                   // 0x08C0(0x0090)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FMargin                                MenuBorderPadding;                                 // 0x0950(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIndianaComboButtonStyle) == 0x000008, "Wrong alignment on FIndianaComboButtonStyle");
static_assert(sizeof(FIndianaComboButtonStyle) == 0x000960, "Wrong size on FIndianaComboButtonStyle");
static_assert(offsetof(FIndianaComboButtonStyle, ButtonStyle) == 0x000008, "Member 'FIndianaComboButtonStyle::ButtonStyle' has a wrong offset!");
static_assert(offsetof(FIndianaComboButtonStyle, DownArrowImage) == 0x000830, "Member 'FIndianaComboButtonStyle::DownArrowImage' has a wrong offset!");
static_assert(offsetof(FIndianaComboButtonStyle, MenuBorderBrush) == 0x0008C0, "Member 'FIndianaComboButtonStyle::MenuBorderBrush' has a wrong offset!");
static_assert(offsetof(FIndianaComboButtonStyle, MenuBorderPadding) == 0x000950, "Member 'FIndianaComboButtonStyle::MenuBorderPadding' has a wrong offset!");

// ScriptStruct Indiana.IndianaComboBoxStyle
// 0x0960 (0x0968 - 0x0008)
struct FIndianaComboBoxStyle final : public FSlateWidgetStyle
{
public:
	struct FIndianaComboButtonStyle               ComboButtonStyle;                                  // 0x0008(0x0960)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIndianaComboBoxStyle) == 0x000008, "Wrong alignment on FIndianaComboBoxStyle");
static_assert(sizeof(FIndianaComboBoxStyle) == 0x000968, "Wrong size on FIndianaComboBoxStyle");
static_assert(offsetof(FIndianaComboBoxStyle, ComboButtonStyle) == 0x000008, "Member 'FIndianaComboBoxStyle::ComboButtonStyle' has a wrong offset!");

// ScriptStruct Indiana.AimAssistConfig
// 0x01C0 (0x01C0 - 0x0000)
struct FAimAssistConfig final
{
public:
	float                                         TargetLockHorizontalRate;                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetLockStrength;                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetLockNoTouchDuration;                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetLockNoTouchFadeTime;                         // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrackQuickTargetInputThreshold;                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrackQuickTargetIdleTime;                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrackQuickTargetDuration;                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrackQuickTargetMinVelocity;                       // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrackQuickTargetHorizontalRate;                    // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrackQuickTargetVerticalRate;                      // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     FrictionInputCurve;                                // 0x0028(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     FrictionStrengthTowardsTargetCurve;                // 0x00B0(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     FrictionStrengthAwayFromTargetCurve;               // 0x0138(0x0088)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAimAssistConfig) == 0x000008, "Wrong alignment on FAimAssistConfig");
static_assert(sizeof(FAimAssistConfig) == 0x0001C0, "Wrong size on FAimAssistConfig");
static_assert(offsetof(FAimAssistConfig, TargetLockHorizontalRate) == 0x000000, "Member 'FAimAssistConfig::TargetLockHorizontalRate' has a wrong offset!");
static_assert(offsetof(FAimAssistConfig, TargetLockStrength) == 0x000004, "Member 'FAimAssistConfig::TargetLockStrength' has a wrong offset!");
static_assert(offsetof(FAimAssistConfig, TargetLockNoTouchDuration) == 0x000008, "Member 'FAimAssistConfig::TargetLockNoTouchDuration' has a wrong offset!");
static_assert(offsetof(FAimAssistConfig, TargetLockNoTouchFadeTime) == 0x00000C, "Member 'FAimAssistConfig::TargetLockNoTouchFadeTime' has a wrong offset!");
static_assert(offsetof(FAimAssistConfig, TrackQuickTargetInputThreshold) == 0x000010, "Member 'FAimAssistConfig::TrackQuickTargetInputThreshold' has a wrong offset!");
static_assert(offsetof(FAimAssistConfig, TrackQuickTargetIdleTime) == 0x000014, "Member 'FAimAssistConfig::TrackQuickTargetIdleTime' has a wrong offset!");
static_assert(offsetof(FAimAssistConfig, TrackQuickTargetDuration) == 0x000018, "Member 'FAimAssistConfig::TrackQuickTargetDuration' has a wrong offset!");
static_assert(offsetof(FAimAssistConfig, TrackQuickTargetMinVelocity) == 0x00001C, "Member 'FAimAssistConfig::TrackQuickTargetMinVelocity' has a wrong offset!");
static_assert(offsetof(FAimAssistConfig, TrackQuickTargetHorizontalRate) == 0x000020, "Member 'FAimAssistConfig::TrackQuickTargetHorizontalRate' has a wrong offset!");
static_assert(offsetof(FAimAssistConfig, TrackQuickTargetVerticalRate) == 0x000024, "Member 'FAimAssistConfig::TrackQuickTargetVerticalRate' has a wrong offset!");
static_assert(offsetof(FAimAssistConfig, FrictionInputCurve) == 0x000028, "Member 'FAimAssistConfig::FrictionInputCurve' has a wrong offset!");
static_assert(offsetof(FAimAssistConfig, FrictionStrengthTowardsTargetCurve) == 0x0000B0, "Member 'FAimAssistConfig::FrictionStrengthTowardsTargetCurve' has a wrong offset!");
static_assert(offsetof(FAimAssistConfig, FrictionStrengthAwayFromTargetCurve) == 0x000138, "Member 'FAimAssistConfig::FrictionStrengthAwayFromTargetCurve' has a wrong offset!");

// ScriptStruct Indiana.BehaviorSettings_Set
// 0x0010 (0x0010 - 0x0000)
struct FBehaviorSettings_Set
{
public:
	class UAISettings_Behavior*                   DefaultBehavior;                                   // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoClear, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInterestDataPackage*                   InterestData;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBehaviorSettings_Set) == 0x000008, "Wrong alignment on FBehaviorSettings_Set");
static_assert(sizeof(FBehaviorSettings_Set) == 0x000010, "Wrong size on FBehaviorSettings_Set");
static_assert(offsetof(FBehaviorSettings_Set, DefaultBehavior) == 0x000000, "Member 'FBehaviorSettings_Set::DefaultBehavior' has a wrong offset!");
static_assert(offsetof(FBehaviorSettings_Set, InterestData) == 0x000008, "Member 'FBehaviorSettings_Set::InterestData' has a wrong offset!");

// ScriptStruct Indiana.ScriptedBehavior_Set
// 0x0068 (0x0078 - 0x0010)
struct FScriptedBehavior_Set final : public FBehaviorSettings_Set
{
public:
	struct FLogicalExpression                     GlobalVariableExpression;                          // 0x0010(0x0068)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScriptedBehavior_Set) == 0x000008, "Wrong alignment on FScriptedBehavior_Set");
static_assert(sizeof(FScriptedBehavior_Set) == 0x000078, "Wrong size on FScriptedBehavior_Set");
static_assert(offsetof(FScriptedBehavior_Set, GlobalVariableExpression) == 0x000010, "Member 'FScriptedBehavior_Set::GlobalVariableExpression' has a wrong offset!");

// ScriptStruct Indiana.BehaviorPackage
// 0x0098 (0x0098 - 0x0000)
struct FBehaviorPackage final
{
public:
	struct FBehaviorSettings_Set                  DefaultBehaviorData;                               // 0x0000(0x0010)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<EPhaseOfDay, struct FBehaviorSettings_Set> TimeOfDayData;                                     // 0x0010(0x0050)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FScriptedBehavior_Set>          ScriptedBehaviors;                                 // 0x0060(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         InterestRadius;                                    // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x24];                                      // 0x0074(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBehaviorPackage) == 0x000008, "Wrong alignment on FBehaviorPackage");
static_assert(sizeof(FBehaviorPackage) == 0x000098, "Wrong size on FBehaviorPackage");
static_assert(offsetof(FBehaviorPackage, DefaultBehaviorData) == 0x000000, "Member 'FBehaviorPackage::DefaultBehaviorData' has a wrong offset!");
static_assert(offsetof(FBehaviorPackage, TimeOfDayData) == 0x000010, "Member 'FBehaviorPackage::TimeOfDayData' has a wrong offset!");
static_assert(offsetof(FBehaviorPackage, ScriptedBehaviors) == 0x000060, "Member 'FBehaviorPackage::ScriptedBehaviors' has a wrong offset!");
static_assert(offsetof(FBehaviorPackage, InterestRadius) == 0x000070, "Member 'FBehaviorPackage::InterestRadius' has a wrong offset!");

// ScriptStruct Indiana.IndianaAINoiseEvent
// 0x0000 (0x0030 - 0x0030)
struct FIndianaAINoiseEvent final : public FAINoiseEvent
{
};
static_assert(alignof(FIndianaAINoiseEvent) == 0x000008, "Wrong alignment on FIndianaAINoiseEvent");
static_assert(sizeof(FIndianaAINoiseEvent) == 0x000030, "Wrong size on FIndianaAINoiseEvent");

// ScriptStruct Indiana.AIDynamicParam_IndianaBase
// 0x0018 (0x0018 - 0x0000)
struct FAIDynamicParam_IndianaBase final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIParamType                                  ParamType;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAISelector_EQSParameter               ValueSelector;                                     // 0x0010(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIDynamicParam_IndianaBase) == 0x000008, "Wrong alignment on FAIDynamicParam_IndianaBase");
static_assert(sizeof(FAIDynamicParam_IndianaBase) == 0x000018, "Wrong size on FAIDynamicParam_IndianaBase");
static_assert(offsetof(FAIDynamicParam_IndianaBase, ParamName) == 0x000000, "Member 'FAIDynamicParam_IndianaBase::ParamName' has a wrong offset!");
static_assert(offsetof(FAIDynamicParam_IndianaBase, ParamType) == 0x000008, "Member 'FAIDynamicParam_IndianaBase::ParamType' has a wrong offset!");
static_assert(offsetof(FAIDynamicParam_IndianaBase, Value) == 0x00000C, "Member 'FAIDynamicParam_IndianaBase::Value' has a wrong offset!");
static_assert(offsetof(FAIDynamicParam_IndianaBase, ValueSelector) == 0x000010, "Member 'FAIDynamicParam_IndianaBase::ValueSelector' has a wrong offset!");

// ScriptStruct Indiana.SaveGameDataDecisionTree
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FSaveGameDataDecisionTree final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSaveGameDataDecisionTree) == 0x000004, "Wrong alignment on FSaveGameDataDecisionTree");
static_assert(sizeof(FSaveGameDataDecisionTree) == 0x000008, "Wrong size on FSaveGameDataDecisionTree");

// ScriptStruct Indiana.AISelector_BoolWriteable
// 0x0008 (0x0008 - 0x0000)
struct FAISelector_BoolWriteable final
{
public:
	TSubclassOf<class UAIBoolWriteable>           AIBool;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISelector_BoolWriteable) == 0x000008, "Wrong alignment on FAISelector_BoolWriteable");
static_assert(sizeof(FAISelector_BoolWriteable) == 0x000008, "Wrong size on FAISelector_BoolWriteable");
static_assert(offsetof(FAISelector_BoolWriteable, AIBool) == 0x000000, "Member 'FAISelector_BoolWriteable::AIBool' has a wrong offset!");

// ScriptStruct Indiana.AISelector_Actor
// 0x0008 (0x0008 - 0x0000)
struct FAISelector_Actor final
{
public:
	TSubclassOf<class UAIActor>                   AIActor;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISelector_Actor) == 0x000008, "Wrong alignment on FAISelector_Actor");
static_assert(sizeof(FAISelector_Actor) == 0x000008, "Wrong size on FAISelector_Actor");
static_assert(offsetof(FAISelector_Actor, AIActor) == 0x000000, "Member 'FAISelector_Actor::AIActor' has a wrong offset!");

// ScriptStruct Indiana.TrajectoryResult
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FTrajectoryResult final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTrajectoryResult) == 0x000004, "Wrong alignment on FTrajectoryResult");
static_assert(sizeof(FTrajectoryResult) == 0x000010, "Wrong size on FTrajectoryResult");

// ScriptStruct Indiana.DecisionTreeResult
// 0x0038 (0x0038 - 0x0000)
struct FDecisionTreeResult final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIEventInfo*                           EventInfo;                                         // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDecisionTreeRequestData*>       DecisionTreeRequests;                              // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDecisionTreeResult) == 0x000008, "Wrong alignment on FDecisionTreeResult");
static_assert(sizeof(FDecisionTreeResult) == 0x000038, "Wrong size on FDecisionTreeResult");
static_assert(offsetof(FDecisionTreeResult, EventInfo) == 0x000010, "Member 'FDecisionTreeResult::EventInfo' has a wrong offset!");
static_assert(offsetof(FDecisionTreeResult, DecisionTreeRequests) == 0x000020, "Member 'FDecisionTreeResult::DecisionTreeRequests' has a wrong offset!");

// ScriptStruct Indiana.BehaviorPhases
// 0x0030 (0x0030 - 0x0000)
struct FBehaviorPhases final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UEventListener*>                 PhaseListeners;                                    // 0x0018(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBehaviorPhases) == 0x000008, "Wrong alignment on FBehaviorPhases");
static_assert(sizeof(FBehaviorPhases) == 0x000030, "Wrong size on FBehaviorPhases");
static_assert(offsetof(FBehaviorPhases, PhaseListeners) == 0x000018, "Member 'FBehaviorPhases::PhaseListeners' has a wrong offset!");

// ScriptStruct Indiana.ActorPoolConfiguration
// 0x0018 (0x0018 - 0x0000)
struct FActorPoolConfiguration final
{
public:
	EActorPoolingMethod                           PoolingMethod;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class APooledActor>               ActorClass;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxActorsToRetain;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanSpawnMoreThanMaxActors;                        // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReuseOldestActorsWhenExhausted;                   // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeferSpawnRequests;                               // 0x0016(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActorPoolConfiguration) == 0x000008, "Wrong alignment on FActorPoolConfiguration");
static_assert(sizeof(FActorPoolConfiguration) == 0x000018, "Wrong size on FActorPoolConfiguration");
static_assert(offsetof(FActorPoolConfiguration, PoolingMethod) == 0x000000, "Member 'FActorPoolConfiguration::PoolingMethod' has a wrong offset!");
static_assert(offsetof(FActorPoolConfiguration, ActorClass) == 0x000008, "Member 'FActorPoolConfiguration::ActorClass' has a wrong offset!");
static_assert(offsetof(FActorPoolConfiguration, MaxActorsToRetain) == 0x000010, "Member 'FActorPoolConfiguration::MaxActorsToRetain' has a wrong offset!");
static_assert(offsetof(FActorPoolConfiguration, bCanSpawnMoreThanMaxActors) == 0x000014, "Member 'FActorPoolConfiguration::bCanSpawnMoreThanMaxActors' has a wrong offset!");
static_assert(offsetof(FActorPoolConfiguration, bReuseOldestActorsWhenExhausted) == 0x000015, "Member 'FActorPoolConfiguration::bReuseOldestActorsWhenExhausted' has a wrong offset!");
static_assert(offsetof(FActorPoolConfiguration, bDeferSpawnRequests) == 0x000016, "Member 'FActorPoolConfiguration::bDeferSpawnRequests' has a wrong offset!");

// ScriptStruct Indiana.AIDetectionData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FAIDetectionData
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIDetectionData) == 0x000008, "Wrong alignment on FAIDetectionData");
static_assert(sizeof(FAIDetectionData) == 0x000018, "Wrong size on FAIDetectionData");

// ScriptStruct Indiana.WeightedImageData
// 0x0050 (0x0050 - 0x0000)
struct FWeightedImageData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              Image;                                             // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanShowTips;                                      // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WeightDecay;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  ID;                                                // 0x003C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeightedImageData) == 0x000008, "Wrong alignment on FWeightedImageData");
static_assert(sizeof(FWeightedImageData) == 0x000050, "Wrong size on FWeightedImageData");
static_assert(offsetof(FWeightedImageData, Image) == 0x000008, "Member 'FWeightedImageData::Image' has a wrong offset!");
static_assert(offsetof(FWeightedImageData, bCanShowTips) == 0x000030, "Member 'FWeightedImageData::bCanShowTips' has a wrong offset!");
static_assert(offsetof(FWeightedImageData, Weight) == 0x000034, "Member 'FWeightedImageData::Weight' has a wrong offset!");
static_assert(offsetof(FWeightedImageData, WeightDecay) == 0x000038, "Member 'FWeightedImageData::WeightDecay' has a wrong offset!");
static_assert(offsetof(FWeightedImageData, ID) == 0x00003C, "Member 'FWeightedImageData::ID' has a wrong offset!");

// ScriptStruct Indiana.ConditionalizedLoadingImageContainer
// 0x00C8 (0x00C8 - 0x0000)
struct FConditionalizedLoadingImageContainer final
{
public:
	class FString                                 DebugName;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FWeightedImageData                     Image;                                             // 0x0010(0x0050)(Edit, NativeAccessSpecifierPrivate)
	struct FLogicalExpression                     Conditional;                                       // 0x0060(0x0068)(Edit, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FConditionalizedLoadingImageContainer) == 0x000008, "Wrong alignment on FConditionalizedLoadingImageContainer");
static_assert(sizeof(FConditionalizedLoadingImageContainer) == 0x0000C8, "Wrong size on FConditionalizedLoadingImageContainer");
static_assert(offsetof(FConditionalizedLoadingImageContainer, DebugName) == 0x000000, "Member 'FConditionalizedLoadingImageContainer::DebugName' has a wrong offset!");
static_assert(offsetof(FConditionalizedLoadingImageContainer, Image) == 0x000010, "Member 'FConditionalizedLoadingImageContainer::Image' has a wrong offset!");
static_assert(offsetof(FConditionalizedLoadingImageContainer, Conditional) == 0x000060, "Member 'FConditionalizedLoadingImageContainer::Conditional' has a wrong offset!");

// ScriptStruct Indiana.AISoundDetectionData
// 0x0028 (0x0040 - 0x0018)
struct FAISoundDetectionData final : public FAIDetectionData
{
public:
	ESoundDetectionType                           SoundType;                                         // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  ShoutTarget;                                       // 0x001C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x1C];                                      // 0x0024(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAISoundDetectionData) == 0x000008, "Wrong alignment on FAISoundDetectionData");
static_assert(sizeof(FAISoundDetectionData) == 0x000040, "Wrong size on FAISoundDetectionData");
static_assert(offsetof(FAISoundDetectionData, SoundType) == 0x000018, "Member 'FAISoundDetectionData::SoundType' has a wrong offset!");
static_assert(offsetof(FAISoundDetectionData, ShoutTarget) == 0x00001C, "Member 'FAISoundDetectionData::ShoutTarget' has a wrong offset!");

// ScriptStruct Indiana.AreaHeightTile
// 0x0058 (0x0058 - 0x0000)
struct FAreaHeightTile final
{
public:
	struct FBox2D                                 WorldArea;                                         // 0x0000(0x0014)(Edit, ZeroConstructor, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UHeightmapData>          HeightmapData;                                     // 0x0018(0x0028)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAreaHeightTile) == 0x000008, "Wrong alignment on FAreaHeightTile");
static_assert(sizeof(FAreaHeightTile) == 0x000058, "Wrong size on FAreaHeightTile");
static_assert(offsetof(FAreaHeightTile, WorldArea) == 0x000000, "Member 'FAreaHeightTile::WorldArea' has a wrong offset!");
static_assert(offsetof(FAreaHeightTile, HeightmapData) == 0x000018, "Member 'FAreaHeightTile::HeightmapData' has a wrong offset!");

// ScriptStruct Indiana.ExtremaOverlap
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FExtremaOverlap final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AIndianaCharacter>       Overlapper;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExtremaOverlap) == 0x000008, "Wrong alignment on FExtremaOverlap");
static_assert(sizeof(FExtremaOverlap) == 0x000020, "Wrong size on FExtremaOverlap");
static_assert(offsetof(FExtremaOverlap, Overlapper) == 0x000008, "Member 'FExtremaOverlap::Overlapper' has a wrong offset!");

// ScriptStruct Indiana.AISelector_Action
// 0x0008 (0x0008 - 0x0000)
struct FAISelector_Action final
{
public:
	TSubclassOf<class UAI_AIAction>               AIAction;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISelector_Action) == 0x000008, "Wrong alignment on FAISelector_Action");
static_assert(sizeof(FAISelector_Action) == 0x000008, "Wrong size on FAISelector_Action");
static_assert(offsetof(FAISelector_Action, AIAction) == 0x000000, "Member 'FAISelector_Action::AIAction' has a wrong offset!");

// ScriptStruct Indiana.ShapeInterface
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FShapeInterface
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FShapeInterface) == 0x000008, "Wrong alignment on FShapeInterface");
static_assert(sizeof(FShapeInterface) == 0x000008, "Wrong size on FShapeInterface");

// ScriptStruct Indiana.SphereShapeData
// 0x0008 (0x0010 - 0x0008)
struct FSphereShapeData final : public FShapeInterface
{
public:
	float                                         SphereRadius;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSphereShapeData) == 0x000008, "Wrong alignment on FSphereShapeData");
static_assert(sizeof(FSphereShapeData) == 0x000010, "Wrong size on FSphereShapeData");
static_assert(offsetof(FSphereShapeData, SphereRadius) == 0x000008, "Member 'FSphereShapeData::SphereRadius' has a wrong offset!");

// ScriptStruct Indiana.AISelector_ActorWritable
// 0x0008 (0x0008 - 0x0000)
struct FAISelector_ActorWritable final
{
public:
	TSubclassOf<class UAIActorWritable>           AIActor;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISelector_ActorWritable) == 0x000008, "Wrong alignment on FAISelector_ActorWritable");
static_assert(sizeof(FAISelector_ActorWritable) == 0x000008, "Wrong size on FAISelector_ActorWritable");
static_assert(offsetof(FAISelector_ActorWritable, AIActor) == 0x000000, "Member 'FAISelector_ActorWritable::AIActor' has a wrong offset!");

// ScriptStruct Indiana.AISelector_Bool
// 0x0008 (0x0008 - 0x0000)
struct FAISelector_Bool final
{
public:
	TSubclassOf<class UAIBool>                    AIBool;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISelector_Bool) == 0x000008, "Wrong alignment on FAISelector_Bool");
static_assert(sizeof(FAISelector_Bool) == 0x000008, "Wrong size on FAISelector_Bool");
static_assert(offsetof(FAISelector_Bool, AIBool) == 0x000000, "Member 'FAISelector_Bool::AIBool' has a wrong offset!");

// ScriptStruct Indiana.AISelector_FiringPattern
// 0x0008 (0x0008 - 0x0000)
struct FAISelector_FiringPattern final
{
public:
	TSubclassOf<class UAIFiringPattern>           AIFiringPattern;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISelector_FiringPattern) == 0x000008, "Wrong alignment on FAISelector_FiringPattern");
static_assert(sizeof(FAISelector_FiringPattern) == 0x000008, "Wrong size on FAISelector_FiringPattern");
static_assert(offsetof(FAISelector_FiringPattern, AIFiringPattern) == 0x000000, "Member 'FAISelector_FiringPattern::AIFiringPattern' has a wrong offset!");

// ScriptStruct Indiana.AISelector_Int
// 0x0008 (0x0008 - 0x0000)
struct FAISelector_Int final
{
public:
	TSubclassOf<class UAIInt>                     AIInt;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISelector_Int) == 0x000008, "Wrong alignment on FAISelector_Int");
static_assert(sizeof(FAISelector_Int) == 0x000008, "Wrong size on FAISelector_Int");
static_assert(offsetof(FAISelector_Int, AIInt) == 0x000000, "Member 'FAISelector_Int::AIInt' has a wrong offset!");

// ScriptStruct Indiana.ObjectRefCounter
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FObjectRefCounter final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FObjectRefCounter) == 0x000008, "Wrong alignment on FObjectRefCounter");
static_assert(sizeof(FObjectRefCounter) == 0x000030, "Wrong size on FObjectRefCounter");

// ScriptStruct Indiana.AISelector_LocationWritable
// 0x0008 (0x0008 - 0x0000)
struct FAISelector_LocationWritable final
{
public:
	TSubclassOf<class UAILocationWritable>        AILocation;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISelector_LocationWritable) == 0x000008, "Wrong alignment on FAISelector_LocationWritable");
static_assert(sizeof(FAISelector_LocationWritable) == 0x000008, "Wrong size on FAISelector_LocationWritable");
static_assert(offsetof(FAISelector_LocationWritable, AILocation) == 0x000000, "Member 'FAISelector_LocationWritable::AILocation' has a wrong offset!");

// ScriptStruct Indiana.AISelector_Location
// 0x0008 (0x0008 - 0x0000)
struct FAISelector_Location final
{
public:
	TSubclassOf<class UAILocation>                AILocation;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISelector_Location) == 0x000008, "Wrong alignment on FAISelector_Location");
static_assert(sizeof(FAISelector_Location) == 0x000008, "Wrong size on FAISelector_Location");
static_assert(offsetof(FAISelector_Location, AILocation) == 0x000000, "Member 'FAISelector_Location::AILocation' has a wrong offset!");

// ScriptStruct Indiana.AISelector_UObject
// 0x0008 (0x0008 - 0x0000)
struct FAISelector_UObject final
{
public:
	TSubclassOf<class UAI_UObject>                Object;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISelector_UObject) == 0x000008, "Wrong alignment on FAISelector_UObject");
static_assert(sizeof(FAISelector_UObject) == 0x000008, "Wrong size on FAISelector_UObject");
static_assert(offsetof(FAISelector_UObject, Object) == 0x000000, "Member 'FAISelector_UObject::Object' has a wrong offset!");

// ScriptStruct Indiana.GameDataStructure
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FGameDataStructure
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameDataStructure) == 0x000008, "Wrong alignment on FGameDataStructure");
static_assert(sizeof(FGameDataStructure) == 0x000008, "Wrong size on FGameDataStructure");

// ScriptStruct Indiana.RandomBank
// 0x0018 (0x0020 - 0x0008)
struct FRandomBank final : public FGameDataStructure
{
public:
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRandomBank) == 0x000008, "Wrong alignment on FRandomBank");
static_assert(sizeof(FRandomBank) == 0x000020, "Wrong size on FRandomBank");

// ScriptStruct Indiana.AutoConsoleCommandProperties
// 0x0028 (0x0028 - 0x0000)
struct FAutoConsoleCommandProperties final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerRegularly;                                 // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExecuteWaitTime;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerAfterTravel;                               // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Command;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAutoConsoleCommandProperties) == 0x000008, "Wrong alignment on FAutoConsoleCommandProperties");
static_assert(sizeof(FAutoConsoleCommandProperties) == 0x000028, "Wrong size on FAutoConsoleCommandProperties");
static_assert(offsetof(FAutoConsoleCommandProperties, bEnable) == 0x000000, "Member 'FAutoConsoleCommandProperties::bEnable' has a wrong offset!");
static_assert(offsetof(FAutoConsoleCommandProperties, bTriggerRegularly) == 0x000001, "Member 'FAutoConsoleCommandProperties::bTriggerRegularly' has a wrong offset!");
static_assert(offsetof(FAutoConsoleCommandProperties, ExecuteWaitTime) == 0x000004, "Member 'FAutoConsoleCommandProperties::ExecuteWaitTime' has a wrong offset!");
static_assert(offsetof(FAutoConsoleCommandProperties, bTriggerAfterTravel) == 0x000008, "Member 'FAutoConsoleCommandProperties::bTriggerAfterTravel' has a wrong offset!");
static_assert(offsetof(FAutoConsoleCommandProperties, Command) == 0x000010, "Member 'FAutoConsoleCommandProperties::Command' has a wrong offset!");

// ScriptStruct Indiana.PerkTier
// 0x0018 (0x0018 - 0x0000)
struct FPerkTier final
{
public:
	int32                                         PreviousPointsRequired;                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UPerk>>              Perks;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerkTier) == 0x000008, "Wrong alignment on FPerkTier");
static_assert(sizeof(FPerkTier) == 0x000018, "Wrong size on FPerkTier");
static_assert(offsetof(FPerkTier, PreviousPointsRequired) == 0x000000, "Member 'FPerkTier::PreviousPointsRequired' has a wrong offset!");
static_assert(offsetof(FPerkTier, Perks) == 0x000008, "Member 'FPerkTier::Perks' has a wrong offset!");

// ScriptStruct Indiana.PerkTiers
// 0x0010 (0x0010 - 0x0000)
struct FPerkTiers final
{
public:
	TArray<struct FPerkTier>                      PerkTiers;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerkTiers) == 0x000008, "Wrong alignment on FPerkTiers");
static_assert(sizeof(FPerkTiers) == 0x000010, "Wrong size on FPerkTiers");
static_assert(offsetof(FPerkTiers, PerkTiers) == 0x000000, "Member 'FPerkTiers::PerkTiers' has a wrong offset!");

// ScriptStruct Indiana.ReputationActionModifiers
// 0x000C (0x000C - 0x0000)
struct FReputationActionModifiers final
{
public:
	float                                         BribeModifier;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TalkModifier;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FightModifier;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FReputationActionModifiers) == 0x000004, "Wrong alignment on FReputationActionModifiers");
static_assert(sizeof(FReputationActionModifiers) == 0x00000C, "Wrong size on FReputationActionModifiers");
static_assert(offsetof(FReputationActionModifiers, BribeModifier) == 0x000000, "Member 'FReputationActionModifiers::BribeModifier' has a wrong offset!");
static_assert(offsetof(FReputationActionModifiers, TalkModifier) == 0x000004, "Member 'FReputationActionModifiers::TalkModifier' has a wrong offset!");
static_assert(offsetof(FReputationActionModifiers, FightModifier) == 0x000008, "Member 'FReputationActionModifiers::FightModifier' has a wrong offset!");

// ScriptStruct Indiana.DependencyLoadRequest
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FDependencyLoadRequest final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDependencyLoadRequest) == 0x000008, "Wrong alignment on FDependencyLoadRequest");
static_assert(sizeof(FDependencyLoadRequest) == 0x000010, "Wrong size on FDependencyLoadRequest");

// ScriptStruct Indiana.TravelShipMapPosition
// 0x0080 (0x0080 - 0x0000)
struct FTravelShipMapPosition final
{
public:
	class UShipDestinationData*                   ShipDestination;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseConditional;                                   // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLogicalExpression                     Conditional;                                       // 0x0010(0x0068)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              WorldCoordinate;                                   // 0x0078(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FTravelShipMapPosition) == 0x000008, "Wrong alignment on FTravelShipMapPosition");
static_assert(sizeof(FTravelShipMapPosition) == 0x000080, "Wrong size on FTravelShipMapPosition");
static_assert(offsetof(FTravelShipMapPosition, ShipDestination) == 0x000000, "Member 'FTravelShipMapPosition::ShipDestination' has a wrong offset!");
static_assert(offsetof(FTravelShipMapPosition, bUseConditional) == 0x000008, "Member 'FTravelShipMapPosition::bUseConditional' has a wrong offset!");
static_assert(offsetof(FTravelShipMapPosition, Conditional) == 0x000010, "Member 'FTravelShipMapPosition::Conditional' has a wrong offset!");
static_assert(offsetof(FTravelShipMapPosition, WorldCoordinate) == 0x000078, "Member 'FTravelShipMapPosition::WorldCoordinate' has a wrong offset!");

// ScriptStruct Indiana.TravelShipData
// 0x0020 (0x0020 - 0x0000)
struct FTravelShipData final
{
public:
	struct FLocString                             Name;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTravelDestinationData*                 PlayerShipDestinationData;                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTravelShipMapPosition>         ShipLocations;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTravelShipData) == 0x000008, "Wrong alignment on FTravelShipData");
static_assert(sizeof(FTravelShipData) == 0x000020, "Wrong size on FTravelShipData");
static_assert(offsetof(FTravelShipData, Name) == 0x000000, "Member 'FTravelShipData::Name' has a wrong offset!");
static_assert(offsetof(FTravelShipData, PlayerShipDestinationData) == 0x000008, "Member 'FTravelShipData::PlayerShipDestinationData' has a wrong offset!");
static_assert(offsetof(FTravelShipData, ShipLocations) == 0x000010, "Member 'FTravelShipData::ShipLocations' has a wrong offset!");

// ScriptStruct Indiana.AISettings_Block
// 0x0014 (0x0014 - 0x0000)
struct FAISettings_Block final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Cooldown;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBlockTime;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlockAttemptTimeWindow;                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISettings_Block) == 0x000004, "Wrong alignment on FAISettings_Block");
static_assert(sizeof(FAISettings_Block) == 0x000014, "Wrong size on FAISettings_Block");
static_assert(offsetof(FAISettings_Block, bEnabled) == 0x000000, "Member 'FAISettings_Block::bEnabled' has a wrong offset!");
static_assert(offsetof(FAISettings_Block, Cooldown) == 0x000004, "Member 'FAISettings_Block::Cooldown' has a wrong offset!");
static_assert(offsetof(FAISettings_Block, Duration) == 0x000008, "Member 'FAISettings_Block::Duration' has a wrong offset!");
static_assert(offsetof(FAISettings_Block, MaxBlockTime) == 0x00000C, "Member 'FAISettings_Block::MaxBlockTime' has a wrong offset!");
static_assert(offsetof(FAISettings_Block, BlockAttemptTimeWindow) == 0x000010, "Member 'FAISettings_Block::BlockAttemptTimeWindow' has a wrong offset!");

// ScriptStruct Indiana.StatModifierDescriptionBase
// 0x0010 (0x0010 - 0x0000)
struct FStatModifierDescriptionBase
{
public:
	class URpgStat*                               RpgStat;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERpgStatGroup                                 Group;                                             // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatModifierType                             ModifierType;                                      // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatModifierDescriptionBase) == 0x000008, "Wrong alignment on FStatModifierDescriptionBase");
static_assert(sizeof(FStatModifierDescriptionBase) == 0x000010, "Wrong size on FStatModifierDescriptionBase");
static_assert(offsetof(FStatModifierDescriptionBase, RpgStat) == 0x000000, "Member 'FStatModifierDescriptionBase::RpgStat' has a wrong offset!");
static_assert(offsetof(FStatModifierDescriptionBase, Group) == 0x000008, "Member 'FStatModifierDescriptionBase::Group' has a wrong offset!");
static_assert(offsetof(FStatModifierDescriptionBase, ModifierType) == 0x000009, "Member 'FStatModifierDescriptionBase::ModifierType' has a wrong offset!");

// ScriptStruct Indiana.RangedStatModifierDescription
// 0x00A0 (0x00B0 - 0x0010)
struct FRangedStatModifierDescription final : public FStatModifierDescriptionBase
{
public:
	bool                                          bUseCurve;                                         // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNormalizeCurveValue;                              // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     RangedCurve;                                       // 0x0018(0x0088)(Edit, NativeAccessSpecifierPublic)
	float                                         MinRpgStatValue;                                   // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRpgStatValue;                                   // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresDLC;                                      // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresMinSkill;                                 // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x2];                                       // 0x00AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinSkill;                                          // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRangedStatModifierDescription) == 0x000008, "Wrong alignment on FRangedStatModifierDescription");
static_assert(sizeof(FRangedStatModifierDescription) == 0x0000B0, "Wrong size on FRangedStatModifierDescription");
static_assert(offsetof(FRangedStatModifierDescription, bUseCurve) == 0x000010, "Member 'FRangedStatModifierDescription::bUseCurve' has a wrong offset!");
static_assert(offsetof(FRangedStatModifierDescription, bNormalizeCurveValue) == 0x000011, "Member 'FRangedStatModifierDescription::bNormalizeCurveValue' has a wrong offset!");
static_assert(offsetof(FRangedStatModifierDescription, RangedCurve) == 0x000018, "Member 'FRangedStatModifierDescription::RangedCurve' has a wrong offset!");
static_assert(offsetof(FRangedStatModifierDescription, MinRpgStatValue) == 0x0000A0, "Member 'FRangedStatModifierDescription::MinRpgStatValue' has a wrong offset!");
static_assert(offsetof(FRangedStatModifierDescription, MaxRpgStatValue) == 0x0000A4, "Member 'FRangedStatModifierDescription::MaxRpgStatValue' has a wrong offset!");
static_assert(offsetof(FRangedStatModifierDescription, bRequiresDLC) == 0x0000A8, "Member 'FRangedStatModifierDescription::bRequiresDLC' has a wrong offset!");
static_assert(offsetof(FRangedStatModifierDescription, bRequiresMinSkill) == 0x0000A9, "Member 'FRangedStatModifierDescription::bRequiresMinSkill' has a wrong offset!");
static_assert(offsetof(FRangedStatModifierDescription, MinSkill) == 0x0000AC, "Member 'FRangedStatModifierDescription::MinSkill' has a wrong offset!");

// ScriptStruct Indiana.AISettings_FiringPattern
// 0x0018 (0x0018 - 0x0000)
struct FAISettings_FiringPattern final
{
public:
	float                                         StartPauseTime;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BurstRounds;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BurstTime;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BurstCount;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BurstPauseTime;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndPauseTime;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISettings_FiringPattern) == 0x000004, "Wrong alignment on FAISettings_FiringPattern");
static_assert(sizeof(FAISettings_FiringPattern) == 0x000018, "Wrong size on FAISettings_FiringPattern");
static_assert(offsetof(FAISettings_FiringPattern, StartPauseTime) == 0x000000, "Member 'FAISettings_FiringPattern::StartPauseTime' has a wrong offset!");
static_assert(offsetof(FAISettings_FiringPattern, BurstRounds) == 0x000004, "Member 'FAISettings_FiringPattern::BurstRounds' has a wrong offset!");
static_assert(offsetof(FAISettings_FiringPattern, BurstTime) == 0x000008, "Member 'FAISettings_FiringPattern::BurstTime' has a wrong offset!");
static_assert(offsetof(FAISettings_FiringPattern, BurstCount) == 0x00000C, "Member 'FAISettings_FiringPattern::BurstCount' has a wrong offset!");
static_assert(offsetof(FAISettings_FiringPattern, BurstPauseTime) == 0x000010, "Member 'FAISettings_FiringPattern::BurstPauseTime' has a wrong offset!");
static_assert(offsetof(FAISettings_FiringPattern, EndPauseTime) == 0x000014, "Member 'FAISettings_FiringPattern::EndPauseTime' has a wrong offset!");

// ScriptStruct Indiana.AISettings_CoverFire
// 0x002C (0x002C - 0x0000)
struct FAISettings_CoverFire final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUsableCoverTypes                             CoverTypes;                                        // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxCoverUses;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAISettings_FiringPattern              FiringPattern;                                     // 0x0008(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         CoverUseCount;                                     // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoverTime;                                         // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CoverTimeFuzz;                                     // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FAISettings_CoverFire) == 0x000004, "Wrong alignment on FAISettings_CoverFire");
static_assert(sizeof(FAISettings_CoverFire) == 0x00002C, "Wrong size on FAISettings_CoverFire");
static_assert(offsetof(FAISettings_CoverFire, bEnabled) == 0x000000, "Member 'FAISettings_CoverFire::bEnabled' has a wrong offset!");
static_assert(offsetof(FAISettings_CoverFire, CoverTypes) == 0x000001, "Member 'FAISettings_CoverFire::CoverTypes' has a wrong offset!");
static_assert(offsetof(FAISettings_CoverFire, MaxCoverUses) == 0x000004, "Member 'FAISettings_CoverFire::MaxCoverUses' has a wrong offset!");
static_assert(offsetof(FAISettings_CoverFire, FiringPattern) == 0x000008, "Member 'FAISettings_CoverFire::FiringPattern' has a wrong offset!");
static_assert(offsetof(FAISettings_CoverFire, CoverUseCount) == 0x000020, "Member 'FAISettings_CoverFire::CoverUseCount' has a wrong offset!");
static_assert(offsetof(FAISettings_CoverFire, CoverTime) == 0x000024, "Member 'FAISettings_CoverFire::CoverTime' has a wrong offset!");
static_assert(offsetof(FAISettings_CoverFire, CoverTimeFuzz) == 0x000028, "Member 'FAISettings_CoverFire::CoverTimeFuzz' has a wrong offset!");

// ScriptStruct Indiana.MeleeInput
// 0x0002 (0x0002 - 0x0000)
struct FMeleeInput final
{
public:
	EMeleeAction                                  PreviousAction;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EButtonPress                                  ButtonPress;                                       // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeleeInput) == 0x000001, "Wrong alignment on FMeleeInput");
static_assert(sizeof(FMeleeInput) == 0x000002, "Wrong size on FMeleeInput");
static_assert(offsetof(FMeleeInput, PreviousAction) == 0x000000, "Member 'FMeleeInput::PreviousAction' has a wrong offset!");
static_assert(offsetof(FMeleeInput, ButtonPress) == 0x000001, "Member 'FMeleeInput::ButtonPress' has a wrong offset!");

// ScriptStruct Indiana.DefensiveActionElement
// 0x0004 (0x0004 - 0x0000)
struct FDefensiveActionElement
{
public:
	float                                         Probability;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDefensiveActionElement) == 0x000004, "Wrong alignment on FDefensiveActionElement");
static_assert(sizeof(FDefensiveActionElement) == 0x000004, "Wrong size on FDefensiveActionElement");
static_assert(offsetof(FDefensiveActionElement, Probability) == 0x000000, "Member 'FDefensiveActionElement::Probability' has a wrong offset!");

// ScriptStruct Indiana.PerkCostModifier
// 0x0010 (0x0010 - 0x0000)
struct FPerkCostModifier final
{
public:
	TSubclassOf<class UPerk>                      Perk;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CostModifier;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPerkCostModifier) == 0x000008, "Wrong alignment on FPerkCostModifier");
static_assert(sizeof(FPerkCostModifier) == 0x000010, "Wrong size on FPerkCostModifier");
static_assert(offsetof(FPerkCostModifier, Perk) == 0x000000, "Member 'FPerkCostModifier::Perk' has a wrong offset!");
static_assert(offsetof(FPerkCostModifier, CostModifier) == 0x000008, "Member 'FPerkCostModifier::CostModifier' has a wrong offset!");

// ScriptStruct Indiana.ReactiveToMeleeElement
// 0x005C (0x0060 - 0x0004)
struct FReactiveToMeleeElement final : public FDefensiveActionElement
{
public:
	float                                         PerMeleeHitModifier;                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxProbability;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EMeleeAction, float>                     MeleeActionProbabilityOverrides;                   // 0x0010(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReactiveToMeleeElement) == 0x000008, "Wrong alignment on FReactiveToMeleeElement");
static_assert(sizeof(FReactiveToMeleeElement) == 0x000060, "Wrong size on FReactiveToMeleeElement");
static_assert(offsetof(FReactiveToMeleeElement, PerMeleeHitModifier) == 0x000004, "Member 'FReactiveToMeleeElement::PerMeleeHitModifier' has a wrong offset!");
static_assert(offsetof(FReactiveToMeleeElement, MaxProbability) == 0x000008, "Member 'FReactiveToMeleeElement::MaxProbability' has a wrong offset!");
static_assert(offsetof(FReactiveToMeleeElement, MeleeActionProbabilityOverrides) == 0x000010, "Member 'FReactiveToMeleeElement::MeleeActionProbabilityOverrides' has a wrong offset!");

// ScriptStruct Indiana.AISettings_Dodge
// 0x0008 (0x0008 - 0x0000)
struct FAISettings_Dodge final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Cooldown;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISettings_Dodge) == 0x000004, "Wrong alignment on FAISettings_Dodge");
static_assert(sizeof(FAISettings_Dodge) == 0x000008, "Wrong size on FAISettings_Dodge");
static_assert(offsetof(FAISettings_Dodge, bEnabled) == 0x000000, "Member 'FAISettings_Dodge::bEnabled' has a wrong offset!");
static_assert(offsetof(FAISettings_Dodge, Cooldown) == 0x000004, "Member 'FAISettings_Dodge::Cooldown' has a wrong offset!");

// ScriptStruct Indiana.DynamicEffectProperties
// 0x0024 (0x0024 - 0x0000)
struct FDynamicEffectProperties final
{
public:
	bool                                          bIgnoreApplyChance;                                // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                EffectDirection;                                   // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EffectBone;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0xC];                                       // 0x0018(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDynamicEffectProperties) == 0x000004, "Wrong alignment on FDynamicEffectProperties");
static_assert(sizeof(FDynamicEffectProperties) == 0x000024, "Wrong size on FDynamicEffectProperties");
static_assert(offsetof(FDynamicEffectProperties, bIgnoreApplyChance) == 0x000000, "Member 'FDynamicEffectProperties::bIgnoreApplyChance' has a wrong offset!");
static_assert(offsetof(FDynamicEffectProperties, EffectDirection) == 0x000004, "Member 'FDynamicEffectProperties::EffectDirection' has a wrong offset!");
static_assert(offsetof(FDynamicEffectProperties, EffectBone) == 0x000010, "Member 'FDynamicEffectProperties::EffectBone' has a wrong offset!");

// ScriptStruct Indiana.AISettings_LostTarget
// 0x000C (0x000C - 0x0000)
struct FAISettings_LostTarget final
{
public:
	ELostTargetWaitTime                           WaitTime;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReenterCoverCount;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELostTargetSearchMode                         SearchMode;                                        // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAISettings_LostTarget) == 0x000004, "Wrong alignment on FAISettings_LostTarget");
static_assert(sizeof(FAISettings_LostTarget) == 0x00000C, "Wrong size on FAISettings_LostTarget");
static_assert(offsetof(FAISettings_LostTarget, WaitTime) == 0x000000, "Member 'FAISettings_LostTarget::WaitTime' has a wrong offset!");
static_assert(offsetof(FAISettings_LostTarget, ReenterCoverCount) == 0x000004, "Member 'FAISettings_LostTarget::ReenterCoverCount' has a wrong offset!");
static_assert(offsetof(FAISettings_LostTarget, SearchMode) == 0x000008, "Member 'FAISettings_LostTarget::SearchMode' has a wrong offset!");

// ScriptStruct Indiana.AISettings_MeleeAction
// 0x001C (0x0058 - 0x003C)
struct FAISettings_MeleeAction final : public FAISettings_MeleeActionBase
{
public:
	float                                         Cooldown;                                          // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeleeActionUseCase                           UseCase;                                           // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UseRange;                                          // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideNumMeleeSlotsRequired;                    // 0x004C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumMeleeSlotsRequired;                             // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreCollisionDuringApproach;                    // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBumpDuringApproach;                               // 0x0055(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSprintDuringApproach;                             // 0x0056(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57[0x1];                                       // 0x0057(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAISettings_MeleeAction) == 0x000004, "Wrong alignment on FAISettings_MeleeAction");
static_assert(sizeof(FAISettings_MeleeAction) == 0x000058, "Wrong size on FAISettings_MeleeAction");
static_assert(offsetof(FAISettings_MeleeAction, Cooldown) == 0x00003C, "Member 'FAISettings_MeleeAction::Cooldown' has a wrong offset!");
static_assert(offsetof(FAISettings_MeleeAction, UseCase) == 0x000040, "Member 'FAISettings_MeleeAction::UseCase' has a wrong offset!");
static_assert(offsetof(FAISettings_MeleeAction, UseRange) == 0x000044, "Member 'FAISettings_MeleeAction::UseRange' has a wrong offset!");
static_assert(offsetof(FAISettings_MeleeAction, Weight) == 0x000048, "Member 'FAISettings_MeleeAction::Weight' has a wrong offset!");
static_assert(offsetof(FAISettings_MeleeAction, bOverrideNumMeleeSlotsRequired) == 0x00004C, "Member 'FAISettings_MeleeAction::bOverrideNumMeleeSlotsRequired' has a wrong offset!");
static_assert(offsetof(FAISettings_MeleeAction, NumMeleeSlotsRequired) == 0x000050, "Member 'FAISettings_MeleeAction::NumMeleeSlotsRequired' has a wrong offset!");
static_assert(offsetof(FAISettings_MeleeAction, bIgnoreCollisionDuringApproach) == 0x000054, "Member 'FAISettings_MeleeAction::bIgnoreCollisionDuringApproach' has a wrong offset!");
static_assert(offsetof(FAISettings_MeleeAction, bBumpDuringApproach) == 0x000055, "Member 'FAISettings_MeleeAction::bBumpDuringApproach' has a wrong offset!");
static_assert(offsetof(FAISettings_MeleeAction, bSprintDuringApproach) == 0x000056, "Member 'FAISettings_MeleeAction::bSprintDuringApproach' has a wrong offset!");

// ScriptStruct Indiana.AISettings_Melee
// 0x00E0 (0x00E0 - 0x0000)
struct FAISettings_Melee final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDelayBetweenActions;                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LostTargetTime;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LostTargetRangeScalar;                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeleeWaitDistance;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAISettings_RecoveryBackupBehavior     MainBackupBehavior;                                // 0x0014(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UMeleeSlotRequestData*, struct FAISettings_MeleeAction> MeleeActions;                                      // 0x0038(0x0050)(Edit, NativeAccessSpecifierPublic)
	bool                                          bUseAttackPattern;                                 // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UMeleeSlotPatternRequestData*, struct FAISettings_MeleePattern> AttackPatterns;                                    // 0x0090(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISettings_Melee) == 0x000008, "Wrong alignment on FAISettings_Melee");
static_assert(sizeof(FAISettings_Melee) == 0x0000E0, "Wrong size on FAISettings_Melee");
static_assert(offsetof(FAISettings_Melee, bEnabled) == 0x000000, "Member 'FAISettings_Melee::bEnabled' has a wrong offset!");
static_assert(offsetof(FAISettings_Melee, MinDelayBetweenActions) == 0x000004, "Member 'FAISettings_Melee::MinDelayBetweenActions' has a wrong offset!");
static_assert(offsetof(FAISettings_Melee, LostTargetTime) == 0x000008, "Member 'FAISettings_Melee::LostTargetTime' has a wrong offset!");
static_assert(offsetof(FAISettings_Melee, LostTargetRangeScalar) == 0x00000C, "Member 'FAISettings_Melee::LostTargetRangeScalar' has a wrong offset!");
static_assert(offsetof(FAISettings_Melee, MeleeWaitDistance) == 0x000010, "Member 'FAISettings_Melee::MeleeWaitDistance' has a wrong offset!");
static_assert(offsetof(FAISettings_Melee, MainBackupBehavior) == 0x000014, "Member 'FAISettings_Melee::MainBackupBehavior' has a wrong offset!");
static_assert(offsetof(FAISettings_Melee, MeleeActions) == 0x000038, "Member 'FAISettings_Melee::MeleeActions' has a wrong offset!");
static_assert(offsetof(FAISettings_Melee, bUseAttackPattern) == 0x000088, "Member 'FAISettings_Melee::bUseAttackPattern' has a wrong offset!");
static_assert(offsetof(FAISettings_Melee, AttackPatterns) == 0x000090, "Member 'FAISettings_Melee::AttackPatterns' has a wrong offset!");

// ScriptStruct Indiana.TrackingSetting
// 0x000C (0x000C - 0x0000)
struct FTrackingSetting final
{
public:
	float                                         Speed;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ComfortAngle;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetDistanceThreshold;                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrackingSetting) == 0x000004, "Wrong alignment on FTrackingSetting");
static_assert(sizeof(FTrackingSetting) == 0x00000C, "Wrong size on FTrackingSetting");
static_assert(offsetof(FTrackingSetting, Speed) == 0x000000, "Member 'FTrackingSetting::Speed' has a wrong offset!");
static_assert(offsetof(FTrackingSetting, ComfortAngle) == 0x000004, "Member 'FTrackingSetting::ComfortAngle' has a wrong offset!");
static_assert(offsetof(FTrackingSetting, TargetDistanceThreshold) == 0x000008, "Member 'FTrackingSetting::TargetDistanceThreshold' has a wrong offset!");

// ScriptStruct Indiana.SpellInstance
// 0x0058 (0x0058 - 0x0000)
struct FSpellInstance final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UEventListener*                         ApplyEvent;                                        // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEventListener*                         RemoveEvent;                                       // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_18[0x40];                                      // 0x0018(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpellInstance) == 0x000008, "Wrong alignment on FSpellInstance");
static_assert(sizeof(FSpellInstance) == 0x000058, "Wrong size on FSpellInstance");
static_assert(offsetof(FSpellInstance, ApplyEvent) == 0x000008, "Member 'FSpellInstance::ApplyEvent' has a wrong offset!");
static_assert(offsetof(FSpellInstance, RemoveEvent) == 0x000010, "Member 'FSpellInstance::RemoveEvent' has a wrong offset!");

// ScriptStruct Indiana.LostTargetTimes
// 0x0010 (0x0010 - 0x0000)
struct FLostTargetTimes final
{
public:
	float                                         RangedInitiallyUnseenTime;                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangedInitiallySeenTime;                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoverInitiallyUnseenTime;                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoverInitiallySeenTime;                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLostTargetTimes) == 0x000004, "Wrong alignment on FLostTargetTimes");
static_assert(sizeof(FLostTargetTimes) == 0x000010, "Wrong size on FLostTargetTimes");
static_assert(offsetof(FLostTargetTimes, RangedInitiallyUnseenTime) == 0x000000, "Member 'FLostTargetTimes::RangedInitiallyUnseenTime' has a wrong offset!");
static_assert(offsetof(FLostTargetTimes, RangedInitiallySeenTime) == 0x000004, "Member 'FLostTargetTimes::RangedInitiallySeenTime' has a wrong offset!");
static_assert(offsetof(FLostTargetTimes, CoverInitiallyUnseenTime) == 0x000008, "Member 'FLostTargetTimes::CoverInitiallyUnseenTime' has a wrong offset!");
static_assert(offsetof(FLostTargetTimes, CoverInitiallySeenTime) == 0x00000C, "Member 'FLostTargetTimes::CoverInitiallySeenTime' has a wrong offset!");

// ScriptStruct Indiana.LevelReference
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FLevelReference final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLevelReference) == 0x000008, "Wrong alignment on FLevelReference");
static_assert(sizeof(FLevelReference) == 0x000028, "Wrong size on FLevelReference");

// ScriptStruct Indiana.AISettings_MovingFire
// 0x002C (0x002C - 0x0000)
struct FAISettings_MovingFire final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PrePauseTime;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAISettings_FiringPattern              FiringPattern;                                     // 0x0008(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCanFireWhileRunning;                              // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFireWhileMovingToPreferredRange;                  // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovingToPreferredRangeNoFireTime;                  // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovingToPreferredRangeFireTime;                    // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FAISettings_MovingFire) == 0x000004, "Wrong alignment on FAISettings_MovingFire");
static_assert(sizeof(FAISettings_MovingFire) == 0x00002C, "Wrong size on FAISettings_MovingFire");
static_assert(offsetof(FAISettings_MovingFire, bEnabled) == 0x000000, "Member 'FAISettings_MovingFire::bEnabled' has a wrong offset!");
static_assert(offsetof(FAISettings_MovingFire, PrePauseTime) == 0x000004, "Member 'FAISettings_MovingFire::PrePauseTime' has a wrong offset!");
static_assert(offsetof(FAISettings_MovingFire, FiringPattern) == 0x000008, "Member 'FAISettings_MovingFire::FiringPattern' has a wrong offset!");
static_assert(offsetof(FAISettings_MovingFire, bCanFireWhileRunning) == 0x000020, "Member 'FAISettings_MovingFire::bCanFireWhileRunning' has a wrong offset!");
static_assert(offsetof(FAISettings_MovingFire, bFireWhileMovingToPreferredRange) == 0x000021, "Member 'FAISettings_MovingFire::bFireWhileMovingToPreferredRange' has a wrong offset!");
static_assert(offsetof(FAISettings_MovingFire, MovingToPreferredRangeNoFireTime) == 0x000024, "Member 'FAISettings_MovingFire::MovingToPreferredRangeNoFireTime' has a wrong offset!");
static_assert(offsetof(FAISettings_MovingFire, MovingToPreferredRangeFireTime) == 0x000028, "Member 'FAISettings_MovingFire::MovingToPreferredRangeFireTime' has a wrong offset!");

// ScriptStruct Indiana.AlternateBrushSet
// 0x03B8 (0x03B8 - 0x0000)
struct FAlternateBrushSet final
{
public:
	struct FSlateBrush                            HiddenBrush;                                       // 0x0000(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            LockedBrush;                                       // 0x0088(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            LockedHoverFocused;                                // 0x0110(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            LockedSelected;                                    // 0x0198(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            UnlockedBrush;                                     // 0x0220(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            UnlockedHoverFocused;                              // 0x02A8(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            UnlockedSelected;                                  // 0x0330(0x0088)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAlternateBrushSet) == 0x000008, "Wrong alignment on FAlternateBrushSet");
static_assert(sizeof(FAlternateBrushSet) == 0x0003B8, "Wrong size on FAlternateBrushSet");
static_assert(offsetof(FAlternateBrushSet, HiddenBrush) == 0x000000, "Member 'FAlternateBrushSet::HiddenBrush' has a wrong offset!");
static_assert(offsetof(FAlternateBrushSet, LockedBrush) == 0x000088, "Member 'FAlternateBrushSet::LockedBrush' has a wrong offset!");
static_assert(offsetof(FAlternateBrushSet, LockedHoverFocused) == 0x000110, "Member 'FAlternateBrushSet::LockedHoverFocused' has a wrong offset!");
static_assert(offsetof(FAlternateBrushSet, LockedSelected) == 0x000198, "Member 'FAlternateBrushSet::LockedSelected' has a wrong offset!");
static_assert(offsetof(FAlternateBrushSet, UnlockedBrush) == 0x000220, "Member 'FAlternateBrushSet::UnlockedBrush' has a wrong offset!");
static_assert(offsetof(FAlternateBrushSet, UnlockedHoverFocused) == 0x0002A8, "Member 'FAlternateBrushSet::UnlockedHoverFocused' has a wrong offset!");
static_assert(offsetof(FAlternateBrushSet, UnlockedSelected) == 0x000330, "Member 'FAlternateBrushSet::UnlockedSelected' has a wrong offset!");

// ScriptStruct Indiana.AISettings_Positioning
// 0x000C (0x000C - 0x0000)
struct FAISettings_Positioning final
{
public:
	float                                         PreferredMinRange;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreferredMaxRange;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AbsoluteRangeBuffer;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FAISettings_Positioning) == 0x000004, "Wrong alignment on FAISettings_Positioning");
static_assert(sizeof(FAISettings_Positioning) == 0x00000C, "Wrong size on FAISettings_Positioning");
static_assert(offsetof(FAISettings_Positioning, PreferredMinRange) == 0x000000, "Member 'FAISettings_Positioning::PreferredMinRange' has a wrong offset!");
static_assert(offsetof(FAISettings_Positioning, PreferredMaxRange) == 0x000004, "Member 'FAISettings_Positioning::PreferredMaxRange' has a wrong offset!");
static_assert(offsetof(FAISettings_Positioning, AbsoluteRangeBuffer) == 0x000008, "Member 'FAISettings_Positioning::AbsoluteRangeBuffer' has a wrong offset!");

// ScriptStruct Indiana.AISettings_RangedBehavior_Set
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FAISettings_RangedBehavior_Set
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CoverWeight;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RangeWeight;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FAISettings_RangedBehavior_Set) == 0x000008, "Wrong alignment on FAISettings_RangedBehavior_Set");
static_assert(sizeof(FAISettings_RangedBehavior_Set) == 0x000010, "Wrong size on FAISettings_RangedBehavior_Set");
static_assert(offsetof(FAISettings_RangedBehavior_Set, CoverWeight) == 0x000008, "Member 'FAISettings_RangedBehavior_Set::CoverWeight' has a wrong offset!");
static_assert(offsetof(FAISettings_RangedBehavior_Set, RangeWeight) == 0x00000C, "Member 'FAISettings_RangedBehavior_Set::RangeWeight' has a wrong offset!");

// ScriptStruct Indiana.AISettings_RangedBehavior_TooFar_Set
// 0x0008 (0x0018 - 0x0010)
struct FAISettings_RangedBehavior_TooFar_Set final : public FAISettings_RangedBehavior_Set
{
public:
	float                                         PreferredRangeWeight;                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAISettings_RangedBehavior_TooFar_Set) == 0x000008, "Wrong alignment on FAISettings_RangedBehavior_TooFar_Set");
static_assert(sizeof(FAISettings_RangedBehavior_TooFar_Set) == 0x000018, "Wrong size on FAISettings_RangedBehavior_TooFar_Set");
static_assert(offsetof(FAISettings_RangedBehavior_TooFar_Set, PreferredRangeWeight) == 0x000010, "Member 'FAISettings_RangedBehavior_TooFar_Set::PreferredRangeWeight' has a wrong offset!");

// ScriptStruct Indiana.AISettings_RangePositioning_Set
// 0x0010 (0x0010 - 0x0000)
struct FAISettings_RangePositioning_Set final
{
public:
	float                                         StationaryWeight;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BackwardWeight;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ForwardWeight;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StrafeWeight;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FAISettings_RangePositioning_Set) == 0x000004, "Wrong alignment on FAISettings_RangePositioning_Set");
static_assert(sizeof(FAISettings_RangePositioning_Set) == 0x000010, "Wrong size on FAISettings_RangePositioning_Set");
static_assert(offsetof(FAISettings_RangePositioning_Set, StationaryWeight) == 0x000000, "Member 'FAISettings_RangePositioning_Set::StationaryWeight' has a wrong offset!");
static_assert(offsetof(FAISettings_RangePositioning_Set, BackwardWeight) == 0x000004, "Member 'FAISettings_RangePositioning_Set::BackwardWeight' has a wrong offset!");
static_assert(offsetof(FAISettings_RangePositioning_Set, ForwardWeight) == 0x000008, "Member 'FAISettings_RangePositioning_Set::ForwardWeight' has a wrong offset!");
static_assert(offsetof(FAISettings_RangePositioning_Set, StrafeWeight) == 0x00000C, "Member 'FAISettings_RangePositioning_Set::StrafeWeight' has a wrong offset!");

// ScriptStruct Indiana.AISettings_RangedPositioning
// 0x0030 (0x0030 - 0x0000)
struct FAISettings_RangedPositioning final
{
public:
	struct FAISettings_RangePositioning_Set       TooNear;                                           // 0x0000(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAISettings_RangePositioning_Set       PreferredRange;                                    // 0x0010(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAISettings_RangePositioning_Set       TooFar;                                            // 0x0020(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FAISettings_RangedPositioning) == 0x000004, "Wrong alignment on FAISettings_RangedPositioning");
static_assert(sizeof(FAISettings_RangedPositioning) == 0x000030, "Wrong size on FAISettings_RangedPositioning");
static_assert(offsetof(FAISettings_RangedPositioning, TooNear) == 0x000000, "Member 'FAISettings_RangedPositioning::TooNear' has a wrong offset!");
static_assert(offsetof(FAISettings_RangedPositioning, PreferredRange) == 0x000010, "Member 'FAISettings_RangedPositioning::PreferredRange' has a wrong offset!");
static_assert(offsetof(FAISettings_RangedPositioning, TooFar) == 0x000020, "Member 'FAISettings_RangedPositioning::TooFar' has a wrong offset!");

// ScriptStruct Indiana.AISettings_RangedBehavior
// 0x0080 (0x0080 - 0x0000)
struct FAISettings_RangedBehavior final
{
public:
	EOnEnterCombatBehavior                        OnEnterCombatBehavior;                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLimitedRange;                                     // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShootAtFeet;                                      // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bArcingWeapon;                                     // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinMoveDistance;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxMoveDistance;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAISettings_RangedBehavior_Set         Near;                                              // 0x0010(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FAISettings_RangedBehavior_Set         PreferedRange;                                     // 0x0020(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FAISettings_RangedBehavior_TooFar_Set  ToFar;                                             // 0x0030(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bOverrideRangeReposition;                          // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAISettings_RangedPositioning          OverrideRangeRepositionData;                       // 0x004C(0x0030)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAISettings_RangedBehavior) == 0x000008, "Wrong alignment on FAISettings_RangedBehavior");
static_assert(sizeof(FAISettings_RangedBehavior) == 0x000080, "Wrong size on FAISettings_RangedBehavior");
static_assert(offsetof(FAISettings_RangedBehavior, OnEnterCombatBehavior) == 0x000000, "Member 'FAISettings_RangedBehavior::OnEnterCombatBehavior' has a wrong offset!");
static_assert(offsetof(FAISettings_RangedBehavior, bLimitedRange) == 0x000001, "Member 'FAISettings_RangedBehavior::bLimitedRange' has a wrong offset!");
static_assert(offsetof(FAISettings_RangedBehavior, bShootAtFeet) == 0x000002, "Member 'FAISettings_RangedBehavior::bShootAtFeet' has a wrong offset!");
static_assert(offsetof(FAISettings_RangedBehavior, bArcingWeapon) == 0x000003, "Member 'FAISettings_RangedBehavior::bArcingWeapon' has a wrong offset!");
static_assert(offsetof(FAISettings_RangedBehavior, MinMoveDistance) == 0x000004, "Member 'FAISettings_RangedBehavior::MinMoveDistance' has a wrong offset!");
static_assert(offsetof(FAISettings_RangedBehavior, MaxMoveDistance) == 0x000008, "Member 'FAISettings_RangedBehavior::MaxMoveDistance' has a wrong offset!");
static_assert(offsetof(FAISettings_RangedBehavior, Near) == 0x000010, "Member 'FAISettings_RangedBehavior::Near' has a wrong offset!");
static_assert(offsetof(FAISettings_RangedBehavior, PreferedRange) == 0x000020, "Member 'FAISettings_RangedBehavior::PreferedRange' has a wrong offset!");
static_assert(offsetof(FAISettings_RangedBehavior, ToFar) == 0x000030, "Member 'FAISettings_RangedBehavior::ToFar' has a wrong offset!");
static_assert(offsetof(FAISettings_RangedBehavior, bOverrideRangeReposition) == 0x000048, "Member 'FAISettings_RangedBehavior::bOverrideRangeReposition' has a wrong offset!");
static_assert(offsetof(FAISettings_RangedBehavior, OverrideRangeRepositionData) == 0x00004C, "Member 'FAISettings_RangedBehavior::OverrideRangeRepositionData' has a wrong offset!");

// ScriptStruct Indiana.FaceFxRigStructure
// 0x0018 (0x0020 - 0x0008)
struct FFaceFxRigStructure final : public FGameDataStructure
{
public:
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFaceFxRigStructure) == 0x000008, "Wrong alignment on FFaceFxRigStructure");
static_assert(sizeof(FFaceFxRigStructure) == 0x000020, "Wrong size on FFaceFxRigStructure");

// ScriptStruct Indiana.DamageTypeScalar
// 0x0018 (0x0018 - 0x0000)
struct FDamageTypeScalar final
{
public:
	TArray<TSubclassOf<class UIndianaDamageType>> DamageTypes;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         Scalar;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageTypeScalar) == 0x000008, "Wrong alignment on FDamageTypeScalar");
static_assert(sizeof(FDamageTypeScalar) == 0x000018, "Wrong size on FDamageTypeScalar");
static_assert(offsetof(FDamageTypeScalar, DamageTypes) == 0x000000, "Member 'FDamageTypeScalar::DamageTypes' has a wrong offset!");
static_assert(offsetof(FDamageTypeScalar, Scalar) == 0x000010, "Member 'FDamageTypeScalar::Scalar' has a wrong offset!");

// ScriptStruct Indiana.PendingDeferredSpawn
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FPendingDeferredSpawn final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPendingDeferredSpawn) == 0x000008, "Wrong alignment on FPendingDeferredSpawn");
static_assert(sizeof(FPendingDeferredSpawn) == 0x000038, "Wrong size on FPendingDeferredSpawn");

// ScriptStruct Indiana.CachedGameState
// 0x0178 (0x0178 - 0x0000)
struct FCachedGameState final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        PreloadedObjects;                                  // 0x0020(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x70];                                      // 0x0030(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPendingDeferredSpawn>          PendingDeferredSpawns;                             // 0x00A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TMap<class AActor*, uint64>                   DeferredSpawnActorStateDataOffsets;                // 0x00B0(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<struct FGuid, class AActor*>             DeferredSpawnsByGUID;                              // 0x0100(0x0050)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_150[0x28];                                     // 0x0150(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCachedGameState) == 0x000008, "Wrong alignment on FCachedGameState");
static_assert(sizeof(FCachedGameState) == 0x000178, "Wrong size on FCachedGameState");
static_assert(offsetof(FCachedGameState, PreloadedObjects) == 0x000020, "Member 'FCachedGameState::PreloadedObjects' has a wrong offset!");
static_assert(offsetof(FCachedGameState, PendingDeferredSpawns) == 0x0000A0, "Member 'FCachedGameState::PendingDeferredSpawns' has a wrong offset!");
static_assert(offsetof(FCachedGameState, DeferredSpawnActorStateDataOffsets) == 0x0000B0, "Member 'FCachedGameState::DeferredSpawnActorStateDataOffsets' has a wrong offset!");
static_assert(offsetof(FCachedGameState, DeferredSpawnsByGUID) == 0x000100, "Member 'FCachedGameState::DeferredSpawnsByGUID' has a wrong offset!");

// ScriptStruct Indiana.AISettings_StationaryFire
// 0x001C (0x001C - 0x0000)
struct FAISettings_StationaryFire final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAISettings_FiringPattern              FiringPattern;                                     // 0x0004(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISettings_StationaryFire) == 0x000004, "Wrong alignment on FAISettings_StationaryFire");
static_assert(sizeof(FAISettings_StationaryFire) == 0x00001C, "Wrong size on FAISettings_StationaryFire");
static_assert(offsetof(FAISettings_StationaryFire, bEnabled) == 0x000000, "Member 'FAISettings_StationaryFire::bEnabled' has a wrong offset!");
static_assert(offsetof(FAISettings_StationaryFire, FiringPattern) == 0x000004, "Member 'FAISettings_StationaryFire::FiringPattern' has a wrong offset!");

// ScriptStruct Indiana.AISettings_SuppressingFire
// 0x0001 (0x0001 - 0x0000)
struct FAISettings_SuppressingFire final
{
public:
	ESuppressingFireDuration                      Duration;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISettings_SuppressingFire) == 0x000001, "Wrong alignment on FAISettings_SuppressingFire");
static_assert(sizeof(FAISettings_SuppressingFire) == 0x000001, "Wrong size on FAISettings_SuppressingFire");
static_assert(offsetof(FAISettings_SuppressingFire, Duration) == 0x000000, "Member 'FAISettings_SuppressingFire::Duration' has a wrong offset!");

// ScriptStruct Indiana.LocomotionNode
// 0x0018 (0x0018 - 0x0000)
struct FLocomotionNode final
{
public:
	class UAnimSequence*                          Node0Sequence;                                     // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Node1Sequence;                                     // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnterNode0;                                        // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnterNode1;                                        // 0x0011(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLocomotionNode) == 0x000008, "Wrong alignment on FLocomotionNode");
static_assert(sizeof(FLocomotionNode) == 0x000018, "Wrong size on FLocomotionNode");
static_assert(offsetof(FLocomotionNode, Node0Sequence) == 0x000000, "Member 'FLocomotionNode::Node0Sequence' has a wrong offset!");
static_assert(offsetof(FLocomotionNode, Node1Sequence) == 0x000008, "Member 'FLocomotionNode::Node1Sequence' has a wrong offset!");
static_assert(offsetof(FLocomotionNode, EnterNode0) == 0x000010, "Member 'FLocomotionNode::EnterNode0' has a wrong offset!");
static_assert(offsetof(FLocomotionNode, EnterNode1) == 0x000011, "Member 'FLocomotionNode::EnterNode1' has a wrong offset!");

// ScriptStruct Indiana.AISettingsWander
// 0x0014 (0x0014 - 0x0000)
struct FAISettingsWander final
{
public:
	float                                         Radius;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinMoveDistance;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMoveDistance;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinIdleTime;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxIdleTime;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISettingsWander) == 0x000004, "Wrong alignment on FAISettingsWander");
static_assert(sizeof(FAISettingsWander) == 0x000014, "Wrong size on FAISettingsWander");
static_assert(offsetof(FAISettingsWander, Radius) == 0x000000, "Member 'FAISettingsWander::Radius' has a wrong offset!");
static_assert(offsetof(FAISettingsWander, MinMoveDistance) == 0x000004, "Member 'FAISettingsWander::MinMoveDistance' has a wrong offset!");
static_assert(offsetof(FAISettingsWander, MaxMoveDistance) == 0x000008, "Member 'FAISettingsWander::MaxMoveDistance' has a wrong offset!");
static_assert(offsetof(FAISettingsWander, MinIdleTime) == 0x00000C, "Member 'FAISettingsWander::MinIdleTime' has a wrong offset!");
static_assert(offsetof(FAISettingsWander, MaxIdleTime) == 0x000010, "Member 'FAISettingsWander::MaxIdleTime' has a wrong offset!");

// ScriptStruct Indiana.BaseItemDefinition
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FBaseItemDefinition
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPristine;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBaseItemDefinition) == 0x000008, "Wrong alignment on FBaseItemDefinition");
static_assert(sizeof(FBaseItemDefinition) == 0x000010, "Wrong size on FBaseItemDefinition");
static_assert(offsetof(FBaseItemDefinition, bPristine) == 0x000008, "Member 'FBaseItemDefinition::bPristine' has a wrong offset!");

// ScriptStruct Indiana.AmmoItemDefinition
// 0x0008 (0x0018 - 0x0010)
struct FAmmoItemDefinition final : public FBaseItemDefinition
{
public:
	TSubclassOf<class UAmmo>                      AmmoClass;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAmmoItemDefinition) == 0x000008, "Wrong alignment on FAmmoItemDefinition");
static_assert(sizeof(FAmmoItemDefinition) == 0x000018, "Wrong size on FAmmoItemDefinition");
static_assert(offsetof(FAmmoItemDefinition, AmmoClass) == 0x000010, "Member 'FAmmoItemDefinition::AmmoClass' has a wrong offset!");

// ScriptStruct Indiana.TeamRelationship
// 0x0002 (0x0002 - 0x0000)
struct FTeamRelationship final
{
public:
	uint8                                         Pad_0[0x2];                                        // 0x0000(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTeamRelationship) == 0x000001, "Wrong alignment on FTeamRelationship");
static_assert(sizeof(FTeamRelationship) == 0x000002, "Wrong size on FTeamRelationship");

// ScriptStruct Indiana.AnimEventGameplayTagData
// 0x0010 (0x0010 - 0x0000)
struct FAnimEventGameplayTagData final
{
public:
	struct FGameplayTag                           GameplayTag;                                       // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBasePlayAnimEventEffect*               AnimEventEffect;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimEventGameplayTagData) == 0x000008, "Wrong alignment on FAnimEventGameplayTagData");
static_assert(sizeof(FAnimEventGameplayTagData) == 0x000010, "Wrong size on FAnimEventGameplayTagData");
static_assert(offsetof(FAnimEventGameplayTagData, GameplayTag) == 0x000000, "Member 'FAnimEventGameplayTagData::GameplayTag' has a wrong offset!");
static_assert(offsetof(FAnimEventGameplayTagData, AnimEventEffect) == 0x000008, "Member 'FAnimEventGameplayTagData::AnimEventEffect' has a wrong offset!");

// ScriptStruct Indiana.AnimEventGameplayTagContainer
// 0x0010 (0x0010 - 0x0000)
struct FAnimEventGameplayTagContainer final
{
public:
	TArray<struct FAnimEventGameplayTagData>      AnimationData;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FAnimEventGameplayTagContainer) == 0x000008, "Wrong alignment on FAnimEventGameplayTagContainer");
static_assert(sizeof(FAnimEventGameplayTagContainer) == 0x000010, "Wrong size on FAnimEventGameplayTagContainer");
static_assert(offsetof(FAnimEventGameplayTagContainer, AnimationData) == 0x000000, "Member 'FAnimEventGameplayTagContainer::AnimationData' has a wrong offset!");

// ScriptStruct Indiana.PendingParticleSpawnInfo
// 0x0010 (0x0010 - 0x0000)
struct FPendingParticleSpawnInfo final
{
public:
	class UParticleSystem*                        Template;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPendingParticleSpawnInfo) == 0x000008, "Wrong alignment on FPendingParticleSpawnInfo");
static_assert(sizeof(FPendingParticleSpawnInfo) == 0x000010, "Wrong size on FPendingParticleSpawnInfo");
static_assert(offsetof(FPendingParticleSpawnInfo, Template) == 0x000000, "Member 'FPendingParticleSpawnInfo::Template' has a wrong offset!");

// ScriptStruct Indiana.JointDriverData
// 0x0090 (0x0090 - 0x0000)
struct alignas(0x10) FJointDriverData final
{
public:
	class FName                                   IKChainName;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFootID                                       FootID;                                            // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FootDownDistance;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootUpDistance;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneReference                         BoneThatWillBeIKed;                                // 0x0014(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         BoneToModify;                                      // 0x0024(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         UpperLegJoint;                                     // 0x0034(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         HipBoneToUseForHeightCalculation;                  // 0x0044(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x3C];                                      // 0x0054(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJointDriverData) == 0x000010, "Wrong alignment on FJointDriverData");
static_assert(sizeof(FJointDriverData) == 0x000090, "Wrong size on FJointDriverData");
static_assert(offsetof(FJointDriverData, IKChainName) == 0x000000, "Member 'FJointDriverData::IKChainName' has a wrong offset!");
static_assert(offsetof(FJointDriverData, FootID) == 0x000008, "Member 'FJointDriverData::FootID' has a wrong offset!");
static_assert(offsetof(FJointDriverData, FootDownDistance) == 0x00000C, "Member 'FJointDriverData::FootDownDistance' has a wrong offset!");
static_assert(offsetof(FJointDriverData, FootUpDistance) == 0x000010, "Member 'FJointDriverData::FootUpDistance' has a wrong offset!");
static_assert(offsetof(FJointDriverData, BoneThatWillBeIKed) == 0x000014, "Member 'FJointDriverData::BoneThatWillBeIKed' has a wrong offset!");
static_assert(offsetof(FJointDriverData, BoneToModify) == 0x000024, "Member 'FJointDriverData::BoneToModify' has a wrong offset!");
static_assert(offsetof(FJointDriverData, UpperLegJoint) == 0x000034, "Member 'FJointDriverData::UpperLegJoint' has a wrong offset!");
static_assert(offsetof(FJointDriverData, HipBoneToUseForHeightCalculation) == 0x000044, "Member 'FJointDriverData::HipBoneToUseForHeightCalculation' has a wrong offset!");

// ScriptStruct Indiana.AnimNode_BatchJointDriver
// 0x0118 (0x01E0 - 0x00C8)
struct FAnimNode_BatchJointDriver final : public FAnimNode_SkeletalControlBase
{
public:
	TArray<struct FJointDriverData>               Legs;                                              // 0x00C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         PlantRollAmount;                                   // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitchClamp;                                     // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPitchClamp;                                     // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BackLeftName;                                      // 0x00E4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BackRightName;                                     // 0x00EC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FrontLeftName;                                     // 0x00F4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FrontRightName;                                    // 0x00FC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeightCompensation;                             // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SetTransformOnMiss;                                // 0x0108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoHeightCompensation;                             // 0x0109(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10A[0x2];                                      // 0x010A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroundRollMultiplier;                              // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneReference                         HipBoneToModify;                                   // 0x0110(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         BipedHipCounterBone;                               // 0x0120(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         ConversationCameraBone;                            // 0x0130(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         HipAdjustRange;                                    // 0x0140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HipTranslationSpeedRun;                            // 0x0144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HipTranslationSpeedIdle;                           // 0x0148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HipLimitSpeedRun;                                  // 0x014C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HipRotationSpeedRun;                               // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HipTranslationSpeed;                               // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HipLimitSpeed;                                     // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HipRotationSpeed;                                  // 0x015C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootTranslationSpeed;                              // 0x0160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootTranslationSpeedRun;                           // 0x0164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootRotationSpeed;                                 // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootRotationSpeedRun;                              // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTickBeforeReset;                                // 0x0170(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreNormalRays;                                 // 0x0174(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_175[0x6B];                                     // 0x0175(0x006B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_BatchJointDriver) == 0x000008, "Wrong alignment on FAnimNode_BatchJointDriver");
static_assert(sizeof(FAnimNode_BatchJointDriver) == 0x0001E0, "Wrong size on FAnimNode_BatchJointDriver");
static_assert(offsetof(FAnimNode_BatchJointDriver, Legs) == 0x0000C8, "Member 'FAnimNode_BatchJointDriver::Legs' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, PlantRollAmount) == 0x0000D8, "Member 'FAnimNode_BatchJointDriver::PlantRollAmount' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, MaxPitchClamp) == 0x0000DC, "Member 'FAnimNode_BatchJointDriver::MaxPitchClamp' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, MinPitchClamp) == 0x0000E0, "Member 'FAnimNode_BatchJointDriver::MinPitchClamp' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, BackLeftName) == 0x0000E4, "Member 'FAnimNode_BatchJointDriver::BackLeftName' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, BackRightName) == 0x0000EC, "Member 'FAnimNode_BatchJointDriver::BackRightName' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, FrontLeftName) == 0x0000F4, "Member 'FAnimNode_BatchJointDriver::FrontLeftName' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, FrontRightName) == 0x0000FC, "Member 'FAnimNode_BatchJointDriver::FrontRightName' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, MaxHeightCompensation) == 0x000104, "Member 'FAnimNode_BatchJointDriver::MaxHeightCompensation' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, SetTransformOnMiss) == 0x000108, "Member 'FAnimNode_BatchJointDriver::SetTransformOnMiss' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, bDoHeightCompensation) == 0x000109, "Member 'FAnimNode_BatchJointDriver::bDoHeightCompensation' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, GroundRollMultiplier) == 0x00010C, "Member 'FAnimNode_BatchJointDriver::GroundRollMultiplier' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, HipBoneToModify) == 0x000110, "Member 'FAnimNode_BatchJointDriver::HipBoneToModify' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, BipedHipCounterBone) == 0x000120, "Member 'FAnimNode_BatchJointDriver::BipedHipCounterBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, ConversationCameraBone) == 0x000130, "Member 'FAnimNode_BatchJointDriver::ConversationCameraBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, HipAdjustRange) == 0x000140, "Member 'FAnimNode_BatchJointDriver::HipAdjustRange' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, HipTranslationSpeedRun) == 0x000144, "Member 'FAnimNode_BatchJointDriver::HipTranslationSpeedRun' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, HipTranslationSpeedIdle) == 0x000148, "Member 'FAnimNode_BatchJointDriver::HipTranslationSpeedIdle' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, HipLimitSpeedRun) == 0x00014C, "Member 'FAnimNode_BatchJointDriver::HipLimitSpeedRun' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, HipRotationSpeedRun) == 0x000150, "Member 'FAnimNode_BatchJointDriver::HipRotationSpeedRun' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, HipTranslationSpeed) == 0x000154, "Member 'FAnimNode_BatchJointDriver::HipTranslationSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, HipLimitSpeed) == 0x000158, "Member 'FAnimNode_BatchJointDriver::HipLimitSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, HipRotationSpeed) == 0x00015C, "Member 'FAnimNode_BatchJointDriver::HipRotationSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, FootTranslationSpeed) == 0x000160, "Member 'FAnimNode_BatchJointDriver::FootTranslationSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, FootTranslationSpeedRun) == 0x000164, "Member 'FAnimNode_BatchJointDriver::FootTranslationSpeedRun' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, FootRotationSpeed) == 0x000168, "Member 'FAnimNode_BatchJointDriver::FootRotationSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, FootRotationSpeedRun) == 0x00016C, "Member 'FAnimNode_BatchJointDriver::FootRotationSpeedRun' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, MaxTickBeforeReset) == 0x000170, "Member 'FAnimNode_BatchJointDriver::MaxTickBeforeReset' has a wrong offset!");
static_assert(offsetof(FAnimNode_BatchJointDriver, bIgnoreNormalRays) == 0x000174, "Member 'FAnimNode_BatchJointDriver::bIgnoreNormalRays' has a wrong offset!");

// ScriptStruct Indiana.StatModifierDescription
// 0x0008 (0x0018 - 0x0010)
struct FStatModifierDescription final : public FStatModifierDescriptionBase
{
public:
	float                                         Value;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreScalingBonus;                               // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatModifierDescription) == 0x000008, "Wrong alignment on FStatModifierDescription");
static_assert(sizeof(FStatModifierDescription) == 0x000018, "Wrong size on FStatModifierDescription");
static_assert(offsetof(FStatModifierDescription, Value) == 0x000010, "Member 'FStatModifierDescription::Value' has a wrong offset!");
static_assert(offsetof(FStatModifierDescription, bIgnoreScalingBonus) == 0x000014, "Member 'FStatModifierDescription::bIgnoreScalingBonus' has a wrong offset!");

// ScriptStruct Indiana.StatModifierInstance
// 0x0028 (0x0028 - 0x0000)
struct FStatModifierInstance final
{
public:
	TWeakObjectPtr<class UObject>                 SourceObject;                                      // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStatModifierDescription               StatModifier;                                      // 0x0010(0x0018)(Transient, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatModifierInstance) == 0x000008, "Wrong alignment on FStatModifierInstance");
static_assert(sizeof(FStatModifierInstance) == 0x000028, "Wrong size on FStatModifierInstance");
static_assert(offsetof(FStatModifierInstance, SourceObject) == 0x000000, "Member 'FStatModifierInstance::SourceObject' has a wrong offset!");
static_assert(offsetof(FStatModifierInstance, StatModifier) == 0x000010, "Member 'FStatModifierInstance::StatModifier' has a wrong offset!");

// ScriptStruct Indiana.AnimNode_BatchModify
// 0x0010 (0x00D8 - 0x00C8)
struct FAnimNode_BatchModify final : public FAnimNode_SkeletalControlBase
{
public:
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_BatchModify) == 0x000008, "Wrong alignment on FAnimNode_BatchModify");
static_assert(sizeof(FAnimNode_BatchModify) == 0x0000D8, "Wrong size on FAnimNode_BatchModify");

// ScriptStruct Indiana.OnHitStatusEffects
// 0x0028 (0x0028 - 0x0000)
struct FOnHitStatusEffects final
{
public:
	ESkill                                        Skill;                                             // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URpgStat*                               SkillModifierStat;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinSkill;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Chance;                                            // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UStatusEffect>              StatusEffect;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysApply;                                      // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOnHitStatusEffects) == 0x000008, "Wrong alignment on FOnHitStatusEffects");
static_assert(sizeof(FOnHitStatusEffects) == 0x000028, "Wrong size on FOnHitStatusEffects");
static_assert(offsetof(FOnHitStatusEffects, Skill) == 0x000000, "Member 'FOnHitStatusEffects::Skill' has a wrong offset!");
static_assert(offsetof(FOnHitStatusEffects, SkillModifierStat) == 0x000008, "Member 'FOnHitStatusEffects::SkillModifierStat' has a wrong offset!");
static_assert(offsetof(FOnHitStatusEffects, MinSkill) == 0x000010, "Member 'FOnHitStatusEffects::MinSkill' has a wrong offset!");
static_assert(offsetof(FOnHitStatusEffects, Chance) == 0x000014, "Member 'FOnHitStatusEffects::Chance' has a wrong offset!");
static_assert(offsetof(FOnHitStatusEffects, StatusEffect) == 0x000018, "Member 'FOnHitStatusEffects::StatusEffect' has a wrong offset!");
static_assert(offsetof(FOnHitStatusEffects, bAlwaysApply) == 0x000020, "Member 'FOnHitStatusEffects::bAlwaysApply' has a wrong offset!");

// ScriptStruct Indiana.BoneMod
// 0x0040 (0x0040 - 0x0000)
struct FBoneMod final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ApplyTranslation;                                  // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ApplyRotation;                                     // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ApplyScale;                                        // 0x0032(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0xD];                                       // 0x0033(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBoneMod) == 0x000010, "Wrong alignment on FBoneMod");
static_assert(sizeof(FBoneMod) == 0x000040, "Wrong size on FBoneMod");
static_assert(offsetof(FBoneMod, Transform) == 0x000000, "Member 'FBoneMod::Transform' has a wrong offset!");
static_assert(offsetof(FBoneMod, ApplyTranslation) == 0x000030, "Member 'FBoneMod::ApplyTranslation' has a wrong offset!");
static_assert(offsetof(FBoneMod, ApplyRotation) == 0x000031, "Member 'FBoneMod::ApplyRotation' has a wrong offset!");
static_assert(offsetof(FBoneMod, ApplyScale) == 0x000032, "Member 'FBoneMod::ApplyScale' has a wrong offset!");

// ScriptStruct Indiana.AnimNode_BoneMatch
// 0x0068 (0x0130 - 0x00C8)
struct alignas(0x10) FAnimNode_BoneMatch final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         SourceBone;                                        // 0x00C8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         TargetBone;                                        // 0x00D8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x48];                                      // 0x00E8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_BoneMatch) == 0x000010, "Wrong alignment on FAnimNode_BoneMatch");
static_assert(sizeof(FAnimNode_BoneMatch) == 0x000130, "Wrong size on FAnimNode_BoneMatch");
static_assert(offsetof(FAnimNode_BoneMatch, SourceBone) == 0x0000C8, "Member 'FAnimNode_BoneMatch::SourceBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_BoneMatch, TargetBone) == 0x0000D8, "Member 'FAnimNode_BoneMatch::TargetBone' has a wrong offset!");

// ScriptStruct Indiana.LogicalExpressionGroup
// 0x0070 (0x0070 - 0x0000)
struct FLogicalExpressionGroup final
{
public:
	Indiana::ELogicalOperator                     Operator;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLogicalExpression                     Expression;                                        // 0x0008(0x0068)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLogicalExpressionGroup) == 0x000008, "Wrong alignment on FLogicalExpressionGroup");
static_assert(sizeof(FLogicalExpressionGroup) == 0x000070, "Wrong size on FLogicalExpressionGroup");
static_assert(offsetof(FLogicalExpressionGroup, Operator) == 0x000000, "Member 'FLogicalExpressionGroup::Operator' has a wrong offset!");
static_assert(offsetof(FLogicalExpressionGroup, Expression) == 0x000008, "Member 'FLogicalExpressionGroup::Expression' has a wrong offset!");

// ScriptStruct Indiana.LogicalGroupedExpression
// 0x0078 (0x0078 - 0x0000)
struct FLogicalGroupedExpression final
{
public:
	struct FLogicalExpression                     BaseExpression;                                    // 0x0000(0x0068)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FLogicalExpressionGroup>        AdditionalExpressions;                             // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLogicalGroupedExpression) == 0x000008, "Wrong alignment on FLogicalGroupedExpression");
static_assert(sizeof(FLogicalGroupedExpression) == 0x000078, "Wrong size on FLogicalGroupedExpression");
static_assert(offsetof(FLogicalGroupedExpression, BaseExpression) == 0x000000, "Member 'FLogicalGroupedExpression::BaseExpression' has a wrong offset!");
static_assert(offsetof(FLogicalGroupedExpression, AdditionalExpressions) == 0x000068, "Member 'FLogicalGroupedExpression::AdditionalExpressions' has a wrong offset!");

// ScriptStruct Indiana.TravelMapPosition
// 0x00A0 (0x00A0 - 0x0000)
struct FTravelMapPosition final
{
public:
	struct FLocString                             Name;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTravelDestinationData*>         TravelDestinations;                                // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PrimaryDestinationIndex;                           // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WorldCoordinate;                                   // 0x001C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertVisibilityConditions;                       // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLogicalGroupedExpression              VisibilityConditions;                              // 0x0028(0x0078)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTravelMapPosition) == 0x000008, "Wrong alignment on FTravelMapPosition");
static_assert(sizeof(FTravelMapPosition) == 0x0000A0, "Wrong size on FTravelMapPosition");
static_assert(offsetof(FTravelMapPosition, Name) == 0x000000, "Member 'FTravelMapPosition::Name' has a wrong offset!");
static_assert(offsetof(FTravelMapPosition, TravelDestinations) == 0x000008, "Member 'FTravelMapPosition::TravelDestinations' has a wrong offset!");
static_assert(offsetof(FTravelMapPosition, PrimaryDestinationIndex) == 0x000018, "Member 'FTravelMapPosition::PrimaryDestinationIndex' has a wrong offset!");
static_assert(offsetof(FTravelMapPosition, WorldCoordinate) == 0x00001C, "Member 'FTravelMapPosition::WorldCoordinate' has a wrong offset!");
static_assert(offsetof(FTravelMapPosition, bInvertVisibilityConditions) == 0x000024, "Member 'FTravelMapPosition::bInvertVisibilityConditions' has a wrong offset!");
static_assert(offsetof(FTravelMapPosition, VisibilityConditions) == 0x000028, "Member 'FTravelMapPosition::VisibilityConditions' has a wrong offset!");

// ScriptStruct Indiana.AnimNode_CurveSlot
// 0x00A0 (0x00B0 - 0x0010)
struct alignas(0x10) FAnimNode_CurveSlot final : public FAnimNode_Base
{
public:
	struct FPoseLink                              Source;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   SlotName;                                          // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysUpdateSourcePose;                           // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x87];                                      // 0x0029(0x0087)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_CurveSlot) == 0x000010, "Wrong alignment on FAnimNode_CurveSlot");
static_assert(sizeof(FAnimNode_CurveSlot) == 0x0000B0, "Wrong size on FAnimNode_CurveSlot");
static_assert(offsetof(FAnimNode_CurveSlot, Source) == 0x000010, "Member 'FAnimNode_CurveSlot::Source' has a wrong offset!");
static_assert(offsetof(FAnimNode_CurveSlot, SlotName) == 0x000020, "Member 'FAnimNode_CurveSlot::SlotName' has a wrong offset!");
static_assert(offsetof(FAnimNode_CurveSlot, bAlwaysUpdateSourcePose) == 0x000028, "Member 'FAnimNode_CurveSlot::bAlwaysUpdateSourcePose' has a wrong offset!");

// ScriptStruct Indiana.AnimNode_EyeLidLimitEntry
// 0x005C (0x005C - 0x0000)
struct FAnimNode_EyeLidLimitEntry final
{
public:
	struct FBoneReference                         UpperEyelidBone;                                   // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         UpperEyelidMidBone;                                // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LowerEyelidBone;                                   // 0x0020(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LowerEyelidMidBone;                                // 0x0030(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bFlipAngles;                                       // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x1B];                                      // 0x0041(0x001B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_EyeLidLimitEntry) == 0x000004, "Wrong alignment on FAnimNode_EyeLidLimitEntry");
static_assert(sizeof(FAnimNode_EyeLidLimitEntry) == 0x00005C, "Wrong size on FAnimNode_EyeLidLimitEntry");
static_assert(offsetof(FAnimNode_EyeLidLimitEntry, UpperEyelidBone) == 0x000000, "Member 'FAnimNode_EyeLidLimitEntry::UpperEyelidBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_EyeLidLimitEntry, UpperEyelidMidBone) == 0x000010, "Member 'FAnimNode_EyeLidLimitEntry::UpperEyelidMidBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_EyeLidLimitEntry, LowerEyelidBone) == 0x000020, "Member 'FAnimNode_EyeLidLimitEntry::LowerEyelidBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_EyeLidLimitEntry, LowerEyelidMidBone) == 0x000030, "Member 'FAnimNode_EyeLidLimitEntry::LowerEyelidMidBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_EyeLidLimitEntry, bFlipAngles) == 0x000040, "Member 'FAnimNode_EyeLidLimitEntry::bFlipAngles' has a wrong offset!");

// ScriptStruct Indiana.AnimNode_EyeLidLimits
// 0x0020 (0x00E8 - 0x00C8)
struct FAnimNode_EyeLidLimits final : public FAnimNode_SkeletalControlBase
{
public:
	float                                         UpperLidCorrectAmount;                             // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverlapDistance;                                   // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAnimNode_EyeLidLimitEntry>     EyeLidEntries;                                     // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_EyeLidLimits) == 0x000008, "Wrong alignment on FAnimNode_EyeLidLimits");
static_assert(sizeof(FAnimNode_EyeLidLimits) == 0x0000E8, "Wrong size on FAnimNode_EyeLidLimits");
static_assert(offsetof(FAnimNode_EyeLidLimits, UpperLidCorrectAmount) == 0x0000C8, "Member 'FAnimNode_EyeLidLimits::UpperLidCorrectAmount' has a wrong offset!");
static_assert(offsetof(FAnimNode_EyeLidLimits, OverlapDistance) == 0x0000CC, "Member 'FAnimNode_EyeLidLimits::OverlapDistance' has a wrong offset!");
static_assert(offsetof(FAnimNode_EyeLidLimits, EyeLidEntries) == 0x0000D0, "Member 'FAnimNode_EyeLidLimits::EyeLidEntries' has a wrong offset!");

// ScriptStruct Indiana.CurveData
// 0x0090 (0x0090 - 0x0000)
struct FCurveData final
{
public:
	class FName                                   ScalerName;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     Parameter;                                         // 0x0008(0x0088)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCurveData) == 0x000008, "Wrong alignment on FCurveData");
static_assert(sizeof(FCurveData) == 0x000090, "Wrong size on FCurveData");
static_assert(offsetof(FCurveData, ScalerName) == 0x000000, "Member 'FCurveData::ScalerName' has a wrong offset!");
static_assert(offsetof(FCurveData, Parameter) == 0x000008, "Member 'FCurveData::Parameter' has a wrong offset!");

// ScriptStruct Indiana.AnimNode_EyeLookAt
// 0x00F8 (0x01C0 - 0x00C8)
struct alignas(0x10) FAnimNode_EyeLookAt final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         BoneToModify;                                      // 0x00C8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LookAtBone;                                        // 0x00D8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   LookAtSocket;                                      // 0x00E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LookAtLocation;                                    // 0x00F0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAxisOption                                   LookAtAxis;                                        // 0x00FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLookUpAxis;                                    // 0x00FD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAxisOption                                   LookUpAxis;                                        // 0x00FE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FF[0x1];                                       // 0x00FF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookAtClampUp;                                     // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtClampRight;                                  // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpolationTime;                                 // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDebug;                                      // 0x010C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearRotationFirst;                               // 0x010D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10E[0xB2];                                     // 0x010E(0x00B2)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_EyeLookAt) == 0x000010, "Wrong alignment on FAnimNode_EyeLookAt");
static_assert(sizeof(FAnimNode_EyeLookAt) == 0x0001C0, "Wrong size on FAnimNode_EyeLookAt");
static_assert(offsetof(FAnimNode_EyeLookAt, BoneToModify) == 0x0000C8, "Member 'FAnimNode_EyeLookAt::BoneToModify' has a wrong offset!");
static_assert(offsetof(FAnimNode_EyeLookAt, LookAtBone) == 0x0000D8, "Member 'FAnimNode_EyeLookAt::LookAtBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_EyeLookAt, LookAtSocket) == 0x0000E8, "Member 'FAnimNode_EyeLookAt::LookAtSocket' has a wrong offset!");
static_assert(offsetof(FAnimNode_EyeLookAt, LookAtLocation) == 0x0000F0, "Member 'FAnimNode_EyeLookAt::LookAtLocation' has a wrong offset!");
static_assert(offsetof(FAnimNode_EyeLookAt, LookAtAxis) == 0x0000FC, "Member 'FAnimNode_EyeLookAt::LookAtAxis' has a wrong offset!");
static_assert(offsetof(FAnimNode_EyeLookAt, bUseLookUpAxis) == 0x0000FD, "Member 'FAnimNode_EyeLookAt::bUseLookUpAxis' has a wrong offset!");
static_assert(offsetof(FAnimNode_EyeLookAt, LookUpAxis) == 0x0000FE, "Member 'FAnimNode_EyeLookAt::LookUpAxis' has a wrong offset!");
static_assert(offsetof(FAnimNode_EyeLookAt, LookAtClampUp) == 0x000100, "Member 'FAnimNode_EyeLookAt::LookAtClampUp' has a wrong offset!");
static_assert(offsetof(FAnimNode_EyeLookAt, LookAtClampRight) == 0x000104, "Member 'FAnimNode_EyeLookAt::LookAtClampRight' has a wrong offset!");
static_assert(offsetof(FAnimNode_EyeLookAt, InterpolationTime) == 0x000108, "Member 'FAnimNode_EyeLookAt::InterpolationTime' has a wrong offset!");
static_assert(offsetof(FAnimNode_EyeLookAt, bEnableDebug) == 0x00010C, "Member 'FAnimNode_EyeLookAt::bEnableDebug' has a wrong offset!");
static_assert(offsetof(FAnimNode_EyeLookAt, bClearRotationFirst) == 0x00010D, "Member 'FAnimNode_EyeLookAt::bClearRotationFirst' has a wrong offset!");

// ScriptStruct Indiana.MeleeAnimEvent
// 0x0010 (0x0010 - 0x0000)
struct FMeleeAnimEvent final
{
public:
	class UAnimMontage*                           Anim;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipIfHaveQueuedAction;                           // 0x000D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMeleeAnimEvent) == 0x000008, "Wrong alignment on FMeleeAnimEvent");
static_assert(sizeof(FMeleeAnimEvent) == 0x000010, "Wrong size on FMeleeAnimEvent");
static_assert(offsetof(FMeleeAnimEvent, Anim) == 0x000000, "Member 'FMeleeAnimEvent::Anim' has a wrong offset!");
static_assert(offsetof(FMeleeAnimEvent, Duration) == 0x000008, "Member 'FMeleeAnimEvent::Duration' has a wrong offset!");
static_assert(offsetof(FMeleeAnimEvent, bLoop) == 0x00000C, "Member 'FMeleeAnimEvent::bLoop' has a wrong offset!");
static_assert(offsetof(FMeleeAnimEvent, bSkipIfHaveQueuedAction) == 0x00000D, "Member 'FMeleeAnimEvent::bSkipIfHaveQueuedAction' has a wrong offset!");

// ScriptStruct Indiana.AnimNode_JointDriver
// 0x00A8 (0x0170 - 0x00C8)
struct alignas(0x10) FAnimNode_JointDriver final : public FAnimNode_SkeletalControlBase
{
public:
	class FName                                   IKChainName;                                       // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFootID                                       FootID;                                            // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FootDownDistance;                                  // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootUpDistance;                                    // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneReference                         BoneThatWillBeIKed;                                // 0x00DC(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         BoneToModify;                                      // 0x00EC(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         UpperLegJoint;                                     // 0x00FC(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         HipBoneToUseForHeightCalculation;                  // 0x010C(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PlantRollAmount;                                   // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitchClamp;                                     // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPitchClamp;                                     // 0x0124(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeightCompensation;                             // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SetTransformOnMiss;                                // 0x012C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoHeightCompensation;                             // 0x012D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPerformVelocityCompensation;                      // 0x012E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12F[0x41];                                     // 0x012F(0x0041)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_JointDriver) == 0x000010, "Wrong alignment on FAnimNode_JointDriver");
static_assert(sizeof(FAnimNode_JointDriver) == 0x000170, "Wrong size on FAnimNode_JointDriver");
static_assert(offsetof(FAnimNode_JointDriver, IKChainName) == 0x0000C8, "Member 'FAnimNode_JointDriver::IKChainName' has a wrong offset!");
static_assert(offsetof(FAnimNode_JointDriver, FootID) == 0x0000D0, "Member 'FAnimNode_JointDriver::FootID' has a wrong offset!");
static_assert(offsetof(FAnimNode_JointDriver, FootDownDistance) == 0x0000D4, "Member 'FAnimNode_JointDriver::FootDownDistance' has a wrong offset!");
static_assert(offsetof(FAnimNode_JointDriver, FootUpDistance) == 0x0000D8, "Member 'FAnimNode_JointDriver::FootUpDistance' has a wrong offset!");
static_assert(offsetof(FAnimNode_JointDriver, BoneThatWillBeIKed) == 0x0000DC, "Member 'FAnimNode_JointDriver::BoneThatWillBeIKed' has a wrong offset!");
static_assert(offsetof(FAnimNode_JointDriver, BoneToModify) == 0x0000EC, "Member 'FAnimNode_JointDriver::BoneToModify' has a wrong offset!");
static_assert(offsetof(FAnimNode_JointDriver, UpperLegJoint) == 0x0000FC, "Member 'FAnimNode_JointDriver::UpperLegJoint' has a wrong offset!");
static_assert(offsetof(FAnimNode_JointDriver, HipBoneToUseForHeightCalculation) == 0x00010C, "Member 'FAnimNode_JointDriver::HipBoneToUseForHeightCalculation' has a wrong offset!");
static_assert(offsetof(FAnimNode_JointDriver, PlantRollAmount) == 0x00011C, "Member 'FAnimNode_JointDriver::PlantRollAmount' has a wrong offset!");
static_assert(offsetof(FAnimNode_JointDriver, MaxPitchClamp) == 0x000120, "Member 'FAnimNode_JointDriver::MaxPitchClamp' has a wrong offset!");
static_assert(offsetof(FAnimNode_JointDriver, MinPitchClamp) == 0x000124, "Member 'FAnimNode_JointDriver::MinPitchClamp' has a wrong offset!");
static_assert(offsetof(FAnimNode_JointDriver, MaxHeightCompensation) == 0x000128, "Member 'FAnimNode_JointDriver::MaxHeightCompensation' has a wrong offset!");
static_assert(offsetof(FAnimNode_JointDriver, SetTransformOnMiss) == 0x00012C, "Member 'FAnimNode_JointDriver::SetTransformOnMiss' has a wrong offset!");
static_assert(offsetof(FAnimNode_JointDriver, bDoHeightCompensation) == 0x00012D, "Member 'FAnimNode_JointDriver::bDoHeightCompensation' has a wrong offset!");
static_assert(offsetof(FAnimNode_JointDriver, bPerformVelocityCompensation) == 0x00012E, "Member 'FAnimNode_JointDriver::bPerformVelocityCompensation' has a wrong offset!");

// ScriptStruct Indiana.AnimNode_LocomotionPlay
// 0x0010 (0x0090 - 0x0080)
struct FAnimNode_LocomotionPlay final : public FAnimNode_SequencePlayer
{
public:
	int32                                         CurrentSlot;                                       // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0xC];                                       // 0x0084(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_LocomotionPlay) == 0x000008, "Wrong alignment on FAnimNode_LocomotionPlay");
static_assert(sizeof(FAnimNode_LocomotionPlay) == 0x000090, "Wrong size on FAnimNode_LocomotionPlay");
static_assert(offsetof(FAnimNode_LocomotionPlay, CurrentSlot) == 0x000080, "Member 'FAnimNode_LocomotionPlay::CurrentSlot' has a wrong offset!");

// ScriptStruct Indiana.VendorStockDescriptor
// 0x0028 (0x0028 - 0x0000)
struct FVendorStockDescriptor final
{
public:
	class ULootTableData*                         LootTable;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOneOff;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRestricted;                                     // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreRestockDelay;                               // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UGenericLogicDataAsset*                 GenerationConditionsDataAsset;                     // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  DescriptorGuid;                                    // 0x0018(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVendorStockDescriptor) == 0x000008, "Wrong alignment on FVendorStockDescriptor");
static_assert(sizeof(FVendorStockDescriptor) == 0x000028, "Wrong size on FVendorStockDescriptor");
static_assert(offsetof(FVendorStockDescriptor, LootTable) == 0x000000, "Member 'FVendorStockDescriptor::LootTable' has a wrong offset!");
static_assert(offsetof(FVendorStockDescriptor, bIsOneOff) == 0x000008, "Member 'FVendorStockDescriptor::bIsOneOff' has a wrong offset!");
static_assert(offsetof(FVendorStockDescriptor, bIsRestricted) == 0x000009, "Member 'FVendorStockDescriptor::bIsRestricted' has a wrong offset!");
static_assert(offsetof(FVendorStockDescriptor, bIgnoreRestockDelay) == 0x00000A, "Member 'FVendorStockDescriptor::bIgnoreRestockDelay' has a wrong offset!");
static_assert(offsetof(FVendorStockDescriptor, GenerationConditionsDataAsset) == 0x000010, "Member 'FVendorStockDescriptor::GenerationConditionsDataAsset' has a wrong offset!");
static_assert(offsetof(FVendorStockDescriptor, DescriptorGuid) == 0x000018, "Member 'FVendorStockDescriptor::DescriptorGuid' has a wrong offset!");

// ScriptStruct Indiana.AnimNode_RandomSequenceNamed
// 0x0078 (0x0088 - 0x0010)
struct FAnimNode_RandomSequenceNamed final : public FAnimNode_Base
{
public:
	bool                                          bShuffleMode;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomTimeOnInitialize;                           // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomTimePercentage;                              // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomTimeStart;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ListName;                                          // 0x001C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SetUpdateName;                                     // 0x0024(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x58];                                      // 0x0030(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_RandomSequenceNamed) == 0x000008, "Wrong alignment on FAnimNode_RandomSequenceNamed");
static_assert(sizeof(FAnimNode_RandomSequenceNamed) == 0x000088, "Wrong size on FAnimNode_RandomSequenceNamed");
static_assert(offsetof(FAnimNode_RandomSequenceNamed, bShuffleMode) == 0x000010, "Member 'FAnimNode_RandomSequenceNamed::bShuffleMode' has a wrong offset!");
static_assert(offsetof(FAnimNode_RandomSequenceNamed, bRandomTimeOnInitialize) == 0x000011, "Member 'FAnimNode_RandomSequenceNamed::bRandomTimeOnInitialize' has a wrong offset!");
static_assert(offsetof(FAnimNode_RandomSequenceNamed, RandomTimePercentage) == 0x000014, "Member 'FAnimNode_RandomSequenceNamed::RandomTimePercentage' has a wrong offset!");
static_assert(offsetof(FAnimNode_RandomSequenceNamed, RandomTimeStart) == 0x000018, "Member 'FAnimNode_RandomSequenceNamed::RandomTimeStart' has a wrong offset!");
static_assert(offsetof(FAnimNode_RandomSequenceNamed, ListName) == 0x00001C, "Member 'FAnimNode_RandomSequenceNamed::ListName' has a wrong offset!");
static_assert(offsetof(FAnimNode_RandomSequenceNamed, SetUpdateName) == 0x000024, "Member 'FAnimNode_RandomSequenceNamed::SetUpdateName' has a wrong offset!");
static_assert(offsetof(FAnimNode_RandomSequenceNamed, PlayRate) == 0x00002C, "Member 'FAnimNode_RandomSequenceNamed::PlayRate' has a wrong offset!");

// ScriptStruct Indiana.RandomPlayerSequenceEntryNamed
// 0x0058 (0x0058 - 0x0000)
struct FRandomPlayerSequenceEntryNamed final
{
public:
	class UAnimSequence*                          Sequence;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChanceToPlay;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinLoopCount;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLoopCount;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPlayRate;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPlayRate;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAlphaBlend                            BlendIn;                                           // 0x0020(0x0030)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bMustPlayFromBeginning;                            // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreForInitialAnimation;                        // 0x0051(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreIfHelmetIsVisible;                          // 0x0052(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreIfWithinTalkRange;                          // 0x0053(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreIfOutsideOfTalkRange;                       // 0x0054(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRandomPlayerSequenceEntryNamed) == 0x000008, "Wrong alignment on FRandomPlayerSequenceEntryNamed");
static_assert(sizeof(FRandomPlayerSequenceEntryNamed) == 0x000058, "Wrong size on FRandomPlayerSequenceEntryNamed");
static_assert(offsetof(FRandomPlayerSequenceEntryNamed, Sequence) == 0x000000, "Member 'FRandomPlayerSequenceEntryNamed::Sequence' has a wrong offset!");
static_assert(offsetof(FRandomPlayerSequenceEntryNamed, ChanceToPlay) == 0x000008, "Member 'FRandomPlayerSequenceEntryNamed::ChanceToPlay' has a wrong offset!");
static_assert(offsetof(FRandomPlayerSequenceEntryNamed, MinLoopCount) == 0x00000C, "Member 'FRandomPlayerSequenceEntryNamed::MinLoopCount' has a wrong offset!");
static_assert(offsetof(FRandomPlayerSequenceEntryNamed, MaxLoopCount) == 0x000010, "Member 'FRandomPlayerSequenceEntryNamed::MaxLoopCount' has a wrong offset!");
static_assert(offsetof(FRandomPlayerSequenceEntryNamed, MinPlayRate) == 0x000014, "Member 'FRandomPlayerSequenceEntryNamed::MinPlayRate' has a wrong offset!");
static_assert(offsetof(FRandomPlayerSequenceEntryNamed, MaxPlayRate) == 0x000018, "Member 'FRandomPlayerSequenceEntryNamed::MaxPlayRate' has a wrong offset!");
static_assert(offsetof(FRandomPlayerSequenceEntryNamed, BlendIn) == 0x000020, "Member 'FRandomPlayerSequenceEntryNamed::BlendIn' has a wrong offset!");
static_assert(offsetof(FRandomPlayerSequenceEntryNamed, bMustPlayFromBeginning) == 0x000050, "Member 'FRandomPlayerSequenceEntryNamed::bMustPlayFromBeginning' has a wrong offset!");
static_assert(offsetof(FRandomPlayerSequenceEntryNamed, bIgnoreForInitialAnimation) == 0x000051, "Member 'FRandomPlayerSequenceEntryNamed::bIgnoreForInitialAnimation' has a wrong offset!");
static_assert(offsetof(FRandomPlayerSequenceEntryNamed, bIgnoreIfHelmetIsVisible) == 0x000052, "Member 'FRandomPlayerSequenceEntryNamed::bIgnoreIfHelmetIsVisible' has a wrong offset!");
static_assert(offsetof(FRandomPlayerSequenceEntryNamed, bIgnoreIfWithinTalkRange) == 0x000053, "Member 'FRandomPlayerSequenceEntryNamed::bIgnoreIfWithinTalkRange' has a wrong offset!");
static_assert(offsetof(FRandomPlayerSequenceEntryNamed, bIgnoreIfOutsideOfTalkRange) == 0x000054, "Member 'FRandomPlayerSequenceEntryNamed::bIgnoreIfOutsideOfTalkRange' has a wrong offset!");

// ScriptStruct Indiana.LoopRandomSequence
// 0x0028 (0x0028 - 0x0000)
struct FLoopRandomSequence final
{
public:
	TArray<struct FRandomPlayerSequenceEntryNamed> LoopSequences;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StartSequence;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StopSequence;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChanceToPlay;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreBarkWhileInBLEBranch;                       // 0x0024(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoopRandomSequence) == 0x000008, "Wrong alignment on FLoopRandomSequence");
static_assert(sizeof(FLoopRandomSequence) == 0x000028, "Wrong size on FLoopRandomSequence");
static_assert(offsetof(FLoopRandomSequence, LoopSequences) == 0x000000, "Member 'FLoopRandomSequence::LoopSequences' has a wrong offset!");
static_assert(offsetof(FLoopRandomSequence, StartSequence) == 0x000010, "Member 'FLoopRandomSequence::StartSequence' has a wrong offset!");
static_assert(offsetof(FLoopRandomSequence, StopSequence) == 0x000018, "Member 'FLoopRandomSequence::StopSequence' has a wrong offset!");
static_assert(offsetof(FLoopRandomSequence, ChanceToPlay) == 0x000020, "Member 'FLoopRandomSequence::ChanceToPlay' has a wrong offset!");
static_assert(offsetof(FLoopRandomSequence, bIgnoreBarkWhileInBLEBranch) == 0x000024, "Member 'FLoopRandomSequence::bIgnoreBarkWhileInBLEBranch' has a wrong offset!");

// ScriptStruct Indiana.AlertStateImageSet
// 0x0010 (0x0010 - 0x0000)
struct FAlertStateImageSet final
{
public:
	class UTexture2D*                             BackingTexture;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             FillTexture;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAlertStateImageSet) == 0x000008, "Wrong alignment on FAlertStateImageSet");
static_assert(sizeof(FAlertStateImageSet) == 0x000010, "Wrong size on FAlertStateImageSet");
static_assert(offsetof(FAlertStateImageSet, BackingTexture) == 0x000000, "Member 'FAlertStateImageSet::BackingTexture' has a wrong offset!");
static_assert(offsetof(FAlertStateImageSet, FillTexture) == 0x000008, "Member 'FAlertStateImageSet::FillTexture' has a wrong offset!");

// ScriptStruct Indiana.AwarenessImageSet
// 0x0060 (0x0060 - 0x0000)
struct FAwarenessImageSet final
{
public:
	struct FAlertStateImageSet                    ImageSetUnaware;                                   // 0x0000(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAlertStateImageSet                    ImageSetSuspicious;                                // 0x0010(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAlertStateImageSet                    ImageSetInvestigating;                             // 0x0020(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAlertStateImageSet                    ImageSetAlerted;                                   // 0x0030(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAlertStateImageSet                    ImageSetDisguise;                                  // 0x0040(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAlertStateImageSet                    ImageSetDisguiseAlert;                             // 0x0050(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAwarenessImageSet) == 0x000008, "Wrong alignment on FAwarenessImageSet");
static_assert(sizeof(FAwarenessImageSet) == 0x000060, "Wrong size on FAwarenessImageSet");
static_assert(offsetof(FAwarenessImageSet, ImageSetUnaware) == 0x000000, "Member 'FAwarenessImageSet::ImageSetUnaware' has a wrong offset!");
static_assert(offsetof(FAwarenessImageSet, ImageSetSuspicious) == 0x000010, "Member 'FAwarenessImageSet::ImageSetSuspicious' has a wrong offset!");
static_assert(offsetof(FAwarenessImageSet, ImageSetInvestigating) == 0x000020, "Member 'FAwarenessImageSet::ImageSetInvestigating' has a wrong offset!");
static_assert(offsetof(FAwarenessImageSet, ImageSetAlerted) == 0x000030, "Member 'FAwarenessImageSet::ImageSetAlerted' has a wrong offset!");
static_assert(offsetof(FAwarenessImageSet, ImageSetDisguise) == 0x000040, "Member 'FAwarenessImageSet::ImageSetDisguise' has a wrong offset!");
static_assert(offsetof(FAwarenessImageSet, ImageSetDisguiseAlert) == 0x000050, "Member 'FAwarenessImageSet::ImageSetDisguiseAlert' has a wrong offset!");

// ScriptStruct Indiana.AnimNode_RotateBoneAboutBone
// 0x0038 (0x0100 - 0x00C8)
struct FAnimNode_RotateBoneAboutBone final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         SourceBone;                                        // 0x00C8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         TargetBone;                                        // 0x00D8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x00E8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0xC];                                       // 0x00F4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_RotateBoneAboutBone) == 0x000008, "Wrong alignment on FAnimNode_RotateBoneAboutBone");
static_assert(sizeof(FAnimNode_RotateBoneAboutBone) == 0x000100, "Wrong size on FAnimNode_RotateBoneAboutBone");
static_assert(offsetof(FAnimNode_RotateBoneAboutBone, SourceBone) == 0x0000C8, "Member 'FAnimNode_RotateBoneAboutBone::SourceBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_RotateBoneAboutBone, TargetBone) == 0x0000D8, "Member 'FAnimNode_RotateBoneAboutBone::TargetBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_RotateBoneAboutBone, Rotation) == 0x0000E8, "Member 'FAnimNode_RotateBoneAboutBone::Rotation' has a wrong offset!");

// ScriptStruct Indiana.DamageTypeRequirement
// 0x0010 (0x0010 - 0x0000)
struct FDamageTypeRequirement final
{
public:
	int32                                         MinSkill;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UIndianaDamageType>         DamageType;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageTypeRequirement) == 0x000008, "Wrong alignment on FDamageTypeRequirement");
static_assert(sizeof(FDamageTypeRequirement) == 0x000010, "Wrong size on FDamageTypeRequirement");
static_assert(offsetof(FDamageTypeRequirement, MinSkill) == 0x000000, "Member 'FDamageTypeRequirement::MinSkill' has a wrong offset!");
static_assert(offsetof(FDamageTypeRequirement, DamageType) == 0x000008, "Member 'FDamageTypeRequirement::DamageType' has a wrong offset!");

// ScriptStruct Indiana.PropEntry
// 0x0068 (0x0068 - 0x0000)
struct FPropEntry final
{
public:
	struct FGameplayTag                           PropTag;                                           // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          SkeletalMeshToSpawn;                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StaticMeshToSpawn;                                 // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketToAttachTo;                                  // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SocketOffset;                                      // 0x0020(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SocketRotation;                                    // 0x002C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ParticleSystemToSpawn;                             // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParticleSocketToAttachTo;                          // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ParticleSocketOffset;                              // 0x0048(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ParticleSocketRotation;                            // 0x0054(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EDespawnRules                                 DespawnRule;                                       // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkeletalMeshUsesParentPose;                       // 0x0061(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPropEntry) == 0x000008, "Wrong alignment on FPropEntry");
static_assert(sizeof(FPropEntry) == 0x000068, "Wrong size on FPropEntry");
static_assert(offsetof(FPropEntry, PropTag) == 0x000000, "Member 'FPropEntry::PropTag' has a wrong offset!");
static_assert(offsetof(FPropEntry, SkeletalMeshToSpawn) == 0x000008, "Member 'FPropEntry::SkeletalMeshToSpawn' has a wrong offset!");
static_assert(offsetof(FPropEntry, StaticMeshToSpawn) == 0x000010, "Member 'FPropEntry::StaticMeshToSpawn' has a wrong offset!");
static_assert(offsetof(FPropEntry, SocketToAttachTo) == 0x000018, "Member 'FPropEntry::SocketToAttachTo' has a wrong offset!");
static_assert(offsetof(FPropEntry, SocketOffset) == 0x000020, "Member 'FPropEntry::SocketOffset' has a wrong offset!");
static_assert(offsetof(FPropEntry, SocketRotation) == 0x00002C, "Member 'FPropEntry::SocketRotation' has a wrong offset!");
static_assert(offsetof(FPropEntry, ParticleSystemToSpawn) == 0x000038, "Member 'FPropEntry::ParticleSystemToSpawn' has a wrong offset!");
static_assert(offsetof(FPropEntry, ParticleSocketToAttachTo) == 0x000040, "Member 'FPropEntry::ParticleSocketToAttachTo' has a wrong offset!");
static_assert(offsetof(FPropEntry, ParticleSocketOffset) == 0x000048, "Member 'FPropEntry::ParticleSocketOffset' has a wrong offset!");
static_assert(offsetof(FPropEntry, ParticleSocketRotation) == 0x000054, "Member 'FPropEntry::ParticleSocketRotation' has a wrong offset!");
static_assert(offsetof(FPropEntry, DespawnRule) == 0x000060, "Member 'FPropEntry::DespawnRule' has a wrong offset!");
static_assert(offsetof(FPropEntry, bSkeletalMeshUsesParentPose) == 0x000061, "Member 'FPropEntry::bSkeletalMeshUsesParentPose' has a wrong offset!");

// ScriptStruct Indiana.AppearanceMatch
// 0x0040 (0x0040 - 0x0000)
struct FAppearanceMatch
{
public:
	struct FGameplayTagContainer                  Genders;                                           // 0x0000(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  Views;                                             // 0x0020(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAppearanceMatch) == 0x000008, "Wrong alignment on FAppearanceMatch");
static_assert(sizeof(FAppearanceMatch) == 0x000040, "Wrong size on FAppearanceMatch");
static_assert(offsetof(FAppearanceMatch, Genders) == 0x000000, "Member 'FAppearanceMatch::Genders' has a wrong offset!");
static_assert(offsetof(FAppearanceMatch, Views) == 0x000020, "Member 'FAppearanceMatch::Views' has a wrong offset!");

// ScriptStruct Indiana.MainAppearances
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FMainAppearances final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMainAppearances) == 0x000008, "Wrong alignment on FMainAppearances");
static_assert(sizeof(FMainAppearances) == 0x000028, "Wrong size on FMainAppearances");

// ScriptStruct Indiana.AppliedAppearanceMod
// 0x0058 (0x0058 - 0x0000)
struct FAppliedAppearanceMod
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UModAppearances*                        ModAppearances;                                    // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UModVisual*                             SourceMod;                                         // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UModVisual*                             Mod;                                               // 0x0018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ComponentTags;                                     // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           RequiredTags;                                      // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAppliedAppearanceMod) == 0x000008, "Wrong alignment on FAppliedAppearanceMod");
static_assert(sizeof(FAppliedAppearanceMod) == 0x000058, "Wrong size on FAppliedAppearanceMod");
static_assert(offsetof(FAppliedAppearanceMod, ModAppearances) == 0x000008, "Member 'FAppliedAppearanceMod::ModAppearances' has a wrong offset!");
static_assert(offsetof(FAppliedAppearanceMod, SourceMod) == 0x000010, "Member 'FAppliedAppearanceMod::SourceMod' has a wrong offset!");
static_assert(offsetof(FAppliedAppearanceMod, Mod) == 0x000018, "Member 'FAppliedAppearanceMod::Mod' has a wrong offset!");
static_assert(offsetof(FAppliedAppearanceMod, ComponentTags) == 0x000020, "Member 'FAppliedAppearanceMod::ComponentTags' has a wrong offset!");
static_assert(offsetof(FAppliedAppearanceMod, RequiredTags) == 0x000030, "Member 'FAppliedAppearanceMod::RequiredTags' has a wrong offset!");

// ScriptStruct Indiana.HeadAppearanceMods
// 0x0038 (0x0090 - 0x0058)
struct FHeadAppearanceMods final : public FAppliedAppearanceMod
{
public:
	EHeadStyle                                    HeadStyle;                                         // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HairMorphTarget;                                   // 0x005C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHelmetVisible;                                    // 0x0064(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x13];                                      // 0x0065(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	class UPosedSkeletalMeshModVisual*            HairMeshMod;                                       // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPosedSkeletalMeshModVisual*            BeardMeshMod;                                      // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParamModVisual*                MaterialParamMods;                                 // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHeadAppearanceMods) == 0x000008, "Wrong alignment on FHeadAppearanceMods");
static_assert(sizeof(FHeadAppearanceMods) == 0x000090, "Wrong size on FHeadAppearanceMods");
static_assert(offsetof(FHeadAppearanceMods, HeadStyle) == 0x000058, "Member 'FHeadAppearanceMods::HeadStyle' has a wrong offset!");
static_assert(offsetof(FHeadAppearanceMods, HairMorphTarget) == 0x00005C, "Member 'FHeadAppearanceMods::HairMorphTarget' has a wrong offset!");
static_assert(offsetof(FHeadAppearanceMods, bHelmetVisible) == 0x000064, "Member 'FHeadAppearanceMods::bHelmetVisible' has a wrong offset!");
static_assert(offsetof(FHeadAppearanceMods, HairMeshMod) == 0x000078, "Member 'FHeadAppearanceMods::HairMeshMod' has a wrong offset!");
static_assert(offsetof(FHeadAppearanceMods, BeardMeshMod) == 0x000080, "Member 'FHeadAppearanceMods::BeardMeshMod' has a wrong offset!");
static_assert(offsetof(FHeadAppearanceMods, MaterialParamMods) == 0x000088, "Member 'FHeadAppearanceMods::MaterialParamMods' has a wrong offset!");

// ScriptStruct Indiana.AppearanceInstance
// 0x02C8 (0x02C8 - 0x0000)
struct FAppearanceInstance final
{
public:
	class FName                                   TargetMeshName;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAppearanceMatch                       AppearanceMatch;                                   // 0x0010(0x0040)(Edit, EditConst, NativeAccessSpecifierPublic)
	bool                                          bUseHeadAsBaseSkeleton;                            // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPosedSkeletalMeshModVisual*            SecondaryAppearanceMesh;                           // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParamModVisual*                AppearanceModVisual;                               // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMainAppearances                       CurrentAppearances;                                // 0x0068(0x0028)(NativeAccessSpecifierPublic)
	struct FMainAppearances                       PendingAppearances;                                // 0x0090(0x0028)(NativeAccessSpecifierPublic)
	struct FHeadAppearanceMods                    CurrentHeadAppearanceMods;                         // 0x00B8(0x0090)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHeadAppearanceMods                    PendingHeadAppearanceMods;                         // 0x0148(0x0090)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class UObject>, struct FAppliedAppearanceMod> CurrentMods;                                       // 0x01D8(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class UObject>, struct FAppliedAppearanceMod> PendingMods;                                       // 0x0228(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class FName>                           CurrentBaseMeshComponentTags;                      // 0x0278(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UFootstepData*                          CurrentFootstepData;                               // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActive;                                           // 0x0290(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x37];                                     // 0x0291(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAppearanceInstance) == 0x000008, "Wrong alignment on FAppearanceInstance");
static_assert(sizeof(FAppearanceInstance) == 0x0002C8, "Wrong size on FAppearanceInstance");
static_assert(offsetof(FAppearanceInstance, TargetMeshName) == 0x000000, "Member 'FAppearanceInstance::TargetMeshName' has a wrong offset!");
static_assert(offsetof(FAppearanceInstance, AppearanceMatch) == 0x000010, "Member 'FAppearanceInstance::AppearanceMatch' has a wrong offset!");
static_assert(offsetof(FAppearanceInstance, bUseHeadAsBaseSkeleton) == 0x000050, "Member 'FAppearanceInstance::bUseHeadAsBaseSkeleton' has a wrong offset!");
static_assert(offsetof(FAppearanceInstance, SecondaryAppearanceMesh) == 0x000058, "Member 'FAppearanceInstance::SecondaryAppearanceMesh' has a wrong offset!");
static_assert(offsetof(FAppearanceInstance, AppearanceModVisual) == 0x000060, "Member 'FAppearanceInstance::AppearanceModVisual' has a wrong offset!");
static_assert(offsetof(FAppearanceInstance, CurrentAppearances) == 0x000068, "Member 'FAppearanceInstance::CurrentAppearances' has a wrong offset!");
static_assert(offsetof(FAppearanceInstance, PendingAppearances) == 0x000090, "Member 'FAppearanceInstance::PendingAppearances' has a wrong offset!");
static_assert(offsetof(FAppearanceInstance, CurrentHeadAppearanceMods) == 0x0000B8, "Member 'FAppearanceInstance::CurrentHeadAppearanceMods' has a wrong offset!");
static_assert(offsetof(FAppearanceInstance, PendingHeadAppearanceMods) == 0x000148, "Member 'FAppearanceInstance::PendingHeadAppearanceMods' has a wrong offset!");
static_assert(offsetof(FAppearanceInstance, CurrentMods) == 0x0001D8, "Member 'FAppearanceInstance::CurrentMods' has a wrong offset!");
static_assert(offsetof(FAppearanceInstance, PendingMods) == 0x000228, "Member 'FAppearanceInstance::PendingMods' has a wrong offset!");
static_assert(offsetof(FAppearanceInstance, CurrentBaseMeshComponentTags) == 0x000278, "Member 'FAppearanceInstance::CurrentBaseMeshComponentTags' has a wrong offset!");
static_assert(offsetof(FAppearanceInstance, CurrentFootstepData) == 0x000288, "Member 'FAppearanceInstance::CurrentFootstepData' has a wrong offset!");
static_assert(offsetof(FAppearanceInstance, bActive) == 0x000290, "Member 'FAppearanceInstance::bActive' has a wrong offset!");

// ScriptStruct Indiana.ScaledActorEntry
// 0x0030 (0x0030 - 0x0000)
struct FScaledActorEntry final
{
public:
	int32                                         MinPlayerLevel;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ActorClass;                                        // 0x0008(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScaledActorEntry) == 0x000008, "Wrong alignment on FScaledActorEntry");
static_assert(sizeof(FScaledActorEntry) == 0x000030, "Wrong size on FScaledActorEntry");
static_assert(offsetof(FScaledActorEntry, MinPlayerLevel) == 0x000000, "Member 'FScaledActorEntry::MinPlayerLevel' has a wrong offset!");
static_assert(offsetof(FScaledActorEntry, ActorClass) == 0x000008, "Member 'FScaledActorEntry::ActorClass' has a wrong offset!");

// ScriptStruct Indiana.DisablePriorityMapElement
// 0x000C (0x000C - 0x0000)
struct FDisablePriorityMapElement final
{
public:
	struct FGameplayTag                           DisableType;                                       // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDisablePriority                              Priority;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDisablePriorityMapElement) == 0x000004, "Wrong alignment on FDisablePriorityMapElement");
static_assert(sizeof(FDisablePriorityMapElement) == 0x00000C, "Wrong size on FDisablePriorityMapElement");
static_assert(offsetof(FDisablePriorityMapElement, DisableType) == 0x000000, "Member 'FDisablePriorityMapElement::DisableType' has a wrong offset!");
static_assert(offsetof(FDisablePriorityMapElement, Priority) == 0x000008, "Member 'FDisablePriorityMapElement::Priority' has a wrong offset!");

// ScriptStruct Indiana.GenericGameStateHeader
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FGenericGameStateHeader
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGenericGameStateHeader) == 0x000004, "Wrong alignment on FGenericGameStateHeader");
static_assert(sizeof(FGenericGameStateHeader) == 0x00000C, "Wrong size on FGenericGameStateHeader");

// ScriptStruct Indiana.GenericVersionedGameStateHeader
// 0x0004 (0x0010 - 0x000C)
struct FGenericVersionedGameStateHeader : public FGenericGameStateHeader
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGenericVersionedGameStateHeader) == 0x000004, "Wrong alignment on FGenericVersionedGameStateHeader");
static_assert(sizeof(FGenericVersionedGameStateHeader) == 0x000010, "Wrong size on FGenericVersionedGameStateHeader");

// ScriptStruct Indiana.WwiseVOEvent
// 0x0020 (0x0020 - 0x0000)
struct FWwiseVOEvent final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          AudioEvent;                                        // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWwiseVOEvent) == 0x000008, "Wrong alignment on FWwiseVOEvent");
static_assert(sizeof(FWwiseVOEvent) == 0x000020, "Wrong size on FWwiseVOEvent");
static_assert(offsetof(FWwiseVOEvent, AudioEvent) == 0x000010, "Member 'FWwiseVOEvent::AudioEvent' has a wrong offset!");

// ScriptStruct Indiana.AppearanceCustomizations
// 0x0078 (0x0078 - 0x0000)
struct FAppearanceCustomizations final
{
public:
	float                                         Age;                                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UEyeColor*                              EyeColor;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHairAppearances*                       Hair;                                              // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHairColor*                             HairColor;                                         // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBrows*                                 Brows;                                             // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBeardAppearances*                      Beard;                                             // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBeardColor*                            BeardColor;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkinTone*                              SkinTone;                                          // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScar*                                  Scar;                                              // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDirt*                                  Dirt;                                              // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMakeup*                                Makeup;                                            // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               DetailMask;                                        // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DetailColor;                                       // 0x0060(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetailRoughness;                                   // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAppearanceCustomizations) == 0x000008, "Wrong alignment on FAppearanceCustomizations");
static_assert(sizeof(FAppearanceCustomizations) == 0x000078, "Wrong size on FAppearanceCustomizations");
static_assert(offsetof(FAppearanceCustomizations, Age) == 0x000000, "Member 'FAppearanceCustomizations::Age' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomizations, EyeColor) == 0x000008, "Member 'FAppearanceCustomizations::EyeColor' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomizations, Hair) == 0x000010, "Member 'FAppearanceCustomizations::Hair' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomizations, HairColor) == 0x000018, "Member 'FAppearanceCustomizations::HairColor' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomizations, Brows) == 0x000020, "Member 'FAppearanceCustomizations::Brows' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomizations, Beard) == 0x000028, "Member 'FAppearanceCustomizations::Beard' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomizations, BeardColor) == 0x000030, "Member 'FAppearanceCustomizations::BeardColor' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomizations, SkinTone) == 0x000038, "Member 'FAppearanceCustomizations::SkinTone' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomizations, Scar) == 0x000040, "Member 'FAppearanceCustomizations::Scar' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomizations, Dirt) == 0x000048, "Member 'FAppearanceCustomizations::Dirt' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomizations, Makeup) == 0x000050, "Member 'FAppearanceCustomizations::Makeup' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomizations, DetailMask) == 0x000058, "Member 'FAppearanceCustomizations::DetailMask' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomizations, DetailColor) == 0x000060, "Member 'FAppearanceCustomizations::DetailColor' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomizations, DetailRoughness) == 0x000070, "Member 'FAppearanceCustomizations::DetailRoughness' has a wrong offset!");

// ScriptStruct Indiana.MaterialParamDescription
// 0x0010 (0x0010 - 0x0000)
struct FMaterialParamDescription final
{
public:
	class FName                                   MaterialSlot;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaterialParam;                                     // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialParamDescription) == 0x000004, "Wrong alignment on FMaterialParamDescription");
static_assert(sizeof(FMaterialParamDescription) == 0x000010, "Wrong size on FMaterialParamDescription");
static_assert(offsetof(FMaterialParamDescription, MaterialSlot) == 0x000000, "Member 'FMaterialParamDescription::MaterialSlot' has a wrong offset!");
static_assert(offsetof(FMaterialParamDescription, MaterialParam) == 0x000008, "Member 'FMaterialParamDescription::MaterialParam' has a wrong offset!");

// ScriptStruct Indiana.IDSet
// 0x0050 (0x0050 - 0x0000)
struct FIDSet final
{
public:
	TSet<int32>                                   Ids;                                               // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIDSet) == 0x000008, "Wrong alignment on FIDSet");
static_assert(sizeof(FIDSet) == 0x000050, "Wrong size on FIDSet");
static_assert(offsetof(FIDSet, Ids) == 0x000000, "Member 'FIDSet::Ids' has a wrong offset!");

// ScriptStruct Indiana.OEIStringEntry
// 0x0058 (0x0058 - 0x0000)
struct FOEIStringEntry final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DefaultText;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 FemaleText;                                        // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AlternateXboxText;                                 // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AlternatePS5Text;                                  // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOEIStringEntry) == 0x000008, "Wrong alignment on FOEIStringEntry");
static_assert(sizeof(FOEIStringEntry) == 0x000058, "Wrong size on FOEIStringEntry");
static_assert(offsetof(FOEIStringEntry, ID) == 0x000000, "Member 'FOEIStringEntry::ID' has a wrong offset!");
static_assert(offsetof(FOEIStringEntry, DefaultText) == 0x000008, "Member 'FOEIStringEntry::DefaultText' has a wrong offset!");
static_assert(offsetof(FOEIStringEntry, FemaleText) == 0x000018, "Member 'FOEIStringEntry::FemaleText' has a wrong offset!");
static_assert(offsetof(FOEIStringEntry, AlternateXboxText) == 0x000028, "Member 'FOEIStringEntry::AlternateXboxText' has a wrong offset!");
static_assert(offsetof(FOEIStringEntry, AlternatePS5Text) == 0x000038, "Member 'FOEIStringEntry::AlternatePS5Text' has a wrong offset!");

// ScriptStruct Indiana.OEIStringTable
// 0x0100 (0x0100 - 0x0000)
struct FOEIStringTable final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<int32>                                   StringsWithTokens;                                 // 0x0010(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TMap<class FString, struct FIDSet>            StringsWithFemaleVO;                               // 0x0060(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TMap<int32, struct FOEIStringEntry>           Entries;                                           // 0x00B0(0x0050)(Edit, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOEIStringTable) == 0x000008, "Wrong alignment on FOEIStringTable");
static_assert(sizeof(FOEIStringTable) == 0x000100, "Wrong size on FOEIStringTable");
static_assert(offsetof(FOEIStringTable, Name) == 0x000000, "Member 'FOEIStringTable::Name' has a wrong offset!");
static_assert(offsetof(FOEIStringTable, StringsWithTokens) == 0x000010, "Member 'FOEIStringTable::StringsWithTokens' has a wrong offset!");
static_assert(offsetof(FOEIStringTable, StringsWithFemaleVO) == 0x000060, "Member 'FOEIStringTable::StringsWithFemaleVO' has a wrong offset!");
static_assert(offsetof(FOEIStringTable, Entries) == 0x0000B0, "Member 'FOEIStringTable::Entries' has a wrong offset!");

// ScriptStruct Indiana.FadeSettings
// 0x0038 (0x0038 - 0x0000)
struct FFadeSettings final
{
public:
	struct FVector                                RevealEmissiveColor;                               // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeadingEdgeBlend;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmissiveLevel;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeadingEdgeAmount;                                 // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RevealEdgeTightness;                               // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmissiveBaseValue;                                 // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               RevealRMEA;                                        // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               RevealNormal;                                      // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               RevealBaseColor;                                   // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFadeSettings) == 0x000008, "Wrong alignment on FFadeSettings");
static_assert(sizeof(FFadeSettings) == 0x000038, "Wrong size on FFadeSettings");
static_assert(offsetof(FFadeSettings, RevealEmissiveColor) == 0x000000, "Member 'FFadeSettings::RevealEmissiveColor' has a wrong offset!");
static_assert(offsetof(FFadeSettings, LeadingEdgeBlend) == 0x00000C, "Member 'FFadeSettings::LeadingEdgeBlend' has a wrong offset!");
static_assert(offsetof(FFadeSettings, EmissiveLevel) == 0x000010, "Member 'FFadeSettings::EmissiveLevel' has a wrong offset!");
static_assert(offsetof(FFadeSettings, LeadingEdgeAmount) == 0x000014, "Member 'FFadeSettings::LeadingEdgeAmount' has a wrong offset!");
static_assert(offsetof(FFadeSettings, RevealEdgeTightness) == 0x000018, "Member 'FFadeSettings::RevealEdgeTightness' has a wrong offset!");
static_assert(offsetof(FFadeSettings, EmissiveBaseValue) == 0x00001C, "Member 'FFadeSettings::EmissiveBaseValue' has a wrong offset!");
static_assert(offsetof(FFadeSettings, RevealRMEA) == 0x000020, "Member 'FFadeSettings::RevealRMEA' has a wrong offset!");
static_assert(offsetof(FFadeSettings, RevealNormal) == 0x000028, "Member 'FFadeSettings::RevealNormal' has a wrong offset!");
static_assert(offsetof(FFadeSettings, RevealBaseColor) == 0x000030, "Member 'FFadeSettings::RevealBaseColor' has a wrong offset!");

// ScriptStruct Indiana.AptitudeTextures
// 0x0078 (0x0078 - 0x0000)
struct FAptitudeTextures final
{
public:
	TSoftObjectPtr<class UTexture>                Uninteractable;                                    // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                Highlighted;                                       // 0x0028(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                Icon;                                              // 0x0050(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAptitudeTextures) == 0x000008, "Wrong alignment on FAptitudeTextures");
static_assert(sizeof(FAptitudeTextures) == 0x000078, "Wrong size on FAptitudeTextures");
static_assert(offsetof(FAptitudeTextures, Uninteractable) == 0x000000, "Member 'FAptitudeTextures::Uninteractable' has a wrong offset!");
static_assert(offsetof(FAptitudeTextures, Highlighted) == 0x000028, "Member 'FAptitudeTextures::Highlighted' has a wrong offset!");
static_assert(offsetof(FAptitudeTextures, Icon) == 0x000050, "Member 'FAptitudeTextures::Icon' has a wrong offset!");

// ScriptStruct Indiana.MapShipDestinations
// 0x0050 (0x0050 - 0x0000)
struct FMapShipDestinations final
{
public:
	TMap<struct FGuid, class UShipDestinationData*> Destinations;                                      // 0x0000(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapShipDestinations) == 0x000008, "Wrong alignment on FMapShipDestinations");
static_assert(sizeof(FMapShipDestinations) == 0x000050, "Wrong size on FMapShipDestinations");
static_assert(offsetof(FMapShipDestinations, Destinations) == 0x000000, "Member 'FMapShipDestinations::Destinations' has a wrong offset!");

// ScriptStruct Indiana.ArmorModifierEntry
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FArmorModifierEntry final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArmorModifierEntry) == 0x000008, "Wrong alignment on FArmorModifierEntry");
static_assert(sizeof(FArmorModifierEntry) == 0x000050, "Wrong size on FArmorModifierEntry");

// ScriptStruct Indiana.QuestItmDefinition
// 0x0008 (0x0018 - 0x0010)
struct FQuestItmDefinition final : public FBaseItemDefinition
{
public:
	TSubclassOf<class UQuestItem>                 QuestItemClass;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestItmDefinition) == 0x000008, "Wrong alignment on FQuestItmDefinition");
static_assert(sizeof(FQuestItmDefinition) == 0x000018, "Wrong size on FQuestItmDefinition");
static_assert(offsetof(FQuestItmDefinition, QuestItemClass) == 0x000010, "Member 'FQuestItmDefinition::QuestItemClass' has a wrong offset!");

// ScriptStruct Indiana.ArmorModifier
// 0x0040 (0x0040 - 0x0000)
struct FArmorModifier final
{
public:
	struct FGameplayTagContainer                  EffectedBodyParts;                                 // 0x0000(0x0020)(Edit, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UIndianaDamageType>> DamageTypes;                                       // 0x0020(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         DamageThreshold;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageThresholdPercent;                            // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageResistance;                                  // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageResistancePercent;                           // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArmorModifier) == 0x000008, "Wrong alignment on FArmorModifier");
static_assert(sizeof(FArmorModifier) == 0x000040, "Wrong size on FArmorModifier");
static_assert(offsetof(FArmorModifier, EffectedBodyParts) == 0x000000, "Member 'FArmorModifier::EffectedBodyParts' has a wrong offset!");
static_assert(offsetof(FArmorModifier, DamageTypes) == 0x000020, "Member 'FArmorModifier::DamageTypes' has a wrong offset!");
static_assert(offsetof(FArmorModifier, DamageThreshold) == 0x000030, "Member 'FArmorModifier::DamageThreshold' has a wrong offset!");
static_assert(offsetof(FArmorModifier, DamageThresholdPercent) == 0x000034, "Member 'FArmorModifier::DamageThresholdPercent' has a wrong offset!");
static_assert(offsetof(FArmorModifier, DamageResistance) == 0x000038, "Member 'FArmorModifier::DamageResistance' has a wrong offset!");
static_assert(offsetof(FArmorModifier, DamageResistancePercent) == 0x00003C, "Member 'FArmorModifier::DamageResistancePercent' has a wrong offset!");

// ScriptStruct Indiana.ArmorPieceEntry
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x08) FArmorPieceEntry final
{
public:
	uint8                                         Pad_0[0x70];                                       // 0x0000(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArmorPieceEntry) == 0x000008, "Wrong alignment on FArmorPieceEntry");
static_assert(sizeof(FArmorPieceEntry) == 0x000070, "Wrong size on FArmorPieceEntry");

// ScriptStruct Indiana.BlockedActorData
// 0x0028 (0x0028 - 0x0000)
struct FBlockedActorData final
{
public:
	int32                                         Slot;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEntryLocationStatus                          LocationStatus;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          BlockingActors;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UPrimitiveComponent>> BlockingComponents;                                // 0x0018(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlockedActorData) == 0x000008, "Wrong alignment on FBlockedActorData");
static_assert(sizeof(FBlockedActorData) == 0x000028, "Wrong size on FBlockedActorData");
static_assert(offsetof(FBlockedActorData, Slot) == 0x000000, "Member 'FBlockedActorData::Slot' has a wrong offset!");
static_assert(offsetof(FBlockedActorData, LocationStatus) == 0x000004, "Member 'FBlockedActorData::LocationStatus' has a wrong offset!");
static_assert(offsetof(FBlockedActorData, BlockingActors) == 0x000008, "Member 'FBlockedActorData::BlockingActors' has a wrong offset!");
static_assert(offsetof(FBlockedActorData, BlockingComponents) == 0x000018, "Member 'FBlockedActorData::BlockingComponents' has a wrong offset!");

// ScriptStruct Indiana.ArmorData
// 0x0048 (0x0048 - 0x0000)
struct FArmorData final
{
public:
	int32                                         PhysicalDT;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalDR;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ThermalDT;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ThermalDR;                                         // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnergyDT;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnergyDR;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShockDT;                                           // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShockDR;                                           // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CorrosionDT;                                       // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CorrosionDR;                                       // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NRayDT;                                            // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NRayDR;                                            // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ColdDT;                                            // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ColdDR;                                            // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageThreshold;                                   // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageResistance;                                  // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ArmorType;                                         // 0x0040(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArmorData) == 0x000004, "Wrong alignment on FArmorData");
static_assert(sizeof(FArmorData) == 0x000048, "Wrong size on FArmorData");
static_assert(offsetof(FArmorData, PhysicalDT) == 0x000000, "Member 'FArmorData::PhysicalDT' has a wrong offset!");
static_assert(offsetof(FArmorData, PhysicalDR) == 0x000004, "Member 'FArmorData::PhysicalDR' has a wrong offset!");
static_assert(offsetof(FArmorData, ThermalDT) == 0x000008, "Member 'FArmorData::ThermalDT' has a wrong offset!");
static_assert(offsetof(FArmorData, ThermalDR) == 0x00000C, "Member 'FArmorData::ThermalDR' has a wrong offset!");
static_assert(offsetof(FArmorData, EnergyDT) == 0x000010, "Member 'FArmorData::EnergyDT' has a wrong offset!");
static_assert(offsetof(FArmorData, EnergyDR) == 0x000014, "Member 'FArmorData::EnergyDR' has a wrong offset!");
static_assert(offsetof(FArmorData, ShockDT) == 0x000018, "Member 'FArmorData::ShockDT' has a wrong offset!");
static_assert(offsetof(FArmorData, ShockDR) == 0x00001C, "Member 'FArmorData::ShockDR' has a wrong offset!");
static_assert(offsetof(FArmorData, CorrosionDT) == 0x000020, "Member 'FArmorData::CorrosionDT' has a wrong offset!");
static_assert(offsetof(FArmorData, CorrosionDR) == 0x000024, "Member 'FArmorData::CorrosionDR' has a wrong offset!");
static_assert(offsetof(FArmorData, NRayDT) == 0x000028, "Member 'FArmorData::NRayDT' has a wrong offset!");
static_assert(offsetof(FArmorData, NRayDR) == 0x00002C, "Member 'FArmorData::NRayDR' has a wrong offset!");
static_assert(offsetof(FArmorData, ColdDT) == 0x000030, "Member 'FArmorData::ColdDT' has a wrong offset!");
static_assert(offsetof(FArmorData, ColdDR) == 0x000034, "Member 'FArmorData::ColdDR' has a wrong offset!");
static_assert(offsetof(FArmorData, DamageThreshold) == 0x000038, "Member 'FArmorData::DamageThreshold' has a wrong offset!");
static_assert(offsetof(FArmorData, DamageResistance) == 0x00003C, "Member 'FArmorData::DamageResistance' has a wrong offset!");
static_assert(offsetof(FArmorData, ArmorType) == 0x000040, "Member 'FArmorData::ArmorType' has a wrong offset!");

// ScriptStruct Indiana.ArmorPiece
// 0x0068 (0x0068 - 0x0000)
struct FArmorPiece final
{
public:
	struct FGameplayTagContainer                  BodyParts;                                         // 0x0000(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FArmorData                             ArmorData;                                         // 0x0020(0x0048)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArmorPiece) == 0x000008, "Wrong alignment on FArmorPiece");
static_assert(sizeof(FArmorPiece) == 0x000068, "Wrong size on FArmorPiece");
static_assert(offsetof(FArmorPiece, BodyParts) == 0x000000, "Member 'FArmorPiece::BodyParts' has a wrong offset!");
static_assert(offsetof(FArmorPiece, ArmorData) == 0x000020, "Member 'FArmorPiece::ArmorData' has a wrong offset!");

// ScriptStruct Indiana.SpecializedAmmoClasses
// 0x0010 (0x0010 - 0x0000)
struct FSpecializedAmmoClasses final
{
public:
	TArray<TSubclassOf<class UAmmo>>              Classes;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecializedAmmoClasses) == 0x000008, "Wrong alignment on FSpecializedAmmoClasses");
static_assert(sizeof(FSpecializedAmmoClasses) == 0x000010, "Wrong size on FSpecializedAmmoClasses");
static_assert(offsetof(FSpecializedAmmoClasses, Classes) == 0x000000, "Member 'FSpecializedAmmoClasses::Classes' has a wrong offset!");

// ScriptStruct Indiana.DegradableItemDefinition
// 0x0008 (0x0018 - 0x0010)
struct FDegradableItemDefinition : public FBaseItemDefinition
{
public:
	float                                         Condition;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDegradableItemDefinition) == 0x000008, "Wrong alignment on FDegradableItemDefinition");
static_assert(sizeof(FDegradableItemDefinition) == 0x000018, "Wrong size on FDegradableItemDefinition");
static_assert(offsetof(FDegradableItemDefinition, Condition) == 0x000010, "Member 'FDegradableItemDefinition::Condition' has a wrong offset!");

// ScriptStruct Indiana.TargetCone
// 0x0030 (0x0030 - 0x0000)
struct FTargetCone final
{
public:
	class URpgStat*                               CollisionSizeStat;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ConeHalfAngle;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EConeAxis                                     ConeAxis;                                          // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInvertAxis;                                       // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                SocketOffset;                                      // 0x0014(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESpellEffectTarget                            SourceType;                                        // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPenetratesWalls;                                  // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CollisionSocket;                                   // 0x0024(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMeshTarget                                   MeshTarget;                                        // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTargetCone) == 0x000008, "Wrong alignment on FTargetCone");
static_assert(sizeof(FTargetCone) == 0x000030, "Wrong size on FTargetCone");
static_assert(offsetof(FTargetCone, CollisionSizeStat) == 0x000000, "Member 'FTargetCone::CollisionSizeStat' has a wrong offset!");
static_assert(offsetof(FTargetCone, ConeHalfAngle) == 0x000008, "Member 'FTargetCone::ConeHalfAngle' has a wrong offset!");
static_assert(offsetof(FTargetCone, ConeAxis) == 0x00000C, "Member 'FTargetCone::ConeAxis' has a wrong offset!");
static_assert(offsetof(FTargetCone, bInvertAxis) == 0x00000D, "Member 'FTargetCone::bInvertAxis' has a wrong offset!");
static_assert(offsetof(FTargetCone, Radius) == 0x000010, "Member 'FTargetCone::Radius' has a wrong offset!");
static_assert(offsetof(FTargetCone, SocketOffset) == 0x000014, "Member 'FTargetCone::SocketOffset' has a wrong offset!");
static_assert(offsetof(FTargetCone, SourceType) == 0x000020, "Member 'FTargetCone::SourceType' has a wrong offset!");
static_assert(offsetof(FTargetCone, bPenetratesWalls) == 0x000021, "Member 'FTargetCone::bPenetratesWalls' has a wrong offset!");
static_assert(offsetof(FTargetCone, CollisionSocket) == 0x000024, "Member 'FTargetCone::CollisionSocket' has a wrong offset!");
static_assert(offsetof(FTargetCone, MeshTarget) == 0x00002C, "Member 'FTargetCone::MeshTarget' has a wrong offset!");

// ScriptStruct Indiana.TransformedShape
// 0x0040 (0x0040 - 0x0000)
struct FTransformedShape final
{
public:
	class UShape*                                 Shape;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ShapeTransform;                                    // 0x0010(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTransformedShape) == 0x000010, "Wrong alignment on FTransformedShape");
static_assert(sizeof(FTransformedShape) == 0x000040, "Wrong size on FTransformedShape");
static_assert(offsetof(FTransformedShape, Shape) == 0x000000, "Member 'FTransformedShape::Shape' has a wrong offset!");
static_assert(offsetof(FTransformedShape, ShapeTransform) == 0x000010, "Member 'FTransformedShape::ShapeTransform' has a wrong offset!");

// ScriptStruct Indiana.AreaOfEffect
// 0x0060 (0x0060 - 0x0000)
struct FAreaOfEffect final
{
public:
	struct FTransformedShape                      CollisionShapeInfo;                                // 0x0000(0x0040)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class URpgStat*                               CollisionSizeStat;                                 // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESpellEffectTarget                            SourceType;                                        // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIgnoreSources;                                    // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOnlyTargetPlayerHostiles;                         // 0x004A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPenetratesWalls;                                  // 0x004B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CollisionSocket;                                   // 0x004C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMeshTarget                                   MeshTarget;                                        // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_55[0xB];                                       // 0x0055(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAreaOfEffect) == 0x000010, "Wrong alignment on FAreaOfEffect");
static_assert(sizeof(FAreaOfEffect) == 0x000060, "Wrong size on FAreaOfEffect");
static_assert(offsetof(FAreaOfEffect, CollisionShapeInfo) == 0x000000, "Member 'FAreaOfEffect::CollisionShapeInfo' has a wrong offset!");
static_assert(offsetof(FAreaOfEffect, CollisionSizeStat) == 0x000040, "Member 'FAreaOfEffect::CollisionSizeStat' has a wrong offset!");
static_assert(offsetof(FAreaOfEffect, SourceType) == 0x000048, "Member 'FAreaOfEffect::SourceType' has a wrong offset!");
static_assert(offsetof(FAreaOfEffect, bIgnoreSources) == 0x000049, "Member 'FAreaOfEffect::bIgnoreSources' has a wrong offset!");
static_assert(offsetof(FAreaOfEffect, bOnlyTargetPlayerHostiles) == 0x00004A, "Member 'FAreaOfEffect::bOnlyTargetPlayerHostiles' has a wrong offset!");
static_assert(offsetof(FAreaOfEffect, bPenetratesWalls) == 0x00004B, "Member 'FAreaOfEffect::bPenetratesWalls' has a wrong offset!");
static_assert(offsetof(FAreaOfEffect, CollisionSocket) == 0x00004C, "Member 'FAreaOfEffect::CollisionSocket' has a wrong offset!");
static_assert(offsetof(FAreaOfEffect, MeshTarget) == 0x000054, "Member 'FAreaOfEffect::MeshTarget' has a wrong offset!");

// ScriptStruct Indiana.TargetEffect
// 0x00D0 (0x00D0 - 0x0000)
struct FTargetEffect final
{
public:
	ESpellEffectTarget                            SpellEffectTarget;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStatusEffect*>                  StatusEffects;                                     // 0x0008(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USpellConditional*>              EffectTargetConditionals;                          // 0x0018(0x0010)(Edit, ExportObject, ZeroConstructor, NoClear, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ESpellEffectDirectionType                     EffectDirectionType;                               // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationAngle;                                     // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomlyNegateRotationAngle;                      // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInverseDirection;                                 // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceTwoDimensionalDirection;                     // 0x0032(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0xD];                                       // 0x0033(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAreaOfEffect                          AreaOfEffect;                                      // 0x0040(0x0060)(Edit, NoDestructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FTargetCone                            TargetCone;                                        // 0x00A0(0x0030)(Edit, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTargetEffect) == 0x000010, "Wrong alignment on FTargetEffect");
static_assert(sizeof(FTargetEffect) == 0x0000D0, "Wrong size on FTargetEffect");
static_assert(offsetof(FTargetEffect, SpellEffectTarget) == 0x000000, "Member 'FTargetEffect::SpellEffectTarget' has a wrong offset!");
static_assert(offsetof(FTargetEffect, StatusEffects) == 0x000008, "Member 'FTargetEffect::StatusEffects' has a wrong offset!");
static_assert(offsetof(FTargetEffect, EffectTargetConditionals) == 0x000018, "Member 'FTargetEffect::EffectTargetConditionals' has a wrong offset!");
static_assert(offsetof(FTargetEffect, EffectDirectionType) == 0x000028, "Member 'FTargetEffect::EffectDirectionType' has a wrong offset!");
static_assert(offsetof(FTargetEffect, RotationAngle) == 0x00002C, "Member 'FTargetEffect::RotationAngle' has a wrong offset!");
static_assert(offsetof(FTargetEffect, bRandomlyNegateRotationAngle) == 0x000030, "Member 'FTargetEffect::bRandomlyNegateRotationAngle' has a wrong offset!");
static_assert(offsetof(FTargetEffect, bInverseDirection) == 0x000031, "Member 'FTargetEffect::bInverseDirection' has a wrong offset!");
static_assert(offsetof(FTargetEffect, bForceTwoDimensionalDirection) == 0x000032, "Member 'FTargetEffect::bForceTwoDimensionalDirection' has a wrong offset!");
static_assert(offsetof(FTargetEffect, AreaOfEffect) == 0x000040, "Member 'FTargetEffect::AreaOfEffect' has a wrong offset!");
static_assert(offsetof(FTargetEffect, TargetCone) == 0x0000A0, "Member 'FTargetEffect::TargetCone' has a wrong offset!");

// ScriptStruct Indiana.SpellEffectByEvent
// 0x0028 (0x0028 - 0x0000)
struct FSpellEffectByEvent final
{
public:
	class UEventListener*                         ApplyEvent;                                        // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEventListener*                         RemoveEvent;                                       // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTargetEffect>                  TargetEffects;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bRemoveSingleStack;                                // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpellEffectByEvent) == 0x000008, "Wrong alignment on FSpellEffectByEvent");
static_assert(sizeof(FSpellEffectByEvent) == 0x000028, "Wrong size on FSpellEffectByEvent");
static_assert(offsetof(FSpellEffectByEvent, ApplyEvent) == 0x000000, "Member 'FSpellEffectByEvent::ApplyEvent' has a wrong offset!");
static_assert(offsetof(FSpellEffectByEvent, RemoveEvent) == 0x000008, "Member 'FSpellEffectByEvent::RemoveEvent' has a wrong offset!");
static_assert(offsetof(FSpellEffectByEvent, TargetEffects) == 0x000010, "Member 'FSpellEffectByEvent::TargetEffects' has a wrong offset!");
static_assert(offsetof(FSpellEffectByEvent, bRemoveSingleStack) == 0x000020, "Member 'FSpellEffectByEvent::bRemoveSingleStack' has a wrong offset!");

// ScriptStruct Indiana.ArmorItemDefinition
// 0x0000 (0x0018 - 0x0018)
struct FArmorItemDefinition : public FDegradableItemDefinition
{
};
static_assert(alignof(FArmorItemDefinition) == 0x000008, "Wrong alignment on FArmorItemDefinition");
static_assert(sizeof(FArmorItemDefinition) == 0x000018, "Wrong size on FArmorItemDefinition");

// ScriptStruct Indiana.ReputationElement
// 0x0010 (0x0010 - 0x0000)
struct FReputationElement final
{
public:
	int32                                         PositiveIndex;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NegativeIndex;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReputationData*                        ReputationData;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReputationElement) == 0x000008, "Wrong alignment on FReputationElement");
static_assert(sizeof(FReputationElement) == 0x000010, "Wrong size on FReputationElement");
static_assert(offsetof(FReputationElement, PositiveIndex) == 0x000000, "Member 'FReputationElement::PositiveIndex' has a wrong offset!");
static_assert(offsetof(FReputationElement, NegativeIndex) == 0x000004, "Member 'FReputationElement::NegativeIndex' has a wrong offset!");
static_assert(offsetof(FReputationElement, ReputationData) == 0x000008, "Member 'FReputationElement::ReputationData' has a wrong offset!");

// ScriptStruct Indiana.ArmorModDampeningItemDefinition
// 0x0008 (0x0020 - 0x0018)
struct FArmorModDampeningItemDefinition final : public FArmorItemDefinition
{
public:
	TSubclassOf<class UArmorModDampening>         DampeningModClass;                                 // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArmorModDampeningItemDefinition) == 0x000008, "Wrong alignment on FArmorModDampeningItemDefinition");
static_assert(sizeof(FArmorModDampeningItemDefinition) == 0x000020, "Wrong size on FArmorModDampeningItemDefinition");
static_assert(offsetof(FArmorModDampeningItemDefinition, DampeningModClass) == 0x000018, "Member 'FArmorModDampeningItemDefinition::DampeningModClass' has a wrong offset!");

// ScriptStruct Indiana.ArmorModResistanceItemDefinition
// 0x0008 (0x0020 - 0x0018)
struct FArmorModResistanceItemDefinition final : public FArmorItemDefinition
{
public:
	TSubclassOf<class UArmorModResistance>        ResistanceModClass;                                // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArmorModResistanceItemDefinition) == 0x000008, "Wrong alignment on FArmorModResistanceItemDefinition");
static_assert(sizeof(FArmorModResistanceItemDefinition) == 0x000020, "Wrong size on FArmorModResistanceItemDefinition");
static_assert(offsetof(FArmorModResistanceItemDefinition, ResistanceModClass) == 0x000018, "Member 'FArmorModResistanceItemDefinition::ResistanceModClass' has a wrong offset!");

// ScriptStruct Indiana.TalkingIdleEntry
// 0x0090 (0x0090 - 0x0000)
struct FTalkingIdleEntry final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StartSequence;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLoopRandomSequence> TalkingSequences;                                  // 0x0010(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FRandomPlayerSequenceEntryNamed> Idle;                                              // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRandomPlayerSequenceEntryNamed> DialogIdle;                                        // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLoopRandomSequence>            IdleStates;                                        // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkingIdleEntry) == 0x000008, "Wrong alignment on FTalkingIdleEntry");
static_assert(sizeof(FTalkingIdleEntry) == 0x000090, "Wrong size on FTalkingIdleEntry");
static_assert(offsetof(FTalkingIdleEntry, Name) == 0x000000, "Member 'FTalkingIdleEntry::Name' has a wrong offset!");
static_assert(offsetof(FTalkingIdleEntry, StartSequence) == 0x000008, "Member 'FTalkingIdleEntry::StartSequence' has a wrong offset!");
static_assert(offsetof(FTalkingIdleEntry, TalkingSequences) == 0x000010, "Member 'FTalkingIdleEntry::TalkingSequences' has a wrong offset!");
static_assert(offsetof(FTalkingIdleEntry, Idle) == 0x000060, "Member 'FTalkingIdleEntry::Idle' has a wrong offset!");
static_assert(offsetof(FTalkingIdleEntry, DialogIdle) == 0x000070, "Member 'FTalkingIdleEntry::DialogIdle' has a wrong offset!");
static_assert(offsetof(FTalkingIdleEntry, IdleStates) == 0x000080, "Member 'FTalkingIdleEntry::IdleStates' has a wrong offset!");

// ScriptStruct Indiana.ArmorModUtilityItemDefinition
// 0x0008 (0x0020 - 0x0018)
struct FArmorModUtilityItemDefinition final : public FArmorItemDefinition
{
public:
	TSubclassOf<class UArmorModUtility>           UtilityModClass;                                   // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArmorModUtilityItemDefinition) == 0x000008, "Wrong alignment on FArmorModUtilityItemDefinition");
static_assert(sizeof(FArmorModUtilityItemDefinition) == 0x000020, "Wrong size on FArmorModUtilityItemDefinition");
static_assert(offsetof(FArmorModUtilityItemDefinition, UtilityModClass) == 0x000018, "Member 'FArmorModUtilityItemDefinition::UtilityModClass' has a wrong offset!");

// ScriptStruct Indiana.ArmorModArmoringItemDefinition
// 0x0008 (0x0020 - 0x0018)
struct FArmorModArmoringItemDefinition final : public FArmorItemDefinition
{
public:
	TSubclassOf<class UArmorModArmoring>          ArmoringModClass;                                  // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArmorModArmoringItemDefinition) == 0x000008, "Wrong alignment on FArmorModArmoringItemDefinition");
static_assert(sizeof(FArmorModArmoringItemDefinition) == 0x000020, "Wrong size on FArmorModArmoringItemDefinition");
static_assert(offsetof(FArmorModArmoringItemDefinition, ArmoringModClass) == 0x000018, "Member 'FArmorModArmoringItemDefinition::ArmoringModClass' has a wrong offset!");

// ScriptStruct Indiana.ChatterEventRestrictedCharacterGroups
// 0x0050 (0x0050 - 0x0000)
struct FChatterEventRestrictedCharacterGroups final
{
public:
	TSet<ECharacterGrouping>                      Values;                                            // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChatterEventRestrictedCharacterGroups) == 0x000008, "Wrong alignment on FChatterEventRestrictedCharacterGroups");
static_assert(sizeof(FChatterEventRestrictedCharacterGroups) == 0x000050, "Wrong size on FChatterEventRestrictedCharacterGroups");
static_assert(offsetof(FChatterEventRestrictedCharacterGroups, Values) == 0x000000, "Member 'FChatterEventRestrictedCharacterGroups::Values' has a wrong offset!");

// ScriptStruct Indiana.NewArmorModVisual
// 0x0020 (0x0020 - 0x0000)
struct FNewArmorModVisual final
{
public:
	class UModAppearances*                        ModAppearances;                                    // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAppliesToAllArmorSets;                            // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           ArmorSets;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNewArmorModVisual) == 0x000008, "Wrong alignment on FNewArmorModVisual");
static_assert(sizeof(FNewArmorModVisual) == 0x000020, "Wrong size on FNewArmorModVisual");
static_assert(offsetof(FNewArmorModVisual, ModAppearances) == 0x000000, "Member 'FNewArmorModVisual::ModAppearances' has a wrong offset!");
static_assert(offsetof(FNewArmorModVisual, bAppliesToAllArmorSets) == 0x000008, "Member 'FNewArmorModVisual::bAppliesToAllArmorSets' has a wrong offset!");
static_assert(offsetof(FNewArmorModVisual, ArmorSets) == 0x000010, "Member 'FNewArmorModVisual::ArmorSets' has a wrong offset!");

// ScriptStruct Indiana.ArmorVisualProperties
// 0x0058 (0x0058 - 0x0000)
struct FArmorVisualProperties final
{
public:
	bool                                          bModdableByArmorSet;                               // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bModdableByHelmet;                                 // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bModdableByModsDefault;                            // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EArmorModSlot, bool>                     ModdablePerMod;                                    // 0x0008(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArmorVisualProperties) == 0x000008, "Wrong alignment on FArmorVisualProperties");
static_assert(sizeof(FArmorVisualProperties) == 0x000058, "Wrong size on FArmorVisualProperties");
static_assert(offsetof(FArmorVisualProperties, bModdableByArmorSet) == 0x000000, "Member 'FArmorVisualProperties::bModdableByArmorSet' has a wrong offset!");
static_assert(offsetof(FArmorVisualProperties, bModdableByHelmet) == 0x000001, "Member 'FArmorVisualProperties::bModdableByHelmet' has a wrong offset!");
static_assert(offsetof(FArmorVisualProperties, bModdableByModsDefault) == 0x000002, "Member 'FArmorVisualProperties::bModdableByModsDefault' has a wrong offset!");
static_assert(offsetof(FArmorVisualProperties, ModdablePerMod) == 0x000008, "Member 'FArmorVisualProperties::ModdablePerMod' has a wrong offset!");

// ScriptStruct Indiana.AkPlaySoundState
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FAkPlaySoundState final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAkPlaySoundState) == 0x000008, "Wrong alignment on FAkPlaySoundState");
static_assert(sizeof(FAkPlaySoundState) == 0x000018, "Wrong size on FAkPlaySoundState");

// ScriptStruct Indiana.AkPlaySoundStatePair
// 0x0020 (0x0020 - 0x0000)
struct FAkPlaySoundStatePair final
{
public:
	TWeakObjectPtr<class UAkPlaySoundEventEffect> EventEffect;                                       // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAkPlaySoundState                      State;                                             // 0x0008(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkPlaySoundStatePair) == 0x000008, "Wrong alignment on FAkPlaySoundStatePair");
static_assert(sizeof(FAkPlaySoundStatePair) == 0x000020, "Wrong size on FAkPlaySoundStatePair");
static_assert(offsetof(FAkPlaySoundStatePair, EventEffect) == 0x000000, "Member 'FAkPlaySoundStatePair::EventEffect' has a wrong offset!");
static_assert(offsetof(FAkPlaySoundStatePair, State) == 0x000008, "Member 'FAkPlaySoundStatePair::State' has a wrong offset!");

// ScriptStruct Indiana.ArmorSetModSlot
// 0x0018 (0x0018 - 0x0000)
struct FArmorSetModSlot final
{
public:
	EArmorModSlot                                 ModSlot;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bModdable;                                         // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UArmorModItem>              CurrentModClass;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArmorModItem*                          EquippedMod;                                       // 0x0010(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArmorSetModSlot) == 0x000008, "Wrong alignment on FArmorSetModSlot");
static_assert(sizeof(FArmorSetModSlot) == 0x000018, "Wrong size on FArmorSetModSlot");
static_assert(offsetof(FArmorSetModSlot, ModSlot) == 0x000000, "Member 'FArmorSetModSlot::ModSlot' has a wrong offset!");
static_assert(offsetof(FArmorSetModSlot, bModdable) == 0x000001, "Member 'FArmorSetModSlot::bModdable' has a wrong offset!");
static_assert(offsetof(FArmorSetModSlot, CurrentModClass) == 0x000008, "Member 'FArmorSetModSlot::CurrentModClass' has a wrong offset!");
static_assert(offsetof(FArmorSetModSlot, EquippedMod) == 0x000010, "Member 'FArmorSetModSlot::EquippedMod' has a wrong offset!");

// ScriptStruct Indiana.NewArmorSetModVisual
// 0x0018 (0x0018 - 0x0000)
struct FNewArmorSetModVisual final
{
public:
	class UModAppearances*                        ModAppearances;                                    // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           ArmorMods;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNewArmorSetModVisual) == 0x000008, "Wrong alignment on FNewArmorSetModVisual");
static_assert(sizeof(FNewArmorSetModVisual) == 0x000018, "Wrong size on FNewArmorSetModVisual");
static_assert(offsetof(FNewArmorSetModVisual, ModAppearances) == 0x000000, "Member 'FNewArmorSetModVisual::ModAppearances' has a wrong offset!");
static_assert(offsetof(FNewArmorSetModVisual, ArmorMods) == 0x000008, "Member 'FNewArmorSetModVisual::ArmorMods' has a wrong offset!");

// ScriptStruct Indiana.DefaultTeamRelationships
// 0x00F0 (0x00F0 - 0x0000)
struct FDefaultTeamRelationships final
{
public:
	TSet<TSubclassOf<class UBaseTeamData>>        HostileTeams;                                      // 0x0000(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	TSet<TSubclassOf<class UBaseTeamData>>        NeutralTeams;                                      // 0x0050(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	TSet<TSubclassOf<class UBaseTeamData>>        FriendlyTeams;                                     // 0x00A0(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDefaultTeamRelationships) == 0x000008, "Wrong alignment on FDefaultTeamRelationships");
static_assert(sizeof(FDefaultTeamRelationships) == 0x0000F0, "Wrong size on FDefaultTeamRelationships");
static_assert(offsetof(FDefaultTeamRelationships, HostileTeams) == 0x000000, "Member 'FDefaultTeamRelationships::HostileTeams' has a wrong offset!");
static_assert(offsetof(FDefaultTeamRelationships, NeutralTeams) == 0x000050, "Member 'FDefaultTeamRelationships::NeutralTeams' has a wrong offset!");
static_assert(offsetof(FDefaultTeamRelationships, FriendlyTeams) == 0x0000A0, "Member 'FDefaultTeamRelationships::FriendlyTeams' has a wrong offset!");

// ScriptStruct Indiana.ArmorSetItemDefinition
// 0x0038 (0x0050 - 0x0018)
struct FArmorSetItemDefinition final : public FArmorItemDefinition
{
public:
	TSubclassOf<class UArmorSet>                  ArmorSetClass;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UArmorModArmoring>          ArmoringModClass;                                  // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UArmorModUtility>           UtilityModClass;                                   // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UArmorModResistance>        ResistanceModClass;                                // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UArmorModDampening>         DampeningModClass;                                 // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGenerateRandomMicroMod;                           // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UMicroMod>                  EquippedMicroMod;                                  // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArmorSetItemDefinition) == 0x000008, "Wrong alignment on FArmorSetItemDefinition");
static_assert(sizeof(FArmorSetItemDefinition) == 0x000050, "Wrong size on FArmorSetItemDefinition");
static_assert(offsetof(FArmorSetItemDefinition, ArmorSetClass) == 0x000018, "Member 'FArmorSetItemDefinition::ArmorSetClass' has a wrong offset!");
static_assert(offsetof(FArmorSetItemDefinition, ArmoringModClass) == 0x000020, "Member 'FArmorSetItemDefinition::ArmoringModClass' has a wrong offset!");
static_assert(offsetof(FArmorSetItemDefinition, UtilityModClass) == 0x000028, "Member 'FArmorSetItemDefinition::UtilityModClass' has a wrong offset!");
static_assert(offsetof(FArmorSetItemDefinition, ResistanceModClass) == 0x000030, "Member 'FArmorSetItemDefinition::ResistanceModClass' has a wrong offset!");
static_assert(offsetof(FArmorSetItemDefinition, DampeningModClass) == 0x000038, "Member 'FArmorSetItemDefinition::DampeningModClass' has a wrong offset!");
static_assert(offsetof(FArmorSetItemDefinition, bGenerateRandomMicroMod) == 0x000040, "Member 'FArmorSetItemDefinition::bGenerateRandomMicroMod' has a wrong offset!");
static_assert(offsetof(FArmorSetItemDefinition, EquippedMicroMod) == 0x000048, "Member 'FArmorSetItemDefinition::EquippedMicroMod' has a wrong offset!");

// ScriptStruct Indiana.AssetInfo
// 0x0030 (0x0030 - 0x0000)
struct FAssetInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Asset;                                             // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAssetInfo) == 0x000008, "Wrong alignment on FAssetInfo");
static_assert(sizeof(FAssetInfo) == 0x000030, "Wrong size on FAssetInfo");
static_assert(offsetof(FAssetInfo, Asset) == 0x000020, "Member 'FAssetInfo::Asset' has a wrong offset!");

// ScriptStruct Indiana.PointOfInterestLocation
// 0x0020 (0x0020 - 0x0000)
struct FPointOfInterestLocation final
{
public:
	struct FVector                                WorldLocation;                                     // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FloorName;                                         // 0x000C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPointOfInterestData*                   POIData;                                           // 0x0018(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPointOfInterestLocation) == 0x000008, "Wrong alignment on FPointOfInterestLocation");
static_assert(sizeof(FPointOfInterestLocation) == 0x000020, "Wrong size on FPointOfInterestLocation");
static_assert(offsetof(FPointOfInterestLocation, WorldLocation) == 0x000000, "Member 'FPointOfInterestLocation::WorldLocation' has a wrong offset!");
static_assert(offsetof(FPointOfInterestLocation, FloorName) == 0x00000C, "Member 'FPointOfInterestLocation::FloorName' has a wrong offset!");
static_assert(offsetof(FPointOfInterestLocation, POIData) == 0x000018, "Member 'FPointOfInterestLocation::POIData' has a wrong offset!");

// ScriptStruct Indiana.AudioLogDefinition
// 0x0010 (0x0010 - 0x0000)
struct FAudioLogDefinition final
{
public:
	class UConversationData*                      ConversationData;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartNode;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAudioLogDefinition) == 0x000008, "Wrong alignment on FAudioLogDefinition");
static_assert(sizeof(FAudioLogDefinition) == 0x000010, "Wrong size on FAudioLogDefinition");
static_assert(offsetof(FAudioLogDefinition, ConversationData) == 0x000000, "Member 'FAudioLogDefinition::ConversationData' has a wrong offset!");
static_assert(offsetof(FAudioLogDefinition, StartNode) == 0x000008, "Member 'FAudioLogDefinition::StartNode' has a wrong offset!");

// ScriptStruct Indiana.BannedNameReaderData
// 0x0010 (0x0018 - 0x0008)
struct FBannedNameReaderData final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBannedNameReaderData) == 0x000008, "Wrong alignment on FBannedNameReaderData");
static_assert(sizeof(FBannedNameReaderData) == 0x000018, "Wrong size on FBannedNameReaderData");

// ScriptStruct Indiana.TextAnimationData
// 0x0008 (0x0008 - 0x0000)
struct FTextAnimationData final
{
public:
	int32                                         CharactersPerSecond;                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInstant;                                          // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTextAnimationData) == 0x000004, "Wrong alignment on FTextAnimationData");
static_assert(sizeof(FTextAnimationData) == 0x000008, "Wrong size on FTextAnimationData");
static_assert(offsetof(FTextAnimationData, CharactersPerSecond) == 0x000000, "Member 'FTextAnimationData::CharactersPerSecond' has a wrong offset!");
static_assert(offsetof(FTextAnimationData, bInstant) == 0x000004, "Member 'FTextAnimationData::bInstant' has a wrong offset!");

// ScriptStruct Indiana.BeaconProperties
// 0x0020 (0x0020 - 0x0000)
struct FBeaconProperties final
{
public:
	struct FLocString                             DisplayText;                                       // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBeaconType                                   BeaconType;                                        // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBeaconTagWidget>           BeaconTagWidgetClass;                              // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAreaBeacon;                                       // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AreaBeaconRadius;                                  // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBeaconProperties) == 0x000008, "Wrong alignment on FBeaconProperties");
static_assert(sizeof(FBeaconProperties) == 0x000020, "Wrong size on FBeaconProperties");
static_assert(offsetof(FBeaconProperties, DisplayText) == 0x000000, "Member 'FBeaconProperties::DisplayText' has a wrong offset!");
static_assert(offsetof(FBeaconProperties, BeaconType) == 0x000008, "Member 'FBeaconProperties::BeaconType' has a wrong offset!");
static_assert(offsetof(FBeaconProperties, BeaconTagWidgetClass) == 0x000010, "Member 'FBeaconProperties::BeaconTagWidgetClass' has a wrong offset!");
static_assert(offsetof(FBeaconProperties, bAreaBeacon) == 0x000018, "Member 'FBeaconProperties::bAreaBeacon' has a wrong offset!");
static_assert(offsetof(FBeaconProperties, AreaBeaconRadius) == 0x00001C, "Member 'FBeaconProperties::AreaBeaconRadius' has a wrong offset!");

// ScriptStruct Indiana.BeaconData
// 0x0040 (0x0040 - 0x0000)
struct FBeaconData final
{
public:
	struct FVector                                Position;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurrentFloor;                                      // 0x000C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpecialBeaconType                            SpecialType;                                       // 0x0014(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UShipDestinationData*                   ShipDestinationData;                               // 0x0018(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBeaconProperties                      BeaconProperties;                                  // 0x0020(0x0020)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBeaconData) == 0x000008, "Wrong alignment on FBeaconData");
static_assert(sizeof(FBeaconData) == 0x000040, "Wrong size on FBeaconData");
static_assert(offsetof(FBeaconData, Position) == 0x000000, "Member 'FBeaconData::Position' has a wrong offset!");
static_assert(offsetof(FBeaconData, CurrentFloor) == 0x00000C, "Member 'FBeaconData::CurrentFloor' has a wrong offset!");
static_assert(offsetof(FBeaconData, SpecialType) == 0x000014, "Member 'FBeaconData::SpecialType' has a wrong offset!");
static_assert(offsetof(FBeaconData, ShipDestinationData) == 0x000018, "Member 'FBeaconData::ShipDestinationData' has a wrong offset!");
static_assert(offsetof(FBeaconData, BeaconProperties) == 0x000020, "Member 'FBeaconData::BeaconProperties' has a wrong offset!");

// ScriptStruct Indiana.MapBeaconCache
// 0x00A0 (0x00A0 - 0x0000)
struct FMapBeaconCache final
{
public:
	TMap<struct FGuid, struct FBeaconData>        BeaconData;                                        // 0x0000(0x0050)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x50];                                      // 0x0050(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapBeaconCache) == 0x000008, "Wrong alignment on FMapBeaconCache");
static_assert(sizeof(FMapBeaconCache) == 0x0000A0, "Wrong size on FMapBeaconCache");
static_assert(offsetof(FMapBeaconCache, BeaconData) == 0x000000, "Member 'FMapBeaconCache::BeaconData' has a wrong offset!");

// ScriptStruct Indiana.FootstepSurfaceMatch
// 0x0018 (0x0018 - 0x0000)
struct FFootstepSurfaceMatch
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPhysicalSurface>                      SurfaceTypes;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFootstepSurfaceMatch) == 0x000008, "Wrong alignment on FFootstepSurfaceMatch");
static_assert(sizeof(FFootstepSurfaceMatch) == 0x000018, "Wrong size on FFootstepSurfaceMatch");
static_assert(offsetof(FFootstepSurfaceMatch, SurfaceTypes) == 0x000008, "Member 'FFootstepSurfaceMatch::SurfaceTypes' has a wrong offset!");

// ScriptStruct Indiana.FootstepMatch
// 0x0020 (0x0038 - 0x0018)
struct FFootstepMatch : public FFootstepSurfaceMatch
{
public:
	TArray<EFootstepType>                         StepTypes;                                         // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EFootID>                               Feet;                                              // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFootstepMatch) == 0x000008, "Wrong alignment on FFootstepMatch");
static_assert(sizeof(FFootstepMatch) == 0x000038, "Wrong size on FFootstepMatch");
static_assert(offsetof(FFootstepMatch, StepTypes) == 0x000018, "Member 'FFootstepMatch::StepTypes' has a wrong offset!");
static_assert(offsetof(FFootstepMatch, Feet) == 0x000028, "Member 'FFootstepMatch::Feet' has a wrong offset!");

// ScriptStruct Indiana.BeardAppearance
// 0x0050 (0x0090 - 0x0040)
struct FBeardAppearance final : public FAppearanceMatch
{
public:
	TSoftObjectPtr<class USkeletalMesh>           Mesh;                                              // 0x0040(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                BeardTexture;                                      // 0x0068(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBeardAppearance) == 0x000008, "Wrong alignment on FBeardAppearance");
static_assert(sizeof(FBeardAppearance) == 0x000090, "Wrong size on FBeardAppearance");
static_assert(offsetof(FBeardAppearance, Mesh) == 0x000040, "Member 'FBeardAppearance::Mesh' has a wrong offset!");
static_assert(offsetof(FBeardAppearance, BeardTexture) == 0x000068, "Member 'FBeardAppearance::BeardTexture' has a wrong offset!");

// ScriptStruct Indiana.TrackingRegion
// 0x00F0 (0x00F0 - 0x0000)
struct alignas(0x08) FTrackingRegion
{
public:
	uint8                                         Pad_0[0xF0];                                       // 0x0000(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTrackingRegion) == 0x000008, "Wrong alignment on FTrackingRegion");
static_assert(sizeof(FTrackingRegion) == 0x0000F0, "Wrong size on FTrackingRegion");

// ScriptStruct Indiana.HeadTrackingRegion
// 0x0060 (0x0150 - 0x00F0)
struct FHeadTrackingRegion final : public FTrackingRegion
{
public:
	uint8                                         Pad_F0[0x60];                                      // 0x00F0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHeadTrackingRegion) == 0x000008, "Wrong alignment on FHeadTrackingRegion");
static_assert(sizeof(FHeadTrackingRegion) == 0x000150, "Wrong size on FHeadTrackingRegion");

// ScriptStruct Indiana.AIStateHistory
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FAIStateHistory final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIStateHistory) == 0x000004, "Wrong alignment on FAIStateHistory");
static_assert(sizeof(FAIStateHistory) == 0x000010, "Wrong size on FAIStateHistory");

// ScriptStruct Indiana.DiscoveredAnims
// 0x0090 (0x0090 - 0x0000)
struct FDiscoveredAnims final
{
public:
	TMap<class FName, struct FLoopRandomSequence> TalkingSequences;                                  // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	TArray<struct FRandomPlayerSequenceEntryNamed> BaseIdle;                                          // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRandomPlayerSequenceEntryNamed> DialogIdles;                                       // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLoopRandomSequence>            IdleStates;                                        // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StartSequence;                                     // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          WalkForwardSequence;                               // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDiscoveredAnims) == 0x000008, "Wrong alignment on FDiscoveredAnims");
static_assert(sizeof(FDiscoveredAnims) == 0x000090, "Wrong size on FDiscoveredAnims");
static_assert(offsetof(FDiscoveredAnims, TalkingSequences) == 0x000000, "Member 'FDiscoveredAnims::TalkingSequences' has a wrong offset!");
static_assert(offsetof(FDiscoveredAnims, BaseIdle) == 0x000050, "Member 'FDiscoveredAnims::BaseIdle' has a wrong offset!");
static_assert(offsetof(FDiscoveredAnims, DialogIdles) == 0x000060, "Member 'FDiscoveredAnims::DialogIdles' has a wrong offset!");
static_assert(offsetof(FDiscoveredAnims, IdleStates) == 0x000070, "Member 'FDiscoveredAnims::IdleStates' has a wrong offset!");
static_assert(offsetof(FDiscoveredAnims, StartSequence) == 0x000080, "Member 'FDiscoveredAnims::StartSequence' has a wrong offset!");
static_assert(offsetof(FDiscoveredAnims, WalkForwardSequence) == 0x000088, "Member 'FDiscoveredAnims::WalkForwardSequence' has a wrong offset!");

// ScriptStruct Indiana.ImpactAudioDamageTypeOverlays
// 0x0050 (0x0050 - 0x0000)
struct FImpactAudioDamageTypeOverlays final
{
public:
	TMap<TSoftClassPtr<class UClass>, class UAkAudioEvent*> DamageTypeOverlays;                                // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FImpactAudioDamageTypeOverlays) == 0x000008, "Wrong alignment on FImpactAudioDamageTypeOverlays");
static_assert(sizeof(FImpactAudioDamageTypeOverlays) == 0x000050, "Wrong size on FImpactAudioDamageTypeOverlays");
static_assert(offsetof(FImpactAudioDamageTypeOverlays, DamageTypeOverlays) == 0x000000, "Member 'FImpactAudioDamageTypeOverlays::DamageTypeOverlays' has a wrong offset!");

// ScriptStruct Indiana.BipedWeaponAnims
// 0x0158 (0x0158 - 0x0000)
struct FBipedWeaponAnims final
{
public:
	class UAimOffsetBlendSpace*                   CombatAimBlendSpace;                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          HobbledWalkForward;                                // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          CombatWalkForward;                                 // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          CombatRunForward;                                  // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpace1D*                          ForwardBlendSpace;                                 // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace1D*                          RunForwardBlendSpace;                              // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CombatWalkBackward;                                // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          CombatRunBackward;                                 // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpace1D*                          BackwardBlendSpace;                                // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace1D*                          RunBackwardBlendSpace;                             // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CombatWalkLeft;                                    // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          CombatRunLeft;                                     // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpace1D*                          LeftBlendSpace;                                    // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace1D*                          RunLeftBlendSpace;                                 // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CombatWalkRight;                                   // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          CombatRunRight;                                    // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpace1D*                          RightBlendSpace;                                   // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace1D*                          RunRightBlendSpace;                                // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CombatCrouchStartSequence;                         // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CombatCrouchIdleSequence;                          // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CombatCrouchEndSequence;                           // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ReadyFireArmPose;                                  // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          IdleFireArmPose;                                   // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          WeaponDownWalkArm;                                 // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          WeaponDownRunArm;                                  // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BlockStartSequence;                                // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BlockIdleSequence;                                 // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpSequence;                                      // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          FallSequence;                                      // 0x0128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LandSequence;                                      // 0x0130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LowGravJumpSequence;                               // 0x0138(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LowGravFallSequence;                               // 0x0140(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LowGravLandSequence;                               // 0x0148(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SearchingStartSequence;                            // 0x0150(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBipedWeaponAnims) == 0x000008, "Wrong alignment on FBipedWeaponAnims");
static_assert(sizeof(FBipedWeaponAnims) == 0x000158, "Wrong size on FBipedWeaponAnims");
static_assert(offsetof(FBipedWeaponAnims, CombatAimBlendSpace) == 0x000000, "Member 'FBipedWeaponAnims::CombatAimBlendSpace' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, HobbledWalkForward) == 0x000008, "Member 'FBipedWeaponAnims::HobbledWalkForward' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, CombatWalkForward) == 0x000018, "Member 'FBipedWeaponAnims::CombatWalkForward' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, CombatRunForward) == 0x000028, "Member 'FBipedWeaponAnims::CombatRunForward' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, ForwardBlendSpace) == 0x000038, "Member 'FBipedWeaponAnims::ForwardBlendSpace' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, RunForwardBlendSpace) == 0x000040, "Member 'FBipedWeaponAnims::RunForwardBlendSpace' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, CombatWalkBackward) == 0x000048, "Member 'FBipedWeaponAnims::CombatWalkBackward' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, CombatRunBackward) == 0x000058, "Member 'FBipedWeaponAnims::CombatRunBackward' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, BackwardBlendSpace) == 0x000068, "Member 'FBipedWeaponAnims::BackwardBlendSpace' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, RunBackwardBlendSpace) == 0x000070, "Member 'FBipedWeaponAnims::RunBackwardBlendSpace' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, CombatWalkLeft) == 0x000078, "Member 'FBipedWeaponAnims::CombatWalkLeft' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, CombatRunLeft) == 0x000088, "Member 'FBipedWeaponAnims::CombatRunLeft' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, LeftBlendSpace) == 0x000098, "Member 'FBipedWeaponAnims::LeftBlendSpace' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, RunLeftBlendSpace) == 0x0000A0, "Member 'FBipedWeaponAnims::RunLeftBlendSpace' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, CombatWalkRight) == 0x0000A8, "Member 'FBipedWeaponAnims::CombatWalkRight' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, CombatRunRight) == 0x0000B8, "Member 'FBipedWeaponAnims::CombatRunRight' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, RightBlendSpace) == 0x0000C8, "Member 'FBipedWeaponAnims::RightBlendSpace' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, RunRightBlendSpace) == 0x0000D0, "Member 'FBipedWeaponAnims::RunRightBlendSpace' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, CombatCrouchStartSequence) == 0x0000D8, "Member 'FBipedWeaponAnims::CombatCrouchStartSequence' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, CombatCrouchIdleSequence) == 0x0000E0, "Member 'FBipedWeaponAnims::CombatCrouchIdleSequence' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, CombatCrouchEndSequence) == 0x0000E8, "Member 'FBipedWeaponAnims::CombatCrouchEndSequence' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, ReadyFireArmPose) == 0x0000F0, "Member 'FBipedWeaponAnims::ReadyFireArmPose' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, IdleFireArmPose) == 0x0000F8, "Member 'FBipedWeaponAnims::IdleFireArmPose' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, WeaponDownWalkArm) == 0x000100, "Member 'FBipedWeaponAnims::WeaponDownWalkArm' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, WeaponDownRunArm) == 0x000108, "Member 'FBipedWeaponAnims::WeaponDownRunArm' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, BlockStartSequence) == 0x000110, "Member 'FBipedWeaponAnims::BlockStartSequence' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, BlockIdleSequence) == 0x000118, "Member 'FBipedWeaponAnims::BlockIdleSequence' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, JumpSequence) == 0x000120, "Member 'FBipedWeaponAnims::JumpSequence' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, FallSequence) == 0x000128, "Member 'FBipedWeaponAnims::FallSequence' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, LandSequence) == 0x000130, "Member 'FBipedWeaponAnims::LandSequence' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, LowGravJumpSequence) == 0x000138, "Member 'FBipedWeaponAnims::LowGravJumpSequence' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, LowGravFallSequence) == 0x000140, "Member 'FBipedWeaponAnims::LowGravFallSequence' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, LowGravLandSequence) == 0x000148, "Member 'FBipedWeaponAnims::LowGravLandSequence' has a wrong offset!");
static_assert(offsetof(FBipedWeaponAnims, SearchingStartSequence) == 0x000150, "Member 'FBipedWeaponAnims::SearchingStartSequence' has a wrong offset!");

// ScriptStruct Indiana.BipedPersonalityAnims
// 0x00B8 (0x00B8 - 0x0000)
struct FBipedPersonalityAnims final
{
public:
	class UAimOffsetBlendSpace*                   NonCombatAimBlendSpace;                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          WalkForward;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          WalkBackward;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RunForward;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RunBackward;                                       // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LowGravRunForward;                                 // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LowGravRunBackward;                                // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          HandPose;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          WalkArmPose;                                       // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RunArmPose;                                        // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpIntro;                                         // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpLoop;                                          // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpLand;                                          // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LowGravJumpIntro;                                  // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LowGravJumpLoop;                                   // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LowGravJumpLand;                                   // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CrouchIdleStart;                                   // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CrouchIdle;                                        // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CrouchIdleEnd;                                     // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CrouchWalkStart;                                   // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CrouchWalk;                                        // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CrouchWalkEnd;                                     // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          HeadAdditiveLayer;                                 // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBipedPersonalityAnims) == 0x000008, "Wrong alignment on FBipedPersonalityAnims");
static_assert(sizeof(FBipedPersonalityAnims) == 0x0000B8, "Wrong size on FBipedPersonalityAnims");
static_assert(offsetof(FBipedPersonalityAnims, NonCombatAimBlendSpace) == 0x000000, "Member 'FBipedPersonalityAnims::NonCombatAimBlendSpace' has a wrong offset!");
static_assert(offsetof(FBipedPersonalityAnims, WalkForward) == 0x000008, "Member 'FBipedPersonalityAnims::WalkForward' has a wrong offset!");
static_assert(offsetof(FBipedPersonalityAnims, WalkBackward) == 0x000010, "Member 'FBipedPersonalityAnims::WalkBackward' has a wrong offset!");
static_assert(offsetof(FBipedPersonalityAnims, RunForward) == 0x000018, "Member 'FBipedPersonalityAnims::RunForward' has a wrong offset!");
static_assert(offsetof(FBipedPersonalityAnims, RunBackward) == 0x000020, "Member 'FBipedPersonalityAnims::RunBackward' has a wrong offset!");
static_assert(offsetof(FBipedPersonalityAnims, LowGravRunForward) == 0x000028, "Member 'FBipedPersonalityAnims::LowGravRunForward' has a wrong offset!");
static_assert(offsetof(FBipedPersonalityAnims, LowGravRunBackward) == 0x000030, "Member 'FBipedPersonalityAnims::LowGravRunBackward' has a wrong offset!");
static_assert(offsetof(FBipedPersonalityAnims, HandPose) == 0x000038, "Member 'FBipedPersonalityAnims::HandPose' has a wrong offset!");
static_assert(offsetof(FBipedPersonalityAnims, WalkArmPose) == 0x000040, "Member 'FBipedPersonalityAnims::WalkArmPose' has a wrong offset!");
static_assert(offsetof(FBipedPersonalityAnims, RunArmPose) == 0x000048, "Member 'FBipedPersonalityAnims::RunArmPose' has a wrong offset!");
static_assert(offsetof(FBipedPersonalityAnims, JumpIntro) == 0x000050, "Member 'FBipedPersonalityAnims::JumpIntro' has a wrong offset!");
static_assert(offsetof(FBipedPersonalityAnims, JumpLoop) == 0x000058, "Member 'FBipedPersonalityAnims::JumpLoop' has a wrong offset!");
static_assert(offsetof(FBipedPersonalityAnims, JumpLand) == 0x000060, "Member 'FBipedPersonalityAnims::JumpLand' has a wrong offset!");
static_assert(offsetof(FBipedPersonalityAnims, LowGravJumpIntro) == 0x000068, "Member 'FBipedPersonalityAnims::LowGravJumpIntro' has a wrong offset!");
static_assert(offsetof(FBipedPersonalityAnims, LowGravJumpLoop) == 0x000070, "Member 'FBipedPersonalityAnims::LowGravJumpLoop' has a wrong offset!");
static_assert(offsetof(FBipedPersonalityAnims, LowGravJumpLand) == 0x000078, "Member 'FBipedPersonalityAnims::LowGravJumpLand' has a wrong offset!");
static_assert(offsetof(FBipedPersonalityAnims, CrouchIdleStart) == 0x000080, "Member 'FBipedPersonalityAnims::CrouchIdleStart' has a wrong offset!");
static_assert(offsetof(FBipedPersonalityAnims, CrouchIdle) == 0x000088, "Member 'FBipedPersonalityAnims::CrouchIdle' has a wrong offset!");
static_assert(offsetof(FBipedPersonalityAnims, CrouchIdleEnd) == 0x000090, "Member 'FBipedPersonalityAnims::CrouchIdleEnd' has a wrong offset!");
static_assert(offsetof(FBipedPersonalityAnims, CrouchWalkStart) == 0x000098, "Member 'FBipedPersonalityAnims::CrouchWalkStart' has a wrong offset!");
static_assert(offsetof(FBipedPersonalityAnims, CrouchWalk) == 0x0000A0, "Member 'FBipedPersonalityAnims::CrouchWalk' has a wrong offset!");
static_assert(offsetof(FBipedPersonalityAnims, CrouchWalkEnd) == 0x0000A8, "Member 'FBipedPersonalityAnims::CrouchWalkEnd' has a wrong offset!");
static_assert(offsetof(FBipedPersonalityAnims, HeadAdditiveLayer) == 0x0000B0, "Member 'FBipedPersonalityAnims::HeadAdditiveLayer' has a wrong offset!");

// ScriptStruct Indiana.WeaponItemDefinition
// 0x0040 (0x0058 - 0x0018)
struct FWeaponItemDefinition final : public FDegradableItemDefinition
{
public:
	TSubclassOf<class UWeapon>                    WeaponClass;                                       // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAmmo>                      AmmoClass;                                         // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UConsumableItem>            AmmoConsumableClass;                               // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmmoPoolSize;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UWeaponMod>>         EquippedMods;                                      // 0x0038(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bGenerateRandomMicroMod;                           // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UMicroMod>                  EquippedMicroMod;                                  // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponItemDefinition) == 0x000008, "Wrong alignment on FWeaponItemDefinition");
static_assert(sizeof(FWeaponItemDefinition) == 0x000058, "Wrong size on FWeaponItemDefinition");
static_assert(offsetof(FWeaponItemDefinition, WeaponClass) == 0x000018, "Member 'FWeaponItemDefinition::WeaponClass' has a wrong offset!");
static_assert(offsetof(FWeaponItemDefinition, AmmoClass) == 0x000020, "Member 'FWeaponItemDefinition::AmmoClass' has a wrong offset!");
static_assert(offsetof(FWeaponItemDefinition, AmmoConsumableClass) == 0x000028, "Member 'FWeaponItemDefinition::AmmoConsumableClass' has a wrong offset!");
static_assert(offsetof(FWeaponItemDefinition, AmmoPoolSize) == 0x000030, "Member 'FWeaponItemDefinition::AmmoPoolSize' has a wrong offset!");
static_assert(offsetof(FWeaponItemDefinition, EquippedMods) == 0x000038, "Member 'FWeaponItemDefinition::EquippedMods' has a wrong offset!");
static_assert(offsetof(FWeaponItemDefinition, bGenerateRandomMicroMod) == 0x000048, "Member 'FWeaponItemDefinition::bGenerateRandomMicroMod' has a wrong offset!");
static_assert(offsetof(FWeaponItemDefinition, EquippedMicroMod) == 0x000050, "Member 'FWeaponItemDefinition::EquippedMicroMod' has a wrong offset!");

// ScriptStruct Indiana.CurrencyItmDefinition
// 0x0008 (0x0018 - 0x0010)
struct FCurrencyItmDefinition final : public FBaseItemDefinition
{
public:
	TSubclassOf<class UCurrencyItem>              CurrencyItemClass;                                 // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCurrencyItmDefinition) == 0x000008, "Wrong alignment on FCurrencyItmDefinition");
static_assert(sizeof(FCurrencyItmDefinition) == 0x000018, "Wrong size on FCurrencyItmDefinition");
static_assert(offsetof(FCurrencyItmDefinition, CurrencyItemClass) == 0x000010, "Member 'FCurrencyItmDefinition::CurrencyItemClass' has a wrong offset!");

// ScriptStruct Indiana.WeaponModItemDefinition
// 0x0008 (0x0018 - 0x0010)
struct FWeaponModItemDefinition final : public FBaseItemDefinition
{
public:
	TSubclassOf<class UWeaponMod>                 WeaponModClass;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponModItemDefinition) == 0x000008, "Wrong alignment on FWeaponModItemDefinition");
static_assert(sizeof(FWeaponModItemDefinition) == 0x000018, "Wrong size on FWeaponModItemDefinition");
static_assert(offsetof(FWeaponModItemDefinition, WeaponModClass) == 0x000010, "Member 'FWeaponModItemDefinition::WeaponModClass' has a wrong offset!");

// ScriptStruct Indiana.ResourceItmDefinition
// 0x0008 (0x0018 - 0x0010)
struct FResourceItmDefinition final : public FBaseItemDefinition
{
public:
	TSubclassOf<class UResourceItem>              ResourceItemClass;                                 // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FResourceItmDefinition) == 0x000008, "Wrong alignment on FResourceItmDefinition");
static_assert(sizeof(FResourceItmDefinition) == 0x000018, "Wrong size on FResourceItmDefinition");
static_assert(offsetof(FResourceItmDefinition, ResourceItemClass) == 0x000010, "Member 'FResourceItmDefinition::ResourceItemClass' has a wrong offset!");

// ScriptStruct Indiana.HelmetItemDefinition
// 0x0008 (0x0020 - 0x0018)
struct FHelmetItemDefinition final : public FArmorItemDefinition
{
public:
	TSubclassOf<class UHelmet>                    HelmetClass;                                       // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHelmetItemDefinition) == 0x000008, "Wrong alignment on FHelmetItemDefinition");
static_assert(sizeof(FHelmetItemDefinition) == 0x000020, "Wrong size on FHelmetItemDefinition");
static_assert(offsetof(FHelmetItemDefinition, HelmetClass) == 0x000018, "Member 'FHelmetItemDefinition::HelmetClass' has a wrong offset!");

// ScriptStruct Indiana.GadgetItemDefinition
// 0x0008 (0x0018 - 0x0010)
struct FGadgetItemDefinition final : public FBaseItemDefinition
{
public:
	TSubclassOf<class UGadget>                    GadgetClass;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGadgetItemDefinition) == 0x000008, "Wrong alignment on FGadgetItemDefinition");
static_assert(sizeof(FGadgetItemDefinition) == 0x000018, "Wrong size on FGadgetItemDefinition");
static_assert(offsetof(FGadgetItemDefinition, GadgetClass) == 0x000010, "Member 'FGadgetItemDefinition::GadgetClass' has a wrong offset!");

// ScriptStruct Indiana.ItemDefinitionVariant
// 0x01F0 (0x01F0 - 0x0000)
struct FItemDefinitionVariant final
{
public:
	EItemType                                     ItemType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWeaponItemDefinition                  WeaponItemDefinition;                              // 0x0008(0x0058)(Edit, NativeAccessSpecifierPublic)
	struct FArmorSetItemDefinition                ArmorSetItemDefinition;                            // 0x0060(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FAmmoItemDefinition                    AmmoItemDefinition;                                // 0x00B0(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FCurrencyItmDefinition                 CurrencyItemDefinition;                            // 0x00C8(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FResourceItmDefinition                 ResourceItemDefinition;                            // 0x00E0(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FQuestItmDefinition                    QuestItemDefinition;                               // 0x00F8(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FWeaponModItemDefinition               WeaponModItemDefinition;                           // 0x0110(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FHelmetItemDefinition                  HelmetItemDefinition;                              // 0x0128(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FArmorModArmoringItemDefinition        ArmorModArmoringItemDefinition;                    // 0x0148(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FArmorModUtilityItemDefinition         ArmorModUtilityItemDefinition;                     // 0x0168(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FArmorModResistanceItemDefinition      ArmorModResistanceItemDefinition;                  // 0x0188(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FArmorModDampeningItemDefinition       ArmorModDampeningItemDefinition;                   // 0x01A8(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FBaseItemDefinition                    MedKitItemDefinitionDeprecated;                    // 0x01C8(0x0010)(Edit, NativeAccessSpecifierPublic)
	struct FGadgetItemDefinition                  GadgetItemDefinition;                              // 0x01D8(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemDefinitionVariant) == 0x000008, "Wrong alignment on FItemDefinitionVariant");
static_assert(sizeof(FItemDefinitionVariant) == 0x0001F0, "Wrong size on FItemDefinitionVariant");
static_assert(offsetof(FItemDefinitionVariant, ItemType) == 0x000000, "Member 'FItemDefinitionVariant::ItemType' has a wrong offset!");
static_assert(offsetof(FItemDefinitionVariant, WeaponItemDefinition) == 0x000008, "Member 'FItemDefinitionVariant::WeaponItemDefinition' has a wrong offset!");
static_assert(offsetof(FItemDefinitionVariant, ArmorSetItemDefinition) == 0x000060, "Member 'FItemDefinitionVariant::ArmorSetItemDefinition' has a wrong offset!");
static_assert(offsetof(FItemDefinitionVariant, AmmoItemDefinition) == 0x0000B0, "Member 'FItemDefinitionVariant::AmmoItemDefinition' has a wrong offset!");
static_assert(offsetof(FItemDefinitionVariant, CurrencyItemDefinition) == 0x0000C8, "Member 'FItemDefinitionVariant::CurrencyItemDefinition' has a wrong offset!");
static_assert(offsetof(FItemDefinitionVariant, ResourceItemDefinition) == 0x0000E0, "Member 'FItemDefinitionVariant::ResourceItemDefinition' has a wrong offset!");
static_assert(offsetof(FItemDefinitionVariant, QuestItemDefinition) == 0x0000F8, "Member 'FItemDefinitionVariant::QuestItemDefinition' has a wrong offset!");
static_assert(offsetof(FItemDefinitionVariant, WeaponModItemDefinition) == 0x000110, "Member 'FItemDefinitionVariant::WeaponModItemDefinition' has a wrong offset!");
static_assert(offsetof(FItemDefinitionVariant, HelmetItemDefinition) == 0x000128, "Member 'FItemDefinitionVariant::HelmetItemDefinition' has a wrong offset!");
static_assert(offsetof(FItemDefinitionVariant, ArmorModArmoringItemDefinition) == 0x000148, "Member 'FItemDefinitionVariant::ArmorModArmoringItemDefinition' has a wrong offset!");
static_assert(offsetof(FItemDefinitionVariant, ArmorModUtilityItemDefinition) == 0x000168, "Member 'FItemDefinitionVariant::ArmorModUtilityItemDefinition' has a wrong offset!");
static_assert(offsetof(FItemDefinitionVariant, ArmorModResistanceItemDefinition) == 0x000188, "Member 'FItemDefinitionVariant::ArmorModResistanceItemDefinition' has a wrong offset!");
static_assert(offsetof(FItemDefinitionVariant, ArmorModDampeningItemDefinition) == 0x0001A8, "Member 'FItemDefinitionVariant::ArmorModDampeningItemDefinition' has a wrong offset!");
static_assert(offsetof(FItemDefinitionVariant, MedKitItemDefinitionDeprecated) == 0x0001C8, "Member 'FItemDefinitionVariant::MedKitItemDefinitionDeprecated' has a wrong offset!");
static_assert(offsetof(FItemDefinitionVariant, GadgetItemDefinition) == 0x0001D8, "Member 'FItemDefinitionVariant::GadgetItemDefinition' has a wrong offset!");

// ScriptStruct Indiana.BlockProperties
// 0x0004 (0x0004 - 0x0000)
struct FBlockProperties final
{
public:
	float                                         AttackDamageMultiplier;                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlockProperties) == 0x000004, "Wrong alignment on FBlockProperties");
static_assert(sizeof(FBlockProperties) == 0x000004, "Wrong size on FBlockProperties");
static_assert(offsetof(FBlockProperties, AttackDamageMultiplier) == 0x000000, "Member 'FBlockProperties::AttackDamageMultiplier' has a wrong offset!");

// ScriptStruct Indiana.AppearanceGoreCap
// 0x0098 (0x0098 - 0x0000)
struct FAppearanceGoreCap final
{
public:
	struct FGameplayTagContainer                  BodyParts;                                         // 0x0000(0x0020)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             UpperCap;                                          // 0x0020(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             LowerCap;                                          // 0x0048(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           SkinnedCap;                                        // 0x0070(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAppearanceGoreCap) == 0x000008, "Wrong alignment on FAppearanceGoreCap");
static_assert(sizeof(FAppearanceGoreCap) == 0x000098, "Wrong size on FAppearanceGoreCap");
static_assert(offsetof(FAppearanceGoreCap, BodyParts) == 0x000000, "Member 'FAppearanceGoreCap::BodyParts' has a wrong offset!");
static_assert(offsetof(FAppearanceGoreCap, UpperCap) == 0x000020, "Member 'FAppearanceGoreCap::UpperCap' has a wrong offset!");
static_assert(offsetof(FAppearanceGoreCap, LowerCap) == 0x000048, "Member 'FAppearanceGoreCap::LowerCap' has a wrong offset!");
static_assert(offsetof(FAppearanceGoreCap, SkinnedCap) == 0x000070, "Member 'FAppearanceGoreCap::SkinnedCap' has a wrong offset!");

// ScriptStruct Indiana.BodyAppearance
// 0x00B0 (0x00F0 - 0x0040)
struct FBodyAppearance final : public FAppearanceMatch
{
public:
	TSoftObjectPtr<class USkeletalMesh>           BodyMesh;                                          // 0x0040(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, TSoftObjectPtr<class UMaterialInterface>> MaterialOverrides;                                 // 0x0068(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FAppearanceGoreCap>             GoreCaps;                                          // 0x00B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFootstepData>           Footsteps;                                         // 0x00C8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBodyAppearance) == 0x000008, "Wrong alignment on FBodyAppearance");
static_assert(sizeof(FBodyAppearance) == 0x0000F0, "Wrong size on FBodyAppearance");
static_assert(offsetof(FBodyAppearance, BodyMesh) == 0x000040, "Member 'FBodyAppearance::BodyMesh' has a wrong offset!");
static_assert(offsetof(FBodyAppearance, MaterialOverrides) == 0x000068, "Member 'FBodyAppearance::MaterialOverrides' has a wrong offset!");
static_assert(offsetof(FBodyAppearance, GoreCaps) == 0x0000B8, "Member 'FBodyAppearance::GoreCaps' has a wrong offset!");
static_assert(offsetof(FBodyAppearance, Footsteps) == 0x0000C8, "Member 'FBodyAppearance::Footsteps' has a wrong offset!");

// ScriptStruct Indiana.FootstepVisuals
// 0x0030 (0x0030 - 0x0000)
struct FFootstepVisuals final
{
public:
	class UParticleSystem*                        PSTemplate;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParticleSpawnType                            ParticleSystemSpawnType;                           // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PSSocket;                                          // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0014(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0020(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFootstepVisuals) == 0x000008, "Wrong alignment on FFootstepVisuals");
static_assert(sizeof(FFootstepVisuals) == 0x000030, "Wrong size on FFootstepVisuals");
static_assert(offsetof(FFootstepVisuals, PSTemplate) == 0x000000, "Member 'FFootstepVisuals::PSTemplate' has a wrong offset!");
static_assert(offsetof(FFootstepVisuals, ParticleSystemSpawnType) == 0x000008, "Member 'FFootstepVisuals::ParticleSystemSpawnType' has a wrong offset!");
static_assert(offsetof(FFootstepVisuals, PSSocket) == 0x00000C, "Member 'FFootstepVisuals::PSSocket' has a wrong offset!");
static_assert(offsetof(FFootstepVisuals, LocationOffset) == 0x000014, "Member 'FFootstepVisuals::LocationOffset' has a wrong offset!");
static_assert(offsetof(FFootstepVisuals, RotationOffset) == 0x000020, "Member 'FFootstepVisuals::RotationOffset' has a wrong offset!");

// ScriptStruct Indiana.FootstepVisualsOverride
// 0x0030 (0x0068 - 0x0038)
struct FFootstepVisualsOverride final : public FFootstepMatch
{
public:
	struct FFootstepVisuals                       Visuals;                                           // 0x0038(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFootstepVisualsOverride) == 0x000008, "Wrong alignment on FFootstepVisualsOverride");
static_assert(sizeof(FFootstepVisualsOverride) == 0x000068, "Wrong size on FFootstepVisualsOverride");
static_assert(offsetof(FFootstepVisualsOverride, Visuals) == 0x000038, "Member 'FFootstepVisualsOverride::Visuals' has a wrong offset!");

// ScriptStruct Indiana.SpellEffectApplyChance
// 0x0070 (0x0070 - 0x0000)
struct FSpellEffectApplyChance final
{
public:
	struct FGameplayTagContainer                  BodyParts;                                         // 0x0000(0x0020)(Edit, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class USpell>, float>        SpellApplyChances;                                 // 0x0020(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpellEffectApplyChance) == 0x000008, "Wrong alignment on FSpellEffectApplyChance");
static_assert(sizeof(FSpellEffectApplyChance) == 0x000070, "Wrong size on FSpellEffectApplyChance");
static_assert(offsetof(FSpellEffectApplyChance, BodyParts) == 0x000000, "Member 'FSpellEffectApplyChance::BodyParts' has a wrong offset!");
static_assert(offsetof(FSpellEffectApplyChance, SpellApplyChances) == 0x000020, "Member 'FSpellEffectApplyChance::SpellApplyChances' has a wrong offset!");

// ScriptStruct Indiana.DamageTypeRequirementFire
// 0x0020 (0x0020 - 0x0000)
struct FDamageTypeRequirementFire final
{
public:
	int32                                         MinSkill;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UIndianaDamageType>         DamageType;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInstantHitData*                        InstantHitData;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RangedAttackMod;                                   // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageTypeRequirementFire) == 0x000008, "Wrong alignment on FDamageTypeRequirementFire");
static_assert(sizeof(FDamageTypeRequirementFire) == 0x000020, "Wrong size on FDamageTypeRequirementFire");
static_assert(offsetof(FDamageTypeRequirementFire, MinSkill) == 0x000000, "Member 'FDamageTypeRequirementFire::MinSkill' has a wrong offset!");
static_assert(offsetof(FDamageTypeRequirementFire, DamageType) == 0x000008, "Member 'FDamageTypeRequirementFire::DamageType' has a wrong offset!");
static_assert(offsetof(FDamageTypeRequirementFire, InstantHitData) == 0x000010, "Member 'FDamageTypeRequirementFire::InstantHitData' has a wrong offset!");
static_assert(offsetof(FDamageTypeRequirementFire, RangedAttackMod) == 0x000018, "Member 'FDamageTypeRequirementFire::RangedAttackMod' has a wrong offset!");

// ScriptStruct Indiana.BodyPart
// 0x0050 (0x0050 - 0x0000)
struct FBodyPart final
{
public:
	class FName                                   PhATBodySetupBoneName;                             // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRepresentsMultipleBodyParts;                      // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           BodyPartTag;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TransformSocketName;                               // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionalBodyPartsOffset;                        // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   DirectionalBodyParts;                              // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bCanBeSevered;                                     // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SeverBoneNameOverride;                             // 0x0034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachedSocket;                                    // 0x003C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DetachedSocket;                                    // 0x0044(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBulletMagnetism;                                  // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBodyPart) == 0x000008, "Wrong alignment on FBodyPart");
static_assert(sizeof(FBodyPart) == 0x000050, "Wrong size on FBodyPart");
static_assert(offsetof(FBodyPart, PhATBodySetupBoneName) == 0x000000, "Member 'FBodyPart::PhATBodySetupBoneName' has a wrong offset!");
static_assert(offsetof(FBodyPart, bRepresentsMultipleBodyParts) == 0x000008, "Member 'FBodyPart::bRepresentsMultipleBodyParts' has a wrong offset!");
static_assert(offsetof(FBodyPart, BodyPartTag) == 0x00000C, "Member 'FBodyPart::BodyPartTag' has a wrong offset!");
static_assert(offsetof(FBodyPart, TransformSocketName) == 0x000014, "Member 'FBodyPart::TransformSocketName' has a wrong offset!");
static_assert(offsetof(FBodyPart, DirectionalBodyPartsOffset) == 0x00001C, "Member 'FBodyPart::DirectionalBodyPartsOffset' has a wrong offset!");
static_assert(offsetof(FBodyPart, DirectionalBodyParts) == 0x000020, "Member 'FBodyPart::DirectionalBodyParts' has a wrong offset!");
static_assert(offsetof(FBodyPart, bCanBeSevered) == 0x000030, "Member 'FBodyPart::bCanBeSevered' has a wrong offset!");
static_assert(offsetof(FBodyPart, SeverBoneNameOverride) == 0x000034, "Member 'FBodyPart::SeverBoneNameOverride' has a wrong offset!");
static_assert(offsetof(FBodyPart, AttachedSocket) == 0x00003C, "Member 'FBodyPart::AttachedSocket' has a wrong offset!");
static_assert(offsetof(FBodyPart, DetachedSocket) == 0x000044, "Member 'FBodyPart::DetachedSocket' has a wrong offset!");
static_assert(offsetof(FBodyPart, bBulletMagnetism) == 0x00004C, "Member 'FBodyPart::bBulletMagnetism' has a wrong offset!");

// ScriptStruct Indiana.FootstepStimulus
// 0x0008 (0x0008 - 0x0000)
struct FFootstepStimulus final
{
public:
	float                                         AIRadius;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AIAwarenessGenerated;                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFootstepStimulus) == 0x000004, "Wrong alignment on FFootstepStimulus");
static_assert(sizeof(FFootstepStimulus) == 0x000008, "Wrong size on FFootstepStimulus");
static_assert(offsetof(FFootstepStimulus, AIRadius) == 0x000000, "Member 'FFootstepStimulus::AIRadius' has a wrong offset!");
static_assert(offsetof(FFootstepStimulus, AIAwarenessGenerated) == 0x000004, "Member 'FFootstepStimulus::AIAwarenessGenerated' has a wrong offset!");

// ScriptStruct Indiana.FootstepStimulusOverride
// 0x0008 (0x0040 - 0x0038)
struct FFootstepStimulusOverride final : public FFootstepMatch
{
public:
	struct FFootstepStimulus                      Stimulus;                                          // 0x0038(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFootstepStimulusOverride) == 0x000008, "Wrong alignment on FFootstepStimulusOverride");
static_assert(sizeof(FFootstepStimulusOverride) == 0x000040, "Wrong size on FFootstepStimulusOverride");
static_assert(offsetof(FFootstepStimulusOverride, Stimulus) == 0x000038, "Member 'FFootstepStimulusOverride::Stimulus' has a wrong offset!");

// ScriptStruct Indiana.BodyTrackingRegion
// 0x0028 (0x0118 - 0x00F0)
struct FBodyTrackingRegion final : public FTrackingRegion
{
public:
	uint8                                         Pad_F0[0x18];                                      // 0x00F0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ULocomotionLogicComponent*              LocomotionLogic;                                   // 0x0108(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_110[0x8];                                      // 0x0110(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBodyTrackingRegion) == 0x000008, "Wrong alignment on FBodyTrackingRegion");
static_assert(sizeof(FBodyTrackingRegion) == 0x000118, "Wrong size on FBodyTrackingRegion");
static_assert(offsetof(FBodyTrackingRegion, LocomotionLogic) == 0x000108, "Member 'FBodyTrackingRegion::LocomotionLogic' has a wrong offset!");

// ScriptStruct Indiana.CompositeConditionalElement
// 0x0010 (0x0010 - 0x0000)
struct FCompositeConditionalElement final
{
public:
	class UBTDecorator_IndianaConditional*        Conditional;                                       // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	Indiana::ELogicalOperator                     LogicalOperator;                                   // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCompositeConditionalElement) == 0x000008, "Wrong alignment on FCompositeConditionalElement");
static_assert(sizeof(FCompositeConditionalElement) == 0x000010, "Wrong size on FCompositeConditionalElement");
static_assert(offsetof(FCompositeConditionalElement, Conditional) == 0x000000, "Member 'FCompositeConditionalElement::Conditional' has a wrong offset!");
static_assert(offsetof(FCompositeConditionalElement, LogicalOperator) == 0x000008, "Member 'FCompositeConditionalElement::LogicalOperator' has a wrong offset!");

// ScriptStruct Indiana.GamepadBindings
// 0x0040 (0x0040 - 0x0000)
struct FGamepadBindings final
{
public:
	class FName                                   ActionName;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   OldKey;                                            // 0x0008(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   NewKey;                                            // 0x0020(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewScale;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputBindingType                             NewBindingType;                                    // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGamepadBindings) == 0x000008, "Wrong alignment on FGamepadBindings");
static_assert(sizeof(FGamepadBindings) == 0x000040, "Wrong size on FGamepadBindings");
static_assert(offsetof(FGamepadBindings, ActionName) == 0x000000, "Member 'FGamepadBindings::ActionName' has a wrong offset!");
static_assert(offsetof(FGamepadBindings, OldKey) == 0x000008, "Member 'FGamepadBindings::OldKey' has a wrong offset!");
static_assert(offsetof(FGamepadBindings, NewKey) == 0x000020, "Member 'FGamepadBindings::NewKey' has a wrong offset!");
static_assert(offsetof(FGamepadBindings, NewScale) == 0x000038, "Member 'FGamepadBindings::NewScale' has a wrong offset!");
static_assert(offsetof(FGamepadBindings, NewBindingType) == 0x00003C, "Member 'FGamepadBindings::NewBindingType' has a wrong offset!");

// ScriptStruct Indiana.UIAppearanceData
// 0x0018 (0x0018 - 0x0000)
struct FUIAppearanceData final
{
public:
	class FName                                   AssetName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLocString                             CustomizationName;                                 // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepSize;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIAppearanceData) == 0x000004, "Wrong alignment on FUIAppearanceData");
static_assert(sizeof(FUIAppearanceData) == 0x000018, "Wrong size on FUIAppearanceData");
static_assert(offsetof(FUIAppearanceData, AssetName) == 0x000000, "Member 'FUIAppearanceData::AssetName' has a wrong offset!");
static_assert(offsetof(FUIAppearanceData, CustomizationName) == 0x000008, "Member 'FUIAppearanceData::CustomizationName' has a wrong offset!");
static_assert(offsetof(FUIAppearanceData, StepSize) == 0x000010, "Member 'FUIAppearanceData::StepSize' has a wrong offset!");

// ScriptStruct Indiana.BoneModificationUIWrapper
// 0x0010 (0x0010 - 0x0000)
struct FBoneModificationUIWrapper final
{
public:
	class UBoneModifications*                     Modification;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiredInverseValue;                             // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBoneModificationUIWrapper) == 0x000008, "Wrong alignment on FBoneModificationUIWrapper");
static_assert(sizeof(FBoneModificationUIWrapper) == 0x000010, "Wrong size on FBoneModificationUIWrapper");
static_assert(offsetof(FBoneModificationUIWrapper, Modification) == 0x000000, "Member 'FBoneModificationUIWrapper::Modification' has a wrong offset!");
static_assert(offsetof(FBoneModificationUIWrapper, bRequiredInverseValue) == 0x000008, "Member 'FBoneModificationUIWrapper::bRequiredInverseValue' has a wrong offset!");

// ScriptStruct Indiana.CharacterCreationAttributeData
// 0x0050 (0x0050 - 0x0000)
struct FCharacterCreationAttributeData final
{
public:
	TMap<EAttribute, ECharacterAttributeRange>    AttributeValues;                                   // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterCreationAttributeData) == 0x000008, "Wrong alignment on FCharacterCreationAttributeData");
static_assert(sizeof(FCharacterCreationAttributeData) == 0x000050, "Wrong size on FCharacterCreationAttributeData");
static_assert(offsetof(FCharacterCreationAttributeData, AttributeValues) == 0x000000, "Member 'FCharacterCreationAttributeData::AttributeValues' has a wrong offset!");

// ScriptStruct Indiana.CharacterCreationSkillData
// 0x0020 (0x0020 - 0x0000)
struct FCharacterCreationSkillData final
{
public:
	TArray<ESkillCategory>                        StartingSkillCategories;                           // 0x0000(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterCreationSkillData) == 0x000008, "Wrong alignment on FCharacterCreationSkillData");
static_assert(sizeof(FCharacterCreationSkillData) == 0x000020, "Wrong size on FCharacterCreationSkillData");
static_assert(offsetof(FCharacterCreationSkillData, StartingSkillCategories) == 0x000000, "Member 'FCharacterCreationSkillData::StartingSkillCategories' has a wrong offset!");

// ScriptStruct Indiana.CharacterCreationPerkData
// 0x0010 (0x0010 - 0x0000)
struct FCharacterCreationPerkData final
{
public:
	TArray<TSubclassOf<class UPerk>>              SelectedPerks;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterCreationPerkData) == 0x000008, "Wrong alignment on FCharacterCreationPerkData");
static_assert(sizeof(FCharacterCreationPerkData) == 0x000010, "Wrong size on FCharacterCreationPerkData");
static_assert(offsetof(FCharacterCreationPerkData, SelectedPerks) == 0x000000, "Member 'FCharacterCreationPerkData::SelectedPerks' has a wrong offset!");

// ScriptStruct Indiana.CreationTemplate
// 0x00A8 (0x00A8 - 0x0000)
struct FCreationTemplate final
{
public:
	struct FLocString                             TitleTextReference;                                // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLocString                             BodyTextReference;                                 // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAptitude>                  Aptitude;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCharacterCreationAttributeData        AttributeData;                                     // 0x0018(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FCharacterCreationSkillData            SkillData;                                         // 0x0068(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FCharacterCreationPerkData             PerkData;                                          // 0x0088(0x0010)(Edit, NativeAccessSpecifierPublic)
	class UAppearancePreset*                      AppearancePreset;                                  // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCustomCharacter;                                // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCreationTemplate) == 0x000008, "Wrong alignment on FCreationTemplate");
static_assert(sizeof(FCreationTemplate) == 0x0000A8, "Wrong size on FCreationTemplate");
static_assert(offsetof(FCreationTemplate, TitleTextReference) == 0x000000, "Member 'FCreationTemplate::TitleTextReference' has a wrong offset!");
static_assert(offsetof(FCreationTemplate, BodyTextReference) == 0x000008, "Member 'FCreationTemplate::BodyTextReference' has a wrong offset!");
static_assert(offsetof(FCreationTemplate, Aptitude) == 0x000010, "Member 'FCreationTemplate::Aptitude' has a wrong offset!");
static_assert(offsetof(FCreationTemplate, AttributeData) == 0x000018, "Member 'FCreationTemplate::AttributeData' has a wrong offset!");
static_assert(offsetof(FCreationTemplate, SkillData) == 0x000068, "Member 'FCreationTemplate::SkillData' has a wrong offset!");
static_assert(offsetof(FCreationTemplate, PerkData) == 0x000088, "Member 'FCreationTemplate::PerkData' has a wrong offset!");
static_assert(offsetof(FCreationTemplate, AppearancePreset) == 0x000098, "Member 'FCreationTemplate::AppearancePreset' has a wrong offset!");
static_assert(offsetof(FCreationTemplate, bIsCustomCharacter) == 0x0000A0, "Member 'FCreationTemplate::bIsCustomCharacter' has a wrong offset!");

// ScriptStruct Indiana.TutorialPlatformStringContainer
// 0x0010 (0x0010 - 0x0000)
struct FTutorialPlatformStringContainer final
{
public:
	struct FLocString                             Name;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLocString                             Description;                                       // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTutorialPlatformStringContainer) == 0x000004, "Wrong alignment on FTutorialPlatformStringContainer");
static_assert(sizeof(FTutorialPlatformStringContainer) == 0x000010, "Wrong size on FTutorialPlatformStringContainer");
static_assert(offsetof(FTutorialPlatformStringContainer, Name) == 0x000000, "Member 'FTutorialPlatformStringContainer::Name' has a wrong offset!");
static_assert(offsetof(FTutorialPlatformStringContainer, Description) == 0x000008, "Member 'FTutorialPlatformStringContainer::Description' has a wrong offset!");

// ScriptStruct Indiana.TutorialBaseEventData
// 0x0078 (0x0078 - 0x0000)
struct FTutorialBaseEventData
{
public:
	bool                                          bIsGamepadTutorial;                                // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETutorialEvent                                MouseAndKeyboardTutorialEvent;                     // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETutorialEvent                                GamepadTutorialEvent;                              // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLogicalExpression                     Conditional;                                       // 0x0008(0x0068)(Edit, NativeAccessSpecifierPublic)
	ETutorialCategory                             Category;                                          // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeverDisplayInJournal;                            // 0x0071(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TutorialSortOrder;                                 // 0x0072(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_73[0x5];                                       // 0x0073(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTutorialBaseEventData) == 0x000008, "Wrong alignment on FTutorialBaseEventData");
static_assert(sizeof(FTutorialBaseEventData) == 0x000078, "Wrong size on FTutorialBaseEventData");
static_assert(offsetof(FTutorialBaseEventData, bIsGamepadTutorial) == 0x000000, "Member 'FTutorialBaseEventData::bIsGamepadTutorial' has a wrong offset!");
static_assert(offsetof(FTutorialBaseEventData, MouseAndKeyboardTutorialEvent) == 0x000001, "Member 'FTutorialBaseEventData::MouseAndKeyboardTutorialEvent' has a wrong offset!");
static_assert(offsetof(FTutorialBaseEventData, GamepadTutorialEvent) == 0x000002, "Member 'FTutorialBaseEventData::GamepadTutorialEvent' has a wrong offset!");
static_assert(offsetof(FTutorialBaseEventData, Conditional) == 0x000008, "Member 'FTutorialBaseEventData::Conditional' has a wrong offset!");
static_assert(offsetof(FTutorialBaseEventData, Category) == 0x000070, "Member 'FTutorialBaseEventData::Category' has a wrong offset!");
static_assert(offsetof(FTutorialBaseEventData, bNeverDisplayInJournal) == 0x000071, "Member 'FTutorialBaseEventData::bNeverDisplayInJournal' has a wrong offset!");
static_assert(offsetof(FTutorialBaseEventData, TutorialSortOrder) == 0x000072, "Member 'FTutorialBaseEventData::TutorialSortOrder' has a wrong offset!");

// ScriptStruct Indiana.TutorialEventDataContainer
// 0x0088 (0x0100 - 0x0078)
struct FTutorialEventDataContainer final : public FTutorialBaseEventData
{
public:
	struct FLocString                             TutorialNameString;                                // 0x0078(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLocString                             TutorialEventString;                               // 0x0080(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EPlatformFamily, struct FTutorialPlatformStringContainer> PlatformOverrides;                                 // 0x0088(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bDisplayInJournalByDefault;                        // 0x00D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayTitleInSideNotification;                   // 0x00D9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA[0x6];                                       // 0x00DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ActionName;                                        // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ActionNameList;                                    // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTutorialEventDataContainer) == 0x000008, "Wrong alignment on FTutorialEventDataContainer");
static_assert(sizeof(FTutorialEventDataContainer) == 0x000100, "Wrong size on FTutorialEventDataContainer");
static_assert(offsetof(FTutorialEventDataContainer, TutorialNameString) == 0x000078, "Member 'FTutorialEventDataContainer::TutorialNameString' has a wrong offset!");
static_assert(offsetof(FTutorialEventDataContainer, TutorialEventString) == 0x000080, "Member 'FTutorialEventDataContainer::TutorialEventString' has a wrong offset!");
static_assert(offsetof(FTutorialEventDataContainer, PlatformOverrides) == 0x000088, "Member 'FTutorialEventDataContainer::PlatformOverrides' has a wrong offset!");
static_assert(offsetof(FTutorialEventDataContainer, bDisplayInJournalByDefault) == 0x0000D8, "Member 'FTutorialEventDataContainer::bDisplayInJournalByDefault' has a wrong offset!");
static_assert(offsetof(FTutorialEventDataContainer, bDisplayTitleInSideNotification) == 0x0000D9, "Member 'FTutorialEventDataContainer::bDisplayTitleInSideNotification' has a wrong offset!");
static_assert(offsetof(FTutorialEventDataContainer, ActionName) == 0x0000E0, "Member 'FTutorialEventDataContainer::ActionName' has a wrong offset!");
static_assert(offsetof(FTutorialEventDataContainer, ActionNameList) == 0x0000F0, "Member 'FTutorialEventDataContainer::ActionNameList' has a wrong offset!");

// ScriptStruct Indiana.AttributeMetaData
// 0x0002 (0x0002 - 0x0000)
struct FAttributeMetaData final
{
public:
	uint8                                         PointedAttributeIndex;                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPointIsUp;                                        // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttributeMetaData) == 0x000001, "Wrong alignment on FAttributeMetaData");
static_assert(sizeof(FAttributeMetaData) == 0x000002, "Wrong size on FAttributeMetaData");
static_assert(offsetof(FAttributeMetaData, PointedAttributeIndex) == 0x000000, "Member 'FAttributeMetaData::PointedAttributeIndex' has a wrong offset!");
static_assert(offsetof(FAttributeMetaData, bPointIsUp) == 0x000001, "Member 'FAttributeMetaData::bPointIsUp' has a wrong offset!");

// ScriptStruct Indiana.DeathClassOverride
// 0x0010 (0x0010 - 0x0000)
struct FDeathClassOverride final
{
public:
	TSubclassOf<class UDeathClass>                DeathClass;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CreatureType;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeathClassOverride) == 0x000008, "Wrong alignment on FDeathClassOverride");
static_assert(sizeof(FDeathClassOverride) == 0x000010, "Wrong size on FDeathClassOverride");
static_assert(offsetof(FDeathClassOverride, DeathClass) == 0x000000, "Member 'FDeathClassOverride::DeathClass' has a wrong offset!");
static_assert(offsetof(FDeathClassOverride, CreatureType) == 0x000008, "Member 'FDeathClassOverride::CreatureType' has a wrong offset!");

// ScriptStruct Indiana.CharacterDeathDamageInfo
// 0x0070 (0x0070 - 0x0000)
struct FCharacterDeathDamageInfo final
{
public:
	TSubclassOf<class UIndianaDamageType>         DmgType;                                           // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WeaponCategory;                                    // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCalledShot;                                       // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCritical;                                         // 0x0011(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImpulseOverride;                                   // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BodyPartHit;                                       // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneHit;                                           // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactLocation;                                    // 0x0028(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactDirection;                                   // 0x0034(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BreakBoneHit;                                      // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BreakAttachedSocket;                               // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BreakDetachedSocket;                               // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGibbing;                                        // 0x0058(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllBonesBroken;                                   // 0x0059(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBreakBoneRemoved;                                 // 0x005A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B[0x5];                                       // 0x005B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDeathClassOverride>            DeathClassOverrides;                               // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterDeathDamageInfo) == 0x000008, "Wrong alignment on FCharacterDeathDamageInfo");
static_assert(sizeof(FCharacterDeathDamageInfo) == 0x000070, "Wrong size on FCharacterDeathDamageInfo");
static_assert(offsetof(FCharacterDeathDamageInfo, DmgType) == 0x000000, "Member 'FCharacterDeathDamageInfo::DmgType' has a wrong offset!");
static_assert(offsetof(FCharacterDeathDamageInfo, WeaponCategory) == 0x000008, "Member 'FCharacterDeathDamageInfo::WeaponCategory' has a wrong offset!");
static_assert(offsetof(FCharacterDeathDamageInfo, bCalledShot) == 0x000010, "Member 'FCharacterDeathDamageInfo::bCalledShot' has a wrong offset!");
static_assert(offsetof(FCharacterDeathDamageInfo, bCritical) == 0x000011, "Member 'FCharacterDeathDamageInfo::bCritical' has a wrong offset!");
static_assert(offsetof(FCharacterDeathDamageInfo, ImpulseOverride) == 0x000014, "Member 'FCharacterDeathDamageInfo::ImpulseOverride' has a wrong offset!");
static_assert(offsetof(FCharacterDeathDamageInfo, BodyPartHit) == 0x000018, "Member 'FCharacterDeathDamageInfo::BodyPartHit' has a wrong offset!");
static_assert(offsetof(FCharacterDeathDamageInfo, BoneHit) == 0x000020, "Member 'FCharacterDeathDamageInfo::BoneHit' has a wrong offset!");
static_assert(offsetof(FCharacterDeathDamageInfo, ImpactLocation) == 0x000028, "Member 'FCharacterDeathDamageInfo::ImpactLocation' has a wrong offset!");
static_assert(offsetof(FCharacterDeathDamageInfo, ImpactDirection) == 0x000034, "Member 'FCharacterDeathDamageInfo::ImpactDirection' has a wrong offset!");
static_assert(offsetof(FCharacterDeathDamageInfo, BreakBoneHit) == 0x000040, "Member 'FCharacterDeathDamageInfo::BreakBoneHit' has a wrong offset!");
static_assert(offsetof(FCharacterDeathDamageInfo, BreakAttachedSocket) == 0x000048, "Member 'FCharacterDeathDamageInfo::BreakAttachedSocket' has a wrong offset!");
static_assert(offsetof(FCharacterDeathDamageInfo, BreakDetachedSocket) == 0x000050, "Member 'FCharacterDeathDamageInfo::BreakDetachedSocket' has a wrong offset!");
static_assert(offsetof(FCharacterDeathDamageInfo, bIsGibbing) == 0x000058, "Member 'FCharacterDeathDamageInfo::bIsGibbing' has a wrong offset!");
static_assert(offsetof(FCharacterDeathDamageInfo, bAllBonesBroken) == 0x000059, "Member 'FCharacterDeathDamageInfo::bAllBonesBroken' has a wrong offset!");
static_assert(offsetof(FCharacterDeathDamageInfo, bBreakBoneRemoved) == 0x00005A, "Member 'FCharacterDeathDamageInfo::bBreakBoneRemoved' has a wrong offset!");
static_assert(offsetof(FCharacterDeathDamageInfo, DeathClassOverrides) == 0x000060, "Member 'FCharacterDeathDamageInfo::DeathClassOverrides' has a wrong offset!");

// ScriptStruct Indiana.TransitionGroupElement
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FTransitionGroupElement final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTransitionGroupElement) == 0x000008, "Wrong alignment on FTransitionGroupElement");
static_assert(sizeof(FTransitionGroupElement) == 0x000010, "Wrong size on FTransitionGroupElement");

// ScriptStruct Indiana.CharacterDeathDataRow
// 0x0030 (0x0030 - 0x0000)
struct FCharacterDeathDataRow final
{
public:
	TSubclassOf<class UIndianaDamageType>         DmgType;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WeaponCategory;                                    // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterDeathTriBool                        CalledShot;                                        // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterDeathTriBool                        CriticalHit;                                       // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharacterDeathImpulse*                 Impulse;                                           // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectChance;                                      // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDeathClass>                DeathClass;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterDeathDataRow) == 0x000008, "Wrong alignment on FCharacterDeathDataRow");
static_assert(sizeof(FCharacterDeathDataRow) == 0x000030, "Wrong size on FCharacterDeathDataRow");
static_assert(offsetof(FCharacterDeathDataRow, DmgType) == 0x000000, "Member 'FCharacterDeathDataRow::DmgType' has a wrong offset!");
static_assert(offsetof(FCharacterDeathDataRow, WeaponCategory) == 0x000008, "Member 'FCharacterDeathDataRow::WeaponCategory' has a wrong offset!");
static_assert(offsetof(FCharacterDeathDataRow, CalledShot) == 0x000010, "Member 'FCharacterDeathDataRow::CalledShot' has a wrong offset!");
static_assert(offsetof(FCharacterDeathDataRow, CriticalHit) == 0x000011, "Member 'FCharacterDeathDataRow::CriticalHit' has a wrong offset!");
static_assert(offsetof(FCharacterDeathDataRow, Priority) == 0x000014, "Member 'FCharacterDeathDataRow::Priority' has a wrong offset!");
static_assert(offsetof(FCharacterDeathDataRow, Impulse) == 0x000018, "Member 'FCharacterDeathDataRow::Impulse' has a wrong offset!");
static_assert(offsetof(FCharacterDeathDataRow, EffectChance) == 0x000020, "Member 'FCharacterDeathDataRow::EffectChance' has a wrong offset!");
static_assert(offsetof(FCharacterDeathDataRow, DeathClass) == 0x000028, "Member 'FCharacterDeathDataRow::DeathClass' has a wrong offset!");

// ScriptStruct Indiana.NavigationBlockDetectionSettings
// 0x0014 (0x0014 - 0x0000)
struct FNavigationBlockDetectionSettings final
{
public:
	float                                         BlockDetectionDistance;                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlockDetectionInterval;                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlockDetectionSampleCount;                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlockDestinationCheckDistance;                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlockDestinationSampleInterval;                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavigationBlockDetectionSettings) == 0x000004, "Wrong alignment on FNavigationBlockDetectionSettings");
static_assert(sizeof(FNavigationBlockDetectionSettings) == 0x000014, "Wrong size on FNavigationBlockDetectionSettings");
static_assert(offsetof(FNavigationBlockDetectionSettings, BlockDetectionDistance) == 0x000000, "Member 'FNavigationBlockDetectionSettings::BlockDetectionDistance' has a wrong offset!");
static_assert(offsetof(FNavigationBlockDetectionSettings, BlockDetectionInterval) == 0x000004, "Member 'FNavigationBlockDetectionSettings::BlockDetectionInterval' has a wrong offset!");
static_assert(offsetof(FNavigationBlockDetectionSettings, BlockDetectionSampleCount) == 0x000008, "Member 'FNavigationBlockDetectionSettings::BlockDetectionSampleCount' has a wrong offset!");
static_assert(offsetof(FNavigationBlockDetectionSettings, BlockDestinationCheckDistance) == 0x00000C, "Member 'FNavigationBlockDetectionSettings::BlockDestinationCheckDistance' has a wrong offset!");
static_assert(offsetof(FNavigationBlockDetectionSettings, BlockDestinationSampleInterval) == 0x000010, "Member 'FNavigationBlockDetectionSettings::BlockDestinationSampleInterval' has a wrong offset!");

// ScriptStruct Indiana.ScannerData
// 0x00A8 (0x00A8 - 0x0000)
struct alignas(0x08) FScannerData final
{
public:
	uint8                                         Pad_0[0xA8];                                       // 0x0000(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScannerData) == 0x000008, "Wrong alignment on FScannerData");
static_assert(sizeof(FScannerData) == 0x0000A8, "Wrong size on FScannerData");

// ScriptStruct Indiana.SharedStateStubData
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FSharedStateStubData final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSharedStateStubData) == 0x000004, "Wrong alignment on FSharedStateStubData");
static_assert(sizeof(FSharedStateStubData) == 0x00001C, "Wrong size on FSharedStateStubData");

// ScriptStruct Indiana.ScannerArmorData
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x08) FScannerArmorData final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScannerArmorData) == 0x000008, "Wrong alignment on FScannerArmorData");
static_assert(sizeof(FScannerArmorData) == 0x000060, "Wrong size on FScannerArmorData");

// ScriptStruct Indiana.ScannerAbility
// 0x0010 (0x0010 - 0x0000)
struct FScannerAbility final
{
public:
	class FString                                 AbilityName;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScannerAbility) == 0x000008, "Wrong alignment on FScannerAbility");
static_assert(sizeof(FScannerAbility) == 0x000010, "Wrong size on FScannerAbility");
static_assert(offsetof(FScannerAbility, AbilityName) == 0x000000, "Member 'FScannerAbility::AbilityName' has a wrong offset!");

// ScriptStruct Indiana.PerkSubclassArray
// 0x0010 (0x0010 - 0x0000)
struct FPerkSubclassArray final
{
public:
	TArray<TSubclassOf<class UPerk>>              Perks;                                             // 0x0000(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerkSubclassArray) == 0x000008, "Wrong alignment on FPerkSubclassArray");
static_assert(sizeof(FPerkSubclassArray) == 0x000010, "Wrong size on FPerkSubclassArray");
static_assert(offsetof(FPerkSubclassArray, Perks) == 0x000000, "Member 'FPerkSubclassArray::Perks' has a wrong offset!");

// ScriptStruct Indiana.PseudoGodModeSettings
// 0x0004 (0x0004 - 0x0000)
struct FPseudoGodModeSettings final
{
public:
	float                                         MinimumHealthPercentage;                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPseudoGodModeSettings) == 0x000004, "Wrong alignment on FPseudoGodModeSettings");
static_assert(sizeof(FPseudoGodModeSettings) == 0x000004, "Wrong size on FPseudoGodModeSettings");
static_assert(offsetof(FPseudoGodModeSettings, MinimumHealthPercentage) == 0x000000, "Member 'FPseudoGodModeSettings::MinimumHealthPercentage' has a wrong offset!");

// ScriptStruct Indiana.SkillCategoryDetail
// 0x0040 (0x0040 - 0x0000)
struct FSkillCategoryDetail final
{
public:
	ESkillCategory                                Category;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ESkill>                                AssociatedSkills;                                  // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillCategoryDetail) == 0x000008, "Wrong alignment on FSkillCategoryDetail");
static_assert(sizeof(FSkillCategoryDetail) == 0x000040, "Wrong size on FSkillCategoryDetail");
static_assert(offsetof(FSkillCategoryDetail, Category) == 0x000000, "Member 'FSkillCategoryDetail::Category' has a wrong offset!");
static_assert(offsetof(FSkillCategoryDetail, Icon) == 0x000008, "Member 'FSkillCategoryDetail::Icon' has a wrong offset!");
static_assert(offsetof(FSkillCategoryDetail, AssociatedSkills) == 0x000030, "Member 'FSkillCategoryDetail::AssociatedSkills' has a wrong offset!");

// ScriptStruct Indiana.ExpressionComponentAsset
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FExpressionComponentAsset
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	Indiana::ELogicalOperator                     Operator;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExpressionComponentAsset) == 0x000008, "Wrong alignment on FExpressionComponentAsset");
static_assert(sizeof(FExpressionComponentAsset) == 0x000010, "Wrong size on FExpressionComponentAsset");
static_assert(offsetof(FExpressionComponentAsset, Operator) == 0x000008, "Member 'FExpressionComponentAsset::Operator' has a wrong offset!");

// ScriptStruct Indiana.ConditionalExpressionAsset
// 0x0020 (0x0030 - 0x0010)
struct FConditionalExpressionAsset final : public FExpressionComponentAsset
{
public:
	TArray<ExpressionComponentType>               ComponentTypes;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 ComponentIndices;                                  // 0x0020(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FConditionalExpressionAsset) == 0x000008, "Wrong alignment on FConditionalExpressionAsset");
static_assert(sizeof(FConditionalExpressionAsset) == 0x000030, "Wrong size on FConditionalExpressionAsset");
static_assert(offsetof(FConditionalExpressionAsset, ComponentTypes) == 0x000010, "Member 'FConditionalExpressionAsset::ComponentTypes' has a wrong offset!");
static_assert(offsetof(FConditionalExpressionAsset, ComponentIndices) == 0x000020, "Member 'FConditionalExpressionAsset::ComponentIndices' has a wrong offset!");

// ScriptStruct Indiana.ConditionalCallAsset
// 0x0048 (0x0058 - 0x0010)
struct FConditionalCallAsset final : public FExpressionComponentAsset
{
public:
	bool                                          Not;                                               // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ScriptCall;                                        // 0x0018(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 FullName;                                          // 0x0028(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 Flags;                                             // 0x0038(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         Parameters;                                        // 0x0048(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FConditionalCallAsset) == 0x000008, "Wrong alignment on FConditionalCallAsset");
static_assert(sizeof(FConditionalCallAsset) == 0x000058, "Wrong size on FConditionalCallAsset");
static_assert(offsetof(FConditionalCallAsset, Not) == 0x000010, "Member 'FConditionalCallAsset::Not' has a wrong offset!");
static_assert(offsetof(FConditionalCallAsset, ScriptCall) == 0x000018, "Member 'FConditionalCallAsset::ScriptCall' has a wrong offset!");
static_assert(offsetof(FConditionalCallAsset, FullName) == 0x000028, "Member 'FConditionalCallAsset::FullName' has a wrong offset!");
static_assert(offsetof(FConditionalCallAsset, Flags) == 0x000038, "Member 'FConditionalCallAsset::Flags' has a wrong offset!");
static_assert(offsetof(FConditionalCallAsset, Parameters) == 0x000048, "Member 'FConditionalCallAsset::Parameters' has a wrong offset!");

// ScriptStruct Indiana.ConditionalAsset
// 0x0050 (0x0050 - 0x0000)
struct FConditionalAsset final
{
public:
	TArray<struct FConditionalExpressionAsset>    ExpressionComponents;                              // 0x0000(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FConditionalCallAsset>          CallComponents;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FConditionalExpressionAsset            Root;                                              // 0x0020(0x0030)(Edit, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FConditionalAsset) == 0x000008, "Wrong alignment on FConditionalAsset");
static_assert(sizeof(FConditionalAsset) == 0x000050, "Wrong size on FConditionalAsset");
static_assert(offsetof(FConditionalAsset, ExpressionComponents) == 0x000000, "Member 'FConditionalAsset::ExpressionComponents' has a wrong offset!");
static_assert(offsetof(FConditionalAsset, CallComponents) == 0x000010, "Member 'FConditionalAsset::CallComponents' has a wrong offset!");
static_assert(offsetof(FConditionalAsset, Root) == 0x000020, "Member 'FConditionalAsset::Root' has a wrong offset!");

// ScriptStruct Indiana.ChatterLinkAsset
// 0x0060 (0x0060 - 0x0000)
struct FChatterLinkAsset final
{
public:
	int32                                         FromNodeID;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ToNodeID;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FConditionalAsset                      Conditional;                                       // 0x0008(0x0050)(Edit, NativeAccessSpecifierPrivate)
	int32                                         RandomWeight;                                      // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChatterLinkAsset) == 0x000008, "Wrong alignment on FChatterLinkAsset");
static_assert(sizeof(FChatterLinkAsset) == 0x000060, "Wrong size on FChatterLinkAsset");
static_assert(offsetof(FChatterLinkAsset, FromNodeID) == 0x000000, "Member 'FChatterLinkAsset::FromNodeID' has a wrong offset!");
static_assert(offsetof(FChatterLinkAsset, ToNodeID) == 0x000004, "Member 'FChatterLinkAsset::ToNodeID' has a wrong offset!");
static_assert(offsetof(FChatterLinkAsset, Conditional) == 0x000008, "Member 'FChatterLinkAsset::Conditional' has a wrong offset!");
static_assert(offsetof(FChatterLinkAsset, RandomWeight) == 0x000058, "Member 'FChatterLinkAsset::RandomWeight' has a wrong offset!");

// ScriptStruct Indiana.ScriptCallAsset
// 0x0070 (0x0070 - 0x0000)
struct FScriptCallAsset final
{
public:
	class FString                                 Script;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 Flags;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FConditionalAsset                      Conditional;                                       // 0x0020(0x0050)(Edit, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FScriptCallAsset) == 0x000008, "Wrong alignment on FScriptCallAsset");
static_assert(sizeof(FScriptCallAsset) == 0x000070, "Wrong size on FScriptCallAsset");
static_assert(offsetof(FScriptCallAsset, Script) == 0x000000, "Member 'FScriptCallAsset::Script' has a wrong offset!");
static_assert(offsetof(FScriptCallAsset, Flags) == 0x000010, "Member 'FScriptCallAsset::Flags' has a wrong offset!");
static_assert(offsetof(FScriptCallAsset, Conditional) == 0x000020, "Member 'FScriptCallAsset::Conditional' has a wrong offset!");

// ScriptStruct Indiana.DialogueNodeAsset
// 0x00B0 (0x00B0 - 0x0000)
struct FDialogueNodeAsset
{
public:
	int32                                         NodeID;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ContainerNodeID;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFlowChartNodeType                            NodeType;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FChatterLinkAsset>              Links;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FConditionalAsset                      Conditional;                                       // 0x0020(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<struct FScriptCallAsset>               OnEnterScripts;                                    // 0x0070(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FScriptCallAsset>               OnExitScripts;                                     // 0x0080(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FScriptCallAsset>               OnUpdateScripts;                                   // 0x0090(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          NotSkippable;                                      // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsQuestionNode;                                    // 0x00A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HideSpeaker;                                       // 0x00A2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENodePlayType                                 PlayType;                                          // 0x00A3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPersistenceType                              Persistence;                                       // 0x00A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NoPlayRandomWeight;                                // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENodeDisplayType                              DisplayType;                                       // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVOPositioning                                VOPositioning;                                     // 0x00AD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AE[0x2];                                       // 0x00AE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDialogueNodeAsset) == 0x000008, "Wrong alignment on FDialogueNodeAsset");
static_assert(sizeof(FDialogueNodeAsset) == 0x0000B0, "Wrong size on FDialogueNodeAsset");
static_assert(offsetof(FDialogueNodeAsset, NodeID) == 0x000000, "Member 'FDialogueNodeAsset::NodeID' has a wrong offset!");
static_assert(offsetof(FDialogueNodeAsset, ContainerNodeID) == 0x000004, "Member 'FDialogueNodeAsset::ContainerNodeID' has a wrong offset!");
static_assert(offsetof(FDialogueNodeAsset, NodeType) == 0x000008, "Member 'FDialogueNodeAsset::NodeType' has a wrong offset!");
static_assert(offsetof(FDialogueNodeAsset, Links) == 0x000010, "Member 'FDialogueNodeAsset::Links' has a wrong offset!");
static_assert(offsetof(FDialogueNodeAsset, Conditional) == 0x000020, "Member 'FDialogueNodeAsset::Conditional' has a wrong offset!");
static_assert(offsetof(FDialogueNodeAsset, OnEnterScripts) == 0x000070, "Member 'FDialogueNodeAsset::OnEnterScripts' has a wrong offset!");
static_assert(offsetof(FDialogueNodeAsset, OnExitScripts) == 0x000080, "Member 'FDialogueNodeAsset::OnExitScripts' has a wrong offset!");
static_assert(offsetof(FDialogueNodeAsset, OnUpdateScripts) == 0x000090, "Member 'FDialogueNodeAsset::OnUpdateScripts' has a wrong offset!");
static_assert(offsetof(FDialogueNodeAsset, NotSkippable) == 0x0000A0, "Member 'FDialogueNodeAsset::NotSkippable' has a wrong offset!");
static_assert(offsetof(FDialogueNodeAsset, IsQuestionNode) == 0x0000A1, "Member 'FDialogueNodeAsset::IsQuestionNode' has a wrong offset!");
static_assert(offsetof(FDialogueNodeAsset, HideSpeaker) == 0x0000A2, "Member 'FDialogueNodeAsset::HideSpeaker' has a wrong offset!");
static_assert(offsetof(FDialogueNodeAsset, PlayType) == 0x0000A3, "Member 'FDialogueNodeAsset::PlayType' has a wrong offset!");
static_assert(offsetof(FDialogueNodeAsset, Persistence) == 0x0000A4, "Member 'FDialogueNodeAsset::Persistence' has a wrong offset!");
static_assert(offsetof(FDialogueNodeAsset, NoPlayRandomWeight) == 0x0000A8, "Member 'FDialogueNodeAsset::NoPlayRandomWeight' has a wrong offset!");
static_assert(offsetof(FDialogueNodeAsset, DisplayType) == 0x0000AC, "Member 'FDialogueNodeAsset::DisplayType' has a wrong offset!");
static_assert(offsetof(FDialogueNodeAsset, VOPositioning) == 0x0000AD, "Member 'FDialogueNodeAsset::VOPositioning' has a wrong offset!");

// ScriptStruct Indiana.EyesTrackingRegion
// 0x0000 (0x00F0 - 0x00F0)
struct FEyesTrackingRegion final : public FTrackingRegion
{
};
static_assert(alignof(FEyesTrackingRegion) == 0x000008, "Wrong alignment on FEyesTrackingRegion");
static_assert(sizeof(FEyesTrackingRegion) == 0x0000F0, "Wrong size on FEyesTrackingRegion");

// ScriptStruct Indiana.CompanionFollowSettings
// 0x0001 (0x0001 - 0x0000)
struct FCompanionFollowSettings final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCompanionFollowSettings) == 0x000001, "Wrong alignment on FCompanionFollowSettings");
static_assert(sizeof(FCompanionFollowSettings) == 0x000001, "Wrong size on FCompanionFollowSettings");

// ScriptStruct Indiana.LevelGameStateHeader
// 0x0028 (0x0038 - 0x0010)
struct alignas(0x08) FLevelGameStateHeader final : public FGenericVersionedGameStateHeader
{
public:
	uint8                                         Pad_10[0x28];                                      // 0x0010(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLevelGameStateHeader) == 0x000008, "Wrong alignment on FLevelGameStateHeader");
static_assert(sizeof(FLevelGameStateHeader) == 0x000038, "Wrong size on FLevelGameStateHeader");

// ScriptStruct Indiana.InputLabelDescription
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FInputLabelDescription final
{
public:
	class FName                                   ActionName;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IconName;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLocString                             TextReference;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayKeyboardMouse;                             // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayGamepad;                                   // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBoundToActionName;                                // 0x001A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresConstantTicking;                          // 0x001B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x1C];                                      // 0x001C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInputLabelDescription) == 0x000008, "Wrong alignment on FInputLabelDescription");
static_assert(sizeof(FInputLabelDescription) == 0x000038, "Wrong size on FInputLabelDescription");
static_assert(offsetof(FInputLabelDescription, ActionName) == 0x000000, "Member 'FInputLabelDescription::ActionName' has a wrong offset!");
static_assert(offsetof(FInputLabelDescription, IconName) == 0x000008, "Member 'FInputLabelDescription::IconName' has a wrong offset!");
static_assert(offsetof(FInputLabelDescription, TextReference) == 0x000010, "Member 'FInputLabelDescription::TextReference' has a wrong offset!");
static_assert(offsetof(FInputLabelDescription, bDisplayKeyboardMouse) == 0x000018, "Member 'FInputLabelDescription::bDisplayKeyboardMouse' has a wrong offset!");
static_assert(offsetof(FInputLabelDescription, bDisplayGamepad) == 0x000019, "Member 'FInputLabelDescription::bDisplayGamepad' has a wrong offset!");
static_assert(offsetof(FInputLabelDescription, bBoundToActionName) == 0x00001A, "Member 'FInputLabelDescription::bBoundToActionName' has a wrong offset!");
static_assert(offsetof(FInputLabelDescription, bRequiresConstantTicking) == 0x00001B, "Member 'FInputLabelDescription::bRequiresConstantTicking' has a wrong offset!");

// ScriptStruct Indiana.ScriptNodeAsset
// 0x0008 (0x00B8 - 0x00B0)
struct FScriptNodeAsset : public FDialogueNodeAsset
{
public:
	bool                                          RequiresValidChildNode;                            // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScriptNodeAsset) == 0x000008, "Wrong alignment on FScriptNodeAsset");
static_assert(sizeof(FScriptNodeAsset) == 0x0000B8, "Wrong size on FScriptNodeAsset");
static_assert(offsetof(FScriptNodeAsset, RequiresValidChildNode) == 0x0000B0, "Member 'FScriptNodeAsset::RequiresValidChildNode' has a wrong offset!");

// ScriptStruct Indiana.ChatterBranchNodeAsset
// 0x0020 (0x00D8 - 0x00B8)
struct FChatterBranchNodeAsset final : public FScriptNodeAsset
{
public:
	struct FGuid                                  ParentID;                                          // 0x00B8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  EventID;                                           // 0x00C8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FChatterBranchNodeAsset) == 0x000008, "Wrong alignment on FChatterBranchNodeAsset");
static_assert(sizeof(FChatterBranchNodeAsset) == 0x0000D8, "Wrong size on FChatterBranchNodeAsset");
static_assert(offsetof(FChatterBranchNodeAsset, ParentID) == 0x0000B8, "Member 'FChatterBranchNodeAsset::ParentID' has a wrong offset!");
static_assert(offsetof(FChatterBranchNodeAsset, EventID) == 0x0000C8, "Member 'FChatterBranchNodeAsset::EventID' has a wrong offset!");

// ScriptStruct Indiana.SpecialEventStimulusOverride
// 0x0008 (0x0020 - 0x0018)
struct FSpecialEventStimulusOverride final : public FFootstepSurfaceMatch
{
public:
	struct FFootstepStimulus                      Stimulus;                                          // 0x0018(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialEventStimulusOverride) == 0x000008, "Wrong alignment on FSpecialEventStimulusOverride");
static_assert(sizeof(FSpecialEventStimulusOverride) == 0x000020, "Wrong size on FSpecialEventStimulusOverride");
static_assert(offsetof(FSpecialEventStimulusOverride, Stimulus) == 0x000018, "Member 'FSpecialEventStimulusOverride::Stimulus' has a wrong offset!");

// ScriptStruct Indiana.ChatterEvent
// 0x0028 (0x0030 - 0x0008)
struct FChatterEvent final : public FGameDataStructure
{
public:
	EChatterEventType                             EventType;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Priority;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Cooldown;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EInterruptType                                OnInterrupt;                                       // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EChatterLevel                                 InterruptionLevel;                                 // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EQueueType                                    OnQueued;                                          // 0x0016(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxWaitTime;                                       // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ChatterPrefix;                                     // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FChatterEvent) == 0x000008, "Wrong alignment on FChatterEvent");
static_assert(sizeof(FChatterEvent) == 0x000030, "Wrong size on FChatterEvent");
static_assert(offsetof(FChatterEvent, EventType) == 0x000008, "Member 'FChatterEvent::EventType' has a wrong offset!");
static_assert(offsetof(FChatterEvent, Priority) == 0x00000C, "Member 'FChatterEvent::Priority' has a wrong offset!");
static_assert(offsetof(FChatterEvent, Cooldown) == 0x000010, "Member 'FChatterEvent::Cooldown' has a wrong offset!");
static_assert(offsetof(FChatterEvent, OnInterrupt) == 0x000014, "Member 'FChatterEvent::OnInterrupt' has a wrong offset!");
static_assert(offsetof(FChatterEvent, InterruptionLevel) == 0x000015, "Member 'FChatterEvent::InterruptionLevel' has a wrong offset!");
static_assert(offsetof(FChatterEvent, OnQueued) == 0x000016, "Member 'FChatterEvent::OnQueued' has a wrong offset!");
static_assert(offsetof(FChatterEvent, MaxWaitTime) == 0x000018, "Member 'FChatterEvent::MaxWaitTime' has a wrong offset!");
static_assert(offsetof(FChatterEvent, ChatterPrefix) == 0x000020, "Member 'FChatterEvent::ChatterPrefix' has a wrong offset!");

// ScriptStruct Indiana.ChatterEventNodeAsset
// 0x0030 (0x00E0 - 0x00B0)
struct FChatterEventNodeAsset final : public FDialogueNodeAsset
{
public:
	struct FChatterEvent                          EventData;                                         // 0x00B0(0x0030)(Edit, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FChatterEventNodeAsset) == 0x000008, "Wrong alignment on FChatterEventNodeAsset");
static_assert(sizeof(FChatterEventNodeAsset) == 0x0000E0, "Wrong size on FChatterEventNodeAsset");
static_assert(offsetof(FChatterEventNodeAsset, EventData) == 0x0000B0, "Member 'FChatterEventNodeAsset::EventData' has a wrong offset!");

// ScriptStruct Indiana.TalkNodeAsset
// 0x0050 (0x0100 - 0x00B0)
struct FTalkNodeAsset final : public FDialogueNodeAsset
{
public:
	struct FGuid                                  SpeakerGameDataID;                                 // 0x00B0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  ListenerGameDataID;                                // 0x00C0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 EmotionType;                                       // 0x00D0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EmotionStrength;                                   // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EmotionDelay;                                      // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 ExternalVO;                                        // 0x00E8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VODelayOverride;                                   // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETalkNodeVOAttenuationType                    VOAttenuationType;                                 // 0x00FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOmitFromUIHistory;                                // 0x00FD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HasVO;                                             // 0x00FE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPersistEmotion;                                   // 0x00FF(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FTalkNodeAsset) == 0x000008, "Wrong alignment on FTalkNodeAsset");
static_assert(sizeof(FTalkNodeAsset) == 0x000100, "Wrong size on FTalkNodeAsset");
static_assert(offsetof(FTalkNodeAsset, SpeakerGameDataID) == 0x0000B0, "Member 'FTalkNodeAsset::SpeakerGameDataID' has a wrong offset!");
static_assert(offsetof(FTalkNodeAsset, ListenerGameDataID) == 0x0000C0, "Member 'FTalkNodeAsset::ListenerGameDataID' has a wrong offset!");
static_assert(offsetof(FTalkNodeAsset, EmotionType) == 0x0000D0, "Member 'FTalkNodeAsset::EmotionType' has a wrong offset!");
static_assert(offsetof(FTalkNodeAsset, EmotionStrength) == 0x0000E0, "Member 'FTalkNodeAsset::EmotionStrength' has a wrong offset!");
static_assert(offsetof(FTalkNodeAsset, EmotionDelay) == 0x0000E4, "Member 'FTalkNodeAsset::EmotionDelay' has a wrong offset!");
static_assert(offsetof(FTalkNodeAsset, ExternalVO) == 0x0000E8, "Member 'FTalkNodeAsset::ExternalVO' has a wrong offset!");
static_assert(offsetof(FTalkNodeAsset, VODelayOverride) == 0x0000F8, "Member 'FTalkNodeAsset::VODelayOverride' has a wrong offset!");
static_assert(offsetof(FTalkNodeAsset, VOAttenuationType) == 0x0000FC, "Member 'FTalkNodeAsset::VOAttenuationType' has a wrong offset!");
static_assert(offsetof(FTalkNodeAsset, bOmitFromUIHistory) == 0x0000FD, "Member 'FTalkNodeAsset::bOmitFromUIHistory' has a wrong offset!");
static_assert(offsetof(FTalkNodeAsset, HasVO) == 0x0000FE, "Member 'FTalkNodeAsset::HasVO' has a wrong offset!");
static_assert(offsetof(FTalkNodeAsset, bPersistEmotion) == 0x0000FF, "Member 'FTalkNodeAsset::bPersistEmotion' has a wrong offset!");

// ScriptStruct Indiana.ChatterNodeAsset
// 0x0008 (0x00B8 - 0x00B0)
struct FChatterNodeAsset final : public FDialogueNodeAsset
{
public:
	int32                                         VariantCount;                                      // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChatterNodeAsset) == 0x000008, "Wrong alignment on FChatterNodeAsset");
static_assert(sizeof(FChatterNodeAsset) == 0x0000B8, "Wrong size on FChatterNodeAsset");
static_assert(offsetof(FChatterNodeAsset, VariantCount) == 0x0000B0, "Member 'FChatterNodeAsset::VariantCount' has a wrong offset!");

// ScriptStruct Indiana.SoundEffectNodeAsset
// 0x0018 (0x00C8 - 0x00B0)
struct FSoundEffectNodeAsset final : public FDialogueNodeAsset
{
public:
	class FString                                 AudioEvent;                                        // 0x00B0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FadeOutDuration;                                   // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSoundEffectNodeAsset) == 0x000008, "Wrong alignment on FSoundEffectNodeAsset");
static_assert(sizeof(FSoundEffectNodeAsset) == 0x0000C8, "Wrong size on FSoundEffectNodeAsset");
static_assert(offsetof(FSoundEffectNodeAsset, AudioEvent) == 0x0000B0, "Member 'FSoundEffectNodeAsset::AudioEvent' has a wrong offset!");
static_assert(offsetof(FSoundEffectNodeAsset, FadeOutDuration) == 0x0000C0, "Member 'FSoundEffectNodeAsset::FadeOutDuration' has a wrong offset!");

// ScriptStruct Indiana.ChatterBundle
// 0x00E0 (0x00E0 - 0x0000)
struct FChatterBundle final
{
public:
	class FString                                 LoadedFilename;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  ID;                                                // 0x0010(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int32, class FString>                    AudioLookup;                                       // 0x0020(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TArray<class FString>                         StringTableFilenames;                              // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FTalkNodeAsset>                 TalkNodes;                                         // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FScriptNodeAsset>               ScriptNodes;                                       // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FChatterNodeAsset>              ChatterNodes;                                      // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FChatterBranchNodeAsset>        ChatterBranchNodes;                                // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FChatterEventNodeAsset>         ChatterEventNodes;                                 // 0x00C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSoundEffectNodeAsset>          SoundEffectNodes;                                  // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FChatterBundle) == 0x000008, "Wrong alignment on FChatterBundle");
static_assert(sizeof(FChatterBundle) == 0x0000E0, "Wrong size on FChatterBundle");
static_assert(offsetof(FChatterBundle, LoadedFilename) == 0x000000, "Member 'FChatterBundle::LoadedFilename' has a wrong offset!");
static_assert(offsetof(FChatterBundle, ID) == 0x000010, "Member 'FChatterBundle::ID' has a wrong offset!");
static_assert(offsetof(FChatterBundle, AudioLookup) == 0x000020, "Member 'FChatterBundle::AudioLookup' has a wrong offset!");
static_assert(offsetof(FChatterBundle, StringTableFilenames) == 0x000070, "Member 'FChatterBundle::StringTableFilenames' has a wrong offset!");
static_assert(offsetof(FChatterBundle, TalkNodes) == 0x000080, "Member 'FChatterBundle::TalkNodes' has a wrong offset!");
static_assert(offsetof(FChatterBundle, ScriptNodes) == 0x000090, "Member 'FChatterBundle::ScriptNodes' has a wrong offset!");
static_assert(offsetof(FChatterBundle, ChatterNodes) == 0x0000A0, "Member 'FChatterBundle::ChatterNodes' has a wrong offset!");
static_assert(offsetof(FChatterBundle, ChatterBranchNodes) == 0x0000B0, "Member 'FChatterBundle::ChatterBranchNodes' has a wrong offset!");
static_assert(offsetof(FChatterBundle, ChatterEventNodes) == 0x0000C0, "Member 'FChatterBundle::ChatterEventNodes' has a wrong offset!");
static_assert(offsetof(FChatterBundle, SoundEffectNodes) == 0x0000D0, "Member 'FChatterBundle::SoundEffectNodes' has a wrong offset!");

// ScriptStruct Indiana.NameTypeBinding
// 0x000C (0x000C - 0x0000)
struct FNameTypeBinding final
{
public:
	class FName                                   ActionName;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputBindingType                             BindingType;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNameTypeBinding) == 0x000004, "Wrong alignment on FNameTypeBinding");
static_assert(sizeof(FNameTypeBinding) == 0x00000C, "Wrong size on FNameTypeBinding");
static_assert(offsetof(FNameTypeBinding, ActionName) == 0x000000, "Member 'FNameTypeBinding::ActionName' has a wrong offset!");
static_assert(offsetof(FNameTypeBinding, BindingType) == 0x000008, "Member 'FNameTypeBinding::BindingType' has a wrong offset!");

// ScriptStruct Indiana.DynamicOverrides
// 0x0008 (0x0008 - 0x0000)
struct FDynamicOverrides final
{
public:
	struct FLocString                             AutoSprintName;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDynamicOverrides) == 0x000004, "Wrong alignment on FDynamicOverrides");
static_assert(sizeof(FDynamicOverrides) == 0x000008, "Wrong size on FDynamicOverrides");
static_assert(offsetof(FDynamicOverrides, AutoSprintName) == 0x000000, "Member 'FDynamicOverrides::AutoSprintName' has a wrong offset!");

// ScriptStruct Indiana.CompanionCommmandMoveToSettings
// 0x0004 (0x0004 - 0x0000)
struct FCompanionCommmandMoveToSettings final
{
public:
	float                                         WalkDistanceThreshold;                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCompanionCommmandMoveToSettings) == 0x000004, "Wrong alignment on FCompanionCommmandMoveToSettings");
static_assert(sizeof(FCompanionCommmandMoveToSettings) == 0x000004, "Wrong size on FCompanionCommmandMoveToSettings");
static_assert(offsetof(FCompanionCommmandMoveToSettings, WalkDistanceThreshold) == 0x000000, "Member 'FCompanionCommmandMoveToSettings::WalkDistanceThreshold' has a wrong offset!");

// ScriptStruct Indiana.QueryPair
// 0x0010 (0x0010 - 0x0000)
struct FQueryPair final
{
public:
	class UEQSRequest_IndianaBase*                EQSRequest;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQueryPair) == 0x000008, "Wrong alignment on FQueryPair");
static_assert(sizeof(FQueryPair) == 0x000010, "Wrong size on FQueryPair");
static_assert(offsetof(FQueryPair, EQSRequest) == 0x000000, "Member 'FQueryPair::EQSRequest' has a wrong offset!");
static_assert(offsetof(FQueryPair, Weight) == 0x000008, "Member 'FQueryPair::Weight' has a wrong offset!");

// ScriptStruct Indiana.ChatterCooldownSet
// 0x0028 (0x0030 - 0x0008)
struct FChatterCooldownSet final : public FGameDataStructure
{
public:
	uint8                                         Pad_8[0x28];                                       // 0x0008(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChatterCooldownSet) == 0x000008, "Wrong alignment on FChatterCooldownSet");
static_assert(sizeof(FChatterCooldownSet) == 0x000030, "Wrong size on FChatterCooldownSet");

// ScriptStruct Indiana.AimTargets
// 0x0014 (0x0014 - 0x0000)
struct FAimTargets final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ComponentTag;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAimTargets) == 0x000004, "Wrong alignment on FAimTargets");
static_assert(sizeof(FAimTargets) == 0x000014, "Wrong size on FAimTargets");
static_assert(offsetof(FAimTargets, SocketName) == 0x000000, "Member 'FAimTargets::SocketName' has a wrong offset!");
static_assert(offsetof(FAimTargets, ComponentTag) == 0x000008, "Member 'FAimTargets::ComponentTag' has a wrong offset!");
static_assert(offsetof(FAimTargets, Priority) == 0x000010, "Member 'FAimTargets::Priority' has a wrong offset!");

// ScriptStruct Indiana.ChatterCooldownSettings
// 0x0010 (0x0018 - 0x0008)
struct FChatterCooldownSettings final : public FGameDataStructure
{
public:
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChatterCooldownSettings) == 0x000008, "Wrong alignment on FChatterCooldownSettings");
static_assert(sizeof(FChatterCooldownSettings) == 0x000018, "Wrong size on FChatterCooldownSettings");

// ScriptStruct Indiana.GameDataReferenceID
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FGameDataReferenceID
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  ID;                                                // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameDataReferenceID) == 0x000008, "Wrong alignment on FGameDataReferenceID");
static_assert(sizeof(FGameDataReferenceID) == 0x000018, "Wrong size on FGameDataReferenceID");
static_assert(offsetof(FGameDataReferenceID, ID) == 0x000008, "Member 'FGameDataReferenceID::ID' has a wrong offset!");

// ScriptStruct Indiana.MainMenuLevelDescription
// 0x0030 (0x0030 - 0x0000)
struct FMainMenuLevelDescription final
{
public:
	struct FSoftObjectPath                        Level;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLocString                             TextReference;                                     // 0x0018(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDeliverableInCurrentMilestone;                  // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTravelDestinationData*                 TravelDestinationData;                             // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMainMenuLevelDescription) == 0x000008, "Wrong alignment on FMainMenuLevelDescription");
static_assert(sizeof(FMainMenuLevelDescription) == 0x000030, "Wrong size on FMainMenuLevelDescription");
static_assert(offsetof(FMainMenuLevelDescription, Level) == 0x000000, "Member 'FMainMenuLevelDescription::Level' has a wrong offset!");
static_assert(offsetof(FMainMenuLevelDescription, TextReference) == 0x000018, "Member 'FMainMenuLevelDescription::TextReference' has a wrong offset!");
static_assert(offsetof(FMainMenuLevelDescription, bIsDeliverableInCurrentMilestone) == 0x000020, "Member 'FMainMenuLevelDescription::bIsDeliverableInCurrentMilestone' has a wrong offset!");
static_assert(offsetof(FMainMenuLevelDescription, TravelDestinationData) == 0x000028, "Member 'FMainMenuLevelDescription::TravelDestinationData' has a wrong offset!");

// ScriptStruct Indiana.ChatterEventsGameDataReferenceID
// 0x0000 (0x0018 - 0x0018)
struct FChatterEventsGameDataReferenceID final : public FGameDataReferenceID
{
};
static_assert(alignof(FChatterEventsGameDataReferenceID) == 0x000008, "Wrong alignment on FChatterEventsGameDataReferenceID");
static_assert(sizeof(FChatterEventsGameDataReferenceID) == 0x000018, "Wrong size on FChatterEventsGameDataReferenceID");

// ScriptStruct Indiana.CompanionCommandMoveToLocation
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FCompanionCommandMoveToLocation final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCompanionCommandMoveToLocation) == 0x000008, "Wrong alignment on FCompanionCommandMoveToLocation");
static_assert(sizeof(FCompanionCommandMoveToLocation) == 0x000040, "Wrong size on FCompanionCommandMoveToLocation");

// ScriptStruct Indiana.MoveToQueryInfo
// 0x0010 (0x0010 - 0x0000)
struct FMoveToQueryInfo final
{
public:
	struct FVector                                Extent;                                            // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZOffset;                                           // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoveToQueryInfo) == 0x000004, "Wrong alignment on FMoveToQueryInfo");
static_assert(sizeof(FMoveToQueryInfo) == 0x000010, "Wrong size on FMoveToQueryInfo");
static_assert(offsetof(FMoveToQueryInfo, Extent) == 0x000000, "Member 'FMoveToQueryInfo::Extent' has a wrong offset!");
static_assert(offsetof(FMoveToQueryInfo, ZOffset) == 0x00000C, "Member 'FMoveToQueryInfo::ZOffset' has a wrong offset!");

// ScriptStruct Indiana.BotchableQuestInfo
// 0x001C (0x001C - 0x0000)
struct FBotchableQuestInfo final
{
public:
	struct FGuid                                  ID;                                                // 0x0000(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DeathEventID;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DeathEndStateID;                                   // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepDescription;                                  // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBotchableQuestInfo) == 0x000004, "Wrong alignment on FBotchableQuestInfo");
static_assert(sizeof(FBotchableQuestInfo) == 0x00001C, "Wrong size on FBotchableQuestInfo");
static_assert(offsetof(FBotchableQuestInfo, ID) == 0x000000, "Member 'FBotchableQuestInfo::ID' has a wrong offset!");
static_assert(offsetof(FBotchableQuestInfo, DeathEventID) == 0x000010, "Member 'FBotchableQuestInfo::DeathEventID' has a wrong offset!");
static_assert(offsetof(FBotchableQuestInfo, DeathEndStateID) == 0x000014, "Member 'FBotchableQuestInfo::DeathEndStateID' has a wrong offset!");
static_assert(offsetof(FBotchableQuestInfo, bKeepDescription) == 0x000018, "Member 'FBotchableQuestInfo::bKeepDescription' has a wrong offset!");

// ScriptStruct Indiana.StatClampingData
// 0x0010 (0x0010 - 0x0000)
struct FStatClampingData final
{
public:
	bool                                          bMinClamp;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinValue;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaxClamp;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxValue;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatClampingData) == 0x000004, "Wrong alignment on FStatClampingData");
static_assert(sizeof(FStatClampingData) == 0x000010, "Wrong size on FStatClampingData");
static_assert(offsetof(FStatClampingData, bMinClamp) == 0x000000, "Member 'FStatClampingData::bMinClamp' has a wrong offset!");
static_assert(offsetof(FStatClampingData, MinValue) == 0x000004, "Member 'FStatClampingData::MinValue' has a wrong offset!");
static_assert(offsetof(FStatClampingData, bMaxClamp) == 0x000008, "Member 'FStatClampingData::bMaxClamp' has a wrong offset!");
static_assert(offsetof(FStatClampingData, MaxValue) == 0x00000C, "Member 'FStatClampingData::MaxValue' has a wrong offset!");

// ScriptStruct Indiana.CompanionEQSRequest
// 0x0028 (0x0028 - 0x0000)
struct FCompanionEQSRequest final
{
public:
	class UEQSRequest_IndianaBase*                EQSRequest;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloseRadius;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FarRadius;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdealAngle;                                        // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAngle;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementDistanceThreshold;                         // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCompanionEQSRequest) == 0x000008, "Wrong alignment on FCompanionEQSRequest");
static_assert(sizeof(FCompanionEQSRequest) == 0x000028, "Wrong size on FCompanionEQSRequest");
static_assert(offsetof(FCompanionEQSRequest, EQSRequest) == 0x000000, "Member 'FCompanionEQSRequest::EQSRequest' has a wrong offset!");
static_assert(offsetof(FCompanionEQSRequest, CloseRadius) == 0x000008, "Member 'FCompanionEQSRequest::CloseRadius' has a wrong offset!");
static_assert(offsetof(FCompanionEQSRequest, Radius) == 0x00000C, "Member 'FCompanionEQSRequest::Radius' has a wrong offset!");
static_assert(offsetof(FCompanionEQSRequest, FarRadius) == 0x000010, "Member 'FCompanionEQSRequest::FarRadius' has a wrong offset!");
static_assert(offsetof(FCompanionEQSRequest, IdealAngle) == 0x000014, "Member 'FCompanionEQSRequest::IdealAngle' has a wrong offset!");
static_assert(offsetof(FCompanionEQSRequest, MinAngle) == 0x000018, "Member 'FCompanionEQSRequest::MinAngle' has a wrong offset!");
static_assert(offsetof(FCompanionEQSRequest, MovementDistanceThreshold) == 0x00001C, "Member 'FCompanionEQSRequest::MovementDistanceThreshold' has a wrong offset!");

// ScriptStruct Indiana.LocationCost
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FLocationCost final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLocationCost) == 0x000004, "Wrong alignment on FLocationCost");
static_assert(sizeof(FLocationCost) == 0x000010, "Wrong size on FLocationCost");

// ScriptStruct Indiana.ConversationCompanionConfig
// 0x0018 (0x0018 - 0x0000)
struct FConversationCompanionConfig final
{
public:
	struct FVector                                Companion1IdealLocation;                           // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Companion2IdealLocation;                           // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConversationCompanionConfig) == 0x000004, "Wrong alignment on FConversationCompanionConfig");
static_assert(sizeof(FConversationCompanionConfig) == 0x000018, "Wrong size on FConversationCompanionConfig");
static_assert(offsetof(FConversationCompanionConfig, Companion1IdealLocation) == 0x000000, "Member 'FConversationCompanionConfig::Companion1IdealLocation' has a wrong offset!");
static_assert(offsetof(FConversationCompanionConfig, Companion2IdealLocation) == 0x00000C, "Member 'FConversationCompanionConfig::Companion2IdealLocation' has a wrong offset!");

// ScriptStruct Indiana.EntryData
// 0x0010 (0x0010 - 0x0000)
struct FEntryData final
{
public:
	class UMaterialInstance*                      MaterialInstance;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             InWorldBeaconImage;                                // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEntryData) == 0x000008, "Wrong alignment on FEntryData");
static_assert(sizeof(FEntryData) == 0x000010, "Wrong size on FEntryData");
static_assert(offsetof(FEntryData, MaterialInstance) == 0x000000, "Member 'FEntryData::MaterialInstance' has a wrong offset!");
static_assert(offsetof(FEntryData, InWorldBeaconImage) == 0x000008, "Member 'FEntryData::InWorldBeaconImage' has a wrong offset!");

// ScriptStruct Indiana.DistanceRatioToSpeedPair
// 0x0008 (0x0008 - 0x0000)
struct FDistanceRatioToSpeedPair final
{
public:
	float                                         DistanceRatio;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDistanceRatioToSpeedPair) == 0x000004, "Wrong alignment on FDistanceRatioToSpeedPair");
static_assert(sizeof(FDistanceRatioToSpeedPair) == 0x000008, "Wrong size on FDistanceRatioToSpeedPair");
static_assert(offsetof(FDistanceRatioToSpeedPair, DistanceRatio) == 0x000000, "Member 'FDistanceRatioToSpeedPair::DistanceRatio' has a wrong offset!");
static_assert(offsetof(FDistanceRatioToSpeedPair, Duration) == 0x000004, "Member 'FDistanceRatioToSpeedPair::Duration' has a wrong offset!");

// ScriptStruct Indiana.CompassAreaBeaconEaseSetting
// 0x0008 (0x0008 - 0x0000)
struct FCompassAreaBeaconEaseSetting final
{
public:
	EEaseType                                     EaseType;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EaseExponent;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCompassAreaBeaconEaseSetting) == 0x000004, "Wrong alignment on FCompassAreaBeaconEaseSetting");
static_assert(sizeof(FCompassAreaBeaconEaseSetting) == 0x000008, "Wrong size on FCompassAreaBeaconEaseSetting");
static_assert(offsetof(FCompassAreaBeaconEaseSetting, EaseType) == 0x000000, "Member 'FCompassAreaBeaconEaseSetting::EaseType' has a wrong offset!");
static_assert(offsetof(FCompassAreaBeaconEaseSetting, EaseExponent) == 0x000004, "Member 'FCompassAreaBeaconEaseSetting::EaseExponent' has a wrong offset!");

// ScriptStruct Indiana.LocomotionData
// 0x0050 (0x0050 - 0x0000)
struct FLocomotionData final
{
public:
	class UAnimSequence*                          AnimSequence;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimSequenceAlt;                                   // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x40];                                      // 0x0010(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLocomotionData) == 0x000008, "Wrong alignment on FLocomotionData");
static_assert(sizeof(FLocomotionData) == 0x000050, "Wrong size on FLocomotionData");
static_assert(offsetof(FLocomotionData, AnimSequence) == 0x000000, "Member 'FLocomotionData::AnimSequence' has a wrong offset!");
static_assert(offsetof(FLocomotionData, AnimSequenceAlt) == 0x000008, "Member 'FLocomotionData::AnimSequenceAlt' has a wrong offset!");

// ScriptStruct Indiana.ComputerBrandData
// 0x0040 (0x0040 - 0x0000)
struct FComputerBrandData final
{
public:
	TArray<struct FLocString>                     BrandSlogans;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              BrandIcon;                                         // 0x0010(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLocString                             BrandName;                                         // 0x0038(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FComputerBrandData) == 0x000008, "Wrong alignment on FComputerBrandData");
static_assert(sizeof(FComputerBrandData) == 0x000040, "Wrong size on FComputerBrandData");
static_assert(offsetof(FComputerBrandData, BrandSlogans) == 0x000000, "Member 'FComputerBrandData::BrandSlogans' has a wrong offset!");
static_assert(offsetof(FComputerBrandData, BrandIcon) == 0x000010, "Member 'FComputerBrandData::BrandIcon' has a wrong offset!");
static_assert(offsetof(FComputerBrandData, BrandName) == 0x000038, "Member 'FComputerBrandData::BrandName' has a wrong offset!");

// ScriptStruct Indiana.AddictionModifier
// 0x000C (0x000C - 0x0000)
struct FAddictionModifier final
{
public:
	struct FGameplayTag                           AddictionTag;                                      // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmountToRemove;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAddictionModifier) == 0x000004, "Wrong alignment on FAddictionModifier");
static_assert(sizeof(FAddictionModifier) == 0x00000C, "Wrong size on FAddictionModifier");
static_assert(offsetof(FAddictionModifier, AddictionTag) == 0x000000, "Member 'FAddictionModifier::AddictionTag' has a wrong offset!");
static_assert(offsetof(FAddictionModifier, AmountToRemove) == 0x000008, "Member 'FAddictionModifier::AmountToRemove' has a wrong offset!");

// ScriptStruct Indiana.SaveGameDataTargetInfo
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FSaveGameDataTargetInfo final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSaveGameDataTargetInfo) == 0x000004, "Wrong alignment on FSaveGameDataTargetInfo");
static_assert(sizeof(FSaveGameDataTargetInfo) == 0x000014, "Wrong size on FSaveGameDataTargetInfo");

// ScriptStruct Indiana.TalkDependencies
// 0x0090 (0x0090 - 0x0000)
struct FTalkDependencies final
{
public:
	uint8                                         Pad_0[0x80];                                       // 0x0000(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           AnimMontage;                                       // 0x0080(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFaceFXAnim*                            AnimFaceFX;                                        // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkDependencies) == 0x000008, "Wrong alignment on FTalkDependencies");
static_assert(sizeof(FTalkDependencies) == 0x000090, "Wrong size on FTalkDependencies");
static_assert(offsetof(FTalkDependencies, AnimMontage) == 0x000080, "Member 'FTalkDependencies::AnimMontage' has a wrong offset!");
static_assert(offsetof(FTalkDependencies, AnimFaceFX) == 0x000088, "Member 'FTalkDependencies::AnimFaceFX' has a wrong offset!");

// ScriptStruct Indiana.SpeakerGameDataReferenceID
// 0x0000 (0x0018 - 0x0018)
struct FSpeakerGameDataReferenceID final : public FGameDataReferenceID
{
};
static_assert(alignof(FSpeakerGameDataReferenceID) == 0x000008, "Wrong alignment on FSpeakerGameDataReferenceID");
static_assert(sizeof(FSpeakerGameDataReferenceID) == 0x000018, "Wrong size on FSpeakerGameDataReferenceID");

// ScriptStruct Indiana.CharacterDescription
// 0x0020 (0x0020 - 0x0000)
struct FCharacterDescription final
{
public:
	TWeakObjectPtr<class AActor>                  Actor;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSpeakerGameDataReferenceID            CharacterReferenceID;                              // 0x0008(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterDescription) == 0x000008, "Wrong alignment on FCharacterDescription");
static_assert(sizeof(FCharacterDescription) == 0x000020, "Wrong size on FCharacterDescription");
static_assert(offsetof(FCharacterDescription, Actor) == 0x000000, "Member 'FCharacterDescription::Actor' has a wrong offset!");
static_assert(offsetof(FCharacterDescription, CharacterReferenceID) == 0x000008, "Member 'FCharacterDescription::CharacterReferenceID' has a wrong offset!");

// ScriptStruct Indiana.CameraProperties
// 0x0010 (0x0010 - 0x0000)
struct FCameraProperties final
{
public:
	ECameraFramingOffset                          CameraOffset;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCameraTracksMovement;                             // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 FixedCameraTarget;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraProperties) == 0x000008, "Wrong alignment on FCameraProperties");
static_assert(sizeof(FCameraProperties) == 0x000010, "Wrong size on FCameraProperties");
static_assert(offsetof(FCameraProperties, CameraOffset) == 0x000000, "Member 'FCameraProperties::CameraOffset' has a wrong offset!");
static_assert(offsetof(FCameraProperties, bCameraTracksMovement) == 0x000001, "Member 'FCameraProperties::bCameraTracksMovement' has a wrong offset!");
static_assert(offsetof(FCameraProperties, FixedCameraTarget) == 0x000008, "Member 'FCameraProperties::FixedCameraTarget' has a wrong offset!");

// ScriptStruct Indiana.ConversationDescription
// 0x01F8 (0x01F8 - 0x0000)
struct FConversationDescription final
{
public:
	class UConversationData*                      ConversationData;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartNode;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCharacterDescription>          Characters;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<struct FSpeakerGameDataReferenceID, struct FCameraProperties> SpeakerCameraOverrides;                            // 0x0020(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<struct FSpeakerGameDataReferenceID, class AActor*> SpeakerAudioOverrides;                             // 0x0070(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSubclassOf<class UConversationInstance>      InstanceClass;                                     // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EPayloadID, class AActor*>               InstancePayloadActors;                             // 0x00C8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCameraProperties                      BaseCameraProperties;                              // 0x0118(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAllowBarkConversationDuringCombat;                // 0x0128(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACineCameraActor*                       OverrideCamera;                                    // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLogicalExpression                     TeleportCondition;                                 // 0x0138(0x0068)(Edit, NativeAccessSpecifierPublic)
	class AIndianaTargetPoint*                    PlayerTeleport;                                    // 0x01A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCompanionCutscene;                                // 0x01A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AIndianaTargetPoint*                    CompanionOneTeleport;                              // 0x01B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpecialObsidianID                            CompanionOnePreference;                            // 0x01B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B9[0x7];                                      // 0x01B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AIndianaTargetPoint*                    CompanionTwoTeleport;                              // 0x01C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpecialObsidianID                            CompanionTwoPreference;                            // 0x01C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C9[0x7];                                      // 0x01C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AIndianaTargetPoint*                    OwnerTeleport;                                     // 0x01D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D8[0x20];                                     // 0x01D8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConversationDescription) == 0x000008, "Wrong alignment on FConversationDescription");
static_assert(sizeof(FConversationDescription) == 0x0001F8, "Wrong size on FConversationDescription");
static_assert(offsetof(FConversationDescription, ConversationData) == 0x000000, "Member 'FConversationDescription::ConversationData' has a wrong offset!");
static_assert(offsetof(FConversationDescription, StartNode) == 0x000008, "Member 'FConversationDescription::StartNode' has a wrong offset!");
static_assert(offsetof(FConversationDescription, Characters) == 0x000010, "Member 'FConversationDescription::Characters' has a wrong offset!");
static_assert(offsetof(FConversationDescription, SpeakerCameraOverrides) == 0x000020, "Member 'FConversationDescription::SpeakerCameraOverrides' has a wrong offset!");
static_assert(offsetof(FConversationDescription, SpeakerAudioOverrides) == 0x000070, "Member 'FConversationDescription::SpeakerAudioOverrides' has a wrong offset!");
static_assert(offsetof(FConversationDescription, InstanceClass) == 0x0000C0, "Member 'FConversationDescription::InstanceClass' has a wrong offset!");
static_assert(offsetof(FConversationDescription, InstancePayloadActors) == 0x0000C8, "Member 'FConversationDescription::InstancePayloadActors' has a wrong offset!");
static_assert(offsetof(FConversationDescription, BaseCameraProperties) == 0x000118, "Member 'FConversationDescription::BaseCameraProperties' has a wrong offset!");
static_assert(offsetof(FConversationDescription, bAllowBarkConversationDuringCombat) == 0x000128, "Member 'FConversationDescription::bAllowBarkConversationDuringCombat' has a wrong offset!");
static_assert(offsetof(FConversationDescription, OverrideCamera) == 0x000130, "Member 'FConversationDescription::OverrideCamera' has a wrong offset!");
static_assert(offsetof(FConversationDescription, TeleportCondition) == 0x000138, "Member 'FConversationDescription::TeleportCondition' has a wrong offset!");
static_assert(offsetof(FConversationDescription, PlayerTeleport) == 0x0001A0, "Member 'FConversationDescription::PlayerTeleport' has a wrong offset!");
static_assert(offsetof(FConversationDescription, bCompanionCutscene) == 0x0001A8, "Member 'FConversationDescription::bCompanionCutscene' has a wrong offset!");
static_assert(offsetof(FConversationDescription, CompanionOneTeleport) == 0x0001B0, "Member 'FConversationDescription::CompanionOneTeleport' has a wrong offset!");
static_assert(offsetof(FConversationDescription, CompanionOnePreference) == 0x0001B8, "Member 'FConversationDescription::CompanionOnePreference' has a wrong offset!");
static_assert(offsetof(FConversationDescription, CompanionTwoTeleport) == 0x0001C0, "Member 'FConversationDescription::CompanionTwoTeleport' has a wrong offset!");
static_assert(offsetof(FConversationDescription, CompanionTwoPreference) == 0x0001C8, "Member 'FConversationDescription::CompanionTwoPreference' has a wrong offset!");
static_assert(offsetof(FConversationDescription, OwnerTeleport) == 0x0001D0, "Member 'FConversationDescription::OwnerTeleport' has a wrong offset!");

// ScriptStruct Indiana.PONRQuest
// 0x0020 (0x0020 - 0x0000)
struct FPONRQuest final
{
public:
	class FString                                 QuestName;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 QuestEventIDs;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPONRQuest) == 0x000008, "Wrong alignment on FPONRQuest");
static_assert(sizeof(FPONRQuest) == 0x000020, "Wrong size on FPONRQuest");
static_assert(offsetof(FPONRQuest, QuestName) == 0x000000, "Member 'FPONRQuest::QuestName' has a wrong offset!");
static_assert(offsetof(FPONRQuest, QuestEventIDs) == 0x000010, "Member 'FPONRQuest::QuestEventIDs' has a wrong offset!");

// ScriptStruct Indiana.PerceptionRangeScalar
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FPerceptionRangeScalar final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPerceptionRangeScalar) == 0x000008, "Wrong alignment on FPerceptionRangeScalar");
static_assert(sizeof(FPerceptionRangeScalar) == 0x000030, "Wrong size on FPerceptionRangeScalar");

// ScriptStruct Indiana.NodeConfig
// 0x0018 (0x0018 - 0x0000)
struct FNodeConfig final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideCameraProperties;                         // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCameraProperties                      CameraProperties;                                  // 0x0008(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNodeConfig) == 0x000008, "Wrong alignment on FNodeConfig");
static_assert(sizeof(FNodeConfig) == 0x000018, "Wrong size on FNodeConfig");
static_assert(offsetof(FNodeConfig, bEnabled) == 0x000000, "Member 'FNodeConfig::bEnabled' has a wrong offset!");
static_assert(offsetof(FNodeConfig, bOverrideCameraProperties) == 0x000001, "Member 'FNodeConfig::bOverrideCameraProperties' has a wrong offset!");
static_assert(offsetof(FNodeConfig, CameraProperties) == 0x000008, "Member 'FNodeConfig::CameraProperties' has a wrong offset!");

// ScriptStruct Indiana.MaterialParamMod
// 0x0060 (0x0060 - 0x0000)
struct FMaterialParamMod final
{
public:
	class FName                                   MaterialSlotName;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamName;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialParamType                            Type;                                              // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScalarParam;                                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           VectorParam;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                TextureParam;                                      // 0x0028(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMaterialParamMod) == 0x000008, "Wrong alignment on FMaterialParamMod");
static_assert(sizeof(FMaterialParamMod) == 0x000060, "Wrong size on FMaterialParamMod");
static_assert(offsetof(FMaterialParamMod, MaterialSlotName) == 0x000000, "Member 'FMaterialParamMod::MaterialSlotName' has a wrong offset!");
static_assert(offsetof(FMaterialParamMod, ParamName) == 0x000008, "Member 'FMaterialParamMod::ParamName' has a wrong offset!");
static_assert(offsetof(FMaterialParamMod, Type) == 0x000010, "Member 'FMaterialParamMod::Type' has a wrong offset!");
static_assert(offsetof(FMaterialParamMod, ScalarParam) == 0x000014, "Member 'FMaterialParamMod::ScalarParam' has a wrong offset!");
static_assert(offsetof(FMaterialParamMod, VectorParam) == 0x000018, "Member 'FMaterialParamMod::VectorParam' has a wrong offset!");
static_assert(offsetof(FMaterialParamMod, TextureParam) == 0x000028, "Member 'FMaterialParamMod::TextureParam' has a wrong offset!");

// ScriptStruct Indiana.CoverAssetCollisionData
// 0x0040 (0x0040 - 0x0000)
struct FCoverAssetCollisionData final
{
public:
	struct FVector                                BoxExtent;                                         // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(Edit, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoverAssetCollisionData) == 0x000010, "Wrong alignment on FCoverAssetCollisionData");
static_assert(sizeof(FCoverAssetCollisionData) == 0x000040, "Wrong size on FCoverAssetCollisionData");
static_assert(offsetof(FCoverAssetCollisionData, BoxExtent) == 0x000000, "Member 'FCoverAssetCollisionData::BoxExtent' has a wrong offset!");
static_assert(offsetof(FCoverAssetCollisionData, Transform) == 0x000010, "Member 'FCoverAssetCollisionData::Transform' has a wrong offset!");

// ScriptStruct Indiana.CreditsEntry
// 0x0038 (0x0038 - 0x0000)
struct FCreditsEntry final
{
public:
	class FString                                 DebugName;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsText;                                           // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFCreditsTextType                             TextType;                                          // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLocString                             LocString;                                         // 0x0014(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSpacing;                                        // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFCreditsSpacingType                          SpacingType;                                       // 0x001D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsImage;                                          // 0x001E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F[0x1];                                       // 0x001F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             ImageAsset;                                        // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideImageSize;                                // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              OverrideImageSize;                                 // 0x002C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCreditsEntry) == 0x000008, "Wrong alignment on FCreditsEntry");
static_assert(sizeof(FCreditsEntry) == 0x000038, "Wrong size on FCreditsEntry");
static_assert(offsetof(FCreditsEntry, DebugName) == 0x000000, "Member 'FCreditsEntry::DebugName' has a wrong offset!");
static_assert(offsetof(FCreditsEntry, bIsText) == 0x000010, "Member 'FCreditsEntry::bIsText' has a wrong offset!");
static_assert(offsetof(FCreditsEntry, TextType) == 0x000011, "Member 'FCreditsEntry::TextType' has a wrong offset!");
static_assert(offsetof(FCreditsEntry, LocString) == 0x000014, "Member 'FCreditsEntry::LocString' has a wrong offset!");
static_assert(offsetof(FCreditsEntry, bIsSpacing) == 0x00001C, "Member 'FCreditsEntry::bIsSpacing' has a wrong offset!");
static_assert(offsetof(FCreditsEntry, SpacingType) == 0x00001D, "Member 'FCreditsEntry::SpacingType' has a wrong offset!");
static_assert(offsetof(FCreditsEntry, bIsImage) == 0x00001E, "Member 'FCreditsEntry::bIsImage' has a wrong offset!");
static_assert(offsetof(FCreditsEntry, ImageAsset) == 0x000020, "Member 'FCreditsEntry::ImageAsset' has a wrong offset!");
static_assert(offsetof(FCreditsEntry, bOverrideImageSize) == 0x000028, "Member 'FCreditsEntry::bOverrideImageSize' has a wrong offset!");
static_assert(offsetof(FCreditsEntry, OverrideImageSize) == 0x00002C, "Member 'FCreditsEntry::OverrideImageSize' has a wrong offset!");

// ScriptStruct Indiana.CreditsGroup
// 0x0020 (0x0020 - 0x0000)
struct FCreditsGroup final
{
public:
	class FString                                 DebugName;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FCreditsEntry>                  Credits;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FCreditsGroup) == 0x000008, "Wrong alignment on FCreditsGroup");
static_assert(sizeof(FCreditsGroup) == 0x000020, "Wrong size on FCreditsGroup");
static_assert(offsetof(FCreditsGroup, DebugName) == 0x000000, "Member 'FCreditsGroup::DebugName' has a wrong offset!");
static_assert(offsetof(FCreditsGroup, Credits) == 0x000010, "Member 'FCreditsGroup::Credits' has a wrong offset!");

// ScriptStruct Indiana.CapsuleShapeData
// 0x0008 (0x0010 - 0x0008)
struct FCapsuleShapeData final : public FShapeInterface
{
public:
	float                                         CapsuleHalfHeight;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleRadius;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCapsuleShapeData) == 0x000008, "Wrong alignment on FCapsuleShapeData");
static_assert(sizeof(FCapsuleShapeData) == 0x000010, "Wrong size on FCapsuleShapeData");
static_assert(offsetof(FCapsuleShapeData, CapsuleHalfHeight) == 0x000008, "Member 'FCapsuleShapeData::CapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(FCapsuleShapeData, CapsuleRadius) == 0x00000C, "Member 'FCapsuleShapeData::CapsuleRadius' has a wrong offset!");

// ScriptStruct Indiana.RandomBankGameDataReferenceID
// 0x0000 (0x0018 - 0x0018)
struct FRandomBankGameDataReferenceID final : public FGameDataReferenceID
{
};
static_assert(alignof(FRandomBankGameDataReferenceID) == 0x000008, "Wrong alignment on FRandomBankGameDataReferenceID");
static_assert(sizeof(FRandomBankGameDataReferenceID) == 0x000018, "Wrong size on FRandomBankGameDataReferenceID");

// ScriptStruct Indiana.AppliedMaterialParam
// 0x0014 (0x0014 - 0x0000)
struct FAppliedMaterialParam final
{
public:
	TWeakObjectPtr<class UMaterialInstanceDynamic> DynamicMaterial;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialParamType                            ParamType;                                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ParamName;                                         // 0x000C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAppliedMaterialParam) == 0x000004, "Wrong alignment on FAppliedMaterialParam");
static_assert(sizeof(FAppliedMaterialParam) == 0x000014, "Wrong size on FAppliedMaterialParam");
static_assert(offsetof(FAppliedMaterialParam, DynamicMaterial) == 0x000000, "Member 'FAppliedMaterialParam::DynamicMaterial' has a wrong offset!");
static_assert(offsetof(FAppliedMaterialParam, ParamType) == 0x000008, "Member 'FAppliedMaterialParam::ParamType' has a wrong offset!");
static_assert(offsetof(FAppliedMaterialParam, ParamName) == 0x00000C, "Member 'FAppliedMaterialParam::ParamName' has a wrong offset!");

// ScriptStruct Indiana.ReceiveDamageData
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FReceiveDamageData final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReceiveDamageData) == 0x000008, "Wrong alignment on FReceiveDamageData");
static_assert(sizeof(FReceiveDamageData) == 0x000048, "Wrong size on FReceiveDamageData");

// ScriptStruct Indiana.AutoRandomInputProperties
// 0x0050 (0x0050 - 0x0000)
struct FAutoRandomInputProperties final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   Key;                                               // 0x0008(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAxis;                                             // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinAxisDeltaSpeed;                                 // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAxisDeltaSpeed;                                 // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHold;                                             // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinHoldTime;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHoldTime;                                       // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTriggerTime;                                    // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTriggerTime;                                    // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAutoRandomInputProperties) == 0x000008, "Wrong alignment on FAutoRandomInputProperties");
static_assert(sizeof(FAutoRandomInputProperties) == 0x000050, "Wrong size on FAutoRandomInputProperties");
static_assert(offsetof(FAutoRandomInputProperties, bEnable) == 0x000000, "Member 'FAutoRandomInputProperties::bEnable' has a wrong offset!");
static_assert(offsetof(FAutoRandomInputProperties, Key) == 0x000008, "Member 'FAutoRandomInputProperties::Key' has a wrong offset!");
static_assert(offsetof(FAutoRandomInputProperties, bAxis) == 0x000020, "Member 'FAutoRandomInputProperties::bAxis' has a wrong offset!");
static_assert(offsetof(FAutoRandomInputProperties, MinAxisDeltaSpeed) == 0x000024, "Member 'FAutoRandomInputProperties::MinAxisDeltaSpeed' has a wrong offset!");
static_assert(offsetof(FAutoRandomInputProperties, MaxAxisDeltaSpeed) == 0x000028, "Member 'FAutoRandomInputProperties::MaxAxisDeltaSpeed' has a wrong offset!");
static_assert(offsetof(FAutoRandomInputProperties, bHold) == 0x00002C, "Member 'FAutoRandomInputProperties::bHold' has a wrong offset!");
static_assert(offsetof(FAutoRandomInputProperties, MinHoldTime) == 0x000030, "Member 'FAutoRandomInputProperties::MinHoldTime' has a wrong offset!");
static_assert(offsetof(FAutoRandomInputProperties, MaxHoldTime) == 0x000034, "Member 'FAutoRandomInputProperties::MaxHoldTime' has a wrong offset!");
static_assert(offsetof(FAutoRandomInputProperties, MinTriggerTime) == 0x000038, "Member 'FAutoRandomInputProperties::MinTriggerTime' has a wrong offset!");
static_assert(offsetof(FAutoRandomInputProperties, MaxTriggerTime) == 0x00003C, "Member 'FAutoRandomInputProperties::MaxTriggerTime' has a wrong offset!");

// ScriptStruct Indiana.DamageMultipliers
// 0x0010 (0x0010 - 0x0000)
struct FDamageMultipliers final
{
public:
	float                                         BaseDamageMultiplier;                              // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageThresholdMultiplier;                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageResistanceMultiplier;                        // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostArmorDamageMultiplier;                         // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageMultipliers) == 0x000004, "Wrong alignment on FDamageMultipliers");
static_assert(sizeof(FDamageMultipliers) == 0x000010, "Wrong size on FDamageMultipliers");
static_assert(offsetof(FDamageMultipliers, BaseDamageMultiplier) == 0x000000, "Member 'FDamageMultipliers::BaseDamageMultiplier' has a wrong offset!");
static_assert(offsetof(FDamageMultipliers, DamageThresholdMultiplier) == 0x000004, "Member 'FDamageMultipliers::DamageThresholdMultiplier' has a wrong offset!");
static_assert(offsetof(FDamageMultipliers, DamageResistanceMultiplier) == 0x000008, "Member 'FDamageMultipliers::DamageResistanceMultiplier' has a wrong offset!");
static_assert(offsetof(FDamageMultipliers, PostArmorDamageMultiplier) == 0x00000C, "Member 'FDamageMultipliers::PostArmorDamageMultiplier' has a wrong offset!");

// ScriptStruct Indiana.ImpactFxEntry
// 0x0048 (0x0048 - 0x0000)
struct FImpactFxEntry final
{
public:
	TArray<struct FImpactParticle>                ImpactParticles;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Decal;                                             // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalSizeMin;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalSizeMax;                                      // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalSizeMinClamp;                                 // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalSizeMaxClamp;                                 // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalDurationMin;                                  // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalDurationMax;                                  // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalFadeTimeMin;                                  // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalFadeTimeMax;                                  // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeScreenSize;                                    // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalDepth;                                        // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalOffset;                                      // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FImpactFxEntry) == 0x000008, "Wrong alignment on FImpactFxEntry");
static_assert(sizeof(FImpactFxEntry) == 0x000048, "Wrong size on FImpactFxEntry");
static_assert(offsetof(FImpactFxEntry, ImpactParticles) == 0x000000, "Member 'FImpactFxEntry::ImpactParticles' has a wrong offset!");
static_assert(offsetof(FImpactFxEntry, Decal) == 0x000010, "Member 'FImpactFxEntry::Decal' has a wrong offset!");
static_assert(offsetof(FImpactFxEntry, DecalSizeMin) == 0x000018, "Member 'FImpactFxEntry::DecalSizeMin' has a wrong offset!");
static_assert(offsetof(FImpactFxEntry, DecalSizeMax) == 0x00001C, "Member 'FImpactFxEntry::DecalSizeMax' has a wrong offset!");
static_assert(offsetof(FImpactFxEntry, DecalSizeMinClamp) == 0x000020, "Member 'FImpactFxEntry::DecalSizeMinClamp' has a wrong offset!");
static_assert(offsetof(FImpactFxEntry, DecalSizeMaxClamp) == 0x000024, "Member 'FImpactFxEntry::DecalSizeMaxClamp' has a wrong offset!");
static_assert(offsetof(FImpactFxEntry, DecalDurationMin) == 0x000028, "Member 'FImpactFxEntry::DecalDurationMin' has a wrong offset!");
static_assert(offsetof(FImpactFxEntry, DecalDurationMax) == 0x00002C, "Member 'FImpactFxEntry::DecalDurationMax' has a wrong offset!");
static_assert(offsetof(FImpactFxEntry, DecalFadeTimeMin) == 0x000030, "Member 'FImpactFxEntry::DecalFadeTimeMin' has a wrong offset!");
static_assert(offsetof(FImpactFxEntry, DecalFadeTimeMax) == 0x000034, "Member 'FImpactFxEntry::DecalFadeTimeMax' has a wrong offset!");
static_assert(offsetof(FImpactFxEntry, FadeScreenSize) == 0x000038, "Member 'FImpactFxEntry::FadeScreenSize' has a wrong offset!");
static_assert(offsetof(FImpactFxEntry, DecalDepth) == 0x00003C, "Member 'FImpactFxEntry::DecalDepth' has a wrong offset!");
static_assert(offsetof(FImpactFxEntry, NormalOffset) == 0x000040, "Member 'FImpactFxEntry::NormalOffset' has a wrong offset!");

// ScriptStruct Indiana.IndianaGenericDamageEvent
// 0x00C8 (0x00D8 - 0x0010)
struct FIndianaGenericDamageEvent final : public FDamageEvent
{
public:
	uint8                                         Pad_10[0xC8];                                      // 0x0010(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIndianaGenericDamageEvent) == 0x000008, "Wrong alignment on FIndianaGenericDamageEvent");
static_assert(sizeof(FIndianaGenericDamageEvent) == 0x0000D8, "Wrong size on FIndianaGenericDamageEvent");

// ScriptStruct Indiana.BreakBoneInfo
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x10) FBreakBoneInfo final
{
public:
	class FName                                   Target;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Source;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneBreakName;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBroke;                                          // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x47];                                      // 0x0019(0x0047)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBreakBoneInfo) == 0x000010, "Wrong alignment on FBreakBoneInfo");
static_assert(sizeof(FBreakBoneInfo) == 0x000060, "Wrong size on FBreakBoneInfo");
static_assert(offsetof(FBreakBoneInfo, Target) == 0x000000, "Member 'FBreakBoneInfo::Target' has a wrong offset!");
static_assert(offsetof(FBreakBoneInfo, Source) == 0x000008, "Member 'FBreakBoneInfo::Source' has a wrong offset!");
static_assert(offsetof(FBreakBoneInfo, BoneBreakName) == 0x000010, "Member 'FBreakBoneInfo::BoneBreakName' has a wrong offset!");
static_assert(offsetof(FBreakBoneInfo, bIsBroke) == 0x000018, "Member 'FBreakBoneInfo::bIsBroke' has a wrong offset!");

// ScriptStruct Indiana.IndianaPointDamageEvent
// 0x00C8 (0x0170 - 0x00A8)
struct FIndianaPointDamageEvent final : public FPointDamageEvent
{
public:
	uint8                                         Pad_A8[0xC8];                                      // 0x00A8(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIndianaPointDamageEvent) == 0x000008, "Wrong alignment on FIndianaPointDamageEvent");
static_assert(sizeof(FIndianaPointDamageEvent) == 0x000170, "Wrong size on FIndianaPointDamageEvent");

// ScriptStruct Indiana.IndianaRadialDamageEvent
// 0x00C8 (0x0108 - 0x0040)
struct FIndianaRadialDamageEvent final : public FRadialDamageEvent
{
public:
	uint8                                         Pad_40[0xC8];                                      // 0x0040(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIndianaRadialDamageEvent) == 0x000008, "Wrong alignment on FIndianaRadialDamageEvent");
static_assert(sizeof(FIndianaRadialDamageEvent) == 0x000108, "Wrong size on FIndianaRadialDamageEvent");

// ScriptStruct Indiana.GameTimespan
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FGameTimespan final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameTimespan) == 0x000008, "Wrong alignment on FGameTimespan");
static_assert(sizeof(FGameTimespan) == 0x000008, "Wrong size on FGameTimespan");

// ScriptStruct Indiana.DamageLevelScaler
// 0x0090 (0x0090 - 0x0000)
struct FDamageLevelScaler final
{
public:
	bool                                          bScaleBaseDamage;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     BaseDamageCurve;                                   // 0x0008(0x0088)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageLevelScaler) == 0x000008, "Wrong alignment on FDamageLevelScaler");
static_assert(sizeof(FDamageLevelScaler) == 0x000090, "Wrong size on FDamageLevelScaler");
static_assert(offsetof(FDamageLevelScaler, bScaleBaseDamage) == 0x000000, "Member 'FDamageLevelScaler::bScaleBaseDamage' has a wrong offset!");
static_assert(offsetof(FDamageLevelScaler, BaseDamageCurve) == 0x000008, "Member 'FDamageLevelScaler::BaseDamageCurve' has a wrong offset!");

// ScriptStruct Indiana.DamageDescription
// 0x0078 (0x0078 - 0x0000)
struct FDamageDescription final
{
public:
	EDamageEventType                              DamageEventType;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UIndianaDamageType>         DamageType;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UIndianaDamageType>         SecondaryDamageType;                               // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UStatusEffect>>      GuaranteedStatusEffects;                           // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	EMeleeAttackType                              MeleeAttackType;                                   // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitReactType                                 HitReactionType;                                   // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseDamage;                                        // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRange;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseCritChance;                                    // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CritMultiplier;                                    // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StealthMultiplier;                                 // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrazeChanceModifier;                               // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrazeMultiplier;                                   // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageResistanceMultiplier;                        // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageThresholdMultiplier;                         // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostArmorDamageMultiplier;                         // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseOverride;                                   // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumDamage;                                     // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InnerRadius;                                       // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OuterRadius;                                       // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageFalloff;                                     // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDeathClassOverride>            DeathClassOverrides;                               // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageDescription) == 0x000008, "Wrong alignment on FDamageDescription");
static_assert(sizeof(FDamageDescription) == 0x000078, "Wrong size on FDamageDescription");
static_assert(offsetof(FDamageDescription, DamageEventType) == 0x000000, "Member 'FDamageDescription::DamageEventType' has a wrong offset!");
static_assert(offsetof(FDamageDescription, DamageType) == 0x000008, "Member 'FDamageDescription::DamageType' has a wrong offset!");
static_assert(offsetof(FDamageDescription, SecondaryDamageType) == 0x000010, "Member 'FDamageDescription::SecondaryDamageType' has a wrong offset!");
static_assert(offsetof(FDamageDescription, GuaranteedStatusEffects) == 0x000018, "Member 'FDamageDescription::GuaranteedStatusEffects' has a wrong offset!");
static_assert(offsetof(FDamageDescription, MeleeAttackType) == 0x000028, "Member 'FDamageDescription::MeleeAttackType' has a wrong offset!");
static_assert(offsetof(FDamageDescription, HitReactionType) == 0x000029, "Member 'FDamageDescription::HitReactionType' has a wrong offset!");
static_assert(offsetof(FDamageDescription, BaseDamage) == 0x00002C, "Member 'FDamageDescription::BaseDamage' has a wrong offset!");
static_assert(offsetof(FDamageDescription, DamageRange) == 0x000030, "Member 'FDamageDescription::DamageRange' has a wrong offset!");
static_assert(offsetof(FDamageDescription, BaseCritChance) == 0x000034, "Member 'FDamageDescription::BaseCritChance' has a wrong offset!");
static_assert(offsetof(FDamageDescription, CritMultiplier) == 0x000038, "Member 'FDamageDescription::CritMultiplier' has a wrong offset!");
static_assert(offsetof(FDamageDescription, StealthMultiplier) == 0x00003C, "Member 'FDamageDescription::StealthMultiplier' has a wrong offset!");
static_assert(offsetof(FDamageDescription, GrazeChanceModifier) == 0x000040, "Member 'FDamageDescription::GrazeChanceModifier' has a wrong offset!");
static_assert(offsetof(FDamageDescription, GrazeMultiplier) == 0x000044, "Member 'FDamageDescription::GrazeMultiplier' has a wrong offset!");
static_assert(offsetof(FDamageDescription, DamageResistanceMultiplier) == 0x000048, "Member 'FDamageDescription::DamageResistanceMultiplier' has a wrong offset!");
static_assert(offsetof(FDamageDescription, DamageThresholdMultiplier) == 0x00004C, "Member 'FDamageDescription::DamageThresholdMultiplier' has a wrong offset!");
static_assert(offsetof(FDamageDescription, PostArmorDamageMultiplier) == 0x000050, "Member 'FDamageDescription::PostArmorDamageMultiplier' has a wrong offset!");
static_assert(offsetof(FDamageDescription, ImpulseOverride) == 0x000054, "Member 'FDamageDescription::ImpulseOverride' has a wrong offset!");
static_assert(offsetof(FDamageDescription, MinimumDamage) == 0x000058, "Member 'FDamageDescription::MinimumDamage' has a wrong offset!");
static_assert(offsetof(FDamageDescription, InnerRadius) == 0x00005C, "Member 'FDamageDescription::InnerRadius' has a wrong offset!");
static_assert(offsetof(FDamageDescription, OuterRadius) == 0x000060, "Member 'FDamageDescription::OuterRadius' has a wrong offset!");
static_assert(offsetof(FDamageDescription, DamageFalloff) == 0x000064, "Member 'FDamageDescription::DamageFalloff' has a wrong offset!");
static_assert(offsetof(FDamageDescription, DeathClassOverrides) == 0x000068, "Member 'FDamageDescription::DeathClassOverrides' has a wrong offset!");

// ScriptStruct Indiana.SpecialEventVisualsOverride
// 0x0030 (0x0048 - 0x0018)
struct FSpecialEventVisualsOverride final : public FFootstepSurfaceMatch
{
public:
	struct FFootstepVisuals                       Visuals;                                           // 0x0018(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialEventVisualsOverride) == 0x000008, "Wrong alignment on FSpecialEventVisualsOverride");
static_assert(sizeof(FSpecialEventVisualsOverride) == 0x000048, "Wrong size on FSpecialEventVisualsOverride");
static_assert(offsetof(FSpecialEventVisualsOverride, Visuals) == 0x000018, "Member 'FSpecialEventVisualsOverride::Visuals' has a wrong offset!");

// ScriptStruct Indiana.IndianaDamageEvent
// 0x0050 (0x0050 - 0x0000)
struct FIndianaDamageEvent final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UImpactDataSet*                         ImpactDataSet;                                     // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIndianaDamageEvent) == 0x000008, "Wrong alignment on FIndianaDamageEvent");
static_assert(sizeof(FIndianaDamageEvent) == 0x000050, "Wrong size on FIndianaDamageEvent");
static_assert(offsetof(FIndianaDamageEvent, ImpactDataSet) == 0x000020, "Member 'FIndianaDamageEvent::ImpactDataSet' has a wrong offset!");

// ScriptStruct Indiana.DeathClassRow
// 0x0020 (0x0020 - 0x0000)
struct FDeathClassRow final
{
public:
	TSubclassOf<class UDeathClass>                DeathClass;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDeathBodyTypeParticleSystems*          ParticleSystemData;                                // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDeathBodyTypeAudioEvents*              AudioEventData;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExagerateVerticalImpulse;                         // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExageratedStrength;                                // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeathClassRow) == 0x000008, "Wrong alignment on FDeathClassRow");
static_assert(sizeof(FDeathClassRow) == 0x000020, "Wrong size on FDeathClassRow");
static_assert(offsetof(FDeathClassRow, DeathClass) == 0x000000, "Member 'FDeathClassRow::DeathClass' has a wrong offset!");
static_assert(offsetof(FDeathClassRow, ParticleSystemData) == 0x000008, "Member 'FDeathClassRow::ParticleSystemData' has a wrong offset!");
static_assert(offsetof(FDeathClassRow, AudioEventData) == 0x000010, "Member 'FDeathClassRow::AudioEventData' has a wrong offset!");
static_assert(offsetof(FDeathClassRow, bExagerateVerticalImpulse) == 0x000018, "Member 'FDeathClassRow::bExagerateVerticalImpulse' has a wrong offset!");
static_assert(offsetof(FDeathClassRow, ExageratedStrength) == 0x00001C, "Member 'FDeathClassRow::ExageratedStrength' has a wrong offset!");

// ScriptStruct Indiana.WeatherState
// 0x002C (0x002C - 0x0000)
struct FWeatherState final
{
public:
	bool                                          HasBeenInitialized;                                // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CloudFormingEnded;                                 // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RainStartedEnded;                                  // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WeatherStarted;                                    // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WeatherEndEnded;                                   // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimelineCloudFormationP;                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimelineRainStart;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimelineRainEnd;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimelineDyingTimeline;                             // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomWindGenerator;                               // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimelineSandstormStart;                            // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimelineSandStormDuration;                         // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimelineSandStormEnding;                           // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SandStormDensity;                                  // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeatherState) == 0x000004, "Wrong alignment on FWeatherState");
static_assert(sizeof(FWeatherState) == 0x00002C, "Wrong size on FWeatherState");
static_assert(offsetof(FWeatherState, HasBeenInitialized) == 0x000000, "Member 'FWeatherState::HasBeenInitialized' has a wrong offset!");
static_assert(offsetof(FWeatherState, CloudFormingEnded) == 0x000001, "Member 'FWeatherState::CloudFormingEnded' has a wrong offset!");
static_assert(offsetof(FWeatherState, RainStartedEnded) == 0x000002, "Member 'FWeatherState::RainStartedEnded' has a wrong offset!");
static_assert(offsetof(FWeatherState, WeatherStarted) == 0x000003, "Member 'FWeatherState::WeatherStarted' has a wrong offset!");
static_assert(offsetof(FWeatherState, WeatherEndEnded) == 0x000004, "Member 'FWeatherState::WeatherEndEnded' has a wrong offset!");
static_assert(offsetof(FWeatherState, TimelineCloudFormationP) == 0x000008, "Member 'FWeatherState::TimelineCloudFormationP' has a wrong offset!");
static_assert(offsetof(FWeatherState, TimelineRainStart) == 0x00000C, "Member 'FWeatherState::TimelineRainStart' has a wrong offset!");
static_assert(offsetof(FWeatherState, TimelineRainEnd) == 0x000010, "Member 'FWeatherState::TimelineRainEnd' has a wrong offset!");
static_assert(offsetof(FWeatherState, TimelineDyingTimeline) == 0x000014, "Member 'FWeatherState::TimelineDyingTimeline' has a wrong offset!");
static_assert(offsetof(FWeatherState, RandomWindGenerator) == 0x000018, "Member 'FWeatherState::RandomWindGenerator' has a wrong offset!");
static_assert(offsetof(FWeatherState, TimelineSandstormStart) == 0x00001C, "Member 'FWeatherState::TimelineSandstormStart' has a wrong offset!");
static_assert(offsetof(FWeatherState, TimelineSandStormDuration) == 0x000020, "Member 'FWeatherState::TimelineSandStormDuration' has a wrong offset!");
static_assert(offsetof(FWeatherState, TimelineSandStormEnding) == 0x000024, "Member 'FWeatherState::TimelineSandStormEnding' has a wrong offset!");
static_assert(offsetof(FWeatherState, SandStormDensity) == 0x000028, "Member 'FWeatherState::SandStormDensity' has a wrong offset!");

// ScriptStruct Indiana.DeathBodyTypeAudioEvent
// 0x0010 (0x0010 - 0x0000)
struct FDeathBodyTypeAudioEvent final
{
public:
	struct FGameplayTag                           DeathAudioEvent;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AudioEvent;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeathBodyTypeAudioEvent) == 0x000008, "Wrong alignment on FDeathBodyTypeAudioEvent");
static_assert(sizeof(FDeathBodyTypeAudioEvent) == 0x000010, "Wrong size on FDeathBodyTypeAudioEvent");
static_assert(offsetof(FDeathBodyTypeAudioEvent, DeathAudioEvent) == 0x000000, "Member 'FDeathBodyTypeAudioEvent::DeathAudioEvent' has a wrong offset!");
static_assert(offsetof(FDeathBodyTypeAudioEvent, AudioEvent) == 0x000008, "Member 'FDeathBodyTypeAudioEvent::AudioEvent' has a wrong offset!");

// ScriptStruct Indiana.DeathPoseData
// 0x0068 (0x0068 - 0x0000)
struct alignas(0x08) FDeathPoseData final
{
public:
	uint8                                         Pad_0[0x68];                                       // 0x0000(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDeathPoseData) == 0x000008, "Wrong alignment on FDeathPoseData");
static_assert(sizeof(FDeathPoseData) == 0x000068, "Wrong size on FDeathPoseData");

// ScriptStruct Indiana.MapCompassUIVisuals
// 0x0018 (0x0018 - 0x0000)
struct FMapCompassUIVisuals final
{
public:
	struct FLocString                             Name;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLocString                             Description;                                       // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Texture;                                           // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapCompassUIVisuals) == 0x000008, "Wrong alignment on FMapCompassUIVisuals");
static_assert(sizeof(FMapCompassUIVisuals) == 0x000018, "Wrong size on FMapCompassUIVisuals");
static_assert(offsetof(FMapCompassUIVisuals, Name) == 0x000000, "Member 'FMapCompassUIVisuals::Name' has a wrong offset!");
static_assert(offsetof(FMapCompassUIVisuals, Description) == 0x000008, "Member 'FMapCompassUIVisuals::Description' has a wrong offset!");
static_assert(offsetof(FMapCompassUIVisuals, Texture) == 0x000010, "Member 'FMapCompassUIVisuals::Texture' has a wrong offset!");

// ScriptStruct Indiana.DeathBodyInstanceData
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x10) FDeathBodyInstanceData final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDeathBodyInstanceData) == 0x000010, "Wrong alignment on FDeathBodyInstanceData");
static_assert(sizeof(FDeathBodyInstanceData) == 0x000060, "Wrong size on FDeathBodyInstanceData");

// ScriptStruct Indiana.RandomRequestItem
// 0x0010 (0x0010 - 0x0000)
struct FRandomRequestItem final
{
public:
	class UDecisionTreeRequestData*               Request;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cooldown;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomRequestItem) == 0x000008, "Wrong alignment on FRandomRequestItem");
static_assert(sizeof(FRandomRequestItem) == 0x000010, "Wrong size on FRandomRequestItem");
static_assert(offsetof(FRandomRequestItem, Request) == 0x000000, "Member 'FRandomRequestItem::Request' has a wrong offset!");
static_assert(offsetof(FRandomRequestItem, Weight) == 0x000008, "Member 'FRandomRequestItem::Weight' has a wrong offset!");
static_assert(offsetof(FRandomRequestItem, Cooldown) == 0x00000C, "Member 'FRandomRequestItem::Cooldown' has a wrong offset!");

// ScriptStruct Indiana.AttributesArray
// 0x0010 (0x0010 - 0x0000)
struct FAttributesArray final
{
public:
	TArray<EAttribute>                            Attributes;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttributesArray) == 0x000008, "Wrong alignment on FAttributesArray");
static_assert(sizeof(FAttributesArray) == 0x000010, "Wrong size on FAttributesArray");
static_assert(offsetof(FAttributesArray, Attributes) == 0x000000, "Member 'FAttributesArray::Attributes' has a wrong offset!");

// ScriptStruct Indiana.PhaseWeaponDefinition
// 0x0008 (0x0008 - 0x0000)
struct FPhaseWeaponDefinition final
{
public:
	int32                                         Phase;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeaponIndex;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPhaseWeaponDefinition) == 0x000004, "Wrong alignment on FPhaseWeaponDefinition");
static_assert(sizeof(FPhaseWeaponDefinition) == 0x000008, "Wrong size on FPhaseWeaponDefinition");
static_assert(offsetof(FPhaseWeaponDefinition, Phase) == 0x000000, "Member 'FPhaseWeaponDefinition::Phase' has a wrong offset!");
static_assert(offsetof(FPhaseWeaponDefinition, WeaponIndex) == 0x000004, "Member 'FPhaseWeaponDefinition::WeaponIndex' has a wrong offset!");

// ScriptStruct Indiana.DecisionTreeStack
// 0x0010 (0x0010 - 0x0000)
struct FDecisionTreeStack final
{
public:
	TArray<TSubclassOf<class UDecisionTree>>      DecisionTrees;                                     // 0x0000(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
};
static_assert(alignof(FDecisionTreeStack) == 0x000008, "Wrong alignment on FDecisionTreeStack");
static_assert(sizeof(FDecisionTreeStack) == 0x000010, "Wrong size on FDecisionTreeStack");
static_assert(offsetof(FDecisionTreeStack, DecisionTrees) == 0x000000, "Member 'FDecisionTreeStack::DecisionTrees' has a wrong offset!");

// ScriptStruct Indiana.DecisionTreeContextMap
// 0x0060 (0x0060 - 0x0000)
struct FDecisionTreeContextMap final
{
public:
	struct FDecisionTreeStack                     DefaultDecisionTrees;                              // 0x0000(0x0010)(Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FDecisionTreeStack>  DecisionTreeMap;                                   // 0x0010(0x0050)(Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FDecisionTreeContextMap) == 0x000008, "Wrong alignment on FDecisionTreeContextMap");
static_assert(sizeof(FDecisionTreeContextMap) == 0x000060, "Wrong size on FDecisionTreeContextMap");
static_assert(offsetof(FDecisionTreeContextMap, DefaultDecisionTrees) == 0x000000, "Member 'FDecisionTreeContextMap::DefaultDecisionTrees' has a wrong offset!");
static_assert(offsetof(FDecisionTreeContextMap, DecisionTreeMap) == 0x000010, "Member 'FDecisionTreeContextMap::DecisionTreeMap' has a wrong offset!");

// ScriptStruct Indiana.GameTimeDataEntry
// 0x000C (0x000C - 0x0000)
struct FGameTimeDataEntry final
{
public:
	int32                                         Days;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Hours;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Minutes;                                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGameTimeDataEntry) == 0x000004, "Wrong alignment on FGameTimeDataEntry");
static_assert(sizeof(FGameTimeDataEntry) == 0x00000C, "Wrong size on FGameTimeDataEntry");
static_assert(offsetof(FGameTimeDataEntry, Days) == 0x000000, "Member 'FGameTimeDataEntry::Days' has a wrong offset!");
static_assert(offsetof(FGameTimeDataEntry, Hours) == 0x000004, "Member 'FGameTimeDataEntry::Hours' has a wrong offset!");
static_assert(offsetof(FGameTimeDataEntry, Minutes) == 0x000008, "Member 'FGameTimeDataEntry::Minutes' has a wrong offset!");

// ScriptStruct Indiana.DecisionTreeMapElement
// 0x0010 (0x0010 - 0x0000)
struct FDecisionTreeMapElement final
{
public:
	struct FGameplayTag                           EventType;                                         // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDecisionTree>              DecisionTree;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDecisionTreeMapElement) == 0x000008, "Wrong alignment on FDecisionTreeMapElement");
static_assert(sizeof(FDecisionTreeMapElement) == 0x000010, "Wrong size on FDecisionTreeMapElement");
static_assert(offsetof(FDecisionTreeMapElement, EventType) == 0x000000, "Member 'FDecisionTreeMapElement::EventType' has a wrong offset!");
static_assert(offsetof(FDecisionTreeMapElement, DecisionTree) == 0x000008, "Member 'FDecisionTreeMapElement::DecisionTree' has a wrong offset!");

// ScriptStruct Indiana.HitLocationChance
// 0x0028 (0x0028 - 0x0000)
struct FHitLocationChance final
{
public:
	struct FGameplayTagContainer                  BodyParts;                                         // 0x0000(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bWeakSpot;                                         // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitLocationChance) == 0x000008, "Wrong alignment on FHitLocationChance");
static_assert(sizeof(FHitLocationChance) == 0x000028, "Wrong size on FHitLocationChance");
static_assert(offsetof(FHitLocationChance, BodyParts) == 0x000000, "Member 'FHitLocationChance::BodyParts' has a wrong offset!");
static_assert(offsetof(FHitLocationChance, bWeakSpot) == 0x000020, "Member 'FHitLocationChance::bWeakSpot' has a wrong offset!");

// ScriptStruct Indiana.DifficultyModifier
// 0x0090 (0x0090 - 0x0000)
struct FDifficultyModifier final
{
public:
	bool                                          bUseCurve;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     Curve;                                             // 0x0008(0x0088)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDifficultyModifier) == 0x000008, "Wrong alignment on FDifficultyModifier");
static_assert(sizeof(FDifficultyModifier) == 0x000090, "Wrong size on FDifficultyModifier");
static_assert(offsetof(FDifficultyModifier, bUseCurve) == 0x000000, "Member 'FDifficultyModifier::bUseCurve' has a wrong offset!");
static_assert(offsetof(FDifficultyModifier, Value) == 0x000004, "Member 'FDifficultyModifier::Value' has a wrong offset!");
static_assert(offsetof(FDifficultyModifier, Curve) == 0x000008, "Member 'FDifficultyModifier::Curve' has a wrong offset!");

// ScriptStruct Indiana.DifficultyStatModifierDescription
// 0x0240 (0x0250 - 0x0010)
struct FDifficultyStatModifierDescription final : public FStatModifierDescriptionBase
{
public:
	struct FDifficultyModifier                    DifficultyModifiers[0x4];                          // 0x0010(0x0090)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDifficultyStatModifierDescription) == 0x000008, "Wrong alignment on FDifficultyStatModifierDescription");
static_assert(sizeof(FDifficultyStatModifierDescription) == 0x000250, "Wrong size on FDifficultyStatModifierDescription");
static_assert(offsetof(FDifficultyStatModifierDescription, DifficultyModifiers) == 0x000010, "Member 'FDifficultyStatModifierDescription::DifficultyModifiers' has a wrong offset!");

// ScriptStruct Indiana.InterestTypeData
// 0x0010 (0x0010 - 0x0000)
struct FInterestTypeData final
{
public:
	struct FGameplayTag                           InterestType;                                      // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Weight;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Cooldown;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FInterestTypeData) == 0x000004, "Wrong alignment on FInterestTypeData");
static_assert(sizeof(FInterestTypeData) == 0x000010, "Wrong size on FInterestTypeData");
static_assert(offsetof(FInterestTypeData, InterestType) == 0x000000, "Member 'FInterestTypeData::InterestType' has a wrong offset!");
static_assert(offsetof(FInterestTypeData, Weight) == 0x000008, "Member 'FInterestTypeData::Weight' has a wrong offset!");
static_assert(offsetof(FInterestTypeData, Cooldown) == 0x00000C, "Member 'FInterestTypeData::Cooldown' has a wrong offset!");

// ScriptStruct Indiana.EmotionEntry
// 0x00A8 (0x00A8 - 0x0000)
struct FEmotionEntry final
{
public:
	TMap<class FName, struct FLoopRandomSequence> TalkingSequences;                                  // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FRandomPlayerSequenceEntryNamed> Idle;                                              // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRandomPlayerSequenceEntryNamed> DialogIdle;                                        // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLoopRandomSequence>            IdleStates;                                        // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimSequence*                          WalkForwardSequence;                               // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BeginEmotionSequence;                              // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          EmotionAdditiveLayerStart;                         // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          EmotionAdditiveLayer;                              // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveLayerStrengthOffset;                       // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEmotionEntry) == 0x000008, "Wrong alignment on FEmotionEntry");
static_assert(sizeof(FEmotionEntry) == 0x0000A8, "Wrong size on FEmotionEntry");
static_assert(offsetof(FEmotionEntry, TalkingSequences) == 0x000000, "Member 'FEmotionEntry::TalkingSequences' has a wrong offset!");
static_assert(offsetof(FEmotionEntry, Idle) == 0x000050, "Member 'FEmotionEntry::Idle' has a wrong offset!");
static_assert(offsetof(FEmotionEntry, DialogIdle) == 0x000060, "Member 'FEmotionEntry::DialogIdle' has a wrong offset!");
static_assert(offsetof(FEmotionEntry, IdleStates) == 0x000070, "Member 'FEmotionEntry::IdleStates' has a wrong offset!");
static_assert(offsetof(FEmotionEntry, WalkForwardSequence) == 0x000080, "Member 'FEmotionEntry::WalkForwardSequence' has a wrong offset!");
static_assert(offsetof(FEmotionEntry, BeginEmotionSequence) == 0x000088, "Member 'FEmotionEntry::BeginEmotionSequence' has a wrong offset!");
static_assert(offsetof(FEmotionEntry, EmotionAdditiveLayerStart) == 0x000090, "Member 'FEmotionEntry::EmotionAdditiveLayerStart' has a wrong offset!");
static_assert(offsetof(FEmotionEntry, EmotionAdditiveLayer) == 0x000098, "Member 'FEmotionEntry::EmotionAdditiveLayer' has a wrong offset!");
static_assert(offsetof(FEmotionEntry, AdditiveLayerStrengthOffset) == 0x0000A0, "Member 'FEmotionEntry::AdditiveLayerStrengthOffset' has a wrong offset!");

// ScriptStruct Indiana.PotentialEncounterList
// 0x0010 (0x0010 - 0x0000)
struct FPotentialEncounterList final
{
public:
	class UEncounterList*                         EncounterList;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistEncounter;                                 // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPotentialEncounterList) == 0x000008, "Wrong alignment on FPotentialEncounterList");
static_assert(sizeof(FPotentialEncounterList) == 0x000010, "Wrong size on FPotentialEncounterList");
static_assert(offsetof(FPotentialEncounterList, EncounterList) == 0x000000, "Member 'FPotentialEncounterList::EncounterList' has a wrong offset!");
static_assert(offsetof(FPotentialEncounterList, Priority) == 0x000008, "Member 'FPotentialEncounterList::Priority' has a wrong offset!");
static_assert(offsetof(FPotentialEncounterList, bPersistEncounter) == 0x00000C, "Member 'FPotentialEncounterList::bPersistEncounter' has a wrong offset!");

// ScriptStruct Indiana.NavigationJumpSettings
// 0x0008 (0x0008 - 0x0000)
struct FNavigationJumpSettings final
{
public:
	float                                         MaxJumpDistance;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxJumpHeight;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavigationJumpSettings) == 0x000004, "Wrong alignment on FNavigationJumpSettings");
static_assert(sizeof(FNavigationJumpSettings) == 0x000008, "Wrong size on FNavigationJumpSettings");
static_assert(offsetof(FNavigationJumpSettings, MaxJumpDistance) == 0x000000, "Member 'FNavigationJumpSettings::MaxJumpDistance' has a wrong offset!");
static_assert(offsetof(FNavigationJumpSettings, MaxJumpHeight) == 0x000004, "Member 'FNavigationJumpSettings::MaxJumpHeight' has a wrong offset!");

// ScriptStruct Indiana.EncounterClearConditions
// 0x00F8 (0x00F8 - 0x0000)
struct FEncounterClearConditions final
{
public:
	struct FLogicalGroupedExpression              ForceClearConditions;                              // 0x0000(0x0078)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLogicalGroupedExpression              ClearConditions;                                   // 0x0078(0x0078)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         KillPercentToClear;                                // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEncounterClearConditions) == 0x000008, "Wrong alignment on FEncounterClearConditions");
static_assert(sizeof(FEncounterClearConditions) == 0x0000F8, "Wrong size on FEncounterClearConditions");
static_assert(offsetof(FEncounterClearConditions, ForceClearConditions) == 0x000000, "Member 'FEncounterClearConditions::ForceClearConditions' has a wrong offset!");
static_assert(offsetof(FEncounterClearConditions, ClearConditions) == 0x000078, "Member 'FEncounterClearConditions::ClearConditions' has a wrong offset!");
static_assert(offsetof(FEncounterClearConditions, KillPercentToClear) == 0x0000F0, "Member 'FEncounterClearConditions::KillPercentToClear' has a wrong offset!");

// ScriptStruct Indiana.ConversationPoNR
// 0x0068 (0x0068 - 0x0000)
struct FConversationPoNR final
{
public:
	class FName                                   Filename;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConversationReference                 Conversation;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TMap<class FString, int32>                    GlobalVariables;                                   // 0x0018(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConversationPoNR) == 0x000008, "Wrong alignment on FConversationPoNR");
static_assert(sizeof(FConversationPoNR) == 0x000068, "Wrong size on FConversationPoNR");
static_assert(offsetof(FConversationPoNR, Filename) == 0x000000, "Member 'FConversationPoNR::Filename' has a wrong offset!");
static_assert(offsetof(FConversationPoNR, Conversation) == 0x000008, "Member 'FConversationPoNR::Conversation' has a wrong offset!");
static_assert(offsetof(FConversationPoNR, GlobalVariables) == 0x000018, "Member 'FConversationPoNR::GlobalVariables' has a wrong offset!");

// ScriptStruct Indiana.EncounterActivationConditions
// 0x0098 (0x0098 - 0x0000)
struct FEncounterActivationConditions final
{
public:
	struct FLogicalGroupedExpression              ValidConditions;                                   // 0x0000(0x0078)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bRestrictTimePhases;                               // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPhaseOfDay>                           ValidTimePhases;                                   // 0x0080(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         ActivationChance;                                  // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEncounterActivationConditions) == 0x000008, "Wrong alignment on FEncounterActivationConditions");
static_assert(sizeof(FEncounterActivationConditions) == 0x000098, "Wrong size on FEncounterActivationConditions");
static_assert(offsetof(FEncounterActivationConditions, ValidConditions) == 0x000000, "Member 'FEncounterActivationConditions::ValidConditions' has a wrong offset!");
static_assert(offsetof(FEncounterActivationConditions, bRestrictTimePhases) == 0x000078, "Member 'FEncounterActivationConditions::bRestrictTimePhases' has a wrong offset!");
static_assert(offsetof(FEncounterActivationConditions, ValidTimePhases) == 0x000080, "Member 'FEncounterActivationConditions::ValidTimePhases' has a wrong offset!");
static_assert(offsetof(FEncounterActivationConditions, ActivationChance) == 0x000090, "Member 'FEncounterActivationConditions::ActivationChance' has a wrong offset!");

// ScriptStruct Indiana.MedKitConsumableSlot
// 0x0010 (0x0010 - 0x0000)
struct FMedKitConsumableSlot final
{
public:
	TSubclassOf<class UConsumableItem>            Consumable;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMedKitConsumableSlot) == 0x000008, "Wrong alignment on FMedKitConsumableSlot");
static_assert(sizeof(FMedKitConsumableSlot) == 0x000010, "Wrong size on FMedKitConsumableSlot");
static_assert(offsetof(FMedKitConsumableSlot, Consumable) == 0x000000, "Member 'FMedKitConsumableSlot::Consumable' has a wrong offset!");

// ScriptStruct Indiana.ExaminableStringSet
// 0x0020 (0x0020 - 0x0000)
struct FExaminableStringSet final
{
public:
	struct FLocString                             Name;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLocString                             Description;                                       // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLocString                             OverrideLabel;                                     // 0x0010(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RemoteEventOnExaminationEnd;                       // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExaminableStringSet) == 0x000004, "Wrong alignment on FExaminableStringSet");
static_assert(sizeof(FExaminableStringSet) == 0x000020, "Wrong size on FExaminableStringSet");
static_assert(offsetof(FExaminableStringSet, Name) == 0x000000, "Member 'FExaminableStringSet::Name' has a wrong offset!");
static_assert(offsetof(FExaminableStringSet, Description) == 0x000008, "Member 'FExaminableStringSet::Description' has a wrong offset!");
static_assert(offsetof(FExaminableStringSet, OverrideLabel) == 0x000010, "Member 'FExaminableStringSet::OverrideLabel' has a wrong offset!");
static_assert(offsetof(FExaminableStringSet, RemoteEventOnExaminationEnd) == 0x000018, "Member 'FExaminableStringSet::RemoteEventOnExaminationEnd' has a wrong offset!");

// ScriptStruct Indiana.WeaponSlot
// 0x0008 (0x0008 - 0x0000)
struct FWeaponSlot final
{
public:
	TWeakObjectPtr<class UWeapon>                 Weapon;                                            // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponSlot) == 0x000004, "Wrong alignment on FWeaponSlot");
static_assert(sizeof(FWeaponSlot) == 0x000008, "Wrong size on FWeaponSlot");
static_assert(offsetof(FWeaponSlot, Weapon) == 0x000000, "Member 'FWeaponSlot::Weapon' has a wrong offset!");

// ScriptStruct Indiana.EventEffectParams
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x08) FEventEffectParams final
{
public:
	uint8                                         Pad_0[0x80];                                       // 0x0000(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEventEffectParams) == 0x000008, "Wrong alignment on FEventEffectParams");
static_assert(sizeof(FEventEffectParams) == 0x000080, "Wrong size on FEventEffectParams");

// ScriptStruct Indiana.InteractPayload
// 0x0018 (0x0018 - 0x0000)
struct FInteractPayload final
{
public:
	int32                                         Int32_1;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float_1;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 String_1;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractPayload) == 0x000008, "Wrong alignment on FInteractPayload");
static_assert(sizeof(FInteractPayload) == 0x000018, "Wrong size on FInteractPayload");
static_assert(offsetof(FInteractPayload, Int32_1) == 0x000000, "Member 'FInteractPayload::Int32_1' has a wrong offset!");
static_assert(offsetof(FInteractPayload, Float_1) == 0x000004, "Member 'FInteractPayload::Float_1' has a wrong offset!");
static_assert(offsetof(FInteractPayload, String_1) == 0x000008, "Member 'FInteractPayload::String_1' has a wrong offset!");

// ScriptStruct Indiana.PlayFxState
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FPlayFxState final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayFxState) == 0x000004, "Wrong alignment on FPlayFxState");
static_assert(sizeof(FPlayFxState) == 0x000008, "Wrong size on FPlayFxState");

// ScriptStruct Indiana.PlayFxPair
// 0x0010 (0x0010 - 0x0000)
struct FPlayFxPair final
{
public:
	TWeakObjectPtr<class UPlayFxEventEffect>      EventEffect;                                       // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayFxState                           State;                                             // 0x0008(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayFxPair) == 0x000004, "Wrong alignment on FPlayFxPair");
static_assert(sizeof(FPlayFxPair) == 0x000010, "Wrong size on FPlayFxPair");
static_assert(offsetof(FPlayFxPair, EventEffect) == 0x000000, "Member 'FPlayFxPair::EventEffect' has a wrong offset!");
static_assert(offsetof(FPlayFxPair, State) == 0x000008, "Member 'FPlayFxPair::State' has a wrong offset!");

// ScriptStruct Indiana.EventEffectState
// 0x0020 (0x0020 - 0x0000)
struct FEventEffectState final
{
public:
	TArray<struct FAkPlaySoundStatePair>          PlayAkSoundStateMap;                               // 0x0000(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FPlayFxPair>                    PlayFxStateMap;                                    // 0x0010(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FEventEffectState) == 0x000008, "Wrong alignment on FEventEffectState");
static_assert(sizeof(FEventEffectState) == 0x000020, "Wrong size on FEventEffectState");
static_assert(offsetof(FEventEffectState, PlayAkSoundStateMap) == 0x000000, "Member 'FEventEffectState::PlayAkSoundStateMap' has a wrong offset!");
static_assert(offsetof(FEventEffectState, PlayFxStateMap) == 0x000010, "Member 'FEventEffectState::PlayFxStateMap' has a wrong offset!");

// ScriptStruct Indiana.FaceFxRigsGameDataReferenceID
// 0x0000 (0x0018 - 0x0018)
struct FFaceFxRigsGameDataReferenceID final : public FGameDataReferenceID
{
};
static_assert(alignof(FFaceFxRigsGameDataReferenceID) == 0x000008, "Wrong alignment on FFaceFxRigsGameDataReferenceID");
static_assert(sizeof(FFaceFxRigsGameDataReferenceID) == 0x000018, "Wrong size on FFaceFxRigsGameDataReferenceID");

// ScriptStruct Indiana.ShotInfo
// 0x0108 (0x0108 - 0x0000)
struct FShotInfo final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDamageDescription                     DamageDescription;                                 // 0x0040(0x0078)(NativeAccessSpecifierPublic)
	struct FIndianaDamageEvent                    DamageEvent;                                       // 0x00B8(0x0050)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShotInfo) == 0x000008, "Wrong alignment on FShotInfo");
static_assert(sizeof(FShotInfo) == 0x000108, "Wrong size on FShotInfo");
static_assert(offsetof(FShotInfo, DamageDescription) == 0x000040, "Member 'FShotInfo::DamageDescription' has a wrong offset!");
static_assert(offsetof(FShotInfo, DamageEvent) == 0x0000B8, "Member 'FShotInfo::DamageEvent' has a wrong offset!");

// ScriptStruct Indiana.SpecialMovementStimulusProperties
// 0x0018 (0x0018 - 0x0000)
struct FSpecialMovementStimulusProperties final
{
public:
	struct FFootstepStimulus                      DefaultEventStimulus;                              // 0x0000(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FSpecialEventStimulusOverride>  EventStimulusOverrides;                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialMovementStimulusProperties) == 0x000008, "Wrong alignment on FSpecialMovementStimulusProperties");
static_assert(sizeof(FSpecialMovementStimulusProperties) == 0x000018, "Wrong size on FSpecialMovementStimulusProperties");
static_assert(offsetof(FSpecialMovementStimulusProperties, DefaultEventStimulus) == 0x000000, "Member 'FSpecialMovementStimulusProperties::DefaultEventStimulus' has a wrong offset!");
static_assert(offsetof(FSpecialMovementStimulusProperties, EventStimulusOverrides) == 0x000008, "Member 'FSpecialMovementStimulusProperties::EventStimulusOverrides' has a wrong offset!");

// ScriptStruct Indiana.SpecialMovementVisualProperties
// 0x0040 (0x0040 - 0x0000)
struct FSpecialMovementVisualProperties final
{
public:
	struct FFootstepVisuals                       DefaultEventVisual;                                // 0x0000(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FSpecialEventVisualsOverride>   EventVisualsOverrides;                             // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialMovementVisualProperties) == 0x000008, "Wrong alignment on FSpecialMovementVisualProperties");
static_assert(sizeof(FSpecialMovementVisualProperties) == 0x000040, "Wrong size on FSpecialMovementVisualProperties");
static_assert(offsetof(FSpecialMovementVisualProperties, DefaultEventVisual) == 0x000000, "Member 'FSpecialMovementVisualProperties::DefaultEventVisual' has a wrong offset!");
static_assert(offsetof(FSpecialMovementVisualProperties, EventVisualsOverrides) == 0x000030, "Member 'FSpecialMovementVisualProperties::EventVisualsOverrides' has a wrong offset!");

// ScriptStruct Indiana.TransformOverride
// 0x0040 (0x0040 - 0x0000)
struct FTransformOverride final
{
public:
	int32                                         Slot;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTransformOverride) == 0x000010, "Wrong alignment on FTransformOverride");
static_assert(sizeof(FTransformOverride) == 0x000040, "Wrong size on FTransformOverride");
static_assert(offsetof(FTransformOverride, Slot) == 0x000000, "Member 'FTransformOverride::Slot' has a wrong offset!");
static_assert(offsetof(FTransformOverride, Transform) == 0x000010, "Member 'FTransformOverride::Transform' has a wrong offset!");

// ScriptStruct Indiana.urniturePositionalAnimationData
// 0x0028 (0x0028 - 0x0000)
struct FUrniturePositionalAnimationData final
{
public:
	class UAnimMontage*                           Start;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           Exit;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           CombatExit;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           Loop;                                              // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsClimbing;                                       // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUrniturePositionalAnimationData) == 0x000008, "Wrong alignment on FUrniturePositionalAnimationData");
static_assert(sizeof(FUrniturePositionalAnimationData) == 0x000028, "Wrong size on FUrniturePositionalAnimationData");
static_assert(offsetof(FUrniturePositionalAnimationData, Start) == 0x000000, "Member 'FUrniturePositionalAnimationData::Start' has a wrong offset!");
static_assert(offsetof(FUrniturePositionalAnimationData, Exit) == 0x000008, "Member 'FUrniturePositionalAnimationData::Exit' has a wrong offset!");
static_assert(offsetof(FUrniturePositionalAnimationData, CombatExit) == 0x000010, "Member 'FUrniturePositionalAnimationData::CombatExit' has a wrong offset!");
static_assert(offsetof(FUrniturePositionalAnimationData, Loop) == 0x000018, "Member 'FUrniturePositionalAnimationData::Loop' has a wrong offset!");
static_assert(offsetof(FUrniturePositionalAnimationData, bIsClimbing) == 0x000020, "Member 'FUrniturePositionalAnimationData::bIsClimbing' has a wrong offset!");

// ScriptStruct Indiana.DelayedEventData
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FDelayedEventData final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDelayedEventData) == 0x000008, "Wrong alignment on FDelayedEventData");
static_assert(sizeof(FDelayedEventData) == 0x000020, "Wrong size on FDelayedEventData");

// ScriptStruct Indiana.GameDateTime
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FGameDateTime final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameDateTime) == 0x000008, "Wrong alignment on FGameDateTime");
static_assert(sizeof(FGameDateTime) == 0x000008, "Wrong size on FGameDateTime");

// ScriptStruct Indiana.AchievementArray
// 0x0010 (0x0010 - 0x0000)
struct FAchievementArray final
{
public:
	TArray<class UAchievementDataAsset*>          Achievements;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAchievementArray) == 0x000008, "Wrong alignment on FAchievementArray");
static_assert(sizeof(FAchievementArray) == 0x000010, "Wrong size on FAchievementArray");
static_assert(offsetof(FAchievementArray, Achievements) == 0x000000, "Member 'FAchievementArray::Achievements' has a wrong offset!");

// ScriptStruct Indiana.MinMaxChatterTime
// 0x0008 (0x0008 - 0x0000)
struct FMinMaxChatterTime final
{
public:
	float                                         Min;                                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinMaxChatterTime) == 0x000004, "Wrong alignment on FMinMaxChatterTime");
static_assert(sizeof(FMinMaxChatterTime) == 0x000008, "Wrong size on FMinMaxChatterTime");
static_assert(offsetof(FMinMaxChatterTime, Min) == 0x000000, "Member 'FMinMaxChatterTime::Min' has a wrong offset!");
static_assert(offsetof(FMinMaxChatterTime, Max) == 0x000004, "Member 'FMinMaxChatterTime::Max' has a wrong offset!");

// ScriptStruct Indiana.InvestigationSettings
// 0x003C (0x003C - 0x0000)
struct FInvestigationSettings final
{
public:
	float                                         MinInitialWaitTime;                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxInitialWaitTime;                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndWaitTime;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WatchTeammateTime;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinArrivalRadius;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxArrivalRadius;                                  // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StimulusUpdateWaitTime;                            // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StimulusUpdateMinDuration;                         // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitChatterTriggerTime;                            // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeammateDistance;                                  // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAISettingsWander                      DeadBodyWanderSearchSettings;                      // 0x0028(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInvestigationSettings) == 0x000004, "Wrong alignment on FInvestigationSettings");
static_assert(sizeof(FInvestigationSettings) == 0x00003C, "Wrong size on FInvestigationSettings");
static_assert(offsetof(FInvestigationSettings, MinInitialWaitTime) == 0x000000, "Member 'FInvestigationSettings::MinInitialWaitTime' has a wrong offset!");
static_assert(offsetof(FInvestigationSettings, MaxInitialWaitTime) == 0x000004, "Member 'FInvestigationSettings::MaxInitialWaitTime' has a wrong offset!");
static_assert(offsetof(FInvestigationSettings, EndWaitTime) == 0x000008, "Member 'FInvestigationSettings::EndWaitTime' has a wrong offset!");
static_assert(offsetof(FInvestigationSettings, WatchTeammateTime) == 0x00000C, "Member 'FInvestigationSettings::WatchTeammateTime' has a wrong offset!");
static_assert(offsetof(FInvestigationSettings, MinArrivalRadius) == 0x000010, "Member 'FInvestigationSettings::MinArrivalRadius' has a wrong offset!");
static_assert(offsetof(FInvestigationSettings, MaxArrivalRadius) == 0x000014, "Member 'FInvestigationSettings::MaxArrivalRadius' has a wrong offset!");
static_assert(offsetof(FInvestigationSettings, StimulusUpdateWaitTime) == 0x000018, "Member 'FInvestigationSettings::StimulusUpdateWaitTime' has a wrong offset!");
static_assert(offsetof(FInvestigationSettings, StimulusUpdateMinDuration) == 0x00001C, "Member 'FInvestigationSettings::StimulusUpdateMinDuration' has a wrong offset!");
static_assert(offsetof(FInvestigationSettings, ExitChatterTriggerTime) == 0x000020, "Member 'FInvestigationSettings::ExitChatterTriggerTime' has a wrong offset!");
static_assert(offsetof(FInvestigationSettings, TeammateDistance) == 0x000024, "Member 'FInvestigationSettings::TeammateDistance' has a wrong offset!");
static_assert(offsetof(FInvestigationSettings, DeadBodyWanderSearchSettings) == 0x000028, "Member 'FInvestigationSettings::DeadBodyWanderSearchSettings' has a wrong offset!");

// ScriptStruct Indiana.NavigationBumpSettings
// 0x000C (0x000C - 0x0000)
struct FNavigationBumpSettings final
{
public:
	float                                         MaxBumpSpeed;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostOverlapBumpTime;                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BumperBlockedTime;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavigationBumpSettings) == 0x000004, "Wrong alignment on FNavigationBumpSettings");
static_assert(sizeof(FNavigationBumpSettings) == 0x00000C, "Wrong size on FNavigationBumpSettings");
static_assert(offsetof(FNavigationBumpSettings, MaxBumpSpeed) == 0x000000, "Member 'FNavigationBumpSettings::MaxBumpSpeed' has a wrong offset!");
static_assert(offsetof(FNavigationBumpSettings, PostOverlapBumpTime) == 0x000004, "Member 'FNavigationBumpSettings::PostOverlapBumpTime' has a wrong offset!");
static_assert(offsetof(FNavigationBumpSettings, BumperBlockedTime) == 0x000008, "Member 'FNavigationBumpSettings::BumperBlockedTime' has a wrong offset!");

// ScriptStruct Indiana.NavigationBlockedSettings
// 0x0018 (0x0018 - 0x0000)
struct FNavigationBlockedSettings final
{
public:
	float                                         BlockDistance;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlockHeadingCosineAngle;                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlockDeltaCosineAngle;                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinBlockTime;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBlockTime;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoBlockerTime;                                     // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavigationBlockedSettings) == 0x000004, "Wrong alignment on FNavigationBlockedSettings");
static_assert(sizeof(FNavigationBlockedSettings) == 0x000018, "Wrong size on FNavigationBlockedSettings");
static_assert(offsetof(FNavigationBlockedSettings, BlockDistance) == 0x000000, "Member 'FNavigationBlockedSettings::BlockDistance' has a wrong offset!");
static_assert(offsetof(FNavigationBlockedSettings, BlockHeadingCosineAngle) == 0x000004, "Member 'FNavigationBlockedSettings::BlockHeadingCosineAngle' has a wrong offset!");
static_assert(offsetof(FNavigationBlockedSettings, BlockDeltaCosineAngle) == 0x000008, "Member 'FNavigationBlockedSettings::BlockDeltaCosineAngle' has a wrong offset!");
static_assert(offsetof(FNavigationBlockedSettings, MinBlockTime) == 0x00000C, "Member 'FNavigationBlockedSettings::MinBlockTime' has a wrong offset!");
static_assert(offsetof(FNavigationBlockedSettings, MaxBlockTime) == 0x000010, "Member 'FNavigationBlockedSettings::MaxBlockTime' has a wrong offset!");
static_assert(offsetof(FNavigationBlockedSettings, NoBlockerTime) == 0x000014, "Member 'FNavigationBlockedSettings::NoBlockerTime' has a wrong offset!");

// ScriptStruct Indiana.AIEventTypeMapElement
// 0x000C (0x000C - 0x0000)
struct FAIEventTypeMapElement final
{
public:
	struct FGameplayTag                           Event;                                             // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIEventType                                  EventType;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIEventTypeMapElement) == 0x000004, "Wrong alignment on FAIEventTypeMapElement");
static_assert(sizeof(FAIEventTypeMapElement) == 0x00000C, "Wrong size on FAIEventTypeMapElement");
static_assert(offsetof(FAIEventTypeMapElement, Event) == 0x000000, "Member 'FAIEventTypeMapElement::Event' has a wrong offset!");
static_assert(offsetof(FAIEventTypeMapElement, EventType) == 0x000008, "Member 'FAIEventTypeMapElement::EventType' has a wrong offset!");

// ScriptStruct Indiana.WeaponAISettingsMapElement
// 0x0010 (0x0010 - 0x0000)
struct FWeaponAISettingsMapElement final
{
public:
	struct FGameplayTag                           WeaponType;                                        // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAISettings_Weapon*                     WeaponSettings;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponAISettingsMapElement) == 0x000008, "Wrong alignment on FWeaponAISettingsMapElement");
static_assert(sizeof(FWeaponAISettingsMapElement) == 0x000010, "Wrong size on FWeaponAISettingsMapElement");
static_assert(offsetof(FWeaponAISettingsMapElement, WeaponType) == 0x000000, "Member 'FWeaponAISettingsMapElement::WeaponType' has a wrong offset!");
static_assert(offsetof(FWeaponAISettingsMapElement, WeaponSettings) == 0x000008, "Member 'FWeaponAISettingsMapElement::WeaponSettings' has a wrong offset!");

// ScriptStruct Indiana.CompanionCommmandSettings
// 0x0008 (0x0008 - 0x0000)
struct FCompanionCommmandSettings final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LostTargetTime;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCompanionCommmandSettings) == 0x000004, "Wrong alignment on FCompanionCommmandSettings");
static_assert(sizeof(FCompanionCommmandSettings) == 0x000008, "Wrong size on FCompanionCommmandSettings");
static_assert(offsetof(FCompanionCommmandSettings, Duration) == 0x000000, "Member 'FCompanionCommmandSettings::Duration' has a wrong offset!");
static_assert(offsetof(FCompanionCommmandSettings, LostTargetTime) == 0x000004, "Member 'FCompanionCommmandSettings::LostTargetTime' has a wrong offset!");

// ScriptStruct Indiana.ArmorVsDamageTypes
// 0x0018 (0x0018 - 0x0000)
struct FArmorVsDamageTypes final
{
public:
	struct FGameplayTag                           ArmorType;                                         // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDamageTypeScalar>              DamageTypeScalars;                                 // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArmorVsDamageTypes) == 0x000008, "Wrong alignment on FArmorVsDamageTypes");
static_assert(sizeof(FArmorVsDamageTypes) == 0x000018, "Wrong size on FArmorVsDamageTypes");
static_assert(offsetof(FArmorVsDamageTypes, ArmorType) == 0x000000, "Member 'FArmorVsDamageTypes::ArmorType' has a wrong offset!");
static_assert(offsetof(FArmorVsDamageTypes, DamageTypeScalars) == 0x000008, "Member 'FArmorVsDamageTypes::DamageTypeScalars' has a wrong offset!");

// ScriptStruct Indiana.InteractAudioEvent
// 0x0010 (0x0010 - 0x0000)
struct FInteractAudioEvent final
{
public:
	class UAkAudioEvent*                          OpenSound;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          CloseSound;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractAudioEvent) == 0x000008, "Wrong alignment on FInteractAudioEvent");
static_assert(sizeof(FInteractAudioEvent) == 0x000010, "Wrong size on FInteractAudioEvent");
static_assert(offsetof(FInteractAudioEvent, OpenSound) == 0x000000, "Member 'FInteractAudioEvent::OpenSound' has a wrong offset!");
static_assert(offsetof(FInteractAudioEvent, CloseSound) == 0x000008, "Member 'FInteractAudioEvent::CloseSound' has a wrong offset!");

// ScriptStruct Indiana.ReputationActionConsequence
// 0x0018 (0x0018 - 0x0000)
struct FReputationActionConsequence final
{
public:
	EReputationType                               ReputationType;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EReputationIncrementType                      IncrementType;                                     // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CustomAmount;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EReputationIncrementType                      TalkIncrementType;                                 // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TalkCustomAmount;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EReputationIncrementType                      BribeIncrementType;                                // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BribeCustomAmount;                                 // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReputationActionConsequence) == 0x000004, "Wrong alignment on FReputationActionConsequence");
static_assert(sizeof(FReputationActionConsequence) == 0x000018, "Wrong size on FReputationActionConsequence");
static_assert(offsetof(FReputationActionConsequence, ReputationType) == 0x000000, "Member 'FReputationActionConsequence::ReputationType' has a wrong offset!");
static_assert(offsetof(FReputationActionConsequence, IncrementType) == 0x000001, "Member 'FReputationActionConsequence::IncrementType' has a wrong offset!");
static_assert(offsetof(FReputationActionConsequence, CustomAmount) == 0x000004, "Member 'FReputationActionConsequence::CustomAmount' has a wrong offset!");
static_assert(offsetof(FReputationActionConsequence, TalkIncrementType) == 0x000008, "Member 'FReputationActionConsequence::TalkIncrementType' has a wrong offset!");
static_assert(offsetof(FReputationActionConsequence, TalkCustomAmount) == 0x00000C, "Member 'FReputationActionConsequence::TalkCustomAmount' has a wrong offset!");
static_assert(offsetof(FReputationActionConsequence, BribeIncrementType) == 0x000010, "Member 'FReputationActionConsequence::BribeIncrementType' has a wrong offset!");
static_assert(offsetof(FReputationActionConsequence, BribeCustomAmount) == 0x000014, "Member 'FReputationActionConsequence::BribeCustomAmount' has a wrong offset!");

// ScriptStruct Indiana.LinkedBinding
// 0x0018 (0x0018 - 0x0000)
struct FLinkedBinding final
{
public:
	class FName                                   LinkedBindingName;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FNameTypeBinding>               Bindings;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLinkedBinding) == 0x000008, "Wrong alignment on FLinkedBinding");
static_assert(sizeof(FLinkedBinding) == 0x000018, "Wrong size on FLinkedBinding");
static_assert(offsetof(FLinkedBinding, LinkedBindingName) == 0x000000, "Member 'FLinkedBinding::LinkedBindingName' has a wrong offset!");
static_assert(offsetof(FLinkedBinding, Bindings) == 0x000008, "Member 'FLinkedBinding::Bindings' has a wrong offset!");

// ScriptStruct Indiana.GamepadBindingsList
// 0x0010 (0x0010 - 0x0000)
struct FGamepadBindingsList final
{
public:
	TArray<struct FGamepadBindings>               Bindings;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGamepadBindingsList) == 0x000008, "Wrong alignment on FGamepadBindingsList");
static_assert(sizeof(FGamepadBindingsList) == 0x000010, "Wrong size on FGamepadBindingsList");
static_assert(offsetof(FGamepadBindingsList, Bindings) == 0x000000, "Member 'FGamepadBindingsList::Bindings' has a wrong offset!");

// ScriptStruct Indiana.MeleeAction
// 0x00A0 (0x00A0 - 0x0000)
struct FMeleeAction final
{
public:
	EMeleeAction                                  Action;                                            // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponEvent                                  WeaponEvent;                                       // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMeleeInput>                    Input;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   ForceFeedbackEffectOneHand;                        // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   ForceFeedbackEffectOneHandBlocked;                 // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   ForceFeedbackEffectTwoHands;                       // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   ForceFeedbackEffectTwoHandsBlocked;                // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearInput;                                       // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowInputAtStart;                                // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanStartQueuedActionAtStart;                      // 0x003A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartWhenQueued;                                  // 0x003B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecoilIfBlocked;                                  // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerForceFeedbackAtStart;                       // 0x003D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageMultiplier;                                  // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CalledShotCharge;                                  // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeleeAttackType                              AttackType;                                        // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeleeAction                                  InterruptAction;                                   // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeleeAction                                  AutoQueuedAction;                                  // 0x004A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B[0x5];                                       // 0x004B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<EMeleeAction>                            ChainActions;                                      // 0x0050(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeleeAction) == 0x000008, "Wrong alignment on FMeleeAction");
static_assert(sizeof(FMeleeAction) == 0x0000A0, "Wrong size on FMeleeAction");
static_assert(offsetof(FMeleeAction, Action) == 0x000000, "Member 'FMeleeAction::Action' has a wrong offset!");
static_assert(offsetof(FMeleeAction, WeaponEvent) == 0x000001, "Member 'FMeleeAction::WeaponEvent' has a wrong offset!");
static_assert(offsetof(FMeleeAction, Input) == 0x000008, "Member 'FMeleeAction::Input' has a wrong offset!");
static_assert(offsetof(FMeleeAction, ForceFeedbackEffectOneHand) == 0x000018, "Member 'FMeleeAction::ForceFeedbackEffectOneHand' has a wrong offset!");
static_assert(offsetof(FMeleeAction, ForceFeedbackEffectOneHandBlocked) == 0x000020, "Member 'FMeleeAction::ForceFeedbackEffectOneHandBlocked' has a wrong offset!");
static_assert(offsetof(FMeleeAction, ForceFeedbackEffectTwoHands) == 0x000028, "Member 'FMeleeAction::ForceFeedbackEffectTwoHands' has a wrong offset!");
static_assert(offsetof(FMeleeAction, ForceFeedbackEffectTwoHandsBlocked) == 0x000030, "Member 'FMeleeAction::ForceFeedbackEffectTwoHandsBlocked' has a wrong offset!");
static_assert(offsetof(FMeleeAction, bClearInput) == 0x000038, "Member 'FMeleeAction::bClearInput' has a wrong offset!");
static_assert(offsetof(FMeleeAction, bAllowInputAtStart) == 0x000039, "Member 'FMeleeAction::bAllowInputAtStart' has a wrong offset!");
static_assert(offsetof(FMeleeAction, bCanStartQueuedActionAtStart) == 0x00003A, "Member 'FMeleeAction::bCanStartQueuedActionAtStart' has a wrong offset!");
static_assert(offsetof(FMeleeAction, bStartWhenQueued) == 0x00003B, "Member 'FMeleeAction::bStartWhenQueued' has a wrong offset!");
static_assert(offsetof(FMeleeAction, bRecoilIfBlocked) == 0x00003C, "Member 'FMeleeAction::bRecoilIfBlocked' has a wrong offset!");
static_assert(offsetof(FMeleeAction, bPlayerForceFeedbackAtStart) == 0x00003D, "Member 'FMeleeAction::bPlayerForceFeedbackAtStart' has a wrong offset!");
static_assert(offsetof(FMeleeAction, DamageMultiplier) == 0x000040, "Member 'FMeleeAction::DamageMultiplier' has a wrong offset!");
static_assert(offsetof(FMeleeAction, CalledShotCharge) == 0x000044, "Member 'FMeleeAction::CalledShotCharge' has a wrong offset!");
static_assert(offsetof(FMeleeAction, AttackType) == 0x000048, "Member 'FMeleeAction::AttackType' has a wrong offset!");
static_assert(offsetof(FMeleeAction, InterruptAction) == 0x000049, "Member 'FMeleeAction::InterruptAction' has a wrong offset!");
static_assert(offsetof(FMeleeAction, AutoQueuedAction) == 0x00004A, "Member 'FMeleeAction::AutoQueuedAction' has a wrong offset!");
static_assert(offsetof(FMeleeAction, ChainActions) == 0x000050, "Member 'FMeleeAction::ChainActions' has a wrong offset!");

// ScriptStruct Indiana.MeleeAnim
// 0x000C (0x000C - 0x0000)
struct FMeleeAnim final
{
public:
	EWeaponEvent                                  WeaponEvent;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimTime;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkippable;                                        // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipIfHoldReleased;                               // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMeleeAnim) == 0x000004, "Wrong alignment on FMeleeAnim");
static_assert(sizeof(FMeleeAnim) == 0x00000C, "Wrong size on FMeleeAnim");
static_assert(offsetof(FMeleeAnim, WeaponEvent) == 0x000000, "Member 'FMeleeAnim::WeaponEvent' has a wrong offset!");
static_assert(offsetof(FMeleeAnim, AnimTime) == 0x000004, "Member 'FMeleeAnim::AnimTime' has a wrong offset!");
static_assert(offsetof(FMeleeAnim, bLoop) == 0x000008, "Member 'FMeleeAnim::bLoop' has a wrong offset!");
static_assert(offsetof(FMeleeAnim, bSkippable) == 0x000009, "Member 'FMeleeAnim::bSkippable' has a wrong offset!");
static_assert(offsetof(FMeleeAnim, bSkipIfHoldReleased) == 0x00000A, "Member 'FMeleeAnim::bSkipIfHoldReleased' has a wrong offset!");

// ScriptStruct Indiana.HUDFadeSettings
// 0x0014 (0x0014 - 0x0000)
struct FHUDFadeSettings final
{
public:
	float                                         HUDActiveTime;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HUDFadeInTime;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HUDFadeInExponent;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HUDFadeOutTime;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HUDFadeOutExponent;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHUDFadeSettings) == 0x000004, "Wrong alignment on FHUDFadeSettings");
static_assert(sizeof(FHUDFadeSettings) == 0x000014, "Wrong size on FHUDFadeSettings");
static_assert(offsetof(FHUDFadeSettings, HUDActiveTime) == 0x000000, "Member 'FHUDFadeSettings::HUDActiveTime' has a wrong offset!");
static_assert(offsetof(FHUDFadeSettings, HUDFadeInTime) == 0x000004, "Member 'FHUDFadeSettings::HUDFadeInTime' has a wrong offset!");
static_assert(offsetof(FHUDFadeSettings, HUDFadeInExponent) == 0x000008, "Member 'FHUDFadeSettings::HUDFadeInExponent' has a wrong offset!");
static_assert(offsetof(FHUDFadeSettings, HUDFadeOutTime) == 0x00000C, "Member 'FHUDFadeSettings::HUDFadeOutTime' has a wrong offset!");
static_assert(offsetof(FHUDFadeSettings, HUDFadeOutExponent) == 0x000010, "Member 'FHUDFadeSettings::HUDFadeOutExponent' has a wrong offset!");

// ScriptStruct Indiana.ActionLabelDescription
// 0x000C (0x000C - 0x0000)
struct FActionLabelDescription final
{
public:
	struct FLocString                             Name;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayKeyboard;                                  // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayGamepad;                                   // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionLabelDescription) == 0x000004, "Wrong alignment on FActionLabelDescription");
static_assert(sizeof(FActionLabelDescription) == 0x00000C, "Wrong size on FActionLabelDescription");
static_assert(offsetof(FActionLabelDescription, Name) == 0x000000, "Member 'FActionLabelDescription::Name' has a wrong offset!");
static_assert(offsetof(FActionLabelDescription, bDisplayKeyboard) == 0x000008, "Member 'FActionLabelDescription::bDisplayKeyboard' has a wrong offset!");
static_assert(offsetof(FActionLabelDescription, bDisplayGamepad) == 0x000009, "Member 'FActionLabelDescription::bDisplayGamepad' has a wrong offset!");

// ScriptStruct Indiana.HairAppearance
// 0x0050 (0x0090 - 0x0040)
struct FHairAppearance final : public FAppearanceMatch
{
public:
	TSoftObjectPtr<class USkeletalMesh>           StandardMesh;                                      // 0x0040(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           CappedMesh;                                        // 0x0068(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHairAppearance) == 0x000008, "Wrong alignment on FHairAppearance");
static_assert(sizeof(FHairAppearance) == 0x000090, "Wrong size on FHairAppearance");
static_assert(offsetof(FHairAppearance, StandardMesh) == 0x000040, "Member 'FHairAppearance::StandardMesh' has a wrong offset!");
static_assert(offsetof(FHairAppearance, CappedMesh) == 0x000068, "Member 'FHairAppearance::CappedMesh' has a wrong offset!");

// ScriptStruct Indiana.NewHeadAppearance
// 0x0080 (0x00C0 - 0x0040)
struct FNewHeadAppearance final : public FAppearanceMatch
{
public:
	TSoftObjectPtr<class USkeletalMesh>           HeadMesh;                                          // 0x0040(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, TSoftObjectPtr<class UMaterialInterface>> MaterialOverrides;                                 // 0x0068(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	class FName                                   HairMorphTarget;                                   // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNewHeadAppearance) == 0x000008, "Wrong alignment on FNewHeadAppearance");
static_assert(sizeof(FNewHeadAppearance) == 0x0000C0, "Wrong size on FNewHeadAppearance");
static_assert(offsetof(FNewHeadAppearance, HeadMesh) == 0x000040, "Member 'FNewHeadAppearance::HeadMesh' has a wrong offset!");
static_assert(offsetof(FNewHeadAppearance, MaterialOverrides) == 0x000068, "Member 'FNewHeadAppearance::MaterialOverrides' has a wrong offset!");
static_assert(offsetof(FNewHeadAppearance, HairMorphTarget) == 0x0000B8, "Member 'FNewHeadAppearance::HairMorphTarget' has a wrong offset!");

// ScriptStruct Indiana.HeightValuesTexture
// 0x00A0 (0x00A0 - 0x0000)
struct FHeightValuesTexture final
{
public:
	class UTexture2D*                             Texture;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x98];                                       // 0x0008(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHeightValuesTexture) == 0x000008, "Wrong alignment on FHeightValuesTexture");
static_assert(sizeof(FHeightValuesTexture) == 0x0000A0, "Wrong size on FHeightValuesTexture");
static_assert(offsetof(FHeightValuesTexture, Texture) == 0x000000, "Member 'FHeightValuesTexture::Texture' has a wrong offset!");

// ScriptStruct Indiana.ImpactAIDataOverride
// 0x0004 (0x0004 - 0x0000)
struct FImpactAIDataOverride final
{
public:
	float                                         AISoundRadius;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FImpactAIDataOverride) == 0x000004, "Wrong alignment on FImpactAIDataOverride");
static_assert(sizeof(FImpactAIDataOverride) == 0x000004, "Wrong size on FImpactAIDataOverride");
static_assert(offsetof(FImpactAIDataOverride, AISoundRadius) == 0x000000, "Member 'FImpactAIDataOverride::AISoundRadius' has a wrong offset!");

// ScriptStruct Indiana.AudioState
// 0x0014 (0x0014 - 0x0000)
struct FAudioState final
{
public:
	class FName                                   StateName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StateValue;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x4];                                       // 0x0010(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAudioState) == 0x000004, "Wrong alignment on FAudioState");
static_assert(sizeof(FAudioState) == 0x000014, "Wrong size on FAudioState");
static_assert(offsetof(FAudioState, StateName) == 0x000000, "Member 'FAudioState::StateName' has a wrong offset!");
static_assert(offsetof(FAudioState, StateValue) == 0x000008, "Member 'FAudioState::StateValue' has a wrong offset!");

// ScriptStruct Indiana.AttributeStatModifierDescription
// 0x0020 (0x0030 - 0x0010)
struct FAttributeStatModifierDescription final : public FStatModifierDescriptionBase
{
public:
	float                                         AttributeStatValues[0x7];                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShowInUIAtValue;                                   // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttributeStatModifierDescription) == 0x000008, "Wrong alignment on FAttributeStatModifierDescription");
static_assert(sizeof(FAttributeStatModifierDescription) == 0x000030, "Wrong size on FAttributeStatModifierDescription");
static_assert(offsetof(FAttributeStatModifierDescription, AttributeStatValues) == 0x000010, "Member 'FAttributeStatModifierDescription::AttributeStatValues' has a wrong offset!");
static_assert(offsetof(FAttributeStatModifierDescription, ShowInUIAtValue) == 0x00002C, "Member 'FAttributeStatModifierDescription::ShowInUIAtValue' has a wrong offset!");

// ScriptStruct Indiana.LandAudioEvent
// 0x0018 (0x0018 - 0x0000)
struct FLandAudioEvent final
{
public:
	bool                                          bHasMinDistance;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDistance;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasMaxDistance;                                   // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistance;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkPlaySoundEventEffect*                Event;                                             // 0x0010(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLandAudioEvent) == 0x000008, "Wrong alignment on FLandAudioEvent");
static_assert(sizeof(FLandAudioEvent) == 0x000018, "Wrong size on FLandAudioEvent");
static_assert(offsetof(FLandAudioEvent, bHasMinDistance) == 0x000000, "Member 'FLandAudioEvent::bHasMinDistance' has a wrong offset!");
static_assert(offsetof(FLandAudioEvent, MinDistance) == 0x000004, "Member 'FLandAudioEvent::MinDistance' has a wrong offset!");
static_assert(offsetof(FLandAudioEvent, bHasMaxDistance) == 0x000008, "Member 'FLandAudioEvent::bHasMaxDistance' has a wrong offset!");
static_assert(offsetof(FLandAudioEvent, MaxDistance) == 0x00000C, "Member 'FLandAudioEvent::MaxDistance' has a wrong offset!");
static_assert(offsetof(FLandAudioEvent, Event) == 0x000010, "Member 'FLandAudioEvent::Event' has a wrong offset!");

// ScriptStruct Indiana.PropComponents
// 0x0018 (0x0018 - 0x0000)
struct FPropComponents final
{
public:
	class UMeshComponent*                         PropMesh;                                          // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               PropParticleSystem;                                // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPropComponents) == 0x000008, "Wrong alignment on FPropComponents");
static_assert(sizeof(FPropComponents) == 0x000018, "Wrong size on FPropComponents");
static_assert(offsetof(FPropComponents, PropMesh) == 0x000000, "Member 'FPropComponents::PropMesh' has a wrong offset!");
static_assert(offsetof(FPropComponents, PropParticleSystem) == 0x000008, "Member 'FPropComponents::PropParticleSystem' has a wrong offset!");

// ScriptStruct Indiana.CompanionInfo
// 0x000C (0x000C - 0x0000)
struct FCompanionInfo final
{
public:
	float                                         Health;                                            // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DTBody;                                            // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DTHead;                                            // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCompanionInfo) == 0x000004, "Wrong alignment on FCompanionInfo");
static_assert(sizeof(FCompanionInfo) == 0x00000C, "Wrong size on FCompanionInfo");
static_assert(offsetof(FCompanionInfo, Health) == 0x000000, "Member 'FCompanionInfo::Health' has a wrong offset!");
static_assert(offsetof(FCompanionInfo, DTBody) == 0x000004, "Member 'FCompanionInfo::DTBody' has a wrong offset!");
static_assert(offsetof(FCompanionInfo, DTHead) == 0x000008, "Member 'FCompanionInfo::DTHead' has a wrong offset!");

// ScriptStruct Indiana.TagToAudio
// 0x0010 (0x0010 - 0x0000)
struct FTagToAudio final
{
public:
	struct FGameplayTag                           PrimaryItemSkill;                                  // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AudioEvent;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTagToAudio) == 0x000008, "Wrong alignment on FTagToAudio");
static_assert(sizeof(FTagToAudio) == 0x000010, "Wrong size on FTagToAudio");
static_assert(offsetof(FTagToAudio, PrimaryItemSkill) == 0x000000, "Member 'FTagToAudio::PrimaryItemSkill' has a wrong offset!");
static_assert(offsetof(FTagToAudio, AudioEvent) == 0x000008, "Member 'FTagToAudio::AudioEvent' has a wrong offset!");

// ScriptStruct Indiana.TagToAudioList
// 0x0010 (0x0010 - 0x0000)
struct FTagToAudioList final
{
public:
	TArray<struct FTagToAudio>                    AudioForItems;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTagToAudioList) == 0x000008, "Wrong alignment on FTagToAudioList");
static_assert(sizeof(FTagToAudioList) == 0x000010, "Wrong size on FTagToAudioList");
static_assert(offsetof(FTagToAudioList, AudioForItems) == 0x000000, "Member 'FTagToAudioList::AudioForItems' has a wrong offset!");

// ScriptStruct Indiana.LoadingScreenRegionMaps
// 0x0010 (0x0010 - 0x0000)
struct FLoadingScreenRegionMaps final
{
public:
	TArray<TSoftObjectPtr<class UWorld>>          Maps;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingScreenRegionMaps) == 0x000008, "Wrong alignment on FLoadingScreenRegionMaps");
static_assert(sizeof(FLoadingScreenRegionMaps) == 0x000010, "Wrong size on FLoadingScreenRegionMaps");
static_assert(offsetof(FLoadingScreenRegionMaps, Maps) == 0x000000, "Member 'FLoadingScreenRegionMaps::Maps' has a wrong offset!");

// ScriptStruct Indiana.LoadingImageContainer
// 0x0010 (0x0010 - 0x0000)
struct FLoadingImageContainer final
{
public:
	TArray<struct FWeightedImageData>             LoadingImages;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLoadingImageContainer) == 0x000008, "Wrong alignment on FLoadingImageContainer");
static_assert(sizeof(FLoadingImageContainer) == 0x000010, "Wrong size on FLoadingImageContainer");
static_assert(offsetof(FLoadingImageContainer, LoadingImages) == 0x000000, "Member 'FLoadingImageContainer::LoadingImages' has a wrong offset!");

// ScriptStruct Indiana.RotatedBox
// 0x0050 (0x0050 - 0x0000)
struct FRotatedBox final
{
public:
	struct FBox                                   Box;                                               // 0x0000(0x001C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0020(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRotatedBox) == 0x000010, "Wrong alignment on FRotatedBox");
static_assert(sizeof(FRotatedBox) == 0x000050, "Wrong size on FRotatedBox");
static_assert(offsetof(FRotatedBox, Box) == 0x000000, "Member 'FRotatedBox::Box' has a wrong offset!");
static_assert(offsetof(FRotatedBox, Transform) == 0x000020, "Member 'FRotatedBox::Transform' has a wrong offset!");

// ScriptStruct Indiana.SkillUnlockEffect
// 0x0018 (0x0018 - 0x0000)
struct FSkillUnlockEffect final
{
public:
	ESkill                                        EquippedWeaponSkill;                               // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinSkill;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class USpell>                     Spell;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLocString                             UnlockTierString;                                  // 0x0010(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillUnlockEffect) == 0x000008, "Wrong alignment on FSkillUnlockEffect");
static_assert(sizeof(FSkillUnlockEffect) == 0x000018, "Wrong size on FSkillUnlockEffect");
static_assert(offsetof(FSkillUnlockEffect, EquippedWeaponSkill) == 0x000000, "Member 'FSkillUnlockEffect::EquippedWeaponSkill' has a wrong offset!");
static_assert(offsetof(FSkillUnlockEffect, MinSkill) == 0x000004, "Member 'FSkillUnlockEffect::MinSkill' has a wrong offset!");
static_assert(offsetof(FSkillUnlockEffect, Spell) == 0x000008, "Member 'FSkillUnlockEffect::Spell' has a wrong offset!");
static_assert(offsetof(FSkillUnlockEffect, UnlockTierString) == 0x000010, "Member 'FSkillUnlockEffect::UnlockTierString' has a wrong offset!");

// ScriptStruct Indiana.SkillCheck
// 0x0018 (0x0018 - 0x0000)
struct FSkillCheck final
{
public:
	int32                                         MinSkill[0x5];                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Variance;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillCheck) == 0x000004, "Wrong alignment on FSkillCheck");
static_assert(sizeof(FSkillCheck) == 0x000018, "Wrong size on FSkillCheck");
static_assert(offsetof(FSkillCheck, MinSkill) == 0x000000, "Member 'FSkillCheck::MinSkill' has a wrong offset!");
static_assert(offsetof(FSkillCheck, Variance) == 0x000014, "Member 'FSkillCheck::Variance' has a wrong offset!");

// ScriptStruct Indiana.SkillsArray
// 0x0010 (0x0010 - 0x0000)
struct FSkillsArray final
{
public:
	TArray<ESkill>                                Skills;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillsArray) == 0x000008, "Wrong alignment on FSkillsArray");
static_assert(sizeof(FSkillsArray) == 0x000010, "Wrong size on FSkillsArray");
static_assert(offsetof(FSkillsArray, Skills) == 0x000000, "Member 'FSkillsArray::Skills' has a wrong offset!");

// ScriptStruct Indiana.OpacityWrapper
// 0x0004 (0x0004 - 0x0000)
struct FOpacityWrapper final
{
public:
	float                                         OpacityValue;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOpacityWrapper) == 0x000004, "Wrong alignment on FOpacityWrapper");
static_assert(sizeof(FOpacityWrapper) == 0x000004, "Wrong size on FOpacityWrapper");
static_assert(offsetof(FOpacityWrapper, OpacityValue) == 0x000000, "Member 'FOpacityWrapper::OpacityValue' has a wrong offset!");

// ScriptStruct Indiana.InteractActorDescription
// 0x0020 (0x0020 - 0x0000)
struct FInteractActorDescription final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInteractPayload                       Payload;                                           // 0x0008(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractActorDescription) == 0x000008, "Wrong alignment on FInteractActorDescription");
static_assert(sizeof(FInteractActorDescription) == 0x000020, "Wrong size on FInteractActorDescription");
static_assert(offsetof(FInteractActorDescription, Actor) == 0x000000, "Member 'FInteractActorDescription::Actor' has a wrong offset!");
static_assert(offsetof(FInteractActorDescription, Payload) == 0x000008, "Member 'FInteractActorDescription::Payload' has a wrong offset!");

// ScriptStruct Indiana.InteractPayloadParamDescription
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FInteractPayloadParamDescription final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractPayloadParamDescription) == 0x000008, "Wrong alignment on FInteractPayloadParamDescription");
static_assert(sizeof(FInteractPayloadParamDescription) == 0x000020, "Wrong size on FInteractPayloadParamDescription");

// ScriptStruct Indiana.DefaultItemStack
// 0x01F8 (0x01F8 - 0x0000)
struct FDefaultItemStack final
{
public:
	struct FItemDefinitionVariant                 Item;                                              // 0x0000(0x01F0)(Edit, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x01F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLootable;                                         // 0x01F4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F5[0x3];                                      // 0x01F5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDefaultItemStack) == 0x000008, "Wrong alignment on FDefaultItemStack");
static_assert(sizeof(FDefaultItemStack) == 0x0001F8, "Wrong size on FDefaultItemStack");
static_assert(offsetof(FDefaultItemStack, Item) == 0x000000, "Member 'FDefaultItemStack::Item' has a wrong offset!");
static_assert(offsetof(FDefaultItemStack, Count) == 0x0001F0, "Member 'FDefaultItemStack::Count' has a wrong offset!");
static_assert(offsetof(FDefaultItemStack, bLootable) == 0x0001F4, "Member 'FDefaultItemStack::bLootable' has a wrong offset!");

// ScriptStruct Indiana.ItemTutorialSet
// 0x0006 (0x0006 - 0x0000)
struct FItemTutorialSet final
{
public:
	ETutorialEvent                                OnItemAddedTutorial;                               // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETutorialEvent                                OnItemEquippedTutorial;                            // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETutorialEvent                                OnItemLostTutorial;                                // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETutorialEvent                                OnItemBreakDownTutorial;                           // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETutorialEvent                                OnItemDroppedTutorial;                             // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETutorialEvent                                OnItemSoldTutorial;                                // 0x0005(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemTutorialSet) == 0x000001, "Wrong alignment on FItemTutorialSet");
static_assert(sizeof(FItemTutorialSet) == 0x000006, "Wrong size on FItemTutorialSet");
static_assert(offsetof(FItemTutorialSet, OnItemAddedTutorial) == 0x000000, "Member 'FItemTutorialSet::OnItemAddedTutorial' has a wrong offset!");
static_assert(offsetof(FItemTutorialSet, OnItemEquippedTutorial) == 0x000001, "Member 'FItemTutorialSet::OnItemEquippedTutorial' has a wrong offset!");
static_assert(offsetof(FItemTutorialSet, OnItemLostTutorial) == 0x000002, "Member 'FItemTutorialSet::OnItemLostTutorial' has a wrong offset!");
static_assert(offsetof(FItemTutorialSet, OnItemBreakDownTutorial) == 0x000003, "Member 'FItemTutorialSet::OnItemBreakDownTutorial' has a wrong offset!");
static_assert(offsetof(FItemTutorialSet, OnItemDroppedTutorial) == 0x000004, "Member 'FItemTutorialSet::OnItemDroppedTutorial' has a wrong offset!");
static_assert(offsetof(FItemTutorialSet, OnItemSoldTutorial) == 0x000005, "Member 'FItemTutorialSet::OnItemSoldTutorial' has a wrong offset!");

// ScriptStruct Indiana.PageDimensions
// 0x0030 (0x0030 - 0x0000)
struct FPageDimensions final
{
public:
	int32                                         VerticalIndent;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rows;                                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UObject>>            SupportedClasses;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<EItemSorting>                          SupportedSortingOptions;                           // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPageDimensions) == 0x000008, "Wrong alignment on FPageDimensions");
static_assert(sizeof(FPageDimensions) == 0x000030, "Wrong size on FPageDimensions");
static_assert(offsetof(FPageDimensions, VerticalIndent) == 0x000000, "Member 'FPageDimensions::VerticalIndent' has a wrong offset!");
static_assert(offsetof(FPageDimensions, Rows) == 0x000004, "Member 'FPageDimensions::Rows' has a wrong offset!");
static_assert(offsetof(FPageDimensions, SupportedClasses) == 0x000010, "Member 'FPageDimensions::SupportedClasses' has a wrong offset!");
static_assert(offsetof(FPageDimensions, SupportedSortingOptions) == 0x000020, "Member 'FPageDimensions::SupportedSortingOptions' has a wrong offset!");

// ScriptStruct Indiana.ItemViewerInitializer
// 0x00A0 (0x00A0 - 0x0000)
struct FItemViewerInitializer final
{
public:
	bool                                          bShowAllCategory;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPageDimensions                        AllDimensions;                                     // 0x0008(0x0030)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FPageDimensions>                PageDimensions;                                    // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bShowJunkCategory;                                 // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPageDimensions                        JunkDimensions;                                    // 0x0050(0x0030)(Edit, NativeAccessSpecifierPublic)
	TArray<class UTexture2D*>                     Images;                                            // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<struct FLocString>                     PageHeaderText;                                    // 0x0090(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemViewerInitializer) == 0x000008, "Wrong alignment on FItemViewerInitializer");
static_assert(sizeof(FItemViewerInitializer) == 0x0000A0, "Wrong size on FItemViewerInitializer");
static_assert(offsetof(FItemViewerInitializer, bShowAllCategory) == 0x000000, "Member 'FItemViewerInitializer::bShowAllCategory' has a wrong offset!");
static_assert(offsetof(FItemViewerInitializer, AllDimensions) == 0x000008, "Member 'FItemViewerInitializer::AllDimensions' has a wrong offset!");
static_assert(offsetof(FItemViewerInitializer, PageDimensions) == 0x000038, "Member 'FItemViewerInitializer::PageDimensions' has a wrong offset!");
static_assert(offsetof(FItemViewerInitializer, bShowJunkCategory) == 0x000048, "Member 'FItemViewerInitializer::bShowJunkCategory' has a wrong offset!");
static_assert(offsetof(FItemViewerInitializer, JunkDimensions) == 0x000050, "Member 'FItemViewerInitializer::JunkDimensions' has a wrong offset!");
static_assert(offsetof(FItemViewerInitializer, Images) == 0x000080, "Member 'FItemViewerInitializer::Images' has a wrong offset!");
static_assert(offsetof(FItemViewerInitializer, PageHeaderText) == 0x000090, "Member 'FItemViewerInitializer::PageHeaderText' has a wrong offset!");

// ScriptStruct Indiana.NavigationCategory
// 0x0090 (0x0090 - 0x0000)
struct FNavigationCategory final
{
public:
	struct FLocString                             Name;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            Brush;                                             // 0x0008(0x0088)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavigationCategory) == 0x000008, "Wrong alignment on FNavigationCategory");
static_assert(sizeof(FNavigationCategory) == 0x000090, "Wrong size on FNavigationCategory");
static_assert(offsetof(FNavigationCategory, Name) == 0x000000, "Member 'FNavigationCategory::Name' has a wrong offset!");
static_assert(offsetof(FNavigationCategory, Brush) == 0x000008, "Member 'FNavigationCategory::Brush' has a wrong offset!");

// ScriptStruct Indiana.DeathMontageGroup
// 0x0018 (0x0018 - 0x0000)
struct FDeathMontageGroup final
{
public:
	TArray<class UAnimMontage*>                   List;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bListIsRadialAnimation;                            // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDeathMontageGroup) == 0x000008, "Wrong alignment on FDeathMontageGroup");
static_assert(sizeof(FDeathMontageGroup) == 0x000018, "Wrong size on FDeathMontageGroup");
static_assert(offsetof(FDeathMontageGroup, List) == 0x000000, "Member 'FDeathMontageGroup::List' has a wrong offset!");
static_assert(offsetof(FDeathMontageGroup, bListIsRadialAnimation) == 0x000010, "Member 'FDeathMontageGroup::bListIsRadialAnimation' has a wrong offset!");

// ScriptStruct Indiana.PlatformSetProductID
// 0x00C0 (0x00C0 - 0x0000)
struct FPlatformSetProductID final
{
public:
	class FString                                 ForcedUniversalID;                                 // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PCWindowsStoreID;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PCGamepassID;                                      // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PCEpicID;                                          // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PCSteamID;                                         // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PCFallbackLink;                                    // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 XboxID;                                            // 0x0060(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PS4AmericaTitleID;                                 // 0x0070(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PS4ID_SIEA;                                        // 0x0080(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PS4EuropeTitleID;                                  // 0x0090(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PS4ID_SIEE;                                        // 0x00A0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SwitchID;                                          // 0x00B0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlatformSetProductID) == 0x000008, "Wrong alignment on FPlatformSetProductID");
static_assert(sizeof(FPlatformSetProductID) == 0x0000C0, "Wrong size on FPlatformSetProductID");
static_assert(offsetof(FPlatformSetProductID, ForcedUniversalID) == 0x000000, "Member 'FPlatformSetProductID::ForcedUniversalID' has a wrong offset!");
static_assert(offsetof(FPlatformSetProductID, PCWindowsStoreID) == 0x000010, "Member 'FPlatformSetProductID::PCWindowsStoreID' has a wrong offset!");
static_assert(offsetof(FPlatformSetProductID, PCGamepassID) == 0x000020, "Member 'FPlatformSetProductID::PCGamepassID' has a wrong offset!");
static_assert(offsetof(FPlatformSetProductID, PCEpicID) == 0x000030, "Member 'FPlatformSetProductID::PCEpicID' has a wrong offset!");
static_assert(offsetof(FPlatformSetProductID, PCSteamID) == 0x000040, "Member 'FPlatformSetProductID::PCSteamID' has a wrong offset!");
static_assert(offsetof(FPlatformSetProductID, PCFallbackLink) == 0x000050, "Member 'FPlatformSetProductID::PCFallbackLink' has a wrong offset!");
static_assert(offsetof(FPlatformSetProductID, XboxID) == 0x000060, "Member 'FPlatformSetProductID::XboxID' has a wrong offset!");
static_assert(offsetof(FPlatformSetProductID, PS4AmericaTitleID) == 0x000070, "Member 'FPlatformSetProductID::PS4AmericaTitleID' has a wrong offset!");
static_assert(offsetof(FPlatformSetProductID, PS4ID_SIEA) == 0x000080, "Member 'FPlatformSetProductID::PS4ID_SIEA' has a wrong offset!");
static_assert(offsetof(FPlatformSetProductID, PS4EuropeTitleID) == 0x000090, "Member 'FPlatformSetProductID::PS4EuropeTitleID' has a wrong offset!");
static_assert(offsetof(FPlatformSetProductID, PS4ID_SIEE) == 0x0000A0, "Member 'FPlatformSetProductID::PS4ID_SIEE' has a wrong offset!");
static_assert(offsetof(FPlatformSetProductID, SwitchID) == 0x0000B0, "Member 'FPlatformSetProductID::SwitchID' has a wrong offset!");

// ScriptStruct Indiana.ManagerDebuggerPlayerData
// 0x0010 (0x0010 - 0x0000)
struct FManagerDebuggerPlayerData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputComponent*                        InputComponent;                                    // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FManagerDebuggerPlayerData) == 0x000008, "Wrong alignment on FManagerDebuggerPlayerData");
static_assert(sizeof(FManagerDebuggerPlayerData) == 0x000010, "Wrong size on FManagerDebuggerPlayerData");
static_assert(offsetof(FManagerDebuggerPlayerData, InputComponent) == 0x000008, "Member 'FManagerDebuggerPlayerData::InputComponent' has a wrong offset!");

// ScriptStruct Indiana.MapFloorData
// 0x0048 (0x0048 - 0x0000)
struct FMapFloorData final
{
public:
	struct FLocString                             FloorName;                                         // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              MapImage;                                          // 0x0008(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MapMinBounds;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MapMaxBounds;                                      // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        FloorLevel;                                        // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadMovementScalar;                             // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapFloorData) == 0x000008, "Wrong alignment on FMapFloorData");
static_assert(sizeof(FMapFloorData) == 0x000048, "Wrong size on FMapFloorData");
static_assert(offsetof(FMapFloorData, FloorName) == 0x000000, "Member 'FMapFloorData::FloorName' has a wrong offset!");
static_assert(offsetof(FMapFloorData, MapImage) == 0x000008, "Member 'FMapFloorData::MapImage' has a wrong offset!");
static_assert(offsetof(FMapFloorData, MapMinBounds) == 0x000030, "Member 'FMapFloorData::MapMinBounds' has a wrong offset!");
static_assert(offsetof(FMapFloorData, MapMaxBounds) == 0x000038, "Member 'FMapFloorData::MapMaxBounds' has a wrong offset!");
static_assert(offsetof(FMapFloorData, FloorLevel) == 0x000040, "Member 'FMapFloorData::FloorLevel' has a wrong offset!");
static_assert(offsetof(FMapFloorData, GamepadMovementScalar) == 0x000044, "Member 'FMapFloorData::GamepadMovementScalar' has a wrong offset!");

// ScriptStruct Indiana.MapTextEntryData
// 0x0020 (0x0020 - 0x0000)
struct FMapTextEntryData final
{
public:
	struct FLocString                             DisplayText;                                       // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TextRotation;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FloorName;                                         // 0x000C(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0014(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapTextEntryData) == 0x000004, "Wrong alignment on FMapTextEntryData");
static_assert(sizeof(FMapTextEntryData) == 0x000020, "Wrong size on FMapTextEntryData");
static_assert(offsetof(FMapTextEntryData, DisplayText) == 0x000000, "Member 'FMapTextEntryData::DisplayText' has a wrong offset!");
static_assert(offsetof(FMapTextEntryData, TextRotation) == 0x000008, "Member 'FMapTextEntryData::TextRotation' has a wrong offset!");
static_assert(offsetof(FMapTextEntryData, FloorName) == 0x00000C, "Member 'FMapTextEntryData::FloorName' has a wrong offset!");
static_assert(offsetof(FMapTextEntryData, Position) == 0x000014, "Member 'FMapTextEntryData::Position' has a wrong offset!");

// ScriptStruct Indiana.BoxShapeData
// 0x0010 (0x0018 - 0x0008)
struct FBoxShapeData final : public FShapeInterface
{
public:
	struct FVector                                BoxExtent;                                         // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBoxShapeData) == 0x000008, "Wrong alignment on FBoxShapeData");
static_assert(sizeof(FBoxShapeData) == 0x000018, "Wrong size on FBoxShapeData");
static_assert(offsetof(FBoxShapeData, BoxExtent) == 0x000008, "Member 'FBoxShapeData::BoxExtent' has a wrong offset!");

// ScriptStruct Indiana.ShapeVariant
// 0x0040 (0x0040 - 0x0000)
struct FShapeVariant final
{
public:
	EShapeType                                    ShapeType;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoxShapeData                          BoxData;                                           // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSphereShapeData                       SphereData;                                        // 0x0020(0x0010)(Edit, NativeAccessSpecifierPublic)
	struct FCapsuleShapeData                      CapsuleData;                                       // 0x0030(0x0010)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShapeVariant) == 0x000008, "Wrong alignment on FShapeVariant");
static_assert(sizeof(FShapeVariant) == 0x000040, "Wrong size on FShapeVariant");
static_assert(offsetof(FShapeVariant, ShapeType) == 0x000000, "Member 'FShapeVariant::ShapeType' has a wrong offset!");
static_assert(offsetof(FShapeVariant, BoxData) == 0x000008, "Member 'FShapeVariant::BoxData' has a wrong offset!");
static_assert(offsetof(FShapeVariant, SphereData) == 0x000020, "Member 'FShapeVariant::SphereData' has a wrong offset!");
static_assert(offsetof(FShapeVariant, CapsuleData) == 0x000030, "Member 'FShapeVariant::CapsuleData' has a wrong offset!");

// ScriptStruct Indiana.TransformedShapeVariant
// 0x0070 (0x0070 - 0x0000)
struct FTransformedShapeVariant final
{
public:
	struct FTransform                             ShapeTransform;                                    // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FShapeVariant                          Shape;                                             // 0x0030(0x0040)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTransformedShapeVariant) == 0x000010, "Wrong alignment on FTransformedShapeVariant");
static_assert(sizeof(FTransformedShapeVariant) == 0x000070, "Wrong size on FTransformedShapeVariant");
static_assert(offsetof(FTransformedShapeVariant, ShapeTransform) == 0x000000, "Member 'FTransformedShapeVariant::ShapeTransform' has a wrong offset!");
static_assert(offsetof(FTransformedShapeVariant, Shape) == 0x000030, "Member 'FTransformedShapeVariant::Shape' has a wrong offset!");

// ScriptStruct Indiana.MeleeCollisionInfo
// 0x0080 (0x0080 - 0x0000)
struct FMeleeCollisionInfo final
{
public:
	bool                                          bWeaponMesh;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CollisionSocket;                                   // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransformedShapeVariant               CollisionShapeInfo;                                // 0x0010(0x0070)(Edit, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FMeleeCollisionInfo) == 0x000010, "Wrong alignment on FMeleeCollisionInfo");
static_assert(sizeof(FMeleeCollisionInfo) == 0x000080, "Wrong size on FMeleeCollisionInfo");
static_assert(offsetof(FMeleeCollisionInfo, bWeaponMesh) == 0x000000, "Member 'FMeleeCollisionInfo::bWeaponMesh' has a wrong offset!");
static_assert(offsetof(FMeleeCollisionInfo, CollisionSocket) == 0x000004, "Member 'FMeleeCollisionInfo::CollisionSocket' has a wrong offset!");
static_assert(offsetof(FMeleeCollisionInfo, CollisionShapeInfo) == 0x000010, "Member 'FMeleeCollisionInfo::CollisionShapeInfo' has a wrong offset!");

// ScriptStruct Indiana.WeaponModVisualOverride
// 0x0018 (0x0018 - 0x0000)
struct FWeaponModVisualOverride final
{
public:
	TArray<TSoftClassPtr<class UClass>>           Mods;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UModVisual*                             VisualOverride;                                    // 0x0010(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponModVisualOverride) == 0x000008, "Wrong alignment on FWeaponModVisualOverride");
static_assert(sizeof(FWeaponModVisualOverride) == 0x000018, "Wrong size on FWeaponModVisualOverride");
static_assert(offsetof(FWeaponModVisualOverride, Mods) == 0x000000, "Member 'FWeaponModVisualOverride::Mods' has a wrong offset!");
static_assert(offsetof(FWeaponModVisualOverride, VisualOverride) == 0x000010, "Member 'FWeaponModVisualOverride::VisualOverride' has a wrong offset!");

// ScriptStruct Indiana.WeaponModSlot
// 0x0058 (0x0058 - 0x0000)
struct FWeaponModSlot final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UModVisual*                             SlotDefaultVisuals;                                // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bModdable;                                         // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UWeaponMod>                 DefaultMod;                                        // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponMod*                             CurrentMod;                                        // 0x0020(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UModVisual*                             CurrentVisuals;                                    // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UModVisual*                             PendingRemovalVisuals;                             // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponModSlot) == 0x000008, "Wrong alignment on FWeaponModSlot");
static_assert(sizeof(FWeaponModSlot) == 0x000058, "Wrong size on FWeaponModSlot");
static_assert(offsetof(FWeaponModSlot, SlotDefaultVisuals) == 0x000008, "Member 'FWeaponModSlot::SlotDefaultVisuals' has a wrong offset!");
static_assert(offsetof(FWeaponModSlot, bModdable) == 0x000010, "Member 'FWeaponModSlot::bModdable' has a wrong offset!");
static_assert(offsetof(FWeaponModSlot, DefaultMod) == 0x000018, "Member 'FWeaponModSlot::DefaultMod' has a wrong offset!");
static_assert(offsetof(FWeaponModSlot, CurrentMod) == 0x000020, "Member 'FWeaponModSlot::CurrentMod' has a wrong offset!");
static_assert(offsetof(FWeaponModSlot, CurrentVisuals) == 0x000038, "Member 'FWeaponModSlot::CurrentVisuals' has a wrong offset!");
static_assert(offsetof(FWeaponModSlot, PendingRemovalVisuals) == 0x000040, "Member 'FWeaponModSlot::PendingRemovalVisuals' has a wrong offset!");

// ScriptStruct Indiana.MeleeEQSResult
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FMeleeEQSResult final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMeleeEQSResult) == 0x000004, "Wrong alignment on FMeleeEQSResult");
static_assert(sizeof(FMeleeEQSResult) == 0x000010, "Wrong size on FMeleeEQSResult");

// ScriptStruct Indiana.MeleeAttacker
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FMeleeAttacker final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMeleeAttacker) == 0x000004, "Wrong alignment on FMeleeAttacker");
static_assert(sizeof(FMeleeAttacker) == 0x000018, "Wrong size on FMeleeAttacker");

// ScriptStruct Indiana.ModAppearance
// 0x0008 (0x0048 - 0x0040)
struct FModAppearance final : public FAppearanceMatch
{
public:
	class UModVisual*                             ModVisual;                                         // 0x0040(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModAppearance) == 0x000008, "Wrong alignment on FModAppearance");
static_assert(sizeof(FModAppearance) == 0x000048, "Wrong size on FModAppearance");
static_assert(offsetof(FModAppearance, ModVisual) == 0x000040, "Member 'FModAppearance::ModVisual' has a wrong offset!");

// ScriptStruct Indiana.AppliedMod
// 0x000C (0x000C - 0x0000)
struct FAppliedMod final
{
public:
	TWeakObjectPtr<class UModVisual>              Mod;                                               // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPermanentlyApplied;                               // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAppliedMod) == 0x000004, "Wrong alignment on FAppliedMod");
static_assert(sizeof(FAppliedMod) == 0x00000C, "Wrong size on FAppliedMod");
static_assert(offsetof(FAppliedMod, Mod) == 0x000000, "Member 'FAppliedMod::Mod' has a wrong offset!");
static_assert(offsetof(FAppliedMod, bPermanentlyApplied) == 0x000008, "Member 'FAppliedMod::bPermanentlyApplied' has a wrong offset!");

// ScriptStruct Indiana.LerpTimer
// 0x0018 (0x0018 - 0x0000)
struct FLerpTimer final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(float Progress, bool Complete)> TickDelegate;                                      // 0x0004(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLerpTimer) == 0x000004, "Wrong alignment on FLerpTimer");
static_assert(sizeof(FLerpTimer) == 0x000018, "Wrong size on FLerpTimer");
static_assert(offsetof(FLerpTimer, Duration) == 0x000000, "Member 'FLerpTimer::Duration' has a wrong offset!");
static_assert(offsetof(FLerpTimer, TickDelegate) == 0x000004, "Member 'FLerpTimer::TickDelegate' has a wrong offset!");

// ScriptStruct Indiana.ConditionalMusicTrack
// 0x0080 (0x0080 - 0x0000)
struct FConditionalMusicTrack final
{
public:
	struct FLogicalGroupedExpression              Condition;                                         // 0x0000(0x0078)(Edit, NativeAccessSpecifierPublic)
	class UMusicTrackData*                        MusicTrack;                                        // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConditionalMusicTrack) == 0x000008, "Wrong alignment on FConditionalMusicTrack");
static_assert(sizeof(FConditionalMusicTrack) == 0x000080, "Wrong size on FConditionalMusicTrack");
static_assert(offsetof(FConditionalMusicTrack, Condition) == 0x000000, "Member 'FConditionalMusicTrack::Condition' has a wrong offset!");
static_assert(offsetof(FConditionalMusicTrack, MusicTrack) == 0x000078, "Member 'FConditionalMusicTrack::MusicTrack' has a wrong offset!");

// ScriptStruct Indiana.HitFlinchAnim
// 0x0028 (0x0028 - 0x0000)
struct FHitFlinchAnim final
{
public:
	struct FGameplayTagContainer                  BodyParts;                                         // 0x0000(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Anim;                                              // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitFlinchAnim) == 0x000008, "Wrong alignment on FHitFlinchAnim");
static_assert(sizeof(FHitFlinchAnim) == 0x000028, "Wrong size on FHitFlinchAnim");
static_assert(offsetof(FHitFlinchAnim, BodyParts) == 0x000000, "Member 'FHitFlinchAnim::BodyParts' has a wrong offset!");
static_assert(offsetof(FHitFlinchAnim, Anim) == 0x000020, "Member 'FHitFlinchAnim::Anim' has a wrong offset!");

// ScriptStruct Indiana.ObjectiveWaypointGameDataReferenceID
// 0x0000 (0x0018 - 0x0018)
struct FObjectiveWaypointGameDataReferenceID final : public FGameDataReferenceID
{
};
static_assert(alignof(FObjectiveWaypointGameDataReferenceID) == 0x000008, "Wrong alignment on FObjectiveWaypointGameDataReferenceID");
static_assert(sizeof(FObjectiveWaypointGameDataReferenceID) == 0x000018, "Wrong size on FObjectiveWaypointGameDataReferenceID");

// ScriptStruct Indiana.ParticleSystemPool
// 0x0020 (0x0020 - 0x0000)
struct FParticleSystemPool final
{
public:
	TArray<class UPooledParticleSystemComponent*> ActiveComponents;                                  // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UPooledParticleSystemComponent*> FreeComponents;                                    // 0x0010(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParticleSystemPool) == 0x000008, "Wrong alignment on FParticleSystemPool");
static_assert(sizeof(FParticleSystemPool) == 0x000020, "Wrong size on FParticleSystemPool");
static_assert(offsetof(FParticleSystemPool, ActiveComponents) == 0x000000, "Member 'FParticleSystemPool::ActiveComponents' has a wrong offset!");
static_assert(offsetof(FParticleSystemPool, FreeComponents) == 0x000010, "Member 'FParticleSystemPool::FreeComponents' has a wrong offset!");

// ScriptStruct Indiana.ActionSet
// 0x0018 (0x0018 - 0x0000)
struct FActionSet final
{
public:
	class UAIAction*                              Action;                                            // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 LookAtOverride;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LookWhileWalking;                                  // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionSet) == 0x000008, "Wrong alignment on FActionSet");
static_assert(sizeof(FActionSet) == 0x000018, "Wrong size on FActionSet");
static_assert(offsetof(FActionSet, Action) == 0x000000, "Member 'FActionSet::Action' has a wrong offset!");
static_assert(offsetof(FActionSet, LookAtOverride) == 0x000008, "Member 'FActionSet::LookAtOverride' has a wrong offset!");
static_assert(offsetof(FActionSet, LookWhileWalking) == 0x000010, "Member 'FActionSet::LookWhileWalking' has a wrong offset!");

// ScriptStruct Indiana.PerkTextures
// 0x0018 (0x0018 - 0x0000)
struct FPerkTextures final
{
public:
	class UTexture2D*                             Unpurchased;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Purchased;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Suppressed;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerkTextures) == 0x000008, "Wrong alignment on FPerkTextures");
static_assert(sizeof(FPerkTextures) == 0x000018, "Wrong size on FPerkTextures");
static_assert(offsetof(FPerkTextures, Unpurchased) == 0x000000, "Member 'FPerkTextures::Unpurchased' has a wrong offset!");
static_assert(offsetof(FPerkTextures, Purchased) == 0x000008, "Member 'FPerkTextures::Purchased' has a wrong offset!");
static_assert(offsetof(FPerkTextures, Suppressed) == 0x000010, "Member 'FPerkTextures::Suppressed' has a wrong offset!");

// ScriptStruct Indiana.HitTypeData
// 0x0020 (0x0020 - 0x0000)
struct FHitTypeData final
{
public:
	class UCurveVector*                           Curve;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationDuration;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalMovementScalarMin;                       // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalMovementScalarMax;                       // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalMovementScalarMin;                         // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalMovementScalarMax;                         // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextDirectionType                            TextMovementDirectionType;                         // 0x001C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitTypeData) == 0x000008, "Wrong alignment on FHitTypeData");
static_assert(sizeof(FHitTypeData) == 0x000020, "Wrong size on FHitTypeData");
static_assert(offsetof(FHitTypeData, Curve) == 0x000000, "Member 'FHitTypeData::Curve' has a wrong offset!");
static_assert(offsetof(FHitTypeData, AnimationDuration) == 0x000008, "Member 'FHitTypeData::AnimationDuration' has a wrong offset!");
static_assert(offsetof(FHitTypeData, HorizontalMovementScalarMin) == 0x00000C, "Member 'FHitTypeData::HorizontalMovementScalarMin' has a wrong offset!");
static_assert(offsetof(FHitTypeData, HorizontalMovementScalarMax) == 0x000010, "Member 'FHitTypeData::HorizontalMovementScalarMax' has a wrong offset!");
static_assert(offsetof(FHitTypeData, VerticalMovementScalarMin) == 0x000014, "Member 'FHitTypeData::VerticalMovementScalarMin' has a wrong offset!");
static_assert(offsetof(FHitTypeData, VerticalMovementScalarMax) == 0x000018, "Member 'FHitTypeData::VerticalMovementScalarMax' has a wrong offset!");
static_assert(offsetof(FHitTypeData, TextMovementDirectionType) == 0x00001C, "Member 'FHitTypeData::TextMovementDirectionType' has a wrong offset!");

// ScriptStruct Indiana.SurvivalTier
// 0x0010 (0x0010 - 0x0000)
struct FSurvivalTier final
{
public:
	TSubclassOf<class USpell>                     Spell;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TierMin;                                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TierMax;                                           // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSurvivalTier) == 0x000008, "Wrong alignment on FSurvivalTier");
static_assert(sizeof(FSurvivalTier) == 0x000010, "Wrong size on FSurvivalTier");
static_assert(offsetof(FSurvivalTier, Spell) == 0x000000, "Member 'FSurvivalTier::Spell' has a wrong offset!");
static_assert(offsetof(FSurvivalTier, TierMin) == 0x000008, "Member 'FSurvivalTier::TierMin' has a wrong offset!");
static_assert(offsetof(FSurvivalTier, TierMax) == 0x00000C, "Member 'FSurvivalTier::TierMax' has a wrong offset!");

// ScriptStruct Indiana.SkillValueExperienceRange
// 0x000C (0x000C - 0x0000)
struct FSkillValueExperienceRange final
{
public:
	int32                                         Min;                                               // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XP;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillValueExperienceRange) == 0x000004, "Wrong alignment on FSkillValueExperienceRange");
static_assert(sizeof(FSkillValueExperienceRange) == 0x00000C, "Wrong size on FSkillValueExperienceRange");
static_assert(offsetof(FSkillValueExperienceRange, Min) == 0x000000, "Member 'FSkillValueExperienceRange::Min' has a wrong offset!");
static_assert(offsetof(FSkillValueExperienceRange, Max) == 0x000004, "Member 'FSkillValueExperienceRange::Max' has a wrong offset!");
static_assert(offsetof(FSkillValueExperienceRange, XP) == 0x000008, "Member 'FSkillValueExperienceRange::XP' has a wrong offset!");

// ScriptStruct Indiana.LevelDifferenceRangeScalar
// 0x000C (0x000C - 0x0000)
struct FLevelDifferenceRangeScalar final
{
public:
	int32                                         Min;                                               // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scalar;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelDifferenceRangeScalar) == 0x000004, "Wrong alignment on FLevelDifferenceRangeScalar");
static_assert(sizeof(FLevelDifferenceRangeScalar) == 0x00000C, "Wrong size on FLevelDifferenceRangeScalar");
static_assert(offsetof(FLevelDifferenceRangeScalar, Min) == 0x000000, "Member 'FLevelDifferenceRangeScalar::Min' has a wrong offset!");
static_assert(offsetof(FLevelDifferenceRangeScalar, Max) == 0x000004, "Member 'FLevelDifferenceRangeScalar::Max' has a wrong offset!");
static_assert(offsetof(FLevelDifferenceRangeScalar, Scalar) == 0x000008, "Member 'FLevelDifferenceRangeScalar::Scalar' has a wrong offset!");

// ScriptStruct Indiana.LootOnBreakdown
// 0x0010 (0x0010 - 0x0000)
struct FLootOnBreakdown final
{
public:
	ESkill                                        Skill;                                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinSkill;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULootTableData*                         LootTable;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLootOnBreakdown) == 0x000008, "Wrong alignment on FLootOnBreakdown");
static_assert(sizeof(FLootOnBreakdown) == 0x000010, "Wrong size on FLootOnBreakdown");
static_assert(offsetof(FLootOnBreakdown, Skill) == 0x000000, "Member 'FLootOnBreakdown::Skill' has a wrong offset!");
static_assert(offsetof(FLootOnBreakdown, MinSkill) == 0x000004, "Member 'FLootOnBreakdown::MinSkill' has a wrong offset!");
static_assert(offsetof(FLootOnBreakdown, LootTable) == 0x000008, "Member 'FLootOnBreakdown::LootTable' has a wrong offset!");

// ScriptStruct Indiana.DodgeProperties
// 0x001C (0x001C - 0x0000)
struct FDodgeProperties final
{
public:
	struct FVector                                RelativeDirection;                                 // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DodgeVelocity;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DodgeVelocityZ;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideTime;                                         // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideFriction;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDodgeProperties) == 0x000004, "Wrong alignment on FDodgeProperties");
static_assert(sizeof(FDodgeProperties) == 0x00001C, "Wrong size on FDodgeProperties");
static_assert(offsetof(FDodgeProperties, RelativeDirection) == 0x000000, "Member 'FDodgeProperties::RelativeDirection' has a wrong offset!");
static_assert(offsetof(FDodgeProperties, DodgeVelocity) == 0x00000C, "Member 'FDodgeProperties::DodgeVelocity' has a wrong offset!");
static_assert(offsetof(FDodgeProperties, DodgeVelocityZ) == 0x000010, "Member 'FDodgeProperties::DodgeVelocityZ' has a wrong offset!");
static_assert(offsetof(FDodgeProperties, SlideTime) == 0x000014, "Member 'FDodgeProperties::SlideTime' has a wrong offset!");
static_assert(offsetof(FDodgeProperties, SlideFriction) == 0x000018, "Member 'FDodgeProperties::SlideFriction' has a wrong offset!");

// ScriptStruct Indiana.DodgeInputRange
// 0x0008 (0x0008 - 0x0000)
struct FDodgeInputRange final
{
public:
	float                                         VerticalWeight;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalWeight;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDodgeInputRange) == 0x000004, "Wrong alignment on FDodgeInputRange");
static_assert(sizeof(FDodgeInputRange) == 0x000008, "Wrong size on FDodgeInputRange");
static_assert(offsetof(FDodgeInputRange, VerticalWeight) == 0x000000, "Member 'FDodgeInputRange::VerticalWeight' has a wrong offset!");
static_assert(offsetof(FDodgeInputRange, HorizontalWeight) == 0x000004, "Member 'FDodgeInputRange::HorizontalWeight' has a wrong offset!");

// ScriptStruct Indiana.InterestStateTextures
// 0x0018 (0x0018 - 0x0000)
struct FInterestStateTextures final
{
public:
	class UTexture2D*                             DiscoveredTexture;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             UnknownTexture;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             MentionedTexture;                                  // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FInterestStateTextures) == 0x000008, "Wrong alignment on FInterestStateTextures");
static_assert(sizeof(FInterestStateTextures) == 0x000018, "Wrong size on FInterestStateTextures");
static_assert(offsetof(FInterestStateTextures, DiscoveredTexture) == 0x000000, "Member 'FInterestStateTextures::DiscoveredTexture' has a wrong offset!");
static_assert(offsetof(FInterestStateTextures, UnknownTexture) == 0x000008, "Member 'FInterestStateTextures::UnknownTexture' has a wrong offset!");
static_assert(offsetof(FInterestStateTextures, MentionedTexture) == 0x000010, "Member 'FInterestStateTextures::MentionedTexture' has a wrong offset!");

// ScriptStruct Indiana.NodeVarConditionalVarReset
// 0x0050 (0x0050 - 0x0000)
struct FNodeVarConditionalVarReset final
{
public:
	class FName                                   ConversationName;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConversationReference                 Conversation;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ConversationNode;                                  // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TestGlobalVar;                                     // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TestGlobalVarValue;                                // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TargetGlobalVar;                                   // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetGlobalVarValue;                              // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNodeVarConditionalVarReset) == 0x000008, "Wrong alignment on FNodeVarConditionalVarReset");
static_assert(sizeof(FNodeVarConditionalVarReset) == 0x000050, "Wrong size on FNodeVarConditionalVarReset");
static_assert(offsetof(FNodeVarConditionalVarReset, ConversationName) == 0x000000, "Member 'FNodeVarConditionalVarReset::ConversationName' has a wrong offset!");
static_assert(offsetof(FNodeVarConditionalVarReset, Conversation) == 0x000008, "Member 'FNodeVarConditionalVarReset::Conversation' has a wrong offset!");
static_assert(offsetof(FNodeVarConditionalVarReset, ConversationNode) == 0x000018, "Member 'FNodeVarConditionalVarReset::ConversationNode' has a wrong offset!");
static_assert(offsetof(FNodeVarConditionalVarReset, TestGlobalVar) == 0x000020, "Member 'FNodeVarConditionalVarReset::TestGlobalVar' has a wrong offset!");
static_assert(offsetof(FNodeVarConditionalVarReset, TestGlobalVarValue) == 0x000030, "Member 'FNodeVarConditionalVarReset::TestGlobalVarValue' has a wrong offset!");
static_assert(offsetof(FNodeVarConditionalVarReset, TargetGlobalVar) == 0x000038, "Member 'FNodeVarConditionalVarReset::TargetGlobalVar' has a wrong offset!");
static_assert(offsetof(FNodeVarConditionalVarReset, TargetGlobalVarValue) == 0x000048, "Member 'FNodeVarConditionalVarReset::TargetGlobalVarValue' has a wrong offset!");

// ScriptStruct Indiana.NodeSet
// 0x0020 (0x0020 - 0x0000)
struct FNodeSet final
{
public:
	struct FConversationReference                 Conversation;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 NodeIDs;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNodeSet) == 0x000008, "Wrong alignment on FNodeSet");
static_assert(sizeof(FNodeSet) == 0x000020, "Wrong size on FNodeSet");
static_assert(offsetof(FNodeSet, Conversation) == 0x000000, "Member 'FNodeSet::Conversation' has a wrong offset!");
static_assert(offsetof(FNodeSet, NodeIDs) == 0x000010, "Member 'FNodeSet::NodeIDs' has a wrong offset!");

// ScriptStruct Indiana.PostProcessFX
// 0x0078 (0x0078 - 0x0000)
struct FPostProcessFX final
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Particle;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentParticle;                               // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FRuntimeFloatCurve>  Params;                                            // 0x0018(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               DynamicMaterial;                                   // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               ActiveParticleSystem;                              // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPostProcessFX) == 0x000008, "Wrong alignment on FPostProcessFX");
static_assert(sizeof(FPostProcessFX) == 0x000078, "Wrong size on FPostProcessFX");
static_assert(offsetof(FPostProcessFX, Material) == 0x000000, "Member 'FPostProcessFX::Material' has a wrong offset!");
static_assert(offsetof(FPostProcessFX, Particle) == 0x000008, "Member 'FPostProcessFX::Particle' has a wrong offset!");
static_assert(offsetof(FPostProcessFX, bPersistentParticle) == 0x000010, "Member 'FPostProcessFX::bPersistentParticle' has a wrong offset!");
static_assert(offsetof(FPostProcessFX, Params) == 0x000018, "Member 'FPostProcessFX::Params' has a wrong offset!");
static_assert(offsetof(FPostProcessFX, DynamicMaterial) == 0x000068, "Member 'FPostProcessFX::DynamicMaterial' has a wrong offset!");
static_assert(offsetof(FPostProcessFX, ActiveParticleSystem) == 0x000070, "Member 'FPostProcessFX::ActiveParticleSystem' has a wrong offset!");

// ScriptStruct Indiana.QuestSubTypeGroup
// 0x0010 (0x0010 - 0x0000)
struct FQuestSubTypeGroup final
{
public:
	TArray<EQuestType>                            AcceptedSubTypes;                                  // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestSubTypeGroup) == 0x000008, "Wrong alignment on FQuestSubTypeGroup");
static_assert(sizeof(FQuestSubTypeGroup) == 0x000010, "Wrong size on FQuestSubTypeGroup");
static_assert(offsetof(FQuestSubTypeGroup, AcceptedSubTypes) == 0x000000, "Member 'FQuestSubTypeGroup::AcceptedSubTypes' has a wrong offset!");

// ScriptStruct Indiana.DifficultyRange
// 0x0008 (0x0008 - 0x0000)
struct FDifficultyRange final
{
public:
	int32                                         RangeMinimum;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RangeMaximum;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FDifficultyRange) == 0x000004, "Wrong alignment on FDifficultyRange");
static_assert(sizeof(FDifficultyRange) == 0x000008, "Wrong size on FDifficultyRange");
static_assert(offsetof(FDifficultyRange, RangeMinimum) == 0x000000, "Member 'FDifficultyRange::RangeMinimum' has a wrong offset!");
static_assert(offsetof(FDifficultyRange, RangeMaximum) == 0x000004, "Member 'FDifficultyRange::RangeMaximum' has a wrong offset!");

// ScriptStruct Indiana.RandomActionSetPair
// 0x0010 (0x0010 - 0x0000)
struct FRandomActionSetPair final
{
public:
	class UAIAction*                              Action;                                            // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Score;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRandomActionSetPair) == 0x000008, "Wrong alignment on FRandomActionSetPair");
static_assert(sizeof(FRandomActionSetPair) == 0x000010, "Wrong size on FRandomActionSetPair");
static_assert(offsetof(FRandomActionSetPair, Action) == 0x000000, "Member 'FRandomActionSetPair::Action' has a wrong offset!");
static_assert(offsetof(FRandomActionSetPair, Score) == 0x000008, "Member 'FRandomActionSetPair::Score' has a wrong offset!");

// ScriptStruct Indiana.WeightedEffect
// 0x0010 (0x0010 - 0x0000)
struct FWeightedEffect final
{
public:
	class UEventEffect*                           Effect;                                            // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeightedEffect) == 0x000008, "Wrong alignment on FWeightedEffect");
static_assert(sizeof(FWeightedEffect) == 0x000010, "Wrong size on FWeightedEffect");
static_assert(offsetof(FWeightedEffect, Effect) == 0x000000, "Member 'FWeightedEffect::Effect' has a wrong offset!");
static_assert(offsetof(FWeightedEffect, Weight) == 0x000008, "Member 'FWeightedEffect::Weight' has a wrong offset!");

// ScriptStruct Indiana.PriorityCreatureSpawn
// 0x0040 (0x0040 - 0x0000)
struct FPriorityCreatureSpawn final
{
public:
	struct FGameplayTagContainer                  CreaturesTypeTags;                                 // 0x0000(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  CreatureRoleTags;                                  // 0x0020(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FPriorityCreatureSpawn) == 0x000008, "Wrong alignment on FPriorityCreatureSpawn");
static_assert(sizeof(FPriorityCreatureSpawn) == 0x000040, "Wrong size on FPriorityCreatureSpawn");
static_assert(offsetof(FPriorityCreatureSpawn, CreaturesTypeTags) == 0x000000, "Member 'FPriorityCreatureSpawn::CreaturesTypeTags' has a wrong offset!");
static_assert(offsetof(FPriorityCreatureSpawn, CreatureRoleTags) == 0x000020, "Member 'FPriorityCreatureSpawn::CreatureRoleTags' has a wrong offset!");

// ScriptStruct Indiana.RandomTextEntry
// 0x0008 (0x0010 - 0x0008)
struct FRandomTextEntry final : public FGameDataStructure
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRandomTextEntry) == 0x000008, "Wrong alignment on FRandomTextEntry");
static_assert(sizeof(FRandomTextEntry) == 0x000010, "Wrong size on FRandomTextEntry");

// ScriptStruct Indiana.DepthOfFieldSettings
// 0x0014 (0x0014 - 0x0000)
struct FDepthOfFieldSettings final
{
public:
	bool                                          bUseSettings;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FocalDistance;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearTransition;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearBlur;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FarBlur;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDepthOfFieldSettings) == 0x000004, "Wrong alignment on FDepthOfFieldSettings");
static_assert(sizeof(FDepthOfFieldSettings) == 0x000014, "Wrong size on FDepthOfFieldSettings");
static_assert(offsetof(FDepthOfFieldSettings, bUseSettings) == 0x000000, "Member 'FDepthOfFieldSettings::bUseSettings' has a wrong offset!");
static_assert(offsetof(FDepthOfFieldSettings, FocalDistance) == 0x000004, "Member 'FDepthOfFieldSettings::FocalDistance' has a wrong offset!");
static_assert(offsetof(FDepthOfFieldSettings, NearTransition) == 0x000008, "Member 'FDepthOfFieldSettings::NearTransition' has a wrong offset!");
static_assert(offsetof(FDepthOfFieldSettings, NearBlur) == 0x00000C, "Member 'FDepthOfFieldSettings::NearBlur' has a wrong offset!");
static_assert(offsetof(FDepthOfFieldSettings, FarBlur) == 0x000010, "Member 'FDepthOfFieldSettings::FarBlur' has a wrong offset!");

// ScriptStruct Indiana.CustomShotAngles
// 0x0008 (0x0008 - 0x0000)
struct FCustomShotAngles final
{
public:
	float                                         Pitch;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Yaw;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomShotAngles) == 0x000004, "Wrong alignment on FCustomShotAngles");
static_assert(sizeof(FCustomShotAngles) == 0x000008, "Wrong size on FCustomShotAngles");
static_assert(offsetof(FCustomShotAngles, Pitch) == 0x000000, "Member 'FCustomShotAngles::Pitch' has a wrong offset!");
static_assert(offsetof(FCustomShotAngles, Yaw) == 0x000004, "Member 'FCustomShotAngles::Yaw' has a wrong offset!");

// ScriptStruct Indiana.HitReaction
// 0x0010 (0x0010 - 0x0000)
struct FHitReaction final
{
public:
	TSubclassOf<class UDirectionalAnimDisableStatusEffect> StatusEffect;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownTime;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitReaction) == 0x000008, "Wrong alignment on FHitReaction");
static_assert(sizeof(FHitReaction) == 0x000010, "Wrong size on FHitReaction");
static_assert(offsetof(FHitReaction, StatusEffect) == 0x000000, "Member 'FHitReaction::StatusEffect' has a wrong offset!");
static_assert(offsetof(FHitReaction, CooldownTime) == 0x000008, "Member 'FHitReaction::CooldownTime' has a wrong offset!");

// ScriptStruct Indiana.CrosshairStates
// 0x0090 (0x0090 - 0x0000)
struct FCrosshairStates final
{
public:
	struct FCrosshairVisuals                      Default;                                           // 0x0000(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCrosshairVisuals                      Hostile;                                           // 0x0030(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCrosshairVisuals                      Neutral;                                           // 0x0060(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrosshairStates) == 0x000008, "Wrong alignment on FCrosshairStates");
static_assert(sizeof(FCrosshairStates) == 0x000090, "Wrong size on FCrosshairStates");
static_assert(offsetof(FCrosshairStates, Default) == 0x000000, "Member 'FCrosshairStates::Default' has a wrong offset!");
static_assert(offsetof(FCrosshairStates, Hostile) == 0x000030, "Member 'FCrosshairStates::Hostile' has a wrong offset!");
static_assert(offsetof(FCrosshairStates, Neutral) == 0x000060, "Member 'FCrosshairStates::Neutral' has a wrong offset!");

// ScriptStruct Indiana.StatInstance
// 0x0038 (0x0038 - 0x0000)
struct FStatInstance final
{
public:
	float                                         InherentValue;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InherentMultiplier;                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FStatModifierInstance>          Modifiers;                                         // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18[0x20];                                      // 0x0018(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatInstance) == 0x000008, "Wrong alignment on FStatInstance");
static_assert(sizeof(FStatInstance) == 0x000038, "Wrong size on FStatInstance");
static_assert(offsetof(FStatInstance, InherentValue) == 0x000000, "Member 'FStatInstance::InherentValue' has a wrong offset!");
static_assert(offsetof(FStatInstance, InherentMultiplier) == 0x000004, "Member 'FStatInstance::InherentMultiplier' has a wrong offset!");
static_assert(offsetof(FStatInstance, Modifiers) == 0x000008, "Member 'FStatInstance::Modifiers' has a wrong offset!");

// ScriptStruct Indiana.RpgStatCollection
// 0x0068 (0x0068 - 0x0000)
struct FRpgStatCollection final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class URpgStat*, struct FStatInstance>   StatMap;                                           // 0x0010(0x0050)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRpgStatCollection) == 0x000008, "Wrong alignment on FRpgStatCollection");
static_assert(sizeof(FRpgStatCollection) == 0x000068, "Wrong size on FRpgStatCollection");
static_assert(offsetof(FRpgStatCollection, StatMap) == 0x000010, "Member 'FRpgStatCollection::StatMap' has a wrong offset!");

// ScriptStruct Indiana.SaveGameDataBehaviorStack
// 0x0010 (0x0010 - 0x0000)
struct FSaveGameDataBehaviorStack final
{
public:
	TArray<class UBehaviorStateInfo*>             SavedStateInfos;                                   // 0x0000(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FSaveGameDataBehaviorStack) == 0x000008, "Wrong alignment on FSaveGameDataBehaviorStack");
static_assert(sizeof(FSaveGameDataBehaviorStack) == 0x000010, "Wrong size on FSaveGameDataBehaviorStack");
static_assert(offsetof(FSaveGameDataBehaviorStack, SavedStateInfos) == 0x000000, "Member 'FSaveGameDataBehaviorStack::SavedStateInfos' has a wrong offset!");

// ScriptStruct Indiana.SaveGameDataInterest
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FSaveGameDataInterest final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSaveGameDataInterest) == 0x000008, "Wrong alignment on FSaveGameDataInterest");
static_assert(sizeof(FSaveGameDataInterest) == 0x000050, "Wrong size on FSaveGameDataInterest");

// ScriptStruct Indiana.SaveGameDataAIController
// 0x00C0 (0x00C0 - 0x0000)
struct FSaveGameDataAIController final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSaveGameDataBehaviorStack             BehaviorStackData;                                 // 0x0010(0x0010)(Protected, NativeAccessSpecifierProtected)
	struct FSaveGameDataDetection                 DetectionData;                                     // 0x0020(0x0030)(Protected, NativeAccessSpecifierProtected)
	struct FSaveGameDataTargetInfo                TargetInfoData;                                    // 0x0050(0x0014)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSaveGameDataDecisionTree              DecisionTreeData;                                  // 0x0064(0x0008)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSaveGameDataInterest                  InterestData;                                      // 0x0070(0x0050)(Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FSaveGameDataAIController) == 0x000008, "Wrong alignment on FSaveGameDataAIController");
static_assert(sizeof(FSaveGameDataAIController) == 0x0000C0, "Wrong size on FSaveGameDataAIController");
static_assert(offsetof(FSaveGameDataAIController, BehaviorStackData) == 0x000010, "Member 'FSaveGameDataAIController::BehaviorStackData' has a wrong offset!");
static_assert(offsetof(FSaveGameDataAIController, DetectionData) == 0x000020, "Member 'FSaveGameDataAIController::DetectionData' has a wrong offset!");
static_assert(offsetof(FSaveGameDataAIController, TargetInfoData) == 0x000050, "Member 'FSaveGameDataAIController::TargetInfoData' has a wrong offset!");
static_assert(offsetof(FSaveGameDataAIController, DecisionTreeData) == 0x000064, "Member 'FSaveGameDataAIController::DecisionTreeData' has a wrong offset!");
static_assert(offsetof(FSaveGameDataAIController, InterestData) == 0x000070, "Member 'FSaveGameDataAIController::InterestData' has a wrong offset!");

// ScriptStruct Indiana.SaveGameGeneralMetadata
// 0x00E8 (0x00E8 - 0x0000)
struct alignas(0x08) FSaveGameGeneralMetadata final
{
public:
	uint8                                         Pad_0[0xE8];                                       // 0x0000(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSaveGameGeneralMetadata) == 0x000008, "Wrong alignment on FSaveGameGeneralMetadata");
static_assert(sizeof(FSaveGameGeneralMetadata) == 0x0000E8, "Wrong size on FSaveGameGeneralMetadata");

// ScriptStruct Indiana.CompanionGameStateHeader
// 0x0030 (0x0040 - 0x0010)
struct alignas(0x08) FCompanionGameStateHeader final : public FGenericVersionedGameStateHeader
{
public:
	uint8                                         Pad_10[0x30];                                      // 0x0010(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCompanionGameStateHeader) == 0x000008, "Wrong alignment on FCompanionGameStateHeader");
static_assert(sizeof(FCompanionGameStateHeader) == 0x000040, "Wrong size on FCompanionGameStateHeader");

// ScriptStruct Indiana.PlayerGameStateHeader
// 0x0010 (0x0020 - 0x0010)
struct alignas(0x08) FPlayerGameStateHeader final : public FGenericVersionedGameStateHeader
{
public:
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerGameStateHeader) == 0x000008, "Wrong alignment on FPlayerGameStateHeader");
static_assert(sizeof(FPlayerGameStateHeader) == 0x000020, "Wrong size on FPlayerGameStateHeader");

// ScriptStruct Indiana.ActorGameStateHeader
// 0x001C (0x0028 - 0x000C)
struct FActorGameStateHeader final : public FGenericGameStateHeader
{
public:
	uint8                                         Pad_C[0x1C];                                       // 0x000C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActorGameStateHeader) == 0x000004, "Wrong alignment on FActorGameStateHeader");
static_assert(sizeof(FActorGameStateHeader) == 0x000028, "Wrong size on FActorGameStateHeader");

// ScriptStruct Indiana.GenericVersionedWithDependenciesGameStateHeader
// 0x0010 (0x0020 - 0x0010)
struct alignas(0x08) FGenericVersionedWithDependenciesGameStateHeader final : public FGenericVersionedGameStateHeader
{
public:
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGenericVersionedWithDependenciesGameStateHeader) == 0x000008, "Wrong alignment on FGenericVersionedWithDependenciesGameStateHeader");
static_assert(sizeof(FGenericVersionedWithDependenciesGameStateHeader) == 0x000020, "Wrong size on FGenericVersionedWithDependenciesGameStateHeader");

// ScriptStruct Indiana.DestroyedPrePlacedActorRegistry
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FDestroyedPrePlacedActorRegistry final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDestroyedPrePlacedActorRegistry) == 0x000008, "Wrong alignment on FDestroyedPrePlacedActorRegistry");
static_assert(sizeof(FDestroyedPrePlacedActorRegistry) == 0x000050, "Wrong size on FDestroyedPrePlacedActorRegistry");

// ScriptStruct Indiana.HUDSetting
// 0x0034 (0x0034 - 0x0000)
struct FHUDSetting final
{
public:
	ECompassVisibilityMode                        CompassVisibility;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDialogSkillMode                              DialogSkillMode;                                   // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TooltipDelay;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NotificationDuration;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInteractionOutlines;                              // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInteractionControls;                              // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaypointMarkers;                                  // 0x000E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEnemyHealthBarMode                           EnemyHealthBarMode;                                // 0x000F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EReticleMode                                  ReticleMode;                                       // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReticleFeedback;                                  // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQuestUpdateMode                              QuestUpdateMode;                                   // 0x0012(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAwarenessMeterMode;                               // 0x0013(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerStatusBarMode                          StatusBarMode;                                     // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowPlayerStatusEffects;                          // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerStatusEffectTextMode                   PlayerStatusEffectTextMode;                        // 0x0016(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECompanionAbilityUIMode                       CompanionAbilityUI;                                // 0x0017(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECompanionAbilityBindingMode                  CompanionAbilityBindings;                          // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHeldWeaponDisplayMode                        HeldWeaponDisplay;                                 // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHeldWeaponDisplayText                        HeldWeaponTextDisplay;                             // 0x001A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAreaNameMode                                 AreaNameMode;                                      // 0x001B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDirectionalDamageIndicatorMode               DirectionalDamageIndicatorMode;                    // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFPSIndicatorMode                             FPSIndicator;                                      // 0x001D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowSurvivalBars;                                 // 0x001E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMedicalInhalerMode                           InhalerMode;                                       // 0x001F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityControlMode                           AbilityControlMode;                                // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECompanionStatusMode                          CompanionStatusMode;                               // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECompanionAbilityPassiveCDMode                CompanionAbilityPassiveCooldowns;                  // 0x0022(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECompanionAbilityPassiveNotificationMode      CompanionAbilityPassiveNotifications;              // 0x0023(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowLevelUpNotifications;                         // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowLevelUpReminders;                             // 0x0025(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowCombatIndicator;                              // 0x0026(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowTTDScanner;                                   // 0x0027(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETTDReticleMeterMode                          TTDReticleMeterMode;                               // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTTDStatusEffectPreview;                           // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDisguiseMeter;                                // 0x002A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEquipmentRepairWarning;                           // 0x002B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponSelectMode                             WeaponSelectMode;                                  // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponSelectAxisMode                         WeaponSelectAxisMode;                              // 0x002D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowTutorialNotifications;                        // 0x002E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowTutorialPopups;                               // 0x002F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowLootTooltips;                                 // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowLootControls;                                 // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHUDSetting) == 0x000004, "Wrong alignment on FHUDSetting");
static_assert(sizeof(FHUDSetting) == 0x000034, "Wrong size on FHUDSetting");
static_assert(offsetof(FHUDSetting, CompassVisibility) == 0x000000, "Member 'FHUDSetting::CompassVisibility' has a wrong offset!");
static_assert(offsetof(FHUDSetting, DialogSkillMode) == 0x000001, "Member 'FHUDSetting::DialogSkillMode' has a wrong offset!");
static_assert(offsetof(FHUDSetting, TooltipDelay) == 0x000004, "Member 'FHUDSetting::TooltipDelay' has a wrong offset!");
static_assert(offsetof(FHUDSetting, NotificationDuration) == 0x000008, "Member 'FHUDSetting::NotificationDuration' has a wrong offset!");
static_assert(offsetof(FHUDSetting, bInteractionOutlines) == 0x00000C, "Member 'FHUDSetting::bInteractionOutlines' has a wrong offset!");
static_assert(offsetof(FHUDSetting, bInteractionControls) == 0x00000D, "Member 'FHUDSetting::bInteractionControls' has a wrong offset!");
static_assert(offsetof(FHUDSetting, bWaypointMarkers) == 0x00000E, "Member 'FHUDSetting::bWaypointMarkers' has a wrong offset!");
static_assert(offsetof(FHUDSetting, EnemyHealthBarMode) == 0x00000F, "Member 'FHUDSetting::EnemyHealthBarMode' has a wrong offset!");
static_assert(offsetof(FHUDSetting, ReticleMode) == 0x000010, "Member 'FHUDSetting::ReticleMode' has a wrong offset!");
static_assert(offsetof(FHUDSetting, bReticleFeedback) == 0x000011, "Member 'FHUDSetting::bReticleFeedback' has a wrong offset!");
static_assert(offsetof(FHUDSetting, QuestUpdateMode) == 0x000012, "Member 'FHUDSetting::QuestUpdateMode' has a wrong offset!");
static_assert(offsetof(FHUDSetting, bAwarenessMeterMode) == 0x000013, "Member 'FHUDSetting::bAwarenessMeterMode' has a wrong offset!");
static_assert(offsetof(FHUDSetting, StatusBarMode) == 0x000014, "Member 'FHUDSetting::StatusBarMode' has a wrong offset!");
static_assert(offsetof(FHUDSetting, bShowPlayerStatusEffects) == 0x000015, "Member 'FHUDSetting::bShowPlayerStatusEffects' has a wrong offset!");
static_assert(offsetof(FHUDSetting, PlayerStatusEffectTextMode) == 0x000016, "Member 'FHUDSetting::PlayerStatusEffectTextMode' has a wrong offset!");
static_assert(offsetof(FHUDSetting, CompanionAbilityUI) == 0x000017, "Member 'FHUDSetting::CompanionAbilityUI' has a wrong offset!");
static_assert(offsetof(FHUDSetting, CompanionAbilityBindings) == 0x000018, "Member 'FHUDSetting::CompanionAbilityBindings' has a wrong offset!");
static_assert(offsetof(FHUDSetting, HeldWeaponDisplay) == 0x000019, "Member 'FHUDSetting::HeldWeaponDisplay' has a wrong offset!");
static_assert(offsetof(FHUDSetting, HeldWeaponTextDisplay) == 0x00001A, "Member 'FHUDSetting::HeldWeaponTextDisplay' has a wrong offset!");
static_assert(offsetof(FHUDSetting, AreaNameMode) == 0x00001B, "Member 'FHUDSetting::AreaNameMode' has a wrong offset!");
static_assert(offsetof(FHUDSetting, DirectionalDamageIndicatorMode) == 0x00001C, "Member 'FHUDSetting::DirectionalDamageIndicatorMode' has a wrong offset!");
static_assert(offsetof(FHUDSetting, FPSIndicator) == 0x00001D, "Member 'FHUDSetting::FPSIndicator' has a wrong offset!");
static_assert(offsetof(FHUDSetting, bShowSurvivalBars) == 0x00001E, "Member 'FHUDSetting::bShowSurvivalBars' has a wrong offset!");
static_assert(offsetof(FHUDSetting, InhalerMode) == 0x00001F, "Member 'FHUDSetting::InhalerMode' has a wrong offset!");
static_assert(offsetof(FHUDSetting, AbilityControlMode) == 0x000020, "Member 'FHUDSetting::AbilityControlMode' has a wrong offset!");
static_assert(offsetof(FHUDSetting, CompanionStatusMode) == 0x000021, "Member 'FHUDSetting::CompanionStatusMode' has a wrong offset!");
static_assert(offsetof(FHUDSetting, CompanionAbilityPassiveCooldowns) == 0x000022, "Member 'FHUDSetting::CompanionAbilityPassiveCooldowns' has a wrong offset!");
static_assert(offsetof(FHUDSetting, CompanionAbilityPassiveNotifications) == 0x000023, "Member 'FHUDSetting::CompanionAbilityPassiveNotifications' has a wrong offset!");
static_assert(offsetof(FHUDSetting, bShowLevelUpNotifications) == 0x000024, "Member 'FHUDSetting::bShowLevelUpNotifications' has a wrong offset!");
static_assert(offsetof(FHUDSetting, bShowLevelUpReminders) == 0x000025, "Member 'FHUDSetting::bShowLevelUpReminders' has a wrong offset!");
static_assert(offsetof(FHUDSetting, bShowCombatIndicator) == 0x000026, "Member 'FHUDSetting::bShowCombatIndicator' has a wrong offset!");
static_assert(offsetof(FHUDSetting, bShowTTDScanner) == 0x000027, "Member 'FHUDSetting::bShowTTDScanner' has a wrong offset!");
static_assert(offsetof(FHUDSetting, TTDReticleMeterMode) == 0x000028, "Member 'FHUDSetting::TTDReticleMeterMode' has a wrong offset!");
static_assert(offsetof(FHUDSetting, bTTDStatusEffectPreview) == 0x000029, "Member 'FHUDSetting::bTTDStatusEffectPreview' has a wrong offset!");
static_assert(offsetof(FHUDSetting, bShowDisguiseMeter) == 0x00002A, "Member 'FHUDSetting::bShowDisguiseMeter' has a wrong offset!");
static_assert(offsetof(FHUDSetting, bEquipmentRepairWarning) == 0x00002B, "Member 'FHUDSetting::bEquipmentRepairWarning' has a wrong offset!");
static_assert(offsetof(FHUDSetting, WeaponSelectMode) == 0x00002C, "Member 'FHUDSetting::WeaponSelectMode' has a wrong offset!");
static_assert(offsetof(FHUDSetting, WeaponSelectAxisMode) == 0x00002D, "Member 'FHUDSetting::WeaponSelectAxisMode' has a wrong offset!");
static_assert(offsetof(FHUDSetting, bShowTutorialNotifications) == 0x00002E, "Member 'FHUDSetting::bShowTutorialNotifications' has a wrong offset!");
static_assert(offsetof(FHUDSetting, bShowTutorialPopups) == 0x00002F, "Member 'FHUDSetting::bShowTutorialPopups' has a wrong offset!");
static_assert(offsetof(FHUDSetting, bShowLootTooltips) == 0x000030, "Member 'FHUDSetting::bShowLootTooltips' has a wrong offset!");
static_assert(offsetof(FHUDSetting, bShowLootControls) == 0x000031, "Member 'FHUDSetting::bShowLootControls' has a wrong offset!");

// ScriptStruct Indiana.GamepadLayout
// 0x0070 (0x0070 - 0x0000)
struct FGamepadLayout final
{
public:
	struct FLocString                             Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLocString                             Description;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EPlatformFamily, struct FSettingPlatformStringContainer> PlatformOverrides;                                 // 0x0010(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FLocString>                     ButtonNames;                                       // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGamepadLayout) == 0x000008, "Wrong alignment on FGamepadLayout");
static_assert(sizeof(FGamepadLayout) == 0x000070, "Wrong size on FGamepadLayout");
static_assert(offsetof(FGamepadLayout, Name) == 0x000000, "Member 'FGamepadLayout::Name' has a wrong offset!");
static_assert(offsetof(FGamepadLayout, Description) == 0x000008, "Member 'FGamepadLayout::Description' has a wrong offset!");
static_assert(offsetof(FGamepadLayout, PlatformOverrides) == 0x000010, "Member 'FGamepadLayout::PlatformOverrides' has a wrong offset!");
static_assert(offsetof(FGamepadLayout, ButtonNames) == 0x000060, "Member 'FGamepadLayout::ButtonNames' has a wrong offset!");

// ScriptStruct Indiana.SettingDescription
// 0x0068 (0x0068 - 0x0000)
struct FSettingDescription final
{
public:
	struct FLocString                             Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLocString                             Description;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESettingSubcategory                           Subcategory;                                       // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPlatformFamily, struct FSettingPlatformStringContainer> PlatformOverrides;                                 // 0x0018(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSettingDescription) == 0x000008, "Wrong alignment on FSettingDescription");
static_assert(sizeof(FSettingDescription) == 0x000068, "Wrong size on FSettingDescription");
static_assert(offsetof(FSettingDescription, Name) == 0x000000, "Member 'FSettingDescription::Name' has a wrong offset!");
static_assert(offsetof(FSettingDescription, Description) == 0x000008, "Member 'FSettingDescription::Description' has a wrong offset!");
static_assert(offsetof(FSettingDescription, Subcategory) == 0x000010, "Member 'FSettingDescription::Subcategory' has a wrong offset!");
static_assert(offsetof(FSettingDescription, PlatformOverrides) == 0x000018, "Member 'FSettingDescription::PlatformOverrides' has a wrong offset!");

// ScriptStruct Indiana.SpawnPropertyModifiers
// 0x00D0 (0x00D0 - 0x0000)
struct FSpawnPropertyModifiers final
{
public:
	TSubclassOf<class UTeamData>                  TeamOverride;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConversationData*                      ConversationDataOverride;                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ULootTableData*>                 AdditionalLoot;                                    // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bOverrideOutOfCombatBehavior;                      // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBehaviorPackage                       OutOfCombatBehavior;                               // 0x0028(0x0098)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreOverrideInterestPackage;                    // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Spline;                                            // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnPropertyModifiers) == 0x000008, "Wrong alignment on FSpawnPropertyModifiers");
static_assert(sizeof(FSpawnPropertyModifiers) == 0x0000D0, "Wrong size on FSpawnPropertyModifiers");
static_assert(offsetof(FSpawnPropertyModifiers, TeamOverride) == 0x000000, "Member 'FSpawnPropertyModifiers::TeamOverride' has a wrong offset!");
static_assert(offsetof(FSpawnPropertyModifiers, ConversationDataOverride) == 0x000008, "Member 'FSpawnPropertyModifiers::ConversationDataOverride' has a wrong offset!");
static_assert(offsetof(FSpawnPropertyModifiers, AdditionalLoot) == 0x000010, "Member 'FSpawnPropertyModifiers::AdditionalLoot' has a wrong offset!");
static_assert(offsetof(FSpawnPropertyModifiers, bOverrideOutOfCombatBehavior) == 0x000020, "Member 'FSpawnPropertyModifiers::bOverrideOutOfCombatBehavior' has a wrong offset!");
static_assert(offsetof(FSpawnPropertyModifiers, OutOfCombatBehavior) == 0x000028, "Member 'FSpawnPropertyModifiers::OutOfCombatBehavior' has a wrong offset!");
static_assert(offsetof(FSpawnPropertyModifiers, bIgnoreOverrideInterestPackage) == 0x0000C0, "Member 'FSpawnPropertyModifiers::bIgnoreOverrideInterestPackage' has a wrong offset!");
static_assert(offsetof(FSpawnPropertyModifiers, Spline) == 0x0000C8, "Member 'FSpawnPropertyModifiers::Spline' has a wrong offset!");

// ScriptStruct Indiana.SpellSet
// 0x0050 (0x0050 - 0x0000)
struct FSpellSet final
{
public:
	TSet<TSubclassOf<class USpell>>               SpellTypes;                                        // 0x0000(0x0050)(Edit, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
};
static_assert(alignof(FSpellSet) == 0x000008, "Wrong alignment on FSpellSet");
static_assert(sizeof(FSpellSet) == 0x000050, "Wrong size on FSpellSet");
static_assert(offsetof(FSpellSet, SpellTypes) == 0x000000, "Member 'FSpellSet::SpellTypes' has a wrong offset!");

// ScriptStruct Indiana.StatusEffectSerializationContext
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FStatusEffectSerializationContext final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusEffectSerializationContext) == 0x000008, "Wrong alignment on FStatusEffectSerializationContext");
static_assert(sizeof(FStatusEffectSerializationContext) == 0x000010, "Wrong size on FStatusEffectSerializationContext");

// ScriptStruct Indiana.AwarenessTalkImageSet
// 0x0020 (0x0020 - 0x0000)
struct FAwarenessTalkImageSet final
{
public:
	class UTexture2D*                             DisguiseUnalerted;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DisguiseAlerted;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             NonDisguiseUnalerted;                              // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             NonDisguiseAlerted;                                // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAwarenessTalkImageSet) == 0x000008, "Wrong alignment on FAwarenessTalkImageSet");
static_assert(sizeof(FAwarenessTalkImageSet) == 0x000020, "Wrong size on FAwarenessTalkImageSet");
static_assert(offsetof(FAwarenessTalkImageSet, DisguiseUnalerted) == 0x000000, "Member 'FAwarenessTalkImageSet::DisguiseUnalerted' has a wrong offset!");
static_assert(offsetof(FAwarenessTalkImageSet, DisguiseAlerted) == 0x000008, "Member 'FAwarenessTalkImageSet::DisguiseAlerted' has a wrong offset!");
static_assert(offsetof(FAwarenessTalkImageSet, NonDisguiseUnalerted) == 0x000010, "Member 'FAwarenessTalkImageSet::NonDisguiseUnalerted' has a wrong offset!");
static_assert(offsetof(FAwarenessTalkImageSet, NonDisguiseAlerted) == 0x000018, "Member 'FAwarenessTalkImageSet::NonDisguiseAlerted' has a wrong offset!");

// ScriptStruct Indiana.MiniTimeSpan
// 0x000C (0x000C - 0x0000)
struct FMiniTimeSpan final
{
public:
	int32                                         Minutes;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seconds;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Milliseconds;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMiniTimeSpan) == 0x000004, "Wrong alignment on FMiniTimeSpan");
static_assert(sizeof(FMiniTimeSpan) == 0x00000C, "Wrong size on FMiniTimeSpan");
static_assert(offsetof(FMiniTimeSpan, Minutes) == 0x000000, "Member 'FMiniTimeSpan::Minutes' has a wrong offset!");
static_assert(offsetof(FMiniTimeSpan, Seconds) == 0x000004, "Member 'FMiniTimeSpan::Seconds' has a wrong offset!");
static_assert(offsetof(FMiniTimeSpan, Milliseconds) == 0x000008, "Member 'FMiniTimeSpan::Milliseconds' has a wrong offset!");

// ScriptStruct Indiana.SubtitleEntry
// 0x0038 (0x0038 - 0x0000)
struct FSubtitleEntry final
{
public:
	class FString                                 DebugName;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMiniTimeSpan                          StartTime;                                         // 0x0010(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FMiniTimeSpan                          EndTime;                                           // 0x001C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FLocString                             NameString;                                        // 0x0028(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubtitleStringID;                                  // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGender                                       Gender;                                            // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSubtitleEntry) == 0x000008, "Wrong alignment on FSubtitleEntry");
static_assert(sizeof(FSubtitleEntry) == 0x000038, "Wrong size on FSubtitleEntry");
static_assert(offsetof(FSubtitleEntry, DebugName) == 0x000000, "Member 'FSubtitleEntry::DebugName' has a wrong offset!");
static_assert(offsetof(FSubtitleEntry, StartTime) == 0x000010, "Member 'FSubtitleEntry::StartTime' has a wrong offset!");
static_assert(offsetof(FSubtitleEntry, EndTime) == 0x00001C, "Member 'FSubtitleEntry::EndTime' has a wrong offset!");
static_assert(offsetof(FSubtitleEntry, NameString) == 0x000028, "Member 'FSubtitleEntry::NameString' has a wrong offset!");
static_assert(offsetof(FSubtitleEntry, SubtitleStringID) == 0x000030, "Member 'FSubtitleEntry::SubtitleStringID' has a wrong offset!");
static_assert(offsetof(FSubtitleEntry, Gender) == 0x000034, "Member 'FSubtitleEntry::Gender' has a wrong offset!");

// ScriptStruct Indiana.StatuEffectVisualSet
// 0x0050 (0x0050 - 0x0000)
struct FStatuEffectVisualSet final
{
public:
	TSet<TSoftObjectPtr<class UStatusEffectUIVisualsData>> StatusEffectVisuals;                               // 0x0000(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatuEffectVisualSet) == 0x000008, "Wrong alignment on FStatuEffectVisualSet");
static_assert(sizeof(FStatuEffectVisualSet) == 0x000050, "Wrong size on FStatuEffectVisualSet");
static_assert(offsetof(FStatuEffectVisualSet, StatusEffectVisuals) == 0x000000, "Member 'FStatuEffectVisualSet::StatusEffectVisuals' has a wrong offset!");

// ScriptStruct Indiana.SystemMapEntryData
// 0x0C00 (0x0C00 - 0x0000)
struct FSystemMapEntryData final
{
public:
	class FString                                 DebugName;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Position;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLocString                             NameString;                                        // 0x0018(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLocString                             DescString;                                        // 0x0020(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TextPadding;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TextAlignment;                                     // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              QuestIconPadding;                                  // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PlayerIconPadding;                                 // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TextZOrder;                                        // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ButtonZOrder;                                      // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QuestIconZOrder;                                   // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerIconZOrder;                                  // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortingOrder;                                      // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayPointOfNoReturnWarning;                    // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowWhileHidden;                                  // 0x005D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlipHorizontal;                                   // 0x005E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F[0x1];                                       // 0x005F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            HiddenBrush;                                       // 0x0060(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FVector2D                              HiddenPosition;                                    // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            LockedBrush;                                       // 0x00F0(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            LockedHoverFocused;                                // 0x0178(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            LockedSelected;                                    // 0x0200(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            UnlockedBrush;                                     // 0x0288(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            UnlockedHoverFocused;                              // 0x0310(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            UnlockedSelected;                                  // 0x0398(0x0088)(Edit, NativeAccessSpecifierPublic)
	bool                                          bHasINX1Overrides;                                 // 0x0420(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_421[0x7];                                      // 0x0421(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAlternateBrushSet                     INX1BrushSet;                                      // 0x0428(0x03B8)(Edit, NativeAccessSpecifierPublic)
	bool                                          bHasINX2Overrides;                                 // 0x07E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E1[0x7];                                      // 0x07E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAlternateBrushSet                     INX2BrushSet;                                      // 0x07E8(0x03B8)(Edit, NativeAccessSpecifierPublic)
	TArray<class UShipDestinationData*>           Destinations;                                      // 0x0BA0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class UShipDestinationData*, class UTexture2D*> DestinationImages;                                 // 0x0BB0(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSystemMapEntryData) == 0x000008, "Wrong alignment on FSystemMapEntryData");
static_assert(sizeof(FSystemMapEntryData) == 0x000C00, "Wrong size on FSystemMapEntryData");
static_assert(offsetof(FSystemMapEntryData, DebugName) == 0x000000, "Member 'FSystemMapEntryData::DebugName' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, Position) == 0x000010, "Member 'FSystemMapEntryData::Position' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, NameString) == 0x000018, "Member 'FSystemMapEntryData::NameString' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, DescString) == 0x000020, "Member 'FSystemMapEntryData::DescString' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, TextPadding) == 0x000028, "Member 'FSystemMapEntryData::TextPadding' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, TextAlignment) == 0x000030, "Member 'FSystemMapEntryData::TextAlignment' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, QuestIconPadding) == 0x000038, "Member 'FSystemMapEntryData::QuestIconPadding' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, PlayerIconPadding) == 0x000040, "Member 'FSystemMapEntryData::PlayerIconPadding' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, TextZOrder) == 0x000048, "Member 'FSystemMapEntryData::TextZOrder' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, ButtonZOrder) == 0x00004C, "Member 'FSystemMapEntryData::ButtonZOrder' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, QuestIconZOrder) == 0x000050, "Member 'FSystemMapEntryData::QuestIconZOrder' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, PlayerIconZOrder) == 0x000054, "Member 'FSystemMapEntryData::PlayerIconZOrder' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, SortingOrder) == 0x000058, "Member 'FSystemMapEntryData::SortingOrder' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, bDisplayPointOfNoReturnWarning) == 0x00005C, "Member 'FSystemMapEntryData::bDisplayPointOfNoReturnWarning' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, bShowWhileHidden) == 0x00005D, "Member 'FSystemMapEntryData::bShowWhileHidden' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, bFlipHorizontal) == 0x00005E, "Member 'FSystemMapEntryData::bFlipHorizontal' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, HiddenBrush) == 0x000060, "Member 'FSystemMapEntryData::HiddenBrush' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, HiddenPosition) == 0x0000E8, "Member 'FSystemMapEntryData::HiddenPosition' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, LockedBrush) == 0x0000F0, "Member 'FSystemMapEntryData::LockedBrush' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, LockedHoverFocused) == 0x000178, "Member 'FSystemMapEntryData::LockedHoverFocused' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, LockedSelected) == 0x000200, "Member 'FSystemMapEntryData::LockedSelected' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, UnlockedBrush) == 0x000288, "Member 'FSystemMapEntryData::UnlockedBrush' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, UnlockedHoverFocused) == 0x000310, "Member 'FSystemMapEntryData::UnlockedHoverFocused' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, UnlockedSelected) == 0x000398, "Member 'FSystemMapEntryData::UnlockedSelected' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, bHasINX1Overrides) == 0x000420, "Member 'FSystemMapEntryData::bHasINX1Overrides' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, INX1BrushSet) == 0x000428, "Member 'FSystemMapEntryData::INX1BrushSet' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, bHasINX2Overrides) == 0x0007E0, "Member 'FSystemMapEntryData::bHasINX2Overrides' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, INX2BrushSet) == 0x0007E8, "Member 'FSystemMapEntryData::INX2BrushSet' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, Destinations) == 0x000BA0, "Member 'FSystemMapEntryData::Destinations' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryData, DestinationImages) == 0x000BB0, "Member 'FSystemMapEntryData::DestinationImages' has a wrong offset!");

// ScriptStruct Indiana.SystemMapEntryHelper
// 0x0018 (0x0018 - 0x0000)
struct FSystemMapEntryHelper final
{
public:
	struct FLocString                             NameString;                                        // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLocString                             DescString;                                        // 0x0008(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAwareLocation;                                    // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHiddenLocation;                                   // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockedLocation;                                   // 0x0012(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActiveQuestLocation;                              // 0x0013(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInactiveQuestLocation;                            // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSystemMapEntryHelper) == 0x000004, "Wrong alignment on FSystemMapEntryHelper");
static_assert(sizeof(FSystemMapEntryHelper) == 0x000018, "Wrong size on FSystemMapEntryHelper");
static_assert(offsetof(FSystemMapEntryHelper, NameString) == 0x000000, "Member 'FSystemMapEntryHelper::NameString' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryHelper, DescString) == 0x000008, "Member 'FSystemMapEntryHelper::DescString' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryHelper, bAwareLocation) == 0x000010, "Member 'FSystemMapEntryHelper::bAwareLocation' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryHelper, bHiddenLocation) == 0x000011, "Member 'FSystemMapEntryHelper::bHiddenLocation' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryHelper, bLockedLocation) == 0x000012, "Member 'FSystemMapEntryHelper::bLockedLocation' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryHelper, bActiveQuestLocation) == 0x000013, "Member 'FSystemMapEntryHelper::bActiveQuestLocation' has a wrong offset!");
static_assert(offsetof(FSystemMapEntryHelper, bInactiveQuestLocation) == 0x000014, "Member 'FSystemMapEntryHelper::bInactiveQuestLocation' has a wrong offset!");

// ScriptStruct Indiana.ScriptedTeamDataSource
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FScriptedTeamDataSource final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScriptedTeamDataSource) == 0x000008, "Wrong alignment on FScriptedTeamDataSource");
static_assert(sizeof(FScriptedTeamDataSource) == 0x000010, "Wrong size on FScriptedTeamDataSource");

// ScriptStruct Indiana.TestAudioDataTypeReferenceID
// 0x0000 (0x0018 - 0x0018)
struct FTestAudioDataTypeReferenceID final : public FGameDataReferenceID
{
};
static_assert(alignof(FTestAudioDataTypeReferenceID) == 0x000008, "Wrong alignment on FTestAudioDataTypeReferenceID");
static_assert(sizeof(FTestAudioDataTypeReferenceID) == 0x000018, "Wrong size on FTestAudioDataTypeReferenceID");

// ScriptStruct Indiana.TimeDilationData
// 0x00A8 (0x00A8 - 0x0000)
struct FTimeDilationData final
{
public:
	ETimeDilationPriority                         Priority;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETimeDilationType                             Type;                                              // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendTimeIn;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTimeOut;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeDilationStatic;                                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     TimeDilationCurve;                                 // 0x0010(0x0088)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x10];                                      // 0x0098(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTimeDilationData) == 0x000008, "Wrong alignment on FTimeDilationData");
static_assert(sizeof(FTimeDilationData) == 0x0000A8, "Wrong size on FTimeDilationData");
static_assert(offsetof(FTimeDilationData, Priority) == 0x000000, "Member 'FTimeDilationData::Priority' has a wrong offset!");
static_assert(offsetof(FTimeDilationData, Type) == 0x000001, "Member 'FTimeDilationData::Type' has a wrong offset!");
static_assert(offsetof(FTimeDilationData, BlendTimeIn) == 0x000004, "Member 'FTimeDilationData::BlendTimeIn' has a wrong offset!");
static_assert(offsetof(FTimeDilationData, BlendTimeOut) == 0x000008, "Member 'FTimeDilationData::BlendTimeOut' has a wrong offset!");
static_assert(offsetof(FTimeDilationData, TimeDilationStatic) == 0x00000C, "Member 'FTimeDilationData::TimeDilationStatic' has a wrong offset!");
static_assert(offsetof(FTimeDilationData, TimeDilationCurve) == 0x000010, "Member 'FTimeDilationData::TimeDilationCurve' has a wrong offset!");

// ScriptStruct Indiana.IKChainConfig
// 0x0001 (0x0001 - 0x0000)
struct FIKChainConfig final
{
public:
	EFootID                                       FootID;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIKChainConfig) == 0x000001, "Wrong alignment on FIKChainConfig");
static_assert(sizeof(FIKChainConfig) == 0x000001, "Wrong size on FIKChainConfig");
static_assert(offsetof(FIKChainConfig, FootID) == 0x000000, "Member 'FIKChainConfig::FootID' has a wrong offset!");

// ScriptStruct Indiana.BodyRotationProperties
// 0x0008 (0x0008 - 0x0000)
struct FBodyRotationProperties final
{
public:
	float                                         RotationInitiateThreshold;                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationCompleteTolerance;                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBodyRotationProperties) == 0x000004, "Wrong alignment on FBodyRotationProperties");
static_assert(sizeof(FBodyRotationProperties) == 0x000008, "Wrong size on FBodyRotationProperties");
static_assert(offsetof(FBodyRotationProperties, RotationInitiateThreshold) == 0x000000, "Member 'FBodyRotationProperties::RotationInitiateThreshold' has a wrong offset!");
static_assert(offsetof(FBodyRotationProperties, RotationCompleteTolerance) == 0x000004, "Member 'FBodyRotationProperties::RotationCompleteTolerance' has a wrong offset!");

// ScriptStruct Indiana.TutorialFullScreenEventDataContainer
// 0x01D8 (0x0250 - 0x0078)
struct FTutorialFullScreenEventDataContainer final : public FTutorialBaseEventData
{
public:
	ETutorialDisplayType                          DisplayType;                                       // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                Padding;                                           // 0x007C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x008C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x008D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowTutorialTag;                                  // 0x008E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowTutorialName;                                 // 0x008F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayInJournalByDefault;                        // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLocString                             PreFlavorString;                                   // 0x0094(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLocString                             TutorialNameString;                                // 0x009C(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLocString                             TutorialBodyString;                                // 0x00A4(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPlatformFamily, struct FTutorialPlatformStringContainer> PlatformOverrides;                                 // 0x00B0(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FLocString                             SubHeaderString;                                   // 0x0100(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLocString                             SubDescriptionString;                              // 0x0108(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EPlatformFamily, struct FTutorialPlatformStringContainer> SubPlatformOverrides;                              // 0x0110(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FLocString                             ColoredString;                                     // 0x0160(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputLabelDescription                 PrimaryDescription;                                // 0x0168(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FInputLabelDescription                 SecondaryDescription;                              // 0x01A0(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FInputLabelDescription                 BindingDescriptionOne;                             // 0x01D8(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FInputLabelDescription                 BindingDescriptionTwo;                             // 0x0210(0x0038)(Edit, NativeAccessSpecifierPublic)
	class UBrandDataAsset*                        BrandType;                                         // 0x0248(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTutorialFullScreenEventDataContainer) == 0x000008, "Wrong alignment on FTutorialFullScreenEventDataContainer");
static_assert(sizeof(FTutorialFullScreenEventDataContainer) == 0x000250, "Wrong size on FTutorialFullScreenEventDataContainer");
static_assert(offsetof(FTutorialFullScreenEventDataContainer, DisplayType) == 0x000078, "Member 'FTutorialFullScreenEventDataContainer::DisplayType' has a wrong offset!");
static_assert(offsetof(FTutorialFullScreenEventDataContainer, Padding) == 0x00007C, "Member 'FTutorialFullScreenEventDataContainer::Padding' has a wrong offset!");
static_assert(offsetof(FTutorialFullScreenEventDataContainer, HorizontalAlignment) == 0x00008C, "Member 'FTutorialFullScreenEventDataContainer::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(FTutorialFullScreenEventDataContainer, VerticalAlignment) == 0x00008D, "Member 'FTutorialFullScreenEventDataContainer::VerticalAlignment' has a wrong offset!");
static_assert(offsetof(FTutorialFullScreenEventDataContainer, bShowTutorialTag) == 0x00008E, "Member 'FTutorialFullScreenEventDataContainer::bShowTutorialTag' has a wrong offset!");
static_assert(offsetof(FTutorialFullScreenEventDataContainer, bShowTutorialName) == 0x00008F, "Member 'FTutorialFullScreenEventDataContainer::bShowTutorialName' has a wrong offset!");
static_assert(offsetof(FTutorialFullScreenEventDataContainer, bDisplayInJournalByDefault) == 0x000090, "Member 'FTutorialFullScreenEventDataContainer::bDisplayInJournalByDefault' has a wrong offset!");
static_assert(offsetof(FTutorialFullScreenEventDataContainer, PreFlavorString) == 0x000094, "Member 'FTutorialFullScreenEventDataContainer::PreFlavorString' has a wrong offset!");
static_assert(offsetof(FTutorialFullScreenEventDataContainer, TutorialNameString) == 0x00009C, "Member 'FTutorialFullScreenEventDataContainer::TutorialNameString' has a wrong offset!");
static_assert(offsetof(FTutorialFullScreenEventDataContainer, TutorialBodyString) == 0x0000A4, "Member 'FTutorialFullScreenEventDataContainer::TutorialBodyString' has a wrong offset!");
static_assert(offsetof(FTutorialFullScreenEventDataContainer, PlatformOverrides) == 0x0000B0, "Member 'FTutorialFullScreenEventDataContainer::PlatformOverrides' has a wrong offset!");
static_assert(offsetof(FTutorialFullScreenEventDataContainer, SubHeaderString) == 0x000100, "Member 'FTutorialFullScreenEventDataContainer::SubHeaderString' has a wrong offset!");
static_assert(offsetof(FTutorialFullScreenEventDataContainer, SubDescriptionString) == 0x000108, "Member 'FTutorialFullScreenEventDataContainer::SubDescriptionString' has a wrong offset!");
static_assert(offsetof(FTutorialFullScreenEventDataContainer, SubPlatformOverrides) == 0x000110, "Member 'FTutorialFullScreenEventDataContainer::SubPlatformOverrides' has a wrong offset!");
static_assert(offsetof(FTutorialFullScreenEventDataContainer, ColoredString) == 0x000160, "Member 'FTutorialFullScreenEventDataContainer::ColoredString' has a wrong offset!");
static_assert(offsetof(FTutorialFullScreenEventDataContainer, PrimaryDescription) == 0x000168, "Member 'FTutorialFullScreenEventDataContainer::PrimaryDescription' has a wrong offset!");
static_assert(offsetof(FTutorialFullScreenEventDataContainer, SecondaryDescription) == 0x0001A0, "Member 'FTutorialFullScreenEventDataContainer::SecondaryDescription' has a wrong offset!");
static_assert(offsetof(FTutorialFullScreenEventDataContainer, BindingDescriptionOne) == 0x0001D8, "Member 'FTutorialFullScreenEventDataContainer::BindingDescriptionOne' has a wrong offset!");
static_assert(offsetof(FTutorialFullScreenEventDataContainer, BindingDescriptionTwo) == 0x000210, "Member 'FTutorialFullScreenEventDataContainer::BindingDescriptionTwo' has a wrong offset!");
static_assert(offsetof(FTutorialFullScreenEventDataContainer, BrandType) == 0x000248, "Member 'FTutorialFullScreenEventDataContainer::BrandType' has a wrong offset!");

// ScriptStruct Indiana.ResolutionFontSizeData
// 0x0020 (0x0020 - 0x0000)
struct FResolutionFontSizeData final
{
public:
	class FString                                 DebugName;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Resolution;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          FontSize;                                          // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FResolutionFontSizeData) == 0x000008, "Wrong alignment on FResolutionFontSizeData");
static_assert(sizeof(FResolutionFontSizeData) == 0x000020, "Wrong size on FResolutionFontSizeData");
static_assert(offsetof(FResolutionFontSizeData, DebugName) == 0x000000, "Member 'FResolutionFontSizeData::DebugName' has a wrong offset!");
static_assert(offsetof(FResolutionFontSizeData, Resolution) == 0x000010, "Member 'FResolutionFontSizeData::Resolution' has a wrong offset!");
static_assert(offsetof(FResolutionFontSizeData, FontSize) == 0x000018, "Member 'FResolutionFontSizeData::FontSize' has a wrong offset!");

// ScriptStruct Indiana.CostModifiers
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FCostModifiers final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCostModifiers) == 0x000004, "Wrong alignment on FCostModifiers");
static_assert(sizeof(FCostModifiers) == 0x000014, "Wrong size on FCostModifiers");

// ScriptStruct Indiana.WaitData
// 0x000C (0x000C - 0x0000)
struct FWaitData final
{
public:
	float                                         StepValue;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLocString                             LocString;                                         // 0x0004(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWaitData) == 0x000004, "Wrong alignment on FWaitData");
static_assert(sizeof(FWaitData) == 0x00000C, "Wrong size on FWaitData");
static_assert(offsetof(FWaitData, StepValue) == 0x000000, "Member 'FWaitData::StepValue' has a wrong offset!");
static_assert(offsetof(FWaitData, LocString) == 0x000004, "Member 'FWaitData::LocString' has a wrong offset!");

// ScriptStruct Indiana.WeaponAimTrackingRegion
// 0x0020 (0x0110 - 0x00F0)
struct FWeaponAimTrackingRegion final : public FTrackingRegion
{
public:
	uint8                                         Pad_F0[0x20];                                      // 0x00F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponAimTrackingRegion) == 0x000008, "Wrong alignment on FWeaponAimTrackingRegion");
static_assert(sizeof(FWeaponAimTrackingRegion) == 0x000110, "Wrong size on FWeaponAimTrackingRegion");

// ScriptStruct Indiana.WeaponModDefaultVisuals
// 0x0028 (0x0028 - 0x0000)
struct FWeaponModDefaultVisuals final
{
public:
	struct FGameplayTagContainer                  WeaponCategories;                                  // 0x0000(0x0020)(Edit, NativeAccessSpecifierPublic)
	class UModVisual*                             DefaultVisuals;                                    // 0x0020(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponModDefaultVisuals) == 0x000008, "Wrong alignment on FWeaponModDefaultVisuals");
static_assert(sizeof(FWeaponModDefaultVisuals) == 0x000028, "Wrong size on FWeaponModDefaultVisuals");
static_assert(offsetof(FWeaponModDefaultVisuals, WeaponCategories) == 0x000000, "Member 'FWeaponModDefaultVisuals::WeaponCategories' has a wrong offset!");
static_assert(offsetof(FWeaponModDefaultVisuals, DefaultVisuals) == 0x000020, "Member 'FWeaponModDefaultVisuals::DefaultVisuals' has a wrong offset!");

// ScriptStruct Indiana.WeaponModProjectileOverride
// 0x0060 (0x0060 - 0x0000)
struct FWeaponModProjectileOverride final
{
public:
	TArray<TSoftClassPtr<class UClass>>           Mods;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   OverrideProjectileClass;                           // 0x0010(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInstantHitData>         OverrideInstantHitData;                            // 0x0038(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponModProjectileOverride) == 0x000008, "Wrong alignment on FWeaponModProjectileOverride");
static_assert(sizeof(FWeaponModProjectileOverride) == 0x000060, "Wrong size on FWeaponModProjectileOverride");
static_assert(offsetof(FWeaponModProjectileOverride, Mods) == 0x000000, "Member 'FWeaponModProjectileOverride::Mods' has a wrong offset!");
static_assert(offsetof(FWeaponModProjectileOverride, OverrideProjectileClass) == 0x000010, "Member 'FWeaponModProjectileOverride::OverrideProjectileClass' has a wrong offset!");
static_assert(offsetof(FWeaponModProjectileOverride, OverrideInstantHitData) == 0x000038, "Member 'FWeaponModProjectileOverride::OverrideInstantHitData' has a wrong offset!");

// ScriptStruct Indiana.IndianaSliderStyle
// 0x0388 (0x0390 - 0x0008)
struct FIndianaSliderStyle final : public FSlateWidgetStyle
{
public:
	struct FSlateBrushContainer                   NormalBarBrush;                                    // 0x0008(0x0090)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrushContainer                   FocusedBarBrush;                                   // 0x0098(0x0090)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrushContainer                   DisabledBarBrush;                                  // 0x0128(0x0090)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrushContainer                   NormalThumbBrush;                                  // 0x01B8(0x0090)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrushContainer                   FocusedThumbBrush;                                 // 0x0248(0x0090)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrushContainer                   DisabledThumbBrush;                                // 0x02D8(0x0090)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         BarThickness;                                      // 0x0368(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36C[0x4];                                      // 0x036C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          HoveredSoundOverride;                              // 0x0370(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          FocusedSoundOverride;                              // 0x0378(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StepSoundOverride;                                 // 0x0380(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SliderIndentation;                                 // 0x0388(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSliderIndentation;                             // 0x038C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38D[0x3];                                      // 0x038D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIndianaSliderStyle) == 0x000008, "Wrong alignment on FIndianaSliderStyle");
static_assert(sizeof(FIndianaSliderStyle) == 0x000390, "Wrong size on FIndianaSliderStyle");
static_assert(offsetof(FIndianaSliderStyle, NormalBarBrush) == 0x000008, "Member 'FIndianaSliderStyle::NormalBarBrush' has a wrong offset!");
static_assert(offsetof(FIndianaSliderStyle, FocusedBarBrush) == 0x000098, "Member 'FIndianaSliderStyle::FocusedBarBrush' has a wrong offset!");
static_assert(offsetof(FIndianaSliderStyle, DisabledBarBrush) == 0x000128, "Member 'FIndianaSliderStyle::DisabledBarBrush' has a wrong offset!");
static_assert(offsetof(FIndianaSliderStyle, NormalThumbBrush) == 0x0001B8, "Member 'FIndianaSliderStyle::NormalThumbBrush' has a wrong offset!");
static_assert(offsetof(FIndianaSliderStyle, FocusedThumbBrush) == 0x000248, "Member 'FIndianaSliderStyle::FocusedThumbBrush' has a wrong offset!");
static_assert(offsetof(FIndianaSliderStyle, DisabledThumbBrush) == 0x0002D8, "Member 'FIndianaSliderStyle::DisabledThumbBrush' has a wrong offset!");
static_assert(offsetof(FIndianaSliderStyle, BarThickness) == 0x000368, "Member 'FIndianaSliderStyle::BarThickness' has a wrong offset!");
static_assert(offsetof(FIndianaSliderStyle, HoveredSoundOverride) == 0x000370, "Member 'FIndianaSliderStyle::HoveredSoundOverride' has a wrong offset!");
static_assert(offsetof(FIndianaSliderStyle, FocusedSoundOverride) == 0x000378, "Member 'FIndianaSliderStyle::FocusedSoundOverride' has a wrong offset!");
static_assert(offsetof(FIndianaSliderStyle, StepSoundOverride) == 0x000380, "Member 'FIndianaSliderStyle::StepSoundOverride' has a wrong offset!");
static_assert(offsetof(FIndianaSliderStyle, SliderIndentation) == 0x000388, "Member 'FIndianaSliderStyle::SliderIndentation' has a wrong offset!");
static_assert(offsetof(FIndianaSliderStyle, bUseSliderIndentation) == 0x00038C, "Member 'FIndianaSliderStyle::bUseSliderIndentation' has a wrong offset!");

// ScriptStruct Indiana.DamageTypeColors
// 0x0002 (0x0002 - 0x0000)
struct FDamageTypeColors final
{
public:
	EIndianaUIColorType                           TextColor;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EIndianaUIColorType                           OutlineColor;                                      // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageTypeColors) == 0x000001, "Wrong alignment on FDamageTypeColors");
static_assert(sizeof(FDamageTypeColors) == 0x000002, "Wrong size on FDamageTypeColors");
static_assert(offsetof(FDamageTypeColors, TextColor) == 0x000000, "Member 'FDamageTypeColors::TextColor' has a wrong offset!");
static_assert(offsetof(FDamageTypeColors, OutlineColor) == 0x000001, "Member 'FDamageTypeColors::OutlineColor' has a wrong offset!");

}

